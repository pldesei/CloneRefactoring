(startLine=111 endLine=237 srcPath=/root/Projects/elasticsearchFilter/1018/elasticsearch/src/main/java/org/elasticsearch/river/routing/RiversRouter.java)
    protected RiverClusterState updateRiverClusterState(final String source, final RiverClusterState currentState,
                                          ClusterState newClusterState, final CountDown countDown) {
        if (!newClusterState.metaData().hasIndex(riverIndexName)) {
            // if there are routings, publish an empty one (so it will be deleted on nodes), otherwise, return the same state
            if (!currentState.routing().isEmpty()) {
                return RiverClusterState.builder().state(currentState).routing(RiversRouting.builder()).build();
            }
            return currentState;
        }

        RiversRouting.Builder routingBuilder = RiversRouting.builder().routing(currentState.routing());
        boolean dirty = false;

        IndexMetaData indexMetaData = newClusterState.metaData().index(riverIndexName);
        // go over and create new river routing (with no node) for new types (rivers names)
        for (MappingMetaData mappingMd : indexMetaData.mappings().values()) {
            String mappingType = mappingMd.type(); // mapping type is the name of the river
            if (!currentState.routing().hasRiverByName(mappingType)) {
                // no river, we need to add it to the routing with no node allocation
                try {
                    GetResponse getResponse = client.prepareGet(riverIndexName, mappingType, "_meta").setPreference("_primary").get();
                    if (!getResponse.isExists()) {
                        if (countDown.countDown()) {
                            logger.warn("no river _meta document found after {} attempts", RIVER_START_MAX_RETRIES);
                        } else {
                            logger.info("no river _meta document found, retrying in {} ms", RIVER_START_RETRY_INTERVAL.millis());
                            try {
                                threadPool.schedule(RIVER_START_RETRY_INTERVAL, ThreadPool.Names.GENERIC, new Runnable() {
                                    @Override
                                    public void run() {
                                        riverClusterService.submitStateUpdateTask(source, new RiverClusterStateUpdateTask() {
                                            @Override
                                            public RiverClusterState execute(RiverClusterState currentState) {
                                                return updateRiverClusterState(source, currentState, riverClusterService.state(), countDown);
                                            }
                                        });
                                    }
                                });
                            } catch(EsRejectedExecutionException ex) {
                                logger.debug("Couldn't schedule river start retry, node might be shutting down", ex);
                            }
                        }
                        return currentState;
                    }
                    String riverType = XContentMapValues.nodeStringValue(getResponse.getSourceAsMap().get("type"), null);
                    if (riverType == null) {
                        logger.warn("no river type provided for [{}], ignoring...", riverIndexName);
                    } else {
                        routingBuilder.put(new RiverRouting(new RiverName(riverType, mappingType), null));
                        dirty = true;
                    }
                } catch (NoShardAvailableActionException e) {
                    // ignore, we will get it next time...
                } catch (ClusterBlockException e) {
                    // ignore, we will get it next time
                } catch (IndexMissingException e) {
                    // ignore, we will get it next time
                } catch (IllegalIndexShardStateException e) {
                    // ignore, we will get it next time
                } catch (Exception e) {
                    logger.warn("failed to get/parse _meta for [{}]", e, mappingType);
                }
            }
        }
        // now, remove routings that were deleted
        // also, apply nodes that were removed and rivers were running on
        for (RiverRouting routing : currentState.routing()) {
            if (!indexMetaData.mappings().containsKey(routing.riverName().name())) {
                routingBuilder.remove(routing);
                dirty = true;
            } else if (routing.node() != null && !newClusterState.nodes().nodeExists(routing.node().id())) {
                routingBuilder.remove(routing);
                routingBuilder.put(new RiverRouting(routing.riverName(), null));
                dirty = true;
            }
        }

        // build a list from nodes to rivers
        Map<DiscoveryNode, List<RiverRouting>> nodesToRivers = Maps.newHashMap();

        for (DiscoveryNode node : newClusterState.nodes()) {
            if (RiverNodeHelper.isRiverNode(node)) {
                nodesToRivers.put(node, Lists.<RiverRouting>newArrayList());
            }
        }

        List<RiverRouting> unassigned = Lists.newArrayList();
        for (RiverRouting routing : routingBuilder.build()) {
            if (routing.node() == null) {
                unassigned.add(routing);
            } else {
                List<RiverRouting> l = nodesToRivers.get(routing.node());
                if (l == null) {
                    l = Lists.newArrayList();
                    nodesToRivers.put(routing.node(), l);
                }
                l.add(routing);
            }
        }
        for (Iterator<RiverRouting> it = unassigned.iterator(); it.hasNext(); ) {
            RiverRouting routing = it.next();
            DiscoveryNode smallest = null;
            int smallestSize = Integer.MAX_VALUE;
            for (Map.Entry<DiscoveryNode, List<RiverRouting>> entry : nodesToRivers.entrySet()) {
                if (RiverNodeHelper.isRiverNode(entry.getKey(), routing.riverName())) {
                    if (entry.getValue().size() < smallestSize) {
                        smallestSize = entry.getValue().size();
                        smallest = entry.getKey();
                    }
                }
            }
            if (smallest != null) {
                dirty = true;
                it.remove();
                routing.node(smallest);
                nodesToRivers.get(smallest).add(routing);
            }
        }


        // add relocation logic...

        if (dirty) {
            return RiverClusterState.builder().state(currentState).routing(routingBuilder).build();
        }
        return currentState;
    }

