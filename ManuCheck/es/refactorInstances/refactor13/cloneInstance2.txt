(startLine=359 endLine=409 srcPath=/root/Projects/elasticsearchFilter/1549/elasticsearch/modules/elasticsearch/src/main/java/org/elasticsearch/discovery/zen/ZenDiscovery.java)
            @Override public ClusterState execute(ClusterState currentState) {
                if (!masterNode.id().equals(currentState.nodes().masterNodeId())) {
                    // master got switched on us, no need to send anything
                    return currentState;
                }

                ClusterBlocks clusterBlocks = currentState.blocks();
                MetaData metaData = currentState.metaData();
                RoutingTable routingTable = currentState.routingTable();
                List<DiscoveryNode> nodes = newArrayList(currentState.nodes().nodes().values());
                nodes.remove(masterNode); // remove the master node from the list, it has failed
                final DiscoveryNode electedMaster = electMaster.electMaster(nodes); // elect master
                if (localNode.equals(electedMaster)) {
                    master = true;
                    masterFD.stop("got elected as new master since master left (reason = " + reason + ")");
                    nodesFD.start();
                    DiscoveryNodes.Builder builder = DiscoveryNodes.newNodesBuilder()
                            .putAll(currentState.nodes())
                                    // make sure the old master node, which has failed, is not part of the nodes we publish
                            .remove(masterNode.id())
                            .masterNodeId(localNode.id());
                    latestDiscoNodes = builder.build();
                    return newClusterStateBuilder().state(currentState).nodes(latestDiscoNodes).build();
                } else {
                    nodesFD.stop();
                    DiscoveryNodes.Builder builder = DiscoveryNodes.newNodesBuilder()
                            .putAll(currentState.nodes()).remove(masterNode.id());
                    if (electedMaster != null) {
                        builder.masterNodeId(electedMaster.id());
                        masterFD.restart(electedMaster, "possible elected master since master left (reason = " + reason + ")");
                    } else {
                        logger.warn("master_left and no other node elected to become master, current nodes: {}", nodes);
                        builder.masterNodeId(null);
                        clusterBlocks = ClusterBlocks.builder().blocks(clusterBlocks).addGlobalBlock(NO_MASTER_BLOCK).build();
                        // if this is a data node, clean the metadata and routing, since we want to recreate the indices and shards
                        if (currentState.nodes().localNode().dataNode()) {
                            metaData = MetaData.newMetaDataBuilder().build();
                            routingTable = RoutingTable.newRoutingTableBuilder().build();
                        }
                        masterFD.stop("no master elected since master left (reason = " + reason + ")");
                        asyncJoinCluster();
                    }
                    latestDiscoNodes = builder.build();
                    return newClusterStateBuilder().state(currentState)
                            .blocks(clusterBlocks)
                            .nodes(latestDiscoNodes)
                            .metaData(metaData)
                            .routingTable(routingTable)
                            .build();
                }
            }

