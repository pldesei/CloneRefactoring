(startLine=1982 endLine=2021 srcPath=/home/sonia/NewExperiment/jrubyFilter/00445/src/org/jruby/evaluator/EvaluationState.java)
    public static Block getBlock(Ruby runtime, ThreadContext context, IRubyObject self, Block currentBlock, Node blockNode) {
        if (blockNode == null) return Block.NULL_BLOCK;
        
        if (blockNode instanceof IterNode) {
            IterNode iterNode = (IterNode) blockNode;
            // Create block for this iter node
            return Block.createBlock(context, iterNode.getVarNode(),
                    new DynamicScope(iterNode.getScope(), context.getCurrentScope()),
                    iterNode.getCallable(), self);
        } else if (blockNode instanceof BlockPassNode) {
            BlockPassNode blockPassNode = (BlockPassNode) blockNode;
            IRubyObject proc = evalInternal(runtime,context, blockPassNode.getBodyNode(), self, currentBlock);

            // No block from a nil proc
            if (proc.isNil()) return Block.NULL_BLOCK;

            // If not already a proc then we should try and make it one.
            if (!(proc instanceof RubyProc)) {
                proc = proc.convertToType("Proc", "to_proc", false);

                if (!(proc instanceof RubyProc)) {
                    throw runtime.newTypeError("wrong argument type "
                            + proc.getMetaClass().getName() + " (expected Proc)");
                }
            }

            // TODO: Add safety check for taintedness
            
            if (currentBlock.isGiven()) {
                RubyProc procObject = currentBlock.getProcObject();
                // The current block is already associated with proc.  No need to create a new one
                if (procObject != null && procObject == proc) return currentBlock;
            }
            
            return ((RubyProc) proc).getBlock();
        }
         
        assert false: "Trying to get block from something which cannot deliver";
        return null;
    }

