(startLine=184 endLine=318 srcPath=/home/sonia/NewExperiment/jrubyFilter/01530/ext/openssl/src/main/java/org/jruby/ext/openssl/PKeyRSA.java)
    public IRubyObject initialize(IRubyObject[] args, Block block) {
        IRubyObject arg;
        IRubyObject pass = null;
        char[] passwd = null;
        if (org.jruby.runtime.Arity.checkArgumentCount(getRuntime(), args, 0, 2) == 0) {
            privKey = null;
            pubKey = null;
        } else {
            arg = args[0];
            if (args.length > 1) {
                pass = args[1];
            }
            if (arg instanceof RubyFixnum) {
                int keysize = RubyNumeric.fix2int(arg);
                BigInteger exp = RSAKeyGenParameterSpec.F4;
                if (null != pass && !pass.isNil()) {
                    exp = BigInteger.valueOf(RubyNumeric.num2long(pass));
                }
                rsaGenerate(this, keysize, exp);
            } else {
                if (pass != null && !pass.isNil()) {
                    passwd = pass.toString().toCharArray();
                }
                arg = OpenSSLImpl.to_der_if_possible(arg);
                RubyString str;
                if (arg instanceof RubyFile) {
                    str = (RubyString)((RubyFile)arg.dup()).read(getRuntime().getCurrentContext());
                } else {
                    str = arg.convertToString();
                }

                Object val = null;
                KeyFactory fact = null;
                try {
                    fact = KeyFactory.getInstance("RSA");
                } catch (Exception e) {
                    throw getRuntime().newRuntimeError("unsupported key algorithm (RSA)");
                }
                // TODO: ugly NoClassDefFoundError catching for no BC env. How can we remove this?
                if (null == val) {
                    // PEM_read_bio_RSAPrivateKey
                    try {
                        val = PEMInputOutput.readPrivateKey(new StringReader(str.toString()), passwd);
                    } catch (NoClassDefFoundError e) {
                        val = null;
                    } catch (Exception e) {
                        val = null;
                    }
                }
                if (null == val) {
                    // PEM_read_bio_RSAPublicKey
                    try {
                        val = PEMInputOutput.readRSAPublicKey(new StringReader(str.toString()), passwd);
                    } catch (NoClassDefFoundError e) {
                        val = null;
                    } catch (Exception e) {
                        val = null;
                    }
                }
                if (null == val) {
                    // PEM_read_bio_RSA_PUBKEY
                    try {
                        val = PEMInputOutput.readRSAPubKey(new StringReader(str.toString()));
                    } catch (NoClassDefFoundError e) {
                        val = null;
                    } catch (Exception e) {
                        val = null;
                    }
                }
                if (null == val) {
                    // d2i_RSAPrivateKey_bio
                    try {
                        val = org.jruby.ext.openssl.impl.PKey.readRSAPrivateKey(str.getBytes());
                    } catch (NoClassDefFoundError e) {
                        val = null;
                    } catch (Exception e) {
                        val = null;
                    }
                }
                if (null == val) {
                    // d2i_RSAPublicKey_bio
                    try {
                        val = org.jruby.ext.openssl.impl.PKey.readRSAPublicKey(str.getBytes());
                    } catch (NoClassDefFoundError e) {
                        val = null;
                    } catch (Exception e) {
                        val = null;
                    }
                }
                if (null == val) {
                    // try to read PrivateKeyInfo.
                    try {
                        val = fact.generatePrivate(new PKCS8EncodedKeySpec(str.getBytes()));
                    } catch (Exception e) {
                        val = null;
                    }
                }
                if (null == val) {
                    // try to read SubjectPublicKeyInfo.
                    try {
                        val = fact.generatePublic(new X509EncodedKeySpec(str.getBytes()));
                    } catch (Exception e) {
                        val = null;
                    }
                }
                if (null == val) {
                    throw newRSAError(getRuntime(), "Neither PUB key nor PRIV key:");
                }

                if (val instanceof KeyPair) {
                    PrivateKey privateKey = ((KeyPair) val).getPrivate();
                    PublicKey publicKey = ((KeyPair) val).getPublic();
                    if (privateKey instanceof RSAPrivateCrtKey) {
                        privKey = (RSAPrivateCrtKey) privateKey;
                        pubKey = (RSAPublicKey) publicKey;
                    } else {
                        throw newRSAError(getRuntime(), "Neither PUB key nor PRIV key:");
                    }
                } else if (val instanceof RSAPrivateCrtKey) {
                    privKey = (RSAPrivateCrtKey) val;
                    try {
                        pubKey = (RSAPublicKey) (fact.generatePublic(new RSAPublicKeySpec(privKey.getModulus(), privKey.getPublicExponent())));
                    } catch (Exception e) {
                        throw newRSAError(getRuntime(), "Something rotten with private key");
                    }
                } else if (val instanceof RSAPublicKey) {
                    pubKey = (RSAPublicKey) val;
                    privKey = null;
                } else {
                    throw newRSAError(getRuntime(), "Neither PUB key nor PRIV key:");
                }
            }
        }
        return this;
    }

