(startLine=464 endLine=504 srcPath=/root/NewExperiment/elasticsearchFilter/01065/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java)
            } else if (failedShard.state() == RELOCATING) {
                boolean dirty = false;
                // the shard is relocating, meaning its the source the shard is relocating from
                // first, we need to cancel the current relocation from the current node
                // now, find the node that we are recovering from, cancel the relocation, remove it from the node
                // and add it to the unassigned shards list...
                RoutingNode relocatingFromNode = routingNodes.node(failedShard.currentNodeId());
                if (relocatingFromNode != null) {
                    for (Iterator<MutableShardRouting> it = relocatingFromNode.iterator(); it.hasNext(); ) {
                        MutableShardRouting shardRouting = it.next();
                        if (shardRouting.equals(failedShard)) {
                            dirty = true;
                            routingNodes.cancelRelocationForShard( shardRouting );
                            it.remove();
                            if (addToIgnoreList) {
                                // make sure we ignore this shard on the relevant node
                                allocation.addIgnoreShardForNode(failedShard.shardId(), failedShard.currentNodeId());
                            }

                            routingNodes.unassigned().add(new MutableShardRouting(failedShard.index(), failedShard.id(),
                                    null, failedShard.primary(), ShardRoutingState.UNASSIGNED, failedShard.version() + 1));
                            break;
                        }
                    }
                }
                if (dirty) {
                    // next, we need to find the target initializing shard that is recovering from, and remove it...
                    RoutingNode initializingNode = routingNodes.node(failedShard.relocatingNodeId());
                    if (initializingNode != null) {
                        for (Iterator<MutableShardRouting> it = initializingNode.iterator(); it.hasNext(); ) {
                            MutableShardRouting shardRouting = it.next();
                            if (shardRouting.shardId().equals(failedShard.shardId()) && shardRouting.state() == INITIALIZING) {
                                dirty = true;
                                routingNodes.deassignShard( shardRouting );
                                it.remove();
                            }
                        }
                    }
                }
                return dirty;
            } else {

