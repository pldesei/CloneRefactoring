(startLine=156 endLine=183 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/02371/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TryStatement.java)
			if (type != null && type.isValidBinding()) {
				ReferenceBinding binding = (ReferenceBinding) type;
				MethodBinding closeMethod = binding.getExactMethod(ConstantPool.Close, new TypeBinding [0], this.scope.compilationUnitScope()); // scope needs to be tighter
				if(closeMethod == null) {
					// https://bugs.eclipse.org/bugs/show_bug.cgi?id=380112
					// closeMethod could be null if the binding is from an interface
					// extending from multiple interfaces.					
					InvocationSite site = new InvocationSite() {
						public TypeBinding[] genericTypeArguments() { return null;}
						public boolean isSuperAccess() {return false;}
						public boolean isTypeAccess() {return false;}
						public void setActualReceiverType(ReferenceBinding receiverType) {/* empty */}
						public void setDepth(int depth) {/* empty */ }
						public void setFieldIndex(int depth) {/* empty */ }
						public int sourceEnd() {return resource.sourceEnd(); }
						public int sourceStart() {return resource.sourceStart(); }
						public TypeBinding expectedType() { return null; }
						public boolean receiverIsImplicitThis() { return false;}
					};
					closeMethod = this.scope.compilationUnitScope().findMethod(binding, ConstantPool.Close, new TypeBinding[0], site, false);
				}
				if (closeMethod != null && closeMethod.isValidBinding() && closeMethod.returnType.id == TypeIds.T_void) {
					ReferenceBinding[] thrownExceptions = closeMethod.thrownExceptions;
					for (int j = 0, length = thrownExceptions.length; j < length; j++) {
						handlingContext.checkExceptionHandlers(thrownExceptions[j], this.resources[i], tryInfo, currentScope, true);
					}
				}
			}

