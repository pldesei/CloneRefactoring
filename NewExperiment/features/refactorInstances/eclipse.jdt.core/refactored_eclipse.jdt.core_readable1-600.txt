[Instance #
frags: 
(startLine=838 endLine=868 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
	public int literalIndex(int key) {
		//Retrieve the index from the cache
		int index;
		// lazy initialization for base type caches
		// If it is null, initialize it, otherwise use it
		if (intCache == null) {
			intCache = new IntegerCache(INT_INITIAL_SIZE);
		}
		if ((index = intCache.get(key)) < 0) {
			index = intCache.put(key, currentIndex++);
			// Write the integer constant entry into the constant pool
			// First add the tag
			writeU1(IntegerTag);
			// Then add the 4 bytes representing the int
			for (int i = 0; i < 4; i++) {
				try {
					poolContent[currentOffset++] = (byte) (key >>> (24 - i * 8));
				} catch (IndexOutOfBoundsException e) { //currentOffset has been ++ already (see the -1)
					int length = poolContent.length;
					System.arraycopy(
						poolContent,
						0,
						(poolContent = new byte[length * 2 + CONSTANTPOOL_INITIAL_SIZE]),
						0,
						length);
					poolContent[currentOffset - 1] = (byte) (key >>> (24 - i * 8));
				}
			}
		};
		return index;
	}

(startLine=878 endLine=911 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
	public int literalIndex(long key) {
		// Retrieve the index from the cache
		// The long constant takes two indexes into the constant pool, but we only store
		// the first index into the long table
		int index;
		// lazy initialization for base type caches
		// If it is null, initialize it, otherwise use it
		if (longCache == null) {
			longCache = new LongCache(LONG_INITIAL_SIZE);
		}
		if ((index = longCache.get(key)) < 0) {
			index = longCache.put(key, currentIndex++);
			currentIndex++; // long value need an extra place into thwe constant pool
			// Write the long into the constant pool
			// First add the tag
			writeU1(LongTag);
			// Then add the 8 bytes representing the long
			for (int i = 0; i < 8; i++) {
				try {
					poolContent[currentOffset++] = (byte) (key >>> (56 - (i << 3)));
				} catch (IndexOutOfBoundsException e) { //currentOffset has been ++ already (see the -1)
					int length = poolContent.length;
					System.arraycopy(
						poolContent,
						0,
						(poolContent = new byte[(length << 1) + CONSTANTPOOL_INITIAL_SIZE]),
						0,
						length);
					poolContent[currentOffset - 1] = (byte) (key >>> (56 - (i << 3)));
				}
			}
		}
		return index;
	}

commonMethod: 
(startLine=2424 endLine=2447 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
/**
 * Write a unsigned byte into the byte array
 * 
 * @param <CODE>int</CODE> The value to write into the byte array
 */
protected final void writeU2(int value) {
	//first byte
	try {
		poolContent[currentOffset++] = (byte) (value >> 8);
	} catch (IndexOutOfBoundsException e) {
		 //currentOffset has been ++ already (see the -1)
		int length = poolContent.length;
		System.arraycopy(poolContent, 0, (poolContent = new byte[length + CONSTANTPOOL_GROW_SIZE]), 0, length);
		poolContent[currentOffset - 1] = (byte) (value >> 8);
	}
	try {
		poolContent[currentOffset++] = (byte) value;
	} catch (IndexOutOfBoundsException e) {
		 //currentOffset has been ++ already (see the -1)
		int length = poolContent.length;
		System.arraycopy(poolContent, 0, (poolContent = new byte[length + CONSTANTPOOL_GROW_SIZE]), 0, length);
		poolContent[currentOffset - 1] = (byte) value;
	}
}


, Instance #
frags: 
(startLine=838 endLine=868 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
	public int literalIndex(int key) {
		//Retrieve the index from the cache
		int index;
		// lazy initialization for base type caches
		// If it is null, initialize it, otherwise use it
		if (intCache == null) {
			intCache = new IntegerCache(INT_INITIAL_SIZE);
		}
		if ((index = intCache.get(key)) < 0) {
			index = intCache.put(key, currentIndex++);
			// Write the integer constant entry into the constant pool
			// First add the tag
			writeU1(IntegerTag);
			// Then add the 4 bytes representing the int
			for (int i = 0; i < 4; i++) {
				try {
					poolContent[currentOffset++] = (byte) (key >>> (24 - i * 8));
				} catch (IndexOutOfBoundsException e) { //currentOffset has been ++ already (see the -1)
					int length = poolContent.length;
					System.arraycopy(
						poolContent,
						0,
						(poolContent = new byte[length * 2 + CONSTANTPOOL_INITIAL_SIZE]),
						0,
						length);
					poolContent[currentOffset - 1] = (byte) (key >>> (24 - i * 8));
				}
			}
		};
		return index;
	}

(startLine=878 endLine=911 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
	public int literalIndex(long key) {
		// Retrieve the index from the cache
		// The long constant takes two indexes into the constant pool, but we only store
		// the first index into the long table
		int index;
		// lazy initialization for base type caches
		// If it is null, initialize it, otherwise use it
		if (longCache == null) {
			longCache = new LongCache(LONG_INITIAL_SIZE);
		}
		if ((index = longCache.get(key)) < 0) {
			index = longCache.put(key, currentIndex++);
			currentIndex++; // long value need an extra place into thwe constant pool
			// Write the long into the constant pool
			// First add the tag
			writeU1(LongTag);
			// Then add the 8 bytes representing the long
			for (int i = 0; i < 8; i++) {
				try {
					poolContent[currentOffset++] = (byte) (key >>> (56 - (i << 3)));
				} catch (IndexOutOfBoundsException e) { //currentOffset has been ++ already (see the -1)
					int length = poolContent.length;
					System.arraycopy(
						poolContent,
						0,
						(poolContent = new byte[(length << 1) + CONSTANTPOOL_INITIAL_SIZE]),
						0,
						length);
					poolContent[currentOffset - 1] = (byte) (key >>> (56 - (i << 3)));
				}
			}
		}
		return index;
	}

commonMethod: 
(startLine=2424 endLine=2447 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
/**
 * Write a unsigned byte into the byte array
 * 
 * @param <CODE>int</CODE> The value to write into the byte array
 */
protected final void writeU2(int value) {
	//first byte
	try {
		poolContent[currentOffset++] = (byte) (value >> 8);
	} catch (IndexOutOfBoundsException e) {
		 //currentOffset has been ++ already (see the -1)
		int length = poolContent.length;
		System.arraycopy(poolContent, 0, (poolContent = new byte[length + CONSTANTPOOL_GROW_SIZE]), 0, length);
		poolContent[currentOffset - 1] = (byte) (value >> 8);
	}
	try {
		poolContent[currentOffset++] = (byte) value;
	} catch (IndexOutOfBoundsException e) {
		 //currentOffset has been ++ already (see the -1)
		int length = poolContent.length;
		System.arraycopy(poolContent, 0, (poolContent = new byte[length + CONSTANTPOOL_GROW_SIZE]), 0, length);
		poolContent[currentOffset - 1] = (byte) value;
	}
}


, Instance #
frags: 
(startLine=888 endLine=909 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
		if ((index = longCache.get(key)) < 0) {
			index = longCache.put(key, currentIndex++);
			currentIndex++; // long value need an extra place into thwe constant pool
			// Write the long into the constant pool
			// First add the tag
			writeU1(LongTag);
			// Then add the 8 bytes representing the long
			for (int i = 0; i < 8; i++) {
				try {
					poolContent[currentOffset++] = (byte) (key >>> (56 - (i << 3)));
				} catch (IndexOutOfBoundsException e) { //currentOffset has been ++ already (see the -1)
					int length = poolContent.length;
					System.arraycopy(
						poolContent,
						0,
						(poolContent = new byte[(length << 1) + CONSTANTPOOL_INITIAL_SIZE]),
						0,
						length);
					poolContent[currentOffset - 1] = (byte) (key >>> (56 - (i << 3)));
				}
			}
		}

(startLine=846 endLine=866 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
		if ((index = intCache.get(key)) < 0) {
			index = intCache.put(key, currentIndex++);
			// Write the integer constant entry into the constant pool
			// First add the tag
			writeU1(IntegerTag);
			// Then add the 4 bytes representing the int
			for (int i = 0; i < 4; i++) {
				try {
					poolContent[currentOffset++] = (byte) (key >>> (24 - i * 8));
				} catch (IndexOutOfBoundsException e) { //currentOffset has been ++ already (see the -1)
					int length = poolContent.length;
					System.arraycopy(
						poolContent,
						0,
						(poolContent = new byte[length * 2 + CONSTANTPOOL_INITIAL_SIZE]),
						0,
						length);
					poolContent[currentOffset - 1] = (byte) (key >>> (24 - i * 8));
				}
			}
		};

commonMethod: 
(startLine=2424 endLine=2447 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
/**
 * Write a unsigned byte into the byte array
 * 
 * @param <CODE>int</CODE> The value to write into the byte array
 */
protected final void writeU2(int value) {
	//first byte
	try {
		poolContent[currentOffset++] = (byte) (value >> 8);
	} catch (IndexOutOfBoundsException e) {
		 //currentOffset has been ++ already (see the -1)
		int length = poolContent.length;
		System.arraycopy(poolContent, 0, (poolContent = new byte[length + CONSTANTPOOL_GROW_SIZE]), 0, length);
		poolContent[currentOffset - 1] = (byte) (value >> 8);
	}
	try {
		poolContent[currentOffset++] = (byte) value;
	} catch (IndexOutOfBoundsException e) {
		 //currentOffset has been ++ already (see the -1)
		int length = poolContent.length;
		System.arraycopy(poolContent, 0, (poolContent = new byte[length + CONSTANTPOOL_GROW_SIZE]), 0, length);
		poolContent[currentOffset - 1] = (byte) value;
	}
}


, Instance #
frags: 
(startLine=1091 endLine=1113 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmple(trueLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifle(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifle(trueLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifle(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this);
					return;
				}
			} else {

(startLine=1113 endLine=1137 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpgt(falseLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifgt(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifgt(falseLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifgt(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}

commonMethod: 
(startLine=2550 endLine=2560 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ifne(Label lbl) {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ifne;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ifne);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=1091 endLine=1113 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmple(trueLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifle(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifle(trueLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifle(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this);
					return;
				}
			} else {

(startLine=1113 endLine=1137 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpgt(falseLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifgt(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifgt(falseLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifgt(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}

commonMethod: 
(startLine=160 endLine=213 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java)
/**
 * Default generation of a boolean value
 */
public void generateOptimizedBoolean(BlockScope currentScope, CodeStream codeStream, Label trueLabel, Label falseLabel, boolean valueRequired) {

	// a label valued to nil means: by default we fall through the case... 
	// both nil means we leave the value on the stack

	if ((constant != Constant.NotAConstant) && (constant.typeID() == T_boolean)) {
		int pc = codeStream.position;
		if (constant.booleanValue() == true) {
			// constant == true
			if (valueRequired) {
				if (falseLabel == null) {
					// implicit falling through the FALSE case
					if (trueLabel != null) {
						codeStream.goto_(trueLabel);
					}
				}
			}
		} else {
			if (valueRequired) {
				if (falseLabel != null) {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.goto_(falseLabel);
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this);
		return;
	}
	generateCode(currentScope, codeStream, valueRequired);
	// branching
	int position = codeStream.position;
	if (valueRequired) {
		if (falseLabel == null) {
			if (trueLabel != null) {
				// Implicit falling through the FALSE case
				codeStream.ifne(trueLabel);
			}
		} else {
			if (trueLabel == null) {
				// Implicit falling through the TRUE case
				codeStream.ifeq(falseLabel);
			} else {
				// No implicit fall through TRUE/FALSE --> should never occur
			}
		}
	}
	// reposition the endPC
	codeStream.updateLastRecordedEndPC(position);
}


, Instance #
frags: 
(startLine=1091 endLine=1113 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmple(trueLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifle(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifle(trueLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifle(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this);
					return;
				}
			} else {

(startLine=1113 endLine=1137 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpgt(falseLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifgt(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifgt(falseLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifgt(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}

commonMethod: 
(startLine=2313 endLine=2324 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iconst_0() {
	countLabels = 0;
	stackDepth++;
	if (stackDepth > stackMax)
		stackMax = stackDepth;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iconst_0;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iconst_0);
	}
}


, Instance #
frags: 
(startLine=1091 endLine=1113 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmple(trueLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifle(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifle(trueLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifle(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this);
					return;
				}
			} else {

(startLine=1113 endLine=1137 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpgt(falseLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifgt(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifgt(falseLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifgt(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}

commonMethod: 
(startLine=2164 endLine=2203 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * We didn't call it goto, because there is a conflit with the goto keyword
 */
final public void goto_(Label lbl) {
	try {
		lbl.inlineForwardReferencesFromLabelsTargeting(position);
		/*
		 Possible optimization for code such as:
		 public Object foo() {
			boolean b = true;
			if (b) {
				if (b)
					return null;
			} else {
				if (b) {
					return null;
				}
			}
			return null;
		}
		The goto around the else block for the first if will
		be unreachable, because the thenClause of the second if
		returns.
		See inlineForwardReferencesFromLabelsTargeting defined
		on the Label class for the remaining part of this
		optimization.
		 if (!lbl.isBranchTarget(position)) {
			switch(bCodeStream[classFileOffset-1]) {
				case OPC_return :
				case OPC_areturn:
					return;
			}
		}*/
		position++;
		bCodeStream[classFileOffset++] = OPC_goto;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_goto);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=1091 endLine=1113 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmple(trueLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifle(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifle(trueLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifle(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this);
					return;
				}
			} else {

(startLine=1113 endLine=1137 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpgt(falseLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifgt(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifgt(falseLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifgt(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}

commonMethod: 
(startLine=2495 endLine=2505 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ifeq(Label lbl) {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ifeq;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ifeq);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=1045 endLine=1064 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifge(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.iflt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this);
				return;
			}

(startLine=1066 endLine=1085 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifle(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifgt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this);
				return;
			}

commonMethod: 
(startLine=2550 endLine=2560 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ifne(Label lbl) {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ifne;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ifne);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=1045 endLine=1064 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifge(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.iflt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this);
				return;
			}

(startLine=1066 endLine=1085 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifle(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifgt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this);
				return;
			}

commonMethod: 
(startLine=160 endLine=213 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java)
/**
 * Default generation of a boolean value
 */
public void generateOptimizedBoolean(BlockScope currentScope, CodeStream codeStream, Label trueLabel, Label falseLabel, boolean valueRequired) {

	// a label valued to nil means: by default we fall through the case... 
	// both nil means we leave the value on the stack

	if ((constant != Constant.NotAConstant) && (constant.typeID() == T_boolean)) {
		int pc = codeStream.position;
		if (constant.booleanValue() == true) {
			// constant == true
			if (valueRequired) {
				if (falseLabel == null) {
					// implicit falling through the FALSE case
					if (trueLabel != null) {
						codeStream.goto_(trueLabel);
					}
				}
			}
		} else {
			if (valueRequired) {
				if (falseLabel != null) {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.goto_(falseLabel);
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this);
		return;
	}
	generateCode(currentScope, codeStream, valueRequired);
	// branching
	int position = codeStream.position;
	if (valueRequired) {
		if (falseLabel == null) {
			if (trueLabel != null) {
				// Implicit falling through the FALSE case
				codeStream.ifne(trueLabel);
			}
		} else {
			if (trueLabel == null) {
				// Implicit falling through the TRUE case
				codeStream.ifeq(falseLabel);
			} else {
				// No implicit fall through TRUE/FALSE --> should never occur
			}
		}
	}
	// reposition the endPC
	codeStream.updateLastRecordedEndPC(position);
}


, Instance #
frags: 
(startLine=1045 endLine=1064 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifge(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.iflt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this);
				return;
			}

(startLine=1066 endLine=1085 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifle(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifgt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this);
				return;
			}

commonMethod: 
(startLine=2313 endLine=2324 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iconst_0() {
	countLabels = 0;
	stackDepth++;
	if (stackDepth > stackMax)
		stackMax = stackDepth;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iconst_0;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iconst_0);
	}
}


, Instance #
frags: 
(startLine=1045 endLine=1064 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifge(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.iflt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this);
				return;
			}

(startLine=1066 endLine=1085 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifle(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifgt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this);
				return;
			}

commonMethod: 
(startLine=2164 endLine=2203 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * We didn't call it goto, because there is a conflit with the goto keyword
 */
final public void goto_(Label lbl) {
	try {
		lbl.inlineForwardReferencesFromLabelsTargeting(position);
		/*
		 Possible optimization for code such as:
		 public Object foo() {
			boolean b = true;
			if (b) {
				if (b)
					return null;
			} else {
				if (b) {
					return null;
				}
			}
			return null;
		}
		The goto around the else block for the first if will
		be unreachable, because the thenClause of the second if
		returns.
		See inlineForwardReferencesFromLabelsTargeting defined
		on the Label class for the remaining part of this
		optimization.
		 if (!lbl.isBranchTarget(position)) {
			switch(bCodeStream[classFileOffset-1]) {
				case OPC_return :
				case OPC_areturn:
					return;
			}
		}*/
		position++;
		bCodeStream[classFileOffset++] = OPC_goto;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_goto);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=1045 endLine=1064 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifge(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.iflt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this);
				return;
			}

(startLine=1066 endLine=1085 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifle(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifgt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this);
				return;
			}

commonMethod: 
(startLine=2495 endLine=2505 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ifeq(Label lbl) {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ifeq;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ifeq);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=1172 endLine=1196 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
				} else {
					// <something equivalent to false> & x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_0();
						} else {
							if (falseLabel != null) {
								// implicit falling through the TRUE case
								codeStream.goto_(falseLabel);
							}
						}
					}
				}

(startLine=1219 endLine=1243 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
				} else {
					// x & <something equivalent to false>
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_0();
						} else {
							if (falseLabel != null) {
								// implicit falling through the TRUE case
								codeStream.goto_(falseLabel);
							}
						}
					}
				}

commonMethod: 
(startLine=2325 endLine=2336 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iconst_1() {
	countLabels = 0;
	stackDepth++;
	if (stackDepth > stackMax)
		stackMax = stackDepth;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iconst_1;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iconst_1);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=774 endLine=783 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void drem() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_drem;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_drem);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3417 endLine=3426 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ladd() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ladd;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ladd);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4212 endLine=4221 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lshr() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lshr;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lshr);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3188 endLine=3197 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void irem() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_irem;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_irem);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=2708 endLine=2717 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void imul() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_imul;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_imul);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=5386 endLine=5403 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * Write a signed 16 bits value into the byte array
 * @param 
 */
public final void writeSignedShort(int b) {
	try {
		position++;
		bCodeStream[classFileOffset++] = (byte) (b >> 8);
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray((byte) (b >> 8));
	}
	try {
		position++;
		bCodeStream[classFileOffset++] = (byte) b;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray((byte) b);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=1096 endLine=1105 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void fdiv() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_fdiv;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_fdiv);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=882 endLine=891 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void dsub() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_dsub;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_dsub);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=2293 endLine=2302 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iand() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iand;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iand);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4329 endLine=4338 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lxor() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lxor;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lxor);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=755 endLine=764 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void dmul() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_dmul;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_dmul);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=2397 endLine=2406 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void idiv() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_idiv;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_idiv);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3358 endLine=3367 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ixor() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ixor;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ixor);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=1010 endLine=1019 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void fadd() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_fadd;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_fadd);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3348 endLine=3357 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iushr() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iushr;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iushr);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3738 endLine=3747 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ldiv() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ldiv;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ldiv);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4967 endLine=5006 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public static final void sort(int[] tab, int lo0, int hi0, int[] result) {
	int lo = lo0;
	int hi = hi0;
	int mid;
	if (hi0 > lo0) {
		/* Arbitrarily establishing partition element as the midpoint of
		  * the array.
		  */
		mid = tab[ (lo0 + hi0) / 2];
		// loop through the array until indices cross
		while (lo <= hi) {
			/* find the first element that is greater than or equal to 
			 * the partition element starting from the left Index.
			 */
			while ((lo < hi0) && (tab[lo] < mid))
				++lo;
			/* find an element that is smaller than or equal to 
			 * the partition element starting from the right Index.
			 */
			while ((hi > lo0) && (tab[hi] > mid))
				--hi;
			// if the indexes have not crossed, swap
			if (lo <= hi) {
				swap(tab, lo, hi, result);
				++lo;
				--hi;
			}
		}
		/* If the right index has not reached the left side of array
		  * must now sort the left partition.
		  */
		if (lo0 < hi)
			sort(tab, lo0, hi, result);
		/* If the left index has not reached the right side of array
		  * must now sort the right partition.
		  */
		if (lo < hi0)
			sort(tab, lo, hi0, result);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3241 endLine=3250 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ishr() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ishr;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ishr);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4319 endLine=4328 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lushr() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lushr;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lushr);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=1222 endLine=1231 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void frem() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_frem;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_frem);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4171 endLine=4180 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lor() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lor;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lor);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3845 endLine=3854 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lmul() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lmul;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lmul);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=1330 endLine=1339 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void fsub() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_fsub;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_fsub);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=1203 endLine=1212 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void fmul() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_fmul;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_fmul);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=2273 endLine=2282 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iadd() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iadd;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iadd);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=644 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ddiv() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ddiv;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ddiv);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3178 endLine=3187 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ior() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ior;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ior);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4202 endLine=4211 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lshl() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lshl;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lshl);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3338 endLine=3347 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void isub() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_isub;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_isub);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4181 endLine=4190 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lrem() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lrem;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lrem);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3436 endLine=3445 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void land() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_land;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_land);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=571 endLine=580 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void dadd() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_dadd;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_dadd);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3231 endLine=3240 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ishl() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ishl;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ishl);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4309 endLine=4318 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lsub() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lsub;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lsub);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=774 endLine=783 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void drem() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_drem;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_drem);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3417 endLine=3426 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ladd() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ladd;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ladd);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4212 endLine=4221 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lshr() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lshr;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lshr);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3188 endLine=3197 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void irem() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_irem;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_irem);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=2708 endLine=2717 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void imul() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_imul;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_imul);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=5386 endLine=5403 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * Write a signed 16 bits value into the byte array
 * @param 
 */
public final void writeSignedShort(int b) {
	try {
		position++;
		bCodeStream[classFileOffset++] = (byte) (b >> 8);
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray((byte) (b >> 8));
	}
	try {
		position++;
		bCodeStream[classFileOffset++] = (byte) b;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray((byte) b);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=1096 endLine=1105 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void fdiv() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_fdiv;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_fdiv);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=882 endLine=891 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void dsub() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_dsub;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_dsub);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=2293 endLine=2302 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iand() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iand;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iand);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4329 endLine=4338 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lxor() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lxor;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lxor);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=755 endLine=764 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void dmul() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_dmul;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_dmul);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=2397 endLine=2406 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void idiv() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_idiv;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_idiv);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3358 endLine=3367 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ixor() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ixor;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ixor);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=1010 endLine=1019 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void fadd() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_fadd;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_fadd);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3348 endLine=3357 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iushr() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iushr;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iushr);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3738 endLine=3747 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ldiv() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ldiv;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ldiv);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4967 endLine=5006 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public static final void sort(int[] tab, int lo0, int hi0, int[] result) {
	int lo = lo0;
	int hi = hi0;
	int mid;
	if (hi0 > lo0) {
		/* Arbitrarily establishing partition element as the midpoint of
		  * the array.
		  */
		mid = tab[ (lo0 + hi0) / 2];
		// loop through the array until indices cross
		while (lo <= hi) {
			/* find the first element that is greater than or equal to 
			 * the partition element starting from the left Index.
			 */
			while ((lo < hi0) && (tab[lo] < mid))
				++lo;
			/* find an element that is smaller than or equal to 
			 * the partition element starting from the right Index.
			 */
			while ((hi > lo0) && (tab[hi] > mid))
				--hi;
			// if the indexes have not crossed, swap
			if (lo <= hi) {
				swap(tab, lo, hi, result);
				++lo;
				--hi;
			}
		}
		/* If the right index has not reached the left side of array
		  * must now sort the left partition.
		  */
		if (lo0 < hi)
			sort(tab, lo0, hi, result);
		/* If the left index has not reached the right side of array
		  * must now sort the right partition.
		  */
		if (lo < hi0)
			sort(tab, lo, hi0, result);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3241 endLine=3250 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ishr() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ishr;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ishr);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4319 endLine=4328 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lushr() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lushr;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lushr);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=1222 endLine=1231 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void frem() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_frem;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_frem);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4171 endLine=4180 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lor() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lor;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lor);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3845 endLine=3854 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lmul() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lmul;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lmul);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=1330 endLine=1339 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void fsub() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_fsub;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_fsub);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=1203 endLine=1212 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void fmul() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_fmul;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_fmul);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=2273 endLine=2282 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iadd() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iadd;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iadd);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=644 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ddiv() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ddiv;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ddiv);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3178 endLine=3187 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ior() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ior;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ior);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4202 endLine=4211 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lshl() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lshl;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lshl);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3338 endLine=3347 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void isub() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_isub;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_isub);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4181 endLine=4190 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lrem() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lrem;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lrem);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3436 endLine=3445 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void land() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_land;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_land);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=571 endLine=580 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void dadd() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_dadd;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_dadd);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=3231 endLine=3240 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ishl() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ishl;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ishl);
	}
}


, Instance #
frags: 
(startLine=5499 endLine=5519 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
			|| (type == BooleanBinding)) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.istore_0();
					break;
				case 1 :
					this.istore_1();
					break;
				case 2 :
					this.istore_2();
					break;
				case 3 :
					this.istore_3();
					break;
				default :
					this.istore(position);
			}
			return;
		}

(startLine=5521 endLine=5541 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == FloatBinding) {
			if (valueRequired)
				this.dup();
			switch (position) {
				case 0 :
					this.fstore_0();
					break;
				case 1 :
					this.fstore_1();
					break;
				case 2 :
					this.fstore_2();
					break;
				case 3 :
					this.fstore_3();
					break;
				default :
					this.fstore(position);
			}
			return;
		}

(startLine=5543 endLine=5563 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == LongBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.lstore_0();
					break;
				case 1 :
					this.lstore_1();
					break;
				case 2 :
					this.lstore_2();
					break;
				case 3 :
					this.lstore_3();
					break;
				default :
					this.lstore(position);
			}
			return;
		}

(startLine=5565 endLine=5585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
		if (type == DoubleBinding) {
			if (valueRequired)
				this.dup2();
			switch (position) {
				case 0 :
					this.dstore_0();
					break;
				case 1 :
					this.dstore_1();
					break;
				case 2 :
					this.dstore_2();
					break;
				case 3 :
					this.dstore_3();
					break;
				default :
					this.dstore(position);
			}
			return;
		}

commonMethod: 
(startLine=4309 endLine=4318 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lsub() {
	countLabels = 0;
	stackDepth -= 2;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lsub;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lsub);
	}
}


, Instance #
frags: 
(startLine=852 endLine=865 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
			for (int i = 0; i < 4; i++) {
				try {
					poolContent[currentOffset++] = (byte) (key >>> (24 - i * 8));
				} catch (IndexOutOfBoundsException e) { //currentOffset has been ++ already (see the -1)
					int length = poolContent.length;
					System.arraycopy(
						poolContent,
						0,
						(poolContent = new byte[length * 2 + CONSTANTPOOL_INITIAL_SIZE]),
						0,
						length);
					poolContent[currentOffset - 1] = (byte) (key >>> (24 - i * 8));
				}
			}

(startLine=895 endLine=908 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00001/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
			for (int i = 0; i < 8; i++) {
				try {
					poolContent[currentOffset++] = (byte) (key >>> (56 - (i << 3)));
				} catch (IndexOutOfBoundsException e) { //currentOffset has been ++ already (see the -1)
					int length = poolContent.length;
					System.arraycopy(
						poolContent,
						0,
						(poolContent = new byte[(length << 1) + CONSTANTPOOL_INITIAL_SIZE]),
						0,
						length);
					poolContent[currentOffset - 1] = (byte) (key >>> (56 - (i << 3)));
				}
			}

commonMethod: 
(startLine=2424 endLine=2447 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/ConstantPool.java)
/**
 * Write a unsigned byte into the byte array
 * 
 * @param <CODE>int</CODE> The value to write into the byte array
 */
protected final void writeU2(int value) {
	//first byte
	try {
		poolContent[currentOffset++] = (byte) (value >> 8);
	} catch (IndexOutOfBoundsException e) {
		 //currentOffset has been ++ already (see the -1)
		int length = poolContent.length;
		System.arraycopy(poolContent, 0, (poolContent = new byte[length + CONSTANTPOOL_GROW_SIZE]), 0, length);
		poolContent[currentOffset - 1] = (byte) (value >> 8);
	}
	try {
		poolContent[currentOffset++] = (byte) value;
	} catch (IndexOutOfBoundsException e) {
		 //currentOffset has been ++ already (see the -1)
		int length = poolContent.length;
		System.arraycopy(poolContent, 0, (poolContent = new byte[length + CONSTANTPOOL_GROW_SIZE]), 0, length);
		poolContent[currentOffset - 1] = (byte) value;
	}
}


, Instance #
frags: 
(startLine=196 endLine=243 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorDeclarationPattern.java)
	public boolean matchesBinary(Object binaryInfo, Object enclosingBinaryInfo) {
		if (!(binaryInfo instanceof IBinaryMethod))
			return false;

		IBinaryMethod method = (IBinaryMethod) binaryInfo;

		// must be a constructor
		if (!method.isConstructor())
			return false;

		// declaring type
		IBinaryType declaringType = (IBinaryType) enclosingBinaryInfo;
		if (declaringType != null) {
			char[] declaringTypeName = (char[]) declaringType.getName().clone();
			CharOperation.replace(declaringTypeName, '/', '.');
			if (!this
				.matchesType(
					this.declaringSimpleName,
					this.declaringQualification,
					declaringTypeName)) {
				return false;
			}
		}

		// parameter types
		int parameterCount =
			this.parameterSimpleNames == null ? -1 : this.parameterSimpleNames.length;
		if (parameterCount > -1) {
			String methodDescriptor =
				new String(method.getMethodDescriptor()).replace('/', '.');
			String[] arguments = Signature.getParameterTypes(methodDescriptor);
			int argumentCount = arguments.length;
			if (parameterCount != argumentCount)
				return false;
			for (int i = 0; i < parameterCount; i++) {
				char[] qualification = this.parameterQualifications[i];
				char[] type = this.parameterSimpleNames[i];
				if (!this
					.matchesType(
						type,
						qualification,
						Signature.toString(arguments[i]).toCharArray()))
					return false;
			}
		}

		return true;
	}

(startLine=271 endLine=329 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodDeclarationPattern.java)
	public boolean matchesBinary(Object binaryInfo, Object enclosingBinaryInfo) {
		if (!(binaryInfo instanceof IBinaryMethod))
			return false;

		IBinaryMethod method = (IBinaryMethod) binaryInfo;

		// selector
		if (!this.matchesName(this.selector, method.getSelector()))
			return false;

		// declaring type
		IBinaryType declaringType = (IBinaryType) enclosingBinaryInfo;
		if (declaringType != null) {
			char[] declaringTypeName = (char[]) declaringType.getName().clone();
			CharOperation.replace(declaringTypeName, '/', '.');
			if (!this
				.matchesType(
					this.declaringSimpleName,
					this.declaringQualification,
					declaringTypeName)) {
				return false;
			}
		}

		// return type
		String methodDescriptor =
			new String(method.getMethodDescriptor()).replace('/', '.');
		String returnTypeSignature =
			Signature.toString(Signature.getReturnType(methodDescriptor));
		if (!this
			.matchesType(
				this.returnSimpleName,
				this.returnQualification,
				returnTypeSignature.toCharArray())) {
			return false;
		}

		// parameter types
		int parameterCount =
			this.parameterSimpleNames == null ? -1 : this.parameterSimpleNames.length;
		if (parameterCount > -1) {
			String[] arguments = Signature.getParameterTypes(methodDescriptor);
			int argumentCount = arguments.length;
			if (parameterCount != argumentCount)
				return false;
			for (int i = 0; i < parameterCount; i++) {
				char[] qualification = this.parameterQualifications[i];
				char[] type = this.parameterSimpleNames[i];
				if (!this
					.matchesType(
						type,
						qualification,
						Signature.toString(arguments[i]).toCharArray()))
					return false;
			}
		}

		return true;
	}

commonMethod: 
(startLine=976 endLine=1000 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00003/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SearchPattern.java)
/**
 * Returns whether the given reference type binding matches or is a subtype of a type
 * that matches the given simple name pattern and qualification pattern.
 */
protected boolean matchesAsSubtype(ReferenceBinding type, char[] simpleNamePattern, char[] qualificationPattern) {
	// matches type
	if (this.matchesType(simpleNamePattern, qualificationPattern, type))
		return true;
	
	// matches superclass
	ReferenceBinding superclass = type.superclass();
	if (superclass != null) {
		if (this.matchesAsSubtype(superclass, simpleNamePattern, qualificationPattern))
			return true;
	}

	// matches interfaces
	ReferenceBinding[] interfaces = type.superInterfaces();
	for (int i = 0; i < interfaces.length; i++) {
		if (this.matchesAsSubtype(interfaces[i], simpleNamePattern, qualificationPattern))
			return true;
	}

	return false;
}


, Instance #
frags: 
(startLine=311 endLine=326 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MethodDeclarationPattern.java)
		if (parameterCount > -1) {
			String[] arguments = Signature.getParameterTypes(methodDescriptor);
			int argumentCount = arguments.length;
			if (parameterCount != argumentCount)
				return false;
			for (int i = 0; i < parameterCount; i++) {
				char[] qualification = this.parameterQualifications[i];
				char[] type = this.parameterSimpleNames[i];
				if (!this
					.matchesType(
						type,
						qualification,
						Signature.toString(arguments[i]).toCharArray()))
					return false;
			}
		}

(startLine=223 endLine=240 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/ConstructorDeclarationPattern.java)
		if (parameterCount > -1) {
			String methodDescriptor =
				new String(method.getMethodDescriptor()).replace('/', '.');
			String[] arguments = Signature.getParameterTypes(methodDescriptor);
			int argumentCount = arguments.length;
			if (parameterCount != argumentCount)
				return false;
			for (int i = 0; i < parameterCount; i++) {
				char[] qualification = this.parameterQualifications[i];
				char[] type = this.parameterSimpleNames[i];
				if (!this
					.matchesType(
						type,
						qualification,
						Signature.toString(arguments[i]).toCharArray()))
					return false;
			}
		}

commonMethod: 
(startLine=976 endLine=1000 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00003/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/SearchPattern.java)
/**
 * Returns whether the given reference type binding matches or is a subtype of a type
 * that matches the given simple name pattern and qualification pattern.
 */
protected boolean matchesAsSubtype(ReferenceBinding type, char[] simpleNamePattern, char[] qualificationPattern) {
	// matches type
	if (this.matchesType(simpleNamePattern, qualificationPattern, type))
		return true;
	
	// matches superclass
	ReferenceBinding superclass = type.superclass();
	if (superclass != null) {
		if (this.matchesAsSubtype(superclass, simpleNamePattern, qualificationPattern))
			return true;
	}

	// matches interfaces
	ReferenceBinding[] interfaces = type.superInterfaces();
	for (int i = 0; i < interfaces.length; i++) {
		if (this.matchesAsSubtype(interfaces[i], simpleNamePattern, qualificationPattern))
			return true;
	}

	return false;
}


, Instance #
frags: 
(startLine=458 endLine=471 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
				{
					// method
					IType declaringClass = getType(in.readInt());
					if (declaringClass.isPrimitive() || declaringClass.isArray()) {
						throw new IOException("Bad format");
					}
					String name = getString(in.readInt());
					int numParams = in.readByte() & 0xFF;
					IType[] params = new IType[numParams];
					for (int i = 0; i < numParams; ++i) {
						params[i] = getType(in.readInt());
					}
					return declaringClass.getMethodHandle(name, params);
				}

(startLine=473 endLine=485 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
				{
					// constructor
					IType declaringClass = getType(in.readInt());
					if (declaringClass.isPrimitive() || declaringClass.isArray()) {
						throw new IOException("Bad format");
					}
					int numParams = in.readByte() & 0xFF;
					IType[] params = new IType[numParams];
					for (int i = 0; i < numParams; ++i) {
						params[i] = getType(in.readInt());
					}
					return declaringClass.getConstructorHandle(params);
				}

commonMethod: 
(startLine=465 endLine=485 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00003/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
/**
 * Internal -- Read a Number from an input stream into the pool.
 */
private Number readNumber(DataInputStream in, int tag) throws IOException {
	switch (tag) {
		case 12:
			// Integer
			return new Integer(in.readInt());
		case 13:
			// Long
			return new Long(in.readLong());
		case 14:
			// Float
			return new Float(Float.intBitsToFloat(in.readInt()));
		case 15:
			// Double
			return new Double(Double.longBitsToDouble(in.readLong()));
		default:
			throw new IOException("Unexpeced kind of Number");
	}
}


, Instance #
frags: 
(startLine=458 endLine=471 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
				{
					// method
					IType declaringClass = getType(in.readInt());
					if (declaringClass.isPrimitive() || declaringClass.isArray()) {
						throw new IOException("Bad format");
					}
					String name = getString(in.readInt());
					int numParams = in.readByte() & 0xFF;
					IType[] params = new IType[numParams];
					for (int i = 0; i < numParams; ++i) {
						params[i] = getType(in.readInt());
					}
					return declaringClass.getMethodHandle(name, params);
				}

(startLine=473 endLine=485 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
				{
					// constructor
					IType declaringClass = getType(in.readInt());
					if (declaringClass.isPrimitive() || declaringClass.isArray()) {
						throw new IOException("Bad format");
					}
					int numParams = in.readByte() & 0xFF;
					IType[] params = new IType[numParams];
					for (int i = 0; i < numParams; ++i) {
						params[i] = getType(in.readInt());
					}
					return declaringClass.getConstructorHandle(params);
				}

commonMethod: 
(startLine=114 endLine=139 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00003/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/OrderedSet.java)
/**
 * Associate the given object with the given index in this OrderedSet.
 * The object's index is not retrievable using index(Object).
 * But the object is retrievable using get(int index).
 * The index must not yet have been assigned.
 *
 * @param		index the index of the object
 * @param		obj	the object to add
 *
 * @see			#get
 * @see			java.lang.Object#equals
 */
public void put(int index, Object obj) {
	if (obj == null) throw new NullPointerException ();
	if (orderedList.length <= index) {
		int[] newOrderedList = new int[orderedList.length*2];
		System.arraycopy(orderedList, 0, newOrderedList, 0, elementCount);
	}
	if (orderedList[index] != null) {
		throw new IllegalArgumentException();
	}
	orderedList[index] = obj;
	if (index >= elementCount) {
		elementCount = index + 1;
	}
}


, Instance #
frags: 
(startLine=458 endLine=471 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
				{
					// method
					IType declaringClass = getType(in.readInt());
					if (declaringClass.isPrimitive() || declaringClass.isArray()) {
						throw new IOException("Bad format");
					}
					String name = getString(in.readInt());
					int numParams = in.readByte() & 0xFF;
					IType[] params = new IType[numParams];
					for (int i = 0; i < numParams; ++i) {
						params[i] = getType(in.readInt());
					}
					return declaringClass.getMethodHandle(name, params);
				}

(startLine=473 endLine=485 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
				{
					// constructor
					IType declaringClass = getType(in.readInt());
					if (declaringClass.isPrimitive() || declaringClass.isArray()) {
						throw new IOException("Bad format");
					}
					int numParams = in.readByte() & 0xFF;
					IType[] params = new IType[numParams];
					for (int i = 0; i < numParams; ++i) {
						params[i] = getType(in.readInt());
					}
					return declaringClass.getConstructorHandle(params);
				}

commonMethod: 
(startLine=358 endLine=376 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00003/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapV5.java)
/** 
 * Read the next source entry.
 */
protected SourceEntry readSourceEntry(StateSnapConstantPool pool, DataInputStream in) throws IOException {
	IPath path = pool.getPath(in.readInt());
	String zipEntryName = pool.getStringOrNull(in.readInt());
	String zipEntryPath = null, zipEntryFileName = null;
	if (zipEntryName != null) {
		int pos = zipEntryName.lastIndexOf('/');
		if (pos != -1) {
			zipEntryPath = zipEntryName.substring(0, pos);
			zipEntryFileName = zipEntryName.substring(pos + 1);
		} else {
			zipEntryPath = null;
			zipEntryFileName = zipEntryName;
		}
	}
	return new SourceEntry(path, zipEntryPath, zipEntryFileName);
}


, Instance #
frags: 
(startLine=458 endLine=471 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
				{
					// method
					IType declaringClass = getType(in.readInt());
					if (declaringClass.isPrimitive() || declaringClass.isArray()) {
						throw new IOException("Bad format");
					}
					String name = getString(in.readInt());
					int numParams = in.readByte() & 0xFF;
					IType[] params = new IType[numParams];
					for (int i = 0; i < numParams; ++i) {
						params[i] = getType(in.readInt());
					}
					return declaringClass.getMethodHandle(name, params);
				}

(startLine=473 endLine=485 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
				{
					// constructor
					IType declaringClass = getType(in.readInt());
					if (declaringClass.isPrimitive() || declaringClass.isArray()) {
						throw new IOException("Bad format");
					}
					int numParams = in.readByte() & 0xFF;
					IType[] params = new IType[numParams];
					for (int i = 0; i < numParams; ++i) {
						params[i] = getType(in.readInt());
					}
					return declaringClass.getConstructorHandle(params);
				}

commonMethod: 
(startLine=394 endLine=464 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00003/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
/**
 * Internal -- Read an IHandle from an input stream into the pool.
 */
private IHandle readHandle(IDevelopmentContext dc, DataInputStream in, int tag) throws IOException {
	switch (tag) {
		case 4: {
			// package
			String name = getString(in.readInt());
			boolean isUnnamed = in.readBoolean();
			return dc.getImage().getPackageHandle(name, isUnnamed);
		}
		case 5: {
			// primitive type
			// Should not occur since primitive types are well known and not written
			throw new IOException("Internal error");
		}
		case 6: {
			// array type
			TypeImpl elementType = (TypeImpl) getType(in.readInt());
			int nesting = in.readByte() & 0xFF;
			return new ArrayTypeHandleImpl(elementType, nesting);
		}
		case 7: {
			// class or interface type
			IPackage pkg = getPackage(in.readInt());
			String simpleName = getString(in.readInt());
			return pkg.getClassHandle(simpleName);
		}
		case 8: {
			// method
			IType declaringClass = getType(in.readInt());
			if (declaringClass.isPrimitive() || declaringClass.isArray()) {
				throw new IOException("Bad format");
			}
			String name = getString(in.readInt());
			int numParams = in.readByte() & 0xFF;
			IType[] params = new IType[numParams];
			for (int i = 0; i < numParams; ++i) {
				params[i] = getType(in.readInt());
			}
			return declaringClass.getMethodHandle(name, params);
		}
		case 9: {
			// constructor
			IType declaringClass = getType(in.readInt());
			if (declaringClass.isPrimitive() || declaringClass.isArray()) {
				throw new IOException("Bad format");
			}
			int numParams = in.readByte() & 0xFF;
			IType[] params = new IType[numParams];
			for (int i = 0; i < numParams; ++i) {
				params[i] = getType(in.readInt());
			}
			return declaringClass.getConstructorHandle(params);
		}
		case 10: {
			// field 
			IType declaringClass = getType(in.readInt());
			if (declaringClass.isPrimitive() || declaringClass.isArray()) {
				throw new IOException("Bad format");
			}
			String name = getString(in.readInt());
			return declaringClass.getFieldHandle(name);
		}
		case 11:
			// image
			return dc.getImage();
		default:
			throw new IOException("Unexpected kind of pool item");
	}
}


, Instance #
frags: 
(startLine=458 endLine=471 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
				{
					// method
					IType declaringClass = getType(in.readInt());
					if (declaringClass.isPrimitive() || declaringClass.isArray()) {
						throw new IOException("Bad format");
					}
					String name = getString(in.readInt());
					int numParams = in.readByte() & 0xFF;
					IType[] params = new IType[numParams];
					for (int i = 0; i < numParams; ++i) {
						params[i] = getType(in.readInt());
					}
					return declaringClass.getMethodHandle(name, params);
				}

(startLine=473 endLine=485 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00002/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
				{
					// constructor
					IType declaringClass = getType(in.readInt());
					if (declaringClass.isPrimitive() || declaringClass.isArray()) {
						throw new IOException("Bad format");
					}
					int numParams = in.readByte() & 0xFF;
					IType[] params = new IType[numParams];
					for (int i = 0; i < numParams; ++i) {
						params[i] = getType(in.readInt());
					}
					return declaringClass.getConstructorHandle(params);
				}

commonMethod: 
(startLine=193 endLine=207 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00003/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/impl/StateSnapConstantPool.java)
/**
 * Returns the IPath at the given index.  It must not be null.
 */
public IPath getPath(int index) throws IOException {
	try {
		IPath result = (IPath)fSet.get(index);
		if (result == null) {
			throw new IOException("Error in format");
		}
		return result;
	}
	catch (ClassCastException e) {
		throw new IOException("Error in format");
	}
}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00025/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00025/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2465 endLine=2487 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00026/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method generates the header of a code attribute.
	 * - the index inside the constant pool for the attribute name (i.e. Code)
	 * - leave some space for attribute_length(4), max_stack(2), max_locals(2), code_length(4).
	 */
	public void generateCodeAttributeHeader() {
		int contentsLength;
		if (contentsOffset + 20 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		int constantValueNameIndex =
			constantPool.literalIndex(AttributeNamesConstants.CodeName);
		contents[contentsOffset++] = (byte) (constantValueNameIndex >> 8);
		contents[contentsOffset++] = (byte) constantValueNameIndex;
		// leave space for attribute_length(4), max_stack(2), max_locals(2), code_length(4)
		contentsOffset += 12;
	}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00025/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00025/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2597 endLine=2632 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00026/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method generates the header of a method info:
	 * The header consists in:
	 * - the access flags
	 * - the name index of the method name inside the constant pool
	 * - the descriptor index of the signature of the method inside the constant pool.
	 *
	 * @param methodBinding org.eclipse.jdt.internal.compiler.lookup.MethodBinding
	 */
	public void generateMethodInfoHeader(MethodBinding methodBinding) {
		// check that there is enough space to write all the bytes for the method info corresponding
		// to the @methodBinding
		int contentsLength;
		methodCount++; // add one more method
		if (contentsOffset + 10 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		int accessFlags = methodBinding.getAccessFlags();
		if (methodBinding.isRequiredToClearPrivateModifier()) {
			accessFlags &= ~AccPrivate;
		}
		contents[contentsOffset++] = (byte) (accessFlags >> 8);
		contents[contentsOffset++] = (byte) accessFlags;
		int nameIndex = constantPool.literalIndex(methodBinding.selector);
		contents[contentsOffset++] = (byte) (nameIndex >> 8);
		contents[contentsOffset++] = (byte) nameIndex;
		int descriptorIndex = constantPool.literalIndex(methodBinding.signature());
		contents[contentsOffset++] = (byte) (descriptorIndex >> 8);
		contents[contentsOffset++] = (byte) descriptorIndex;
	}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00025/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00025/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2748 endLine=2788 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00026/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public void init(ClassFile classFile) {
	this.classFile = classFile;
	this.constantPool = classFile.constantPool;
	this.bCodeStream = classFile.contents;
	this.classFileOffset = classFile.contentsOffset;
	this.startingClassFileOffset = this.classFileOffset;
	pcToSourceMapSize = 0;
	lastEntryPC = 0;
	int length = visibleLocals.length;
	if (noVisibleLocals.length < length) {
		noVisibleLocals = new LocalVariableBinding[length];
	}
	System.arraycopy(noVisibleLocals, 0, visibleLocals, 0, length);
	visibleLocalsCount = 0;
	
	length = locals.length;
	if (noLocals.length < length) {
		noLocals = new LocalVariableBinding[length];
	}
	System.arraycopy(noLocals, 0, locals, 0, length);
	allLocalsCounter = 0;

	length = exceptionHandlers.length;
	if (noExceptionHandlers.length < length) {
		noExceptionHandlers = new ExceptionLabel[length];
	}
	System.arraycopy(noExceptionHandlers, 0, exceptionHandlers, 0, length);
	exceptionHandlersNumber = 0;
	
	length = labels.length;
	if (noLabels.length < length) {
		noLabels = new Label[length];
	}
	System.arraycopy(noLabels, 0, labels, 0, length);
	countLabels = 0;

	stackMax = 0;
	stackDepth = 0;
	maxLocals = 0;
	position = 0;
}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00025/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00025/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2106 endLine=2274 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00026/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method completes the creation of the code attribute by setting
	 * - the attribute_length
	 * - max_stack
	 * - max_locals
	 * - code_length
	 * - exception table
	 * - and debug attributes if necessary.
	 *
	 * @param binding org.eclipse.jdt.internal.compiler.lookup.SyntheticAccessMethodBinding
	 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
	 * @param codeAttributeOffset <CODE>int</CODE>
	 */
	public void completeCodeAttributeForSyntheticAccessMethod(
		SyntheticAccessMethodBinding binding,
		int codeAttributeOffset,
		int[] startLineIndexes) {
		// reinitialize the contents with the byte modified by the code stream
		contents = codeStream.bCodeStream;
		int localContentsOffset = codeStream.classFileOffset;
		// codeAttributeOffset is the position inside contents byte array before we started to write
		// any information about the codeAttribute
		// That means that to write the attribute_length you need to offset by 2 the value of codeAttributeOffset
		// to get the right position, 6 for the max_stack etc...
		int max_stack = codeStream.stackMax;
		contents[codeAttributeOffset + 6] = (byte) (max_stack >> 8);
		contents[codeAttributeOffset + 7] = (byte) max_stack;
		int max_locals = codeStream.maxLocals;
		contents[codeAttributeOffset + 8] = (byte) (max_locals >> 8);
		contents[codeAttributeOffset + 9] = (byte) max_locals;
		int code_length = codeStream.position;
		contents[codeAttributeOffset + 10] = (byte) (code_length >> 24);
		contents[codeAttributeOffset + 11] = (byte) (code_length >> 16);
		contents[codeAttributeOffset + 12] = (byte) (code_length >> 8);
		contents[codeAttributeOffset + 13] = (byte) code_length;
		int contentsLength;
		if ((localContentsOffset + 40) >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		// there is no exception table, so we need to offset by 2 the current offset and move 
		// on the attribute generation
		localContentsOffset += 2;
		// debug attributes
		int codeAttributeAttributeOffset = localContentsOffset;
		int attributeNumber = 0;
		// leave two bytes for the attribute_length
		localContentsOffset += 2;

		// first we handle the linenumber attribute
		if (codeStream.generateLineNumberAttributes) {
			int index = 0, max = startLineIndexes.length;
			int lineNumberNameIndex =
				constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			contents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			contents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6;
			// leave space for attribute_length and line_number_table_length
			// Seems like do would be better, but this preserves the existing behavior.
			index = searchLineNumber(startLineIndexes, binding.sourceStart);
			contents[localContentsOffset++] = 0;
			contents[localContentsOffset++] = 0;
			contents[localContentsOffset++] = (byte) (index >> 8);
			contents[localContentsOffset++] = (byte) index;
			// now we change the size of the line number attribute
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 6;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 1;
			attributeNumber++;
		}
		// then we do the local variable attribute
		if (codeStream.generateLocalVariableTableAttributes) {
			int localVariableTableOffset = localContentsOffset;
			int numberOfEntries = 0;
			int localVariableNameIndex =
				constantPool.literalIndex(AttributeNamesConstants.LocalVariableTableName);
			if (localContentsOffset + 8 > (contentsLength = contents.length)) {
				System.arraycopy(
					contents,
					0,
					(contents = new byte[contentsLength + INCREMENT_SIZE]),
					0,
					contentsLength);
			}
			contents[localContentsOffset++] = (byte) (localVariableNameIndex >> 8);
			contents[localContentsOffset++] = (byte) localVariableNameIndex;
			localContentsOffset += 6;
			// leave space for attribute_length and local_variable_table_length
			int nameIndex;
			int descriptorIndex;
			for (int i = 0; i < codeStream.allLocalsCounter; i++) {
				LocalVariableBinding localVariable = codeStream.locals[i];
				for (int j = 0; j < localVariable.initializationCount; j++) {
					int startPC = localVariable.initializationPCs[j << 1];
					int endPC = localVariable.initializationPCs[(j << 1) + 1];
					if (startPC != endPC) { // only entries for non zero length
						int currentLength;
						if (endPC == -1) {
							localVariable.declaringScope.problemReporter().abortDueToInternalError(
								Util.bind("abort.invalidAttribute" /*nonNLS*/, new String(localVariable.name)),
								(AstNode) localVariable.declaringScope.methodScope().referenceContext);
						}
						if (localContentsOffset + 10 > (contentsLength = contents.length)) {
							System.arraycopy(
								contents,
								0,
								(contents = new byte[contentsLength + INCREMENT_SIZE]),
								0,
								contentsLength);
						}
						// now we can safely add the local entry
						numberOfEntries++;
						contents[localContentsOffset++] = (byte) (startPC >> 8);
						contents[localContentsOffset++] = (byte) startPC;
						int length = endPC - startPC;
						contents[localContentsOffset++] = (byte) (length >> 8);
						contents[localContentsOffset++] = (byte) length;
						nameIndex = constantPool.literalIndex(localVariable.name);
						contents[localContentsOffset++] = (byte) (nameIndex >> 8);
						contents[localContentsOffset++] = (byte) nameIndex;
						descriptorIndex = constantPool.literalIndex(localVariable.type.signature());
						contents[localContentsOffset++] = (byte) (descriptorIndex >> 8);
						contents[localContentsOffset++] = (byte) descriptorIndex;
						int resolvedPosition = localVariable.resolvedPosition;
						contents[localContentsOffset++] = (byte) (resolvedPosition >> 8);
						contents[localContentsOffset++] = (byte) resolvedPosition;
					}
				}
			}
			int value = numberOfEntries * 10 + 2;
			localVariableTableOffset += 2;
			contents[localVariableTableOffset++] = (byte) (value >> 24);
			contents[localVariableTableOffset++] = (byte) (value >> 16);
			contents[localVariableTableOffset++] = (byte) (value >> 8);
			contents[localVariableTableOffset++] = (byte) value;
			contents[localVariableTableOffset++] = (byte) (numberOfEntries >> 8);
			contents[localVariableTableOffset] = (byte) numberOfEntries;
			attributeNumber++;
		}
		// update the number of attributes
		// ensure first that there is enough space available inside the contents array
		if (codeAttributeAttributeOffset + 2 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		contents[codeAttributeAttributeOffset++] = (byte) (attributeNumber >> 8);
		contents[codeAttributeAttributeOffset] = (byte) attributeNumber;

		// update the attribute length
		int codeAttributeLength = localContentsOffset - (codeAttributeOffset + 6);
		contents[codeAttributeOffset + 2] = (byte) (codeAttributeLength >> 24);
		contents[codeAttributeOffset + 3] = (byte) (codeAttributeLength >> 16);
		contents[codeAttributeOffset + 4] = (byte) (codeAttributeLength >> 8);
		contents[codeAttributeOffset + 5] = (byte) codeAttributeLength;
		contentsOffset = localContentsOffset;
	}


, Instance #
frags: 
(startLine=927 endLine=955 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00037/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

(startLine=701 endLine=733 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00037/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=664 endLine=742 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00037/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		Scope invocationScope) {

		if (fieldName == null)
			return;

		ReferenceBinding currentType = receiverType;
		ReferenceBinding[][] interfacesToVisit = null;
		int lastPosition = -1;
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findFields(
				fieldName,
				currentType.fields(),
				scope,
				fieldsFound,
				localsFound,
				onlyStaticFields,
				receiverType,
				invocationSite,
				invocationScope);
			currentType = currentType.superclass();
		} while (currentType != null);

		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
	}

(startLine=880 endLine=964 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00037/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		SourceTypeBinding typeInvocation) {

		ReferenceBinding currentType = receiverType;
		if (typeName == null)
			return;
		if (currentType.superInterfaces() == null)
			return; // we're trying to find a supertype

		ObjectVector typesFound = new ObjectVector();
		if (insideQualifiedReference
			|| typeName.length == 0) { // do not search up the hierarchy
			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			return;
		}

		ReferenceBinding[][] interfacesToVisit = null;
		int lastPosition = -1;
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			currentType = currentType.superclass();
		} while (currentType != null);

		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
	}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=672 endLine=698 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00037/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findFields(
				fieldName,
				currentType.fields(),
				scope,
				fieldsFound,
				localsFound,
				onlyStaticFields,
				receiverType,
				invocationSite,
				invocationScope);
			currentType = currentType.superclass();
		} while (currentType != null);

(startLine=902 endLine=924 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00037/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			currentType = currentType.superclass();
		} while (currentType != null);

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=703 endLine=732 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00037/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}

(startLine=929 endLine=954 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00037/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2106 endLine=2274 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method completes the creation of the code attribute by setting
	 * - the attribute_length
	 * - max_stack
	 * - max_locals
	 * - code_length
	 * - exception table
	 * - and debug attributes if necessary.
	 *
	 * @param binding org.eclipse.jdt.internal.compiler.lookup.SyntheticAccessMethodBinding
	 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
	 * @param codeAttributeOffset <CODE>int</CODE>
	 */
	public void completeCodeAttributeForSyntheticAccessMethod(
		SyntheticAccessMethodBinding binding,
		int codeAttributeOffset,
		int[] startLineIndexes) {
		// reinitialize the contents with the byte modified by the code stream
		contents = codeStream.bCodeStream;
		int localContentsOffset = codeStream.classFileOffset;
		// codeAttributeOffset is the position inside contents byte array before we started to write
		// any information about the codeAttribute
		// That means that to write the attribute_length you need to offset by 2 the value of codeAttributeOffset
		// to get the right position, 6 for the max_stack etc...
		int max_stack = codeStream.stackMax;
		contents[codeAttributeOffset + 6] = (byte) (max_stack >> 8);
		contents[codeAttributeOffset + 7] = (byte) max_stack;
		int max_locals = codeStream.maxLocals;
		contents[codeAttributeOffset + 8] = (byte) (max_locals >> 8);
		contents[codeAttributeOffset + 9] = (byte) max_locals;
		int code_length = codeStream.position;
		contents[codeAttributeOffset + 10] = (byte) (code_length >> 24);
		contents[codeAttributeOffset + 11] = (byte) (code_length >> 16);
		contents[codeAttributeOffset + 12] = (byte) (code_length >> 8);
		contents[codeAttributeOffset + 13] = (byte) code_length;
		int contentsLength;
		if ((localContentsOffset + 40) >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		// there is no exception table, so we need to offset by 2 the current offset and move 
		// on the attribute generation
		localContentsOffset += 2;
		// debug attributes
		int codeAttributeAttributeOffset = localContentsOffset;
		int attributeNumber = 0;
		// leave two bytes for the attribute_length
		localContentsOffset += 2;

		// first we handle the linenumber attribute
		if (codeStream.generateLineNumberAttributes) {
			int index = 0, max = startLineIndexes.length;
			int lineNumberNameIndex =
				constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			contents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			contents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6;
			// leave space for attribute_length and line_number_table_length
			// Seems like do would be better, but this preserves the existing behavior.
			index = searchLineNumber(startLineIndexes, binding.sourceStart);
			contents[localContentsOffset++] = 0;
			contents[localContentsOffset++] = 0;
			contents[localContentsOffset++] = (byte) (index >> 8);
			contents[localContentsOffset++] = (byte) index;
			// now we change the size of the line number attribute
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 6;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 1;
			attributeNumber++;
		}
		// then we do the local variable attribute
		if (codeStream.generateLocalVariableTableAttributes) {
			int localVariableTableOffset = localContentsOffset;
			int numberOfEntries = 0;
			int localVariableNameIndex =
				constantPool.literalIndex(AttributeNamesConstants.LocalVariableTableName);
			if (localContentsOffset + 8 > (contentsLength = contents.length)) {
				System.arraycopy(
					contents,
					0,
					(contents = new byte[contentsLength + INCREMENT_SIZE]),
					0,
					contentsLength);
			}
			contents[localContentsOffset++] = (byte) (localVariableNameIndex >> 8);
			contents[localContentsOffset++] = (byte) localVariableNameIndex;
			localContentsOffset += 6;
			// leave space for attribute_length and local_variable_table_length
			int nameIndex;
			int descriptorIndex;
			for (int i = 0; i < codeStream.allLocalsCounter; i++) {
				LocalVariableBinding localVariable = codeStream.locals[i];
				for (int j = 0; j < localVariable.initializationCount; j++) {
					int startPC = localVariable.initializationPCs[j << 1];
					int endPC = localVariable.initializationPCs[(j << 1) + 1];
					if (startPC != endPC) { // only entries for non zero length
						int currentLength;
						if (endPC == -1) {
							localVariable.declaringScope.problemReporter().abortDueToInternalError(
								Util.bind("abort.invalidAttribute" , new String(localVariable.name)), //$NON-NLS-1$
								(AstNode) localVariable.declaringScope.methodScope().referenceContext);
						}
						if (localContentsOffset + 10 > (contentsLength = contents.length)) {
							System.arraycopy(
								contents,
								0,
								(contents = new byte[contentsLength + INCREMENT_SIZE]),
								0,
								contentsLength);
						}
						// now we can safely add the local entry
						numberOfEntries++;
						contents[localContentsOffset++] = (byte) (startPC >> 8);
						contents[localContentsOffset++] = (byte) startPC;
						int length = endPC - startPC;
						contents[localContentsOffset++] = (byte) (length >> 8);
						contents[localContentsOffset++] = (byte) length;
						nameIndex = constantPool.literalIndex(localVariable.name);
						contents[localContentsOffset++] = (byte) (nameIndex >> 8);
						contents[localContentsOffset++] = (byte) nameIndex;
						descriptorIndex = constantPool.literalIndex(localVariable.type.signature());
						contents[localContentsOffset++] = (byte) (descriptorIndex >> 8);
						contents[localContentsOffset++] = (byte) descriptorIndex;
						int resolvedPosition = localVariable.resolvedPosition;
						contents[localContentsOffset++] = (byte) (resolvedPosition >> 8);
						contents[localContentsOffset++] = (byte) resolvedPosition;
					}
				}
			}
			int value = numberOfEntries * 10 + 2;
			localVariableTableOffset += 2;
			contents[localVariableTableOffset++] = (byte) (value >> 24);
			contents[localVariableTableOffset++] = (byte) (value >> 16);
			contents[localVariableTableOffset++] = (byte) (value >> 8);
			contents[localVariableTableOffset++] = (byte) value;
			contents[localVariableTableOffset++] = (byte) (numberOfEntries >> 8);
			contents[localVariableTableOffset] = (byte) numberOfEntries;
			attributeNumber++;
		}
		// update the number of attributes
		// ensure first that there is enough space available inside the contents array
		if (codeAttributeAttributeOffset + 2 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		contents[codeAttributeAttributeOffset++] = (byte) (attributeNumber >> 8);
		contents[codeAttributeAttributeOffset] = (byte) attributeNumber;

		// update the attribute length
		int codeAttributeLength = localContentsOffset - (codeAttributeOffset + 6);
		contents[codeAttributeOffset + 2] = (byte) (codeAttributeLength >> 24);
		contents[codeAttributeOffset + 3] = (byte) (codeAttributeLength >> 16);
		contents[codeAttributeOffset + 4] = (byte) (codeAttributeLength >> 8);
		contents[codeAttributeOffset + 5] = (byte) codeAttributeLength;
		contentsOffset = localContentsOffset;
	}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2597 endLine=2632 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method generates the header of a method info:
	 * The header consists in:
	 * - the access flags
	 * - the name index of the method name inside the constant pool
	 * - the descriptor index of the signature of the method inside the constant pool.
	 *
	 * @param methodBinding org.eclipse.jdt.internal.compiler.lookup.MethodBinding
	 */
	public void generateMethodInfoHeader(MethodBinding methodBinding) {
		// check that there is enough space to write all the bytes for the method info corresponding
		// to the @methodBinding
		int contentsLength;
		methodCount++; // add one more method
		if (contentsOffset + 10 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		int accessFlags = methodBinding.getAccessFlags();
		if (methodBinding.isRequiredToClearPrivateModifier()) {
			accessFlags &= ~AccPrivate;
		}
		contents[contentsOffset++] = (byte) (accessFlags >> 8);
		contents[contentsOffset++] = (byte) accessFlags;
		int nameIndex = constantPool.literalIndex(methodBinding.selector);
		contents[contentsOffset++] = (byte) (nameIndex >> 8);
		contents[contentsOffset++] = (byte) nameIndex;
		int descriptorIndex = constantPool.literalIndex(methodBinding.signature());
		contents[contentsOffset++] = (byte) (descriptorIndex >> 8);
		contents[contentsOffset++] = (byte) descriptorIndex;
	}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2748 endLine=2788 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public void init(ClassFile classFile) {
	this.classFile = classFile;
	this.constantPool = classFile.constantPool;
	this.bCodeStream = classFile.contents;
	this.classFileOffset = classFile.contentsOffset;
	this.startingClassFileOffset = this.classFileOffset;
	pcToSourceMapSize = 0;
	lastEntryPC = 0;
	int length = visibleLocals.length;
	if (noVisibleLocals.length < length) {
		noVisibleLocals = new LocalVariableBinding[length];
	}
	System.arraycopy(noVisibleLocals, 0, visibleLocals, 0, length);
	visibleLocalsCount = 0;
	
	length = locals.length;
	if (noLocals.length < length) {
		noLocals = new LocalVariableBinding[length];
	}
	System.arraycopy(noLocals, 0, locals, 0, length);
	allLocalsCounter = 0;

	length = exceptionHandlers.length;
	if (noExceptionHandlers.length < length) {
		noExceptionHandlers = new ExceptionLabel[length];
	}
	System.arraycopy(noExceptionHandlers, 0, exceptionHandlers, 0, length);
	exceptionHandlersNumber = 0;
	
	length = labels.length;
	if (noLabels.length < length) {
		noLabels = new Label[length];
	}
	System.arraycopy(noLabels, 0, labels, 0, length);
	countLabels = 0;

	stackMax = 0;
	stackDepth = 0;
	maxLocals = 0;
	position = 0;
}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2465 endLine=2487 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method generates the header of a code attribute.
	 * - the index inside the constant pool for the attribute name (i.e. Code)
	 * - leave some space for attribute_length(4), max_stack(2), max_locals(2), code_length(4).
	 */
	public void generateCodeAttributeHeader() {
		int contentsLength;
		if (contentsOffset + 20 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		int constantValueNameIndex =
			constantPool.literalIndex(AttributeNamesConstants.CodeName);
		contents[contentsOffset++] = (byte) (constantValueNameIndex >> 8);
		contents[contentsOffset++] = (byte) constantValueNameIndex;
		// leave space for attribute_length(4), max_stack(2), max_locals(2), code_length(4)
		contentsOffset += 12;
	}


, Instance #
frags: 
(startLine=701 endLine=713 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
	if (fieldDeclaration.isField()) {
		// create defining field handle
		IField field = this.createFieldHandle(fieldDeclaration, definingTypeNames);
	
		// accept reference
		if (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {
			this.pattern.matchReportReference((AstNode)reference, field, accuracy, this);
		} else if (reference instanceof MessageSend) { // message ref are starting at the selector start
			this.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, field, accuracy);
		} else {
			this.report(reference.sourceStart, reference.sourceEnd, field, accuracy);
		}
	} else { // initializer

(startLine=713 endLine=725 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00038/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
	} else { // initializer
		// create defining initializer
		IInitializer initializer = this.createInitializerHandle(typeDeclaration, fieldDeclaration, definingTypeNames);
		
		// accept reference
		if (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {
			this.pattern.matchReportReference((AstNode)reference, initializer, accuracy, this);
		} else if (reference instanceof MessageSend) { // message ref are starting at the selector start
			this.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, initializer, accuracy);
		} else {
			this.report(reference.sourceStart, reference.sourceEnd, initializer, accuracy);
		}
	}

commonMethod: 
(startLine=111 endLine=117 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PotentialMatch.java)
public void locateMatches() throws CoreException {
	if (this.openable instanceof CompilationUnit) {
		this.locateMatchesInCompilationUnit();
	} else if (this.openable instanceof org.eclipse.jdt.internal.core.ClassFile) {
		this.locateMatchesInClassFile();
	}
}


, Instance #
frags: 
(startLine=927 endLine=955 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

(startLine=701 endLine=733 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00040/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=700 endLine=741 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

(startLine=926 endLine=963 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00040/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=700 endLine=741 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

(startLine=926 endLine=963 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00040/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=700 endLine=741 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

(startLine=926 endLine=963 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00040/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=664 endLine=742 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		Scope invocationScope) {

		if (fieldName == null)
			return;

		ReferenceBinding currentType = receiverType;
		ReferenceBinding[][] interfacesToVisit = null;
		int lastPosition = -1;
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findFields(
				fieldName,
				currentType.fields(),
				scope,
				fieldsFound,
				localsFound,
				onlyStaticFields,
				receiverType,
				invocationSite,
				invocationScope);
			currentType = currentType.superclass();
		} while (currentType != null);

		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
	}

(startLine=880 endLine=964 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		SourceTypeBinding typeInvocation) {

		ReferenceBinding currentType = receiverType;
		if (typeName == null)
			return;
		if (currentType.superInterfaces() == null)
			return; // we're trying to find a supertype

		ObjectVector typesFound = new ObjectVector();
		if (insideQualifiedReference
			|| typeName.length == 0) { // do not search up the hierarchy
			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			return;
		}

		ReferenceBinding[][] interfacesToVisit = null;
		int lastPosition = -1;
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			currentType = currentType.superclass();
		} while (currentType != null);

		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
	}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00040/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=672 endLine=698 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findFields(
				fieldName,
				currentType.fields(),
				scope,
				fieldsFound,
				localsFound,
				onlyStaticFields,
				receiverType,
				invocationSite,
				invocationScope);
			currentType = currentType.superclass();
		} while (currentType != null);

(startLine=902 endLine=924 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			currentType = currentType.superclass();
		} while (currentType != null);

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00040/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=703 endLine=732 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}

(startLine=929 endLine=954 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00039/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00040/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00041/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00041/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2106 endLine=2274 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method completes the creation of the code attribute by setting
	 * - the attribute_length
	 * - max_stack
	 * - max_locals
	 * - code_length
	 * - exception table
	 * - and debug attributes if necessary.
	 *
	 * @param binding org.eclipse.jdt.internal.compiler.lookup.SyntheticAccessMethodBinding
	 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
	 * @param codeAttributeOffset <CODE>int</CODE>
	 */
	public void completeCodeAttributeForSyntheticAccessMethod(
		SyntheticAccessMethodBinding binding,
		int codeAttributeOffset,
		int[] startLineIndexes) {
		// reinitialize the contents with the byte modified by the code stream
		contents = codeStream.bCodeStream;
		int localContentsOffset = codeStream.classFileOffset;
		// codeAttributeOffset is the position inside contents byte array before we started to write
		// any information about the codeAttribute
		// That means that to write the attribute_length you need to offset by 2 the value of codeAttributeOffset
		// to get the right position, 6 for the max_stack etc...
		int max_stack = codeStream.stackMax;
		contents[codeAttributeOffset + 6] = (byte) (max_stack >> 8);
		contents[codeAttributeOffset + 7] = (byte) max_stack;
		int max_locals = codeStream.maxLocals;
		contents[codeAttributeOffset + 8] = (byte) (max_locals >> 8);
		contents[codeAttributeOffset + 9] = (byte) max_locals;
		int code_length = codeStream.position;
		contents[codeAttributeOffset + 10] = (byte) (code_length >> 24);
		contents[codeAttributeOffset + 11] = (byte) (code_length >> 16);
		contents[codeAttributeOffset + 12] = (byte) (code_length >> 8);
		contents[codeAttributeOffset + 13] = (byte) code_length;
		int contentsLength;
		if ((localContentsOffset + 40) >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		// there is no exception table, so we need to offset by 2 the current offset and move 
		// on the attribute generation
		localContentsOffset += 2;
		// debug attributes
		int codeAttributeAttributeOffset = localContentsOffset;
		int attributeNumber = 0;
		// leave two bytes for the attribute_length
		localContentsOffset += 2;

		// first we handle the linenumber attribute
		if (codeStream.generateLineNumberAttributes) {
			int index = 0, max = startLineIndexes.length;
			int lineNumberNameIndex =
				constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			contents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			contents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6;
			// leave space for attribute_length and line_number_table_length
			// Seems like do would be better, but this preserves the existing behavior.
			index = searchLineNumber(startLineIndexes, binding.sourceStart);
			contents[localContentsOffset++] = 0;
			contents[localContentsOffset++] = 0;
			contents[localContentsOffset++] = (byte) (index >> 8);
			contents[localContentsOffset++] = (byte) index;
			// now we change the size of the line number attribute
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 6;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 1;
			attributeNumber++;
		}
		// then we do the local variable attribute
		if (codeStream.generateLocalVariableTableAttributes) {
			int localVariableTableOffset = localContentsOffset;
			int numberOfEntries = 0;
			int localVariableNameIndex =
				constantPool.literalIndex(AttributeNamesConstants.LocalVariableTableName);
			if (localContentsOffset + 8 > (contentsLength = contents.length)) {
				System.arraycopy(
					contents,
					0,
					(contents = new byte[contentsLength + INCREMENT_SIZE]),
					0,
					contentsLength);
			}
			contents[localContentsOffset++] = (byte) (localVariableNameIndex >> 8);
			contents[localContentsOffset++] = (byte) localVariableNameIndex;
			localContentsOffset += 6;
			// leave space for attribute_length and local_variable_table_length
			int nameIndex;
			int descriptorIndex;
			for (int i = 0; i < codeStream.allLocalsCounter; i++) {
				LocalVariableBinding localVariable = codeStream.locals[i];
				for (int j = 0; j < localVariable.initializationCount; j++) {
					int startPC = localVariable.initializationPCs[j << 1];
					int endPC = localVariable.initializationPCs[(j << 1) + 1];
					if (startPC != endPC) { // only entries for non zero length
						int currentLength;
						if (endPC == -1) {
							localVariable.declaringScope.problemReporter().abortDueToInternalError(
								Util.bind("abort.invalidAttribute" , new String(localVariable.name)), //$NON-NLS-1$
								(AstNode) localVariable.declaringScope.methodScope().referenceContext);
						}
						if (localContentsOffset + 10 > (contentsLength = contents.length)) {
							System.arraycopy(
								contents,
								0,
								(contents = new byte[contentsLength + INCREMENT_SIZE]),
								0,
								contentsLength);
						}
						// now we can safely add the local entry
						numberOfEntries++;
						contents[localContentsOffset++] = (byte) (startPC >> 8);
						contents[localContentsOffset++] = (byte) startPC;
						int length = endPC - startPC;
						contents[localContentsOffset++] = (byte) (length >> 8);
						contents[localContentsOffset++] = (byte) length;
						nameIndex = constantPool.literalIndex(localVariable.name);
						contents[localContentsOffset++] = (byte) (nameIndex >> 8);
						contents[localContentsOffset++] = (byte) nameIndex;
						descriptorIndex = constantPool.literalIndex(localVariable.type.signature());
						contents[localContentsOffset++] = (byte) (descriptorIndex >> 8);
						contents[localContentsOffset++] = (byte) descriptorIndex;
						int resolvedPosition = localVariable.resolvedPosition;
						contents[localContentsOffset++] = (byte) (resolvedPosition >> 8);
						contents[localContentsOffset++] = (byte) resolvedPosition;
					}
				}
			}
			int value = numberOfEntries * 10 + 2;
			localVariableTableOffset += 2;
			contents[localVariableTableOffset++] = (byte) (value >> 24);
			contents[localVariableTableOffset++] = (byte) (value >> 16);
			contents[localVariableTableOffset++] = (byte) (value >> 8);
			contents[localVariableTableOffset++] = (byte) value;
			contents[localVariableTableOffset++] = (byte) (numberOfEntries >> 8);
			contents[localVariableTableOffset] = (byte) numberOfEntries;
			attributeNumber++;
		}
		// update the number of attributes
		// ensure first that there is enough space available inside the contents array
		if (codeAttributeAttributeOffset + 2 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		contents[codeAttributeAttributeOffset++] = (byte) (attributeNumber >> 8);
		contents[codeAttributeAttributeOffset] = (byte) attributeNumber;

		// update the attribute length
		int codeAttributeLength = localContentsOffset - (codeAttributeOffset + 6);
		contents[codeAttributeOffset + 2] = (byte) (codeAttributeLength >> 24);
		contents[codeAttributeOffset + 3] = (byte) (codeAttributeLength >> 16);
		contents[codeAttributeOffset + 4] = (byte) (codeAttributeLength >> 8);
		contents[codeAttributeOffset + 5] = (byte) codeAttributeLength;
		contentsOffset = localContentsOffset;
	}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00041/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00041/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2465 endLine=2487 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method generates the header of a code attribute.
	 * - the index inside the constant pool for the attribute name (i.e. Code)
	 * - leave some space for attribute_length(4), max_stack(2), max_locals(2), code_length(4).
	 */
	public void generateCodeAttributeHeader() {
		int contentsLength;
		if (contentsOffset + 20 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		int constantValueNameIndex =
			constantPool.literalIndex(AttributeNamesConstants.CodeName);
		contents[contentsOffset++] = (byte) (constantValueNameIndex >> 8);
		contents[contentsOffset++] = (byte) constantValueNameIndex;
		// leave space for attribute_length(4), max_stack(2), max_locals(2), code_length(4)
		contentsOffset += 12;
	}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00041/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00041/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2748 endLine=2788 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public void init(ClassFile classFile) {
	this.classFile = classFile;
	this.constantPool = classFile.constantPool;
	this.bCodeStream = classFile.contents;
	this.classFileOffset = classFile.contentsOffset;
	this.startingClassFileOffset = this.classFileOffset;
	pcToSourceMapSize = 0;
	lastEntryPC = 0;
	int length = visibleLocals.length;
	if (noVisibleLocals.length < length) {
		noVisibleLocals = new LocalVariableBinding[length];
	}
	System.arraycopy(noVisibleLocals, 0, visibleLocals, 0, length);
	visibleLocalsCount = 0;
	
	length = locals.length;
	if (noLocals.length < length) {
		noLocals = new LocalVariableBinding[length];
	}
	System.arraycopy(noLocals, 0, locals, 0, length);
	allLocalsCounter = 0;

	length = exceptionHandlers.length;
	if (noExceptionHandlers.length < length) {
		noExceptionHandlers = new ExceptionLabel[length];
	}
	System.arraycopy(noExceptionHandlers, 0, exceptionHandlers, 0, length);
	exceptionHandlersNumber = 0;
	
	length = labels.length;
	if (noLabels.length < length) {
		noLabels = new Label[length];
	}
	System.arraycopy(noLabels, 0, labels, 0, length);
	countLabels = 0;

	stackMax = 0;
	stackDepth = 0;
	maxLocals = 0;
	position = 0;
}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00041/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00041/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2597 endLine=2632 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method generates the header of a method info:
	 * The header consists in:
	 * - the access flags
	 * - the name index of the method name inside the constant pool
	 * - the descriptor index of the signature of the method inside the constant pool.
	 *
	 * @param methodBinding org.eclipse.jdt.internal.compiler.lookup.MethodBinding
	 */
	public void generateMethodInfoHeader(MethodBinding methodBinding) {
		// check that there is enough space to write all the bytes for the method info corresponding
		// to the @methodBinding
		int contentsLength;
		methodCount++; // add one more method
		if (contentsOffset + 10 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		int accessFlags = methodBinding.getAccessFlags();
		if (methodBinding.isRequiredToClearPrivateModifier()) {
			accessFlags &= ~AccPrivate;
		}
		contents[contentsOffset++] = (byte) (accessFlags >> 8);
		contents[contentsOffset++] = (byte) accessFlags;
		int nameIndex = constantPool.literalIndex(methodBinding.selector);
		contents[contentsOffset++] = (byte) (nameIndex >> 8);
		contents[contentsOffset++] = (byte) nameIndex;
		int descriptorIndex = constantPool.literalIndex(methodBinding.signature());
		contents[contentsOffset++] = (byte) (descriptorIndex >> 8);
		contents[contentsOffset++] = (byte) descriptorIndex;
	}


, Instance #
frags: 
(startLine=701 endLine=713 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00041/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
	if (fieldDeclaration.isField()) {
		// create defining field handle
		IField field = this.createFieldHandle(fieldDeclaration, definingTypeNames);
	
		// accept reference
		if (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {
			this.pattern.matchReportReference((AstNode)reference, field, accuracy, this);
		} else if (reference instanceof MessageSend) { // message ref are starting at the selector start
			this.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, field, accuracy);
		} else {
			this.report(reference.sourceStart, reference.sourceEnd, field, accuracy);
		}
	} else { // initializer

(startLine=713 endLine=725 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00041/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
	} else { // initializer
		// create defining initializer
		IInitializer initializer = this.createInitializerHandle(typeDeclaration, fieldDeclaration, definingTypeNames);
		
		// accept reference
		if (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {
			this.pattern.matchReportReference((AstNode)reference, initializer, accuracy, this);
		} else if (reference instanceof MessageSend) { // message ref are starting at the selector start
			this.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, initializer, accuracy);
		} else {
			this.report(reference.sourceStart, reference.sourceEnd, initializer, accuracy);
		}
	}

commonMethod: 
(startLine=111 endLine=117 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PotentialMatch.java)
public void locateMatches() throws CoreException {
	if (this.openable instanceof CompilationUnit) {
		this.locateMatchesInCompilationUnit();
	} else if (this.openable instanceof org.eclipse.jdt.internal.core.ClassFile) {
		this.locateMatchesInClassFile();
	}
}


, Instance #
frags: 
(startLine=927 endLine=955 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

(startLine=701 endLine=733 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=700 endLine=741 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

(startLine=926 endLine=963 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=700 endLine=741 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

(startLine=926 endLine=963 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=664 endLine=742 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		Scope invocationScope) {

		if (fieldName == null)
			return;

		ReferenceBinding currentType = receiverType;
		ReferenceBinding[][] interfacesToVisit = null;
		int lastPosition = -1;
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findFields(
				fieldName,
				currentType.fields(),
				scope,
				fieldsFound,
				localsFound,
				onlyStaticFields,
				receiverType,
				invocationSite,
				invocationScope);
			currentType = currentType.superclass();
		} while (currentType != null);

		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
	}

(startLine=880 endLine=964 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		SourceTypeBinding typeInvocation) {

		ReferenceBinding currentType = receiverType;
		if (typeName == null)
			return;
		if (currentType.superInterfaces() == null)
			return; // we're trying to find a supertype

		ObjectVector typesFound = new ObjectVector();
		if (insideQualifiedReference
			|| typeName.length == 0) { // do not search up the hierarchy
			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			return;
		}

		ReferenceBinding[][] interfacesToVisit = null;
		int lastPosition = -1;
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			currentType = currentType.superclass();
		} while (currentType != null);

		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
	}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=672 endLine=698 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findFields(
				fieldName,
				currentType.fields(),
				scope,
				fieldsFound,
				localsFound,
				onlyStaticFields,
				receiverType,
				invocationSite,
				invocationScope);
			currentType = currentType.superclass();
		} while (currentType != null);

(startLine=902 endLine=924 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			currentType = currentType.superclass();
		} while (currentType != null);

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=703 endLine=732 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}

(startLine=929 endLine=954 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00042/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2465 endLine=2487 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method generates the header of a code attribute.
	 * - the index inside the constant pool for the attribute name (i.e. Code)
	 * - leave some space for attribute_length(4), max_stack(2), max_locals(2), code_length(4).
	 */
	public void generateCodeAttributeHeader() {
		int contentsLength;
		if (contentsOffset + 20 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		int constantValueNameIndex =
			constantPool.literalIndex(AttributeNamesConstants.CodeName);
		contents[contentsOffset++] = (byte) (constantValueNameIndex >> 8);
		contents[contentsOffset++] = (byte) constantValueNameIndex;
		// leave space for attribute_length(4), max_stack(2), max_locals(2), code_length(4)
		contentsOffset += 12;
	}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2748 endLine=2788 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public void init(ClassFile classFile) {
	this.classFile = classFile;
	this.constantPool = classFile.constantPool;
	this.bCodeStream = classFile.contents;
	this.classFileOffset = classFile.contentsOffset;
	this.startingClassFileOffset = this.classFileOffset;
	pcToSourceMapSize = 0;
	lastEntryPC = 0;
	int length = visibleLocals.length;
	if (noVisibleLocals.length < length) {
		noVisibleLocals = new LocalVariableBinding[length];
	}
	System.arraycopy(noVisibleLocals, 0, visibleLocals, 0, length);
	visibleLocalsCount = 0;
	
	length = locals.length;
	if (noLocals.length < length) {
		noLocals = new LocalVariableBinding[length];
	}
	System.arraycopy(noLocals, 0, locals, 0, length);
	allLocalsCounter = 0;

	length = exceptionHandlers.length;
	if (noExceptionHandlers.length < length) {
		noExceptionHandlers = new ExceptionLabel[length];
	}
	System.arraycopy(noExceptionHandlers, 0, exceptionHandlers, 0, length);
	exceptionHandlersNumber = 0;
	
	length = labels.length;
	if (noLabels.length < length) {
		noLabels = new Label[length];
	}
	System.arraycopy(noLabels, 0, labels, 0, length);
	countLabels = 0;

	stackMax = 0;
	stackDepth = 0;
	maxLocals = 0;
	position = 0;
}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2597 endLine=2632 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method generates the header of a method info:
	 * The header consists in:
	 * - the access flags
	 * - the name index of the method name inside the constant pool
	 * - the descriptor index of the signature of the method inside the constant pool.
	 *
	 * @param methodBinding org.eclipse.jdt.internal.compiler.lookup.MethodBinding
	 */
	public void generateMethodInfoHeader(MethodBinding methodBinding) {
		// check that there is enough space to write all the bytes for the method info corresponding
		// to the @methodBinding
		int contentsLength;
		methodCount++; // add one more method
		if (contentsOffset + 10 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		int accessFlags = methodBinding.getAccessFlags();
		if (methodBinding.isRequiredToClearPrivateModifier()) {
			accessFlags &= ~AccPrivate;
		}
		contents[contentsOffset++] = (byte) (accessFlags >> 8);
		contents[contentsOffset++] = (byte) accessFlags;
		int nameIndex = constantPool.literalIndex(methodBinding.selector);
		contents[contentsOffset++] = (byte) (nameIndex >> 8);
		contents[contentsOffset++] = (byte) nameIndex;
		int descriptorIndex = constantPool.literalIndex(methodBinding.signature());
		contents[contentsOffset++] = (byte) (descriptorIndex >> 8);
		contents[contentsOffset++] = (byte) descriptorIndex;
	}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2106 endLine=2274 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method completes the creation of the code attribute by setting
	 * - the attribute_length
	 * - max_stack
	 * - max_locals
	 * - code_length
	 * - exception table
	 * - and debug attributes if necessary.
	 *
	 * @param binding org.eclipse.jdt.internal.compiler.lookup.SyntheticAccessMethodBinding
	 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
	 * @param codeAttributeOffset <CODE>int</CODE>
	 */
	public void completeCodeAttributeForSyntheticAccessMethod(
		SyntheticAccessMethodBinding binding,
		int codeAttributeOffset,
		int[] startLineIndexes) {
		// reinitialize the contents with the byte modified by the code stream
		contents = codeStream.bCodeStream;
		int localContentsOffset = codeStream.classFileOffset;
		// codeAttributeOffset is the position inside contents byte array before we started to write
		// any information about the codeAttribute
		// That means that to write the attribute_length you need to offset by 2 the value of codeAttributeOffset
		// to get the right position, 6 for the max_stack etc...
		int max_stack = codeStream.stackMax;
		contents[codeAttributeOffset + 6] = (byte) (max_stack >> 8);
		contents[codeAttributeOffset + 7] = (byte) max_stack;
		int max_locals = codeStream.maxLocals;
		contents[codeAttributeOffset + 8] = (byte) (max_locals >> 8);
		contents[codeAttributeOffset + 9] = (byte) max_locals;
		int code_length = codeStream.position;
		contents[codeAttributeOffset + 10] = (byte) (code_length >> 24);
		contents[codeAttributeOffset + 11] = (byte) (code_length >> 16);
		contents[codeAttributeOffset + 12] = (byte) (code_length >> 8);
		contents[codeAttributeOffset + 13] = (byte) code_length;
		int contentsLength;
		if ((localContentsOffset + 40) >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		// there is no exception table, so we need to offset by 2 the current offset and move 
		// on the attribute generation
		localContentsOffset += 2;
		// debug attributes
		int codeAttributeAttributeOffset = localContentsOffset;
		int attributeNumber = 0;
		// leave two bytes for the attribute_length
		localContentsOffset += 2;

		// first we handle the linenumber attribute
		if (codeStream.generateLineNumberAttributes) {
			int index = 0, max = startLineIndexes.length;
			int lineNumberNameIndex =
				constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			contents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			contents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6;
			// leave space for attribute_length and line_number_table_length
			// Seems like do would be better, but this preserves the existing behavior.
			index = searchLineNumber(startLineIndexes, binding.sourceStart);
			contents[localContentsOffset++] = 0;
			contents[localContentsOffset++] = 0;
			contents[localContentsOffset++] = (byte) (index >> 8);
			contents[localContentsOffset++] = (byte) index;
			// now we change the size of the line number attribute
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 6;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 1;
			attributeNumber++;
		}
		// then we do the local variable attribute
		if (codeStream.generateLocalVariableTableAttributes) {
			int localVariableTableOffset = localContentsOffset;
			int numberOfEntries = 0;
			int localVariableNameIndex =
				constantPool.literalIndex(AttributeNamesConstants.LocalVariableTableName);
			if (localContentsOffset + 8 > (contentsLength = contents.length)) {
				System.arraycopy(
					contents,
					0,
					(contents = new byte[contentsLength + INCREMENT_SIZE]),
					0,
					contentsLength);
			}
			contents[localContentsOffset++] = (byte) (localVariableNameIndex >> 8);
			contents[localContentsOffset++] = (byte) localVariableNameIndex;
			localContentsOffset += 6;
			// leave space for attribute_length and local_variable_table_length
			int nameIndex;
			int descriptorIndex;
			for (int i = 0; i < codeStream.allLocalsCounter; i++) {
				LocalVariableBinding localVariable = codeStream.locals[i];
				for (int j = 0; j < localVariable.initializationCount; j++) {
					int startPC = localVariable.initializationPCs[j << 1];
					int endPC = localVariable.initializationPCs[(j << 1) + 1];
					if (startPC != endPC) { // only entries for non zero length
						int currentLength;
						if (endPC == -1) {
							localVariable.declaringScope.problemReporter().abortDueToInternalError(
								Util.bind("abort.invalidAttribute" , new String(localVariable.name)), //$NON-NLS-1$
								(AstNode) localVariable.declaringScope.methodScope().referenceContext);
						}
						if (localContentsOffset + 10 > (contentsLength = contents.length)) {
							System.arraycopy(
								contents,
								0,
								(contents = new byte[contentsLength + INCREMENT_SIZE]),
								0,
								contentsLength);
						}
						// now we can safely add the local entry
						numberOfEntries++;
						contents[localContentsOffset++] = (byte) (startPC >> 8);
						contents[localContentsOffset++] = (byte) startPC;
						int length = endPC - startPC;
						contents[localContentsOffset++] = (byte) (length >> 8);
						contents[localContentsOffset++] = (byte) length;
						nameIndex = constantPool.literalIndex(localVariable.name);
						contents[localContentsOffset++] = (byte) (nameIndex >> 8);
						contents[localContentsOffset++] = (byte) nameIndex;
						descriptorIndex = constantPool.literalIndex(localVariable.type.signature());
						contents[localContentsOffset++] = (byte) (descriptorIndex >> 8);
						contents[localContentsOffset++] = (byte) descriptorIndex;
						int resolvedPosition = localVariable.resolvedPosition;
						contents[localContentsOffset++] = (byte) (resolvedPosition >> 8);
						contents[localContentsOffset++] = (byte) resolvedPosition;
					}
				}
			}
			int value = numberOfEntries * 10 + 2;
			localVariableTableOffset += 2;
			contents[localVariableTableOffset++] = (byte) (value >> 24);
			contents[localVariableTableOffset++] = (byte) (value >> 16);
			contents[localVariableTableOffset++] = (byte) (value >> 8);
			contents[localVariableTableOffset++] = (byte) value;
			contents[localVariableTableOffset++] = (byte) (numberOfEntries >> 8);
			contents[localVariableTableOffset] = (byte) numberOfEntries;
			attributeNumber++;
		}
		// update the number of attributes
		// ensure first that there is enough space available inside the contents array
		if (codeAttributeAttributeOffset + 2 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		contents[codeAttributeAttributeOffset++] = (byte) (attributeNumber >> 8);
		contents[codeAttributeAttributeOffset] = (byte) attributeNumber;

		// update the attribute length
		int codeAttributeLength = localContentsOffset - (codeAttributeOffset + 6);
		contents[codeAttributeOffset + 2] = (byte) (codeAttributeLength >> 24);
		contents[codeAttributeOffset + 3] = (byte) (codeAttributeLength >> 16);
		contents[codeAttributeOffset + 4] = (byte) (codeAttributeLength >> 8);
		contents[codeAttributeOffset + 5] = (byte) codeAttributeLength;
		contentsOffset = localContentsOffset;
	}


, Instance #
frags: 
(startLine=701 endLine=713 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
	if (fieldDeclaration.isField()) {
		// create defining field handle
		IField field = this.createFieldHandle(fieldDeclaration, definingTypeNames);
	
		// accept reference
		if (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {
			this.pattern.matchReportReference((AstNode)reference, field, accuracy, this);
		} else if (reference instanceof MessageSend) { // message ref are starting at the selector start
			this.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, field, accuracy);
		} else {
			this.report(reference.sourceStart, reference.sourceEnd, field, accuracy);
		}
	} else { // initializer

(startLine=713 endLine=725 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00043/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
	} else { // initializer
		// create defining initializer
		IInitializer initializer = this.createInitializerHandle(typeDeclaration, fieldDeclaration, definingTypeNames);
		
		// accept reference
		if (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {
			this.pattern.matchReportReference((AstNode)reference, initializer, accuracy, this);
		} else if (reference instanceof MessageSend) { // message ref are starting at the selector start
			this.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, initializer, accuracy);
		} else {
			this.report(reference.sourceStart, reference.sourceEnd, initializer, accuracy);
		}
	}

commonMethod: 
(startLine=111 endLine=117 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PotentialMatch.java)
public void locateMatches() throws CoreException {
	if (this.openable instanceof CompilationUnit) {
		this.locateMatchesInCompilationUnit();
	} else if (this.openable instanceof org.eclipse.jdt.internal.core.ClassFile) {
		this.locateMatchesInClassFile();
	}
}


, Instance #
frags: 
(startLine=927 endLine=955 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

(startLine=701 endLine=733 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=700 endLine=741 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

(startLine=926 endLine=963 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=664 endLine=742 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		Scope invocationScope) {

		if (fieldName == null)
			return;

		ReferenceBinding currentType = receiverType;
		ReferenceBinding[][] interfacesToVisit = null;
		int lastPosition = -1;
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findFields(
				fieldName,
				currentType.fields(),
				scope,
				fieldsFound,
				localsFound,
				onlyStaticFields,
				receiverType,
				invocationSite,
				invocationScope);
			currentType = currentType.superclass();
		} while (currentType != null);

		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
	}

(startLine=880 endLine=964 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		SourceTypeBinding typeInvocation) {

		ReferenceBinding currentType = receiverType;
		if (typeName == null)
			return;
		if (currentType.superInterfaces() == null)
			return; // we're trying to find a supertype

		ObjectVector typesFound = new ObjectVector();
		if (insideQualifiedReference
			|| typeName.length == 0) { // do not search up the hierarchy
			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			return;
		}

		ReferenceBinding[][] interfacesToVisit = null;
		int lastPosition = -1;
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			currentType = currentType.superclass();
		} while (currentType != null);

		if (interfacesToVisit != null) {
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
	}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=672 endLine=698 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findFields(
				fieldName,
				currentType.fields(),
				scope,
				fieldsFound,
				localsFound,
				onlyStaticFields,
				receiverType,
				invocationSite,
				invocationScope);
			currentType = currentType.superclass();
		} while (currentType != null);

(startLine=902 endLine=924 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		do {
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				if (interfacesToVisit == null)
					interfacesToVisit = new ReferenceBinding[5][];
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;
			}

			findMemberTypes(
				typeName,
				currentType.memberTypes(),
				typesFound,
				receiverType,
				typeInvocation);
			currentType = currentType.superclass();
		} while (currentType != null);

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=703 endLine=732 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findFields(
							fieldName,
							anInterface.fields(),
							scope,
							fieldsFound,
							localsFound,
							onlyStaticFields,
							receiverType,
							invocationSite,
							invocationScope);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}

(startLine=929 endLine=954 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00044/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
				for (int j = 0, length = interfaces.length; j < length; j++) {
					ReferenceBinding anInterface = interfaces[j];
					if ((anInterface.tagBits & TagBits.InterfaceVisited) == 0) {
						// if interface as not already been visited
						anInterface.tagBits |= TagBits.InterfaceVisited;

						findMemberTypes(
							typeName,
							anInterface.memberTypes(),
							typesFound,
							receiverType,
							typeInvocation);

						ReferenceBinding[] itsInterfaces = anInterface.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(
									interfacesToVisit,
									0,
									interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
									0,
									lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}

commonMethod: 
(startLine=769 endLine=823 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
private void findMethods(
	char[] selector,
	TypeBinding[] argTypes,
	ReferenceBinding receiverType,
	Scope scope,
	ObjectVector methodsFound,
	boolean onlyStaticMethods,
	boolean exactMatch) {

	if (selector == null) return;

	ReferenceBinding currentType = receiverType;
	if (currentType.isInterface()) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != NoSuperInterfaces) {
			ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
			int lastPosition = 0;
			interfacesToVisit[lastPosition] = itsInterfaces;
			
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++) {
					currentType = interfaces[j];
					if ((currentType.tagBits & TagBits.InterfaceVisited) == 0) { // if interface as not already been visited
						currentType.tagBits |= TagBits.InterfaceVisited;

						findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);

						itsInterfaces = currentType.superInterfaces();
						if (itsInterfaces != NoSuperInterfaces) {
							if (++lastPosition == interfacesToVisit.length)
								System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[lastPosition * 2][], 0, lastPosition);
							interfacesToVisit[lastPosition] = itsInterfaces;
						}
					}
				}
			}

			// bit reinitialization
			for (int i = 0; i <= lastPosition; i++) {
				ReferenceBinding[] interfaces = interfacesToVisit[i];
				for (int j = 0, length = interfaces.length; j < length; j++)
					interfaces[j].tagBits &= ~TagBits.InterfaceVisited;
			}
		}
		currentType = scope.getJavaLangObject();
	}

	while (currentType != null) {
		findMethods(selector, argTypes, currentType.methods(), scope, methodsFound, onlyStaticMethods, exactMatch);
		currentType = currentType.superclass();
	}
}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2597 endLine=2632 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00046/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method generates the header of a method info:
	 * The header consists in:
	 * - the access flags
	 * - the name index of the method name inside the constant pool
	 * - the descriptor index of the signature of the method inside the constant pool.
	 *
	 * @param methodBinding org.eclipse.jdt.internal.compiler.lookup.MethodBinding
	 */
	public void generateMethodInfoHeader(MethodBinding methodBinding) {
		// check that there is enough space to write all the bytes for the method info corresponding
		// to the @methodBinding
		int contentsLength;
		methodCount++; // add one more method
		if (contentsOffset + 10 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		int accessFlags = methodBinding.getAccessFlags();
		if (methodBinding.isRequiredToClearPrivateModifier()) {
			accessFlags &= ~AccPrivate;
		}
		contents[contentsOffset++] = (byte) (accessFlags >> 8);
		contents[contentsOffset++] = (byte) accessFlags;
		int nameIndex = constantPool.literalIndex(methodBinding.selector);
		contents[contentsOffset++] = (byte) (nameIndex >> 8);
		contents[contentsOffset++] = (byte) nameIndex;
		int descriptorIndex = constantPool.literalIndex(methodBinding.signature());
		contents[contentsOffset++] = (byte) (descriptorIndex >> 8);
		contents[contentsOffset++] = (byte) descriptorIndex;
	}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2465 endLine=2487 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00046/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method generates the header of a code attribute.
	 * - the index inside the constant pool for the attribute name (i.e. Code)
	 * - leave some space for attribute_length(4), max_stack(2), max_locals(2), code_length(4).
	 */
	public void generateCodeAttributeHeader() {
		int contentsLength;
		if (contentsOffset + 20 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		int constantValueNameIndex =
			constantPool.literalIndex(AttributeNamesConstants.CodeName);
		contents[contentsOffset++] = (byte) (constantValueNameIndex >> 8);
		contents[contentsOffset++] = (byte) constantValueNameIndex;
		// leave space for attribute_length(4), max_stack(2), max_locals(2), code_length(4)
		contentsOffset += 12;
	}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2106 endLine=2274 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00046/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	/**
	 * INTERNAL USE-ONLY
	 * That method completes the creation of the code attribute by setting
	 * - the attribute_length
	 * - max_stack
	 * - max_locals
	 * - code_length
	 * - exception table
	 * - and debug attributes if necessary.
	 *
	 * @param binding org.eclipse.jdt.internal.compiler.lookup.SyntheticAccessMethodBinding
	 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
	 * @param codeAttributeOffset <CODE>int</CODE>
	 */
	public void completeCodeAttributeForSyntheticAccessMethod(
		SyntheticAccessMethodBinding binding,
		int codeAttributeOffset,
		int[] startLineIndexes) {
		// reinitialize the contents with the byte modified by the code stream
		contents = codeStream.bCodeStream;
		int localContentsOffset = codeStream.classFileOffset;
		// codeAttributeOffset is the position inside contents byte array before we started to write
		// any information about the codeAttribute
		// That means that to write the attribute_length you need to offset by 2 the value of codeAttributeOffset
		// to get the right position, 6 for the max_stack etc...
		int max_stack = codeStream.stackMax;
		contents[codeAttributeOffset + 6] = (byte) (max_stack >> 8);
		contents[codeAttributeOffset + 7] = (byte) max_stack;
		int max_locals = codeStream.maxLocals;
		contents[codeAttributeOffset + 8] = (byte) (max_locals >> 8);
		contents[codeAttributeOffset + 9] = (byte) max_locals;
		int code_length = codeStream.position;
		contents[codeAttributeOffset + 10] = (byte) (code_length >> 24);
		contents[codeAttributeOffset + 11] = (byte) (code_length >> 16);
		contents[codeAttributeOffset + 12] = (byte) (code_length >> 8);
		contents[codeAttributeOffset + 13] = (byte) code_length;
		int contentsLength;
		if ((localContentsOffset + 40) >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		// there is no exception table, so we need to offset by 2 the current offset and move 
		// on the attribute generation
		localContentsOffset += 2;
		// debug attributes
		int codeAttributeAttributeOffset = localContentsOffset;
		int attributeNumber = 0;
		// leave two bytes for the attribute_length
		localContentsOffset += 2;

		// first we handle the linenumber attribute
		if (codeStream.generateLineNumberAttributes) {
			int index = 0, max = startLineIndexes.length;
			int lineNumberNameIndex =
				constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			contents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			contents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6;
			// leave space for attribute_length and line_number_table_length
			// Seems like do would be better, but this preserves the existing behavior.
			index = searchLineNumber(startLineIndexes, binding.sourceStart);
			contents[localContentsOffset++] = 0;
			contents[localContentsOffset++] = 0;
			contents[localContentsOffset++] = (byte) (index >> 8);
			contents[localContentsOffset++] = (byte) index;
			// now we change the size of the line number attribute
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 6;
			contents[lineNumberTableOffset++] = 0;
			contents[lineNumberTableOffset++] = 1;
			attributeNumber++;
		}
		// then we do the local variable attribute
		if (codeStream.generateLocalVariableTableAttributes) {
			int localVariableTableOffset = localContentsOffset;
			int numberOfEntries = 0;
			int localVariableNameIndex =
				constantPool.literalIndex(AttributeNamesConstants.LocalVariableTableName);
			if (localContentsOffset + 8 > (contentsLength = contents.length)) {
				System.arraycopy(
					contents,
					0,
					(contents = new byte[contentsLength + INCREMENT_SIZE]),
					0,
					contentsLength);
			}
			contents[localContentsOffset++] = (byte) (localVariableNameIndex >> 8);
			contents[localContentsOffset++] = (byte) localVariableNameIndex;
			localContentsOffset += 6;
			// leave space for attribute_length and local_variable_table_length
			int nameIndex;
			int descriptorIndex;
			for (int i = 0; i < codeStream.allLocalsCounter; i++) {
				LocalVariableBinding localVariable = codeStream.locals[i];
				for (int j = 0; j < localVariable.initializationCount; j++) {
					int startPC = localVariable.initializationPCs[j << 1];
					int endPC = localVariable.initializationPCs[(j << 1) + 1];
					if (startPC != endPC) { // only entries for non zero length
						int currentLength;
						if (endPC == -1) {
							localVariable.declaringScope.problemReporter().abortDueToInternalError(
								Util.bind("abort.invalidAttribute" , new String(localVariable.name)), //$NON-NLS-1$
								(AstNode) localVariable.declaringScope.methodScope().referenceContext);
						}
						if (localContentsOffset + 10 > (contentsLength = contents.length)) {
							System.arraycopy(
								contents,
								0,
								(contents = new byte[contentsLength + INCREMENT_SIZE]),
								0,
								contentsLength);
						}
						// now we can safely add the local entry
						numberOfEntries++;
						contents[localContentsOffset++] = (byte) (startPC >> 8);
						contents[localContentsOffset++] = (byte) startPC;
						int length = endPC - startPC;
						contents[localContentsOffset++] = (byte) (length >> 8);
						contents[localContentsOffset++] = (byte) length;
						nameIndex = constantPool.literalIndex(localVariable.name);
						contents[localContentsOffset++] = (byte) (nameIndex >> 8);
						contents[localContentsOffset++] = (byte) nameIndex;
						descriptorIndex = constantPool.literalIndex(localVariable.type.signature());
						contents[localContentsOffset++] = (byte) (descriptorIndex >> 8);
						contents[localContentsOffset++] = (byte) descriptorIndex;
						int resolvedPosition = localVariable.resolvedPosition;
						contents[localContentsOffset++] = (byte) (resolvedPosition >> 8);
						contents[localContentsOffset++] = (byte) resolvedPosition;
					}
				}
			}
			int value = numberOfEntries * 10 + 2;
			localVariableTableOffset += 2;
			contents[localVariableTableOffset++] = (byte) (value >> 24);
			contents[localVariableTableOffset++] = (byte) (value >> 16);
			contents[localVariableTableOffset++] = (byte) (value >> 8);
			contents[localVariableTableOffset++] = (byte) value;
			contents[localVariableTableOffset++] = (byte) (numberOfEntries >> 8);
			contents[localVariableTableOffset] = (byte) numberOfEntries;
			attributeNumber++;
		}
		// update the number of attributes
		// ensure first that there is enough space available inside the contents array
		if (codeAttributeAttributeOffset + 2 >= (contentsLength = contents.length)) {
			System.arraycopy(
				contents,
				0,
				(contents = new byte[contentsLength + INCREMENT_SIZE]),
				0,
				contentsLength);
		}
		contents[codeAttributeAttributeOffset++] = (byte) (attributeNumber >> 8);
		contents[codeAttributeAttributeOffset] = (byte) attributeNumber;

		// update the attribute length
		int codeAttributeLength = localContentsOffset - (codeAttributeOffset + 6);
		contents[codeAttributeOffset + 2] = (byte) (codeAttributeLength >> 24);
		contents[codeAttributeOffset + 3] = (byte) (codeAttributeLength >> 16);
		contents[codeAttributeOffset + 4] = (byte) (codeAttributeLength >> 8);
		contents[codeAttributeOffset + 5] = (byte) codeAttributeLength;
		contentsOffset = localContentsOffset;
	}


, Instance #
frags: 
(startLine=1341 endLine=1383 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

(startLine=1078 endLine=1165 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ClassFile.java)
	if (codeStream.generateLineNumberAttributes) {
		/* Create and add the line number attribute (used for debugging) 
		 * Build the pairs of:
		 * 	(bytecodePC lineNumber)
		 * according to the table of start line indexes and the pcToSourceMap table
		 * contained into the codestream
		 */
		/** OLD CODE
				int[][] pcToSourceMapTable;
		int previousLineNumber;
		int[] flatTable;
		int index;
		int startLineIndexes[] = codeStream.methodDeclaration.scope.referenceCompilationUnit().compilationResult.lineSeparatorPositions;
		int max = startLineIndexes.length;
		*/ 
		int[] pcToSourceMapTable;
		if (((pcToSourceMapTable = codeStream.pcToSourceMap) != null) && (codeStream.pcToSourceMapSize != 0)) {
			int lineNumberNameIndex = constantPool.literalIndex(AttributeNamesConstants.LineNumberTableName);
			if (localContentsOffset + 8 >= (contentsLength = localContents.length)) {
				System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
			}
			localContents[localContentsOffset++] = (byte) (lineNumberNameIndex >> 8);
			localContents[localContentsOffset++] = (byte) lineNumberNameIndex;
			int lineNumberTableOffset = localContentsOffset;
			localContentsOffset += 6; // leave space for attribute_length and line_number_table_length
			/** OLD CODE
			previousLineNumber = 0;

			// Seems like do would be better, but this preserves the existing behavior.

			flatTable = new int[code_length];
			for (int i = codeStream.pcToSourceMapSize - 1; i >= 0; i--) {
				// entry contains the following structure:
				// position 1: startPC
				// position 2: endPC
				// position 3: sourceStart
				// position 4: sourceEnd
				// Compute the line number for a given source position
				index = searchLineNumber(startLineIndexes, pcToSourceMapTable[i][2]);
				for (int j = pcToSourceMapTable[i][0]; j < pcToSourceMapTable[i][1]; j++)
					flatTable[j] = index;
			}
			previousLineNumber = -1;
			
			*/
			int numberOfEntries = 0;
			int length = codeStream.pcToSourceMapSize;
			/** OLD CODE
				int length = flatTable.length;
						for (int i = 0; i < length; i++) {
				if (flatTable[i] != previousLineNumber) {
					previousLineNumber = flatTable[i];
					// write the entry
					if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
						System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
					}
					localContents[localContentsOffset++] = (byte) (i >> 8);
					localContents[localContentsOffset++] = (byte) i;
					localContents[localContentsOffset++] = (byte) (previousLineNumber >> 8);
					localContents[localContentsOffset++] = (byte) previousLineNumber;
					numberOfEntries++;
				}
			}
			*/			
			for (int i = 0; i < length;) {
				// write the entry
				if (localContentsOffset + 4 >= (contentsLength = localContents.length)) {
					System.arraycopy(contents, 0, (localContents = contents = new byte[contentsLength + INCREMENT_SIZE]), 0, contentsLength);
				}
				int pc = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (pc >> 8);
				localContents[localContentsOffset++] = (byte) pc;
				int lineNumber = pcToSourceMapTable[i++];
				localContents[localContentsOffset++] = (byte) (lineNumber >> 8);
				localContents[localContentsOffset++] = (byte) lineNumber;
				numberOfEntries++;
			}
			// now we change the size of the line number attribute
			int lineNumberAttr_length = numberOfEntries * 4 + 2;
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 24);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 16);
			localContents[lineNumberTableOffset++] = (byte) (lineNumberAttr_length >> 8);
			localContents[lineNumberTableOffset++] = (byte) lineNumberAttr_length;
			localContents[lineNumberTableOffset++] = (byte) (numberOfEntries >> 8);
			localContents[lineNumberTableOffset++] = (byte) numberOfEntries;
			attributeNumber++;
		}
	}

commonMethod: 
(startLine=2748 endLine=2788 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00046/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public void init(ClassFile classFile) {
	this.classFile = classFile;
	this.constantPool = classFile.constantPool;
	this.bCodeStream = classFile.contents;
	this.classFileOffset = classFile.contentsOffset;
	this.startingClassFileOffset = this.classFileOffset;
	pcToSourceMapSize = 0;
	lastEntryPC = 0;
	int length = visibleLocals.length;
	if (noVisibleLocals.length < length) {
		noVisibleLocals = new LocalVariableBinding[length];
	}
	System.arraycopy(noVisibleLocals, 0, visibleLocals, 0, length);
	visibleLocalsCount = 0;
	
	length = locals.length;
	if (noLocals.length < length) {
		noLocals = new LocalVariableBinding[length];
	}
	System.arraycopy(noLocals, 0, locals, 0, length);
	allLocalsCounter = 0;

	length = exceptionHandlers.length;
	if (noExceptionHandlers.length < length) {
		noExceptionHandlers = new ExceptionLabel[length];
	}
	System.arraycopy(noExceptionHandlers, 0, exceptionHandlers, 0, length);
	exceptionHandlersNumber = 0;
	
	length = labels.length;
	if (noLabels.length < length) {
		noLabels = new Label[length];
	}
	System.arraycopy(noLabels, 0, labels, 0, length);
	countLabels = 0;

	stackMax = 0;
	stackDepth = 0;
	maxLocals = 0;
	position = 0;
}


, Instance #
frags: 
(startLine=701 endLine=713 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
	if (fieldDeclaration.isField()) {
		// create defining field handle
		IField field = this.createFieldHandle(fieldDeclaration, definingTypeNames);
	
		// accept reference
		if (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {
			this.pattern.matchReportReference((AstNode)reference, field, accuracy, this);
		} else if (reference instanceof MessageSend) { // message ref are starting at the selector start
			this.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, field, accuracy);
		} else {
			this.report(reference.sourceStart, reference.sourceEnd, field, accuracy);
		}
	} else { // initializer

(startLine=713 endLine=725 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00045/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
	} else { // initializer
		// create defining initializer
		IInitializer initializer = this.createInitializerHandle(typeDeclaration, fieldDeclaration, definingTypeNames);
		
		// accept reference
		if (reference instanceof QualifiedNameReference || reference instanceof QualifiedTypeReference) {
			this.pattern.matchReportReference((AstNode)reference, initializer, accuracy, this);
		} else if (reference instanceof MessageSend) { // message ref are starting at the selector start
			this.report((int)(((MessageSend)reference).nameSourcePosition >> 32), reference.sourceEnd, initializer, accuracy);
		} else {
			this.report(reference.sourceStart, reference.sourceEnd, initializer, accuracy);
		}
	}

commonMethod: 
(startLine=111 endLine=117 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00046/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PotentialMatch.java)
public void locateMatches() throws CoreException {
	if (this.openable instanceof CompilationUnit) {
		this.locateMatchesInCompilationUnit();
	} else if (this.openable instanceof org.eclipse.jdt.internal.core.ClassFile) {
		this.locateMatchesInClassFile();
	}
}


, Instance #
frags: 
(startLine=69 endLine=87 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00055/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
public void computeConstant(BlockScope scope, int leftId, int rightId) {
	//the TC has been done so leftId and rightId are both equal to T_boolean

	Constant cst;
	if ((cst = left.constant) != NotAConstant) {
		if (cst.booleanValue() == false) { // false && x --> false
			constant = cst; // inlined to constant(false)
		} else { // true && x --> x
			if ((constant = right.constant) == NotAConstant) {
				// compute conditionalConstant
				optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
			}
		}
	} else {
		constant = NotAConstant;
		// compute conditionalConstant
		optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
	}
}

(startLine=70 endLine=88 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00055/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
public void computeConstant(BlockScope scope, int leftId, int rightId) {
	//the TC has been done so leftId and rightId are both equal to T_boolean

	Constant cst;
	if ((cst = left.constant) != NotAConstant) {
		if (cst.booleanValue() == true) { // true || x --> true
			constant = cst; // inlined to constant(false)
		} else { // false || x --> x
			if ((constant = right.constant) == NotAConstant) {
				// compute conditionalConstant
				optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
			}
		}
	} else {
		constant = NotAConstant;
		// compute conditionalConstant
		optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
	}
}

commonMethod: 
(startLine=1089 endLine=1097 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00056/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java)
	public final MethodScope methodScope() {
		Scope scope = this;
		do {
			if (scope instanceof MethodScope)
				return (MethodScope) scope;
			scope = scope.parent;
		} while (scope != null);
		return null;
	}


, Instance #
frags: 
(startLine=69 endLine=87 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00055/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
public void computeConstant(BlockScope scope, int leftId, int rightId) {
	//the TC has been done so leftId and rightId are both equal to T_boolean

	Constant cst;
	if ((cst = left.constant) != NotAConstant) {
		if (cst.booleanValue() == false) { // false && x --> false
			constant = cst; // inlined to constant(false)
		} else { // true && x --> x
			if ((constant = right.constant) == NotAConstant) {
				// compute conditionalConstant
				optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
			}
		}
	} else {
		constant = NotAConstant;
		// compute conditionalConstant
		optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
	}
}

(startLine=70 endLine=88 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00055/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
public void computeConstant(BlockScope scope, int leftId, int rightId) {
	//the TC has been done so leftId and rightId are both equal to T_boolean

	Constant cst;
	if ((cst = left.constant) != NotAConstant) {
		if (cst.booleanValue() == true) { // true || x --> true
			constant = cst; // inlined to constant(false)
		} else { // false || x --> x
			if ((constant = right.constant) == NotAConstant) {
				// compute conditionalConstant
				optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
			}
		}
	} else {
		constant = NotAConstant;
		// compute conditionalConstant
		optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
	}
}

commonMethod: 
(startLine=23 endLine=26 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00056/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowInfo.java)
public static FlowInfo conditional(FlowInfo initsWhenTrue, FlowInfo initsWhenFalse){
	// if (initsWhenTrue.equals(initsWhenFalse)) return initsWhenTrue; -- could optimize if #equals is defined
	return new ConditionalFlowInfo(initsWhenTrue, initsWhenFalse);
}


, Instance #
frags: 
(startLine=69 endLine=87 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00055/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
public void computeConstant(BlockScope scope, int leftId, int rightId) {
	//the TC has been done so leftId and rightId are both equal to T_boolean

	Constant cst;
	if ((cst = left.constant) != NotAConstant) {
		if (cst.booleanValue() == false) { // false && x --> false
			constant = cst; // inlined to constant(false)
		} else { // true && x --> x
			if ((constant = right.constant) == NotAConstant) {
				// compute conditionalConstant
				optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
			}
		}
	} else {
		constant = NotAConstant;
		// compute conditionalConstant
		optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
	}
}

(startLine=70 endLine=88 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00055/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
public void computeConstant(BlockScope scope, int leftId, int rightId) {
	//the TC has been done so leftId and rightId are both equal to T_boolean

	Constant cst;
	if ((cst = left.constant) != NotAConstant) {
		if (cst.booleanValue() == true) { // true || x --> true
			constant = cst; // inlined to constant(false)
		} else { // false || x --> x
			if ((constant = right.constant) == NotAConstant) {
				// compute conditionalConstant
				optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
			}
		}
	} else {
		constant = NotAConstant;
		// compute conditionalConstant
		optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
	}
}

commonMethod: 
(startLine=137 endLine=160 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00056/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/UnconditionalFlowInfo.java)
/**
 * Answers a copy of the current instance
 */
public FlowInfo copy() {
	// do not clone the DeadEnd
	if (this == DeadEnd)
		return this;

	// look for an unused preallocated object
	UnconditionalFlowInfo copy = new UnconditionalFlowInfo();

	// copy slots
	copy.definiteInits = definiteInits;
	copy.potentialInits = potentialInits;
	copy.isFakeReachable = isFakeReachable;
	copy.maxFieldCount = maxFieldCount;
	
	if (extraDefiniteInits != null) {
		int length;
		System.arraycopy(extraDefiniteInits, 0, (copy.extraDefiniteInits = new long[ (length = extraDefiniteInits.length)]), 0, length);
		System.arraycopy(extraPotentialInits, 0, (copy.extraPotentialInits = new long[length]), 0, length);
	};
	return copy;
}


, Instance #
frags: 
(startLine=69 endLine=87 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00055/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
public void computeConstant(BlockScope scope, int leftId, int rightId) {
	//the TC has been done so leftId and rightId are both equal to T_boolean

	Constant cst;
	if ((cst = left.constant) != NotAConstant) {
		if (cst.booleanValue() == false) { // false && x --> false
			constant = cst; // inlined to constant(false)
		} else { // true && x --> x
			if ((constant = right.constant) == NotAConstant) {
				// compute conditionalConstant
				optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
			}
		}
	} else {
		constant = NotAConstant;
		// compute conditionalConstant
		optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
	}
}

(startLine=70 endLine=88 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00055/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
public void computeConstant(BlockScope scope, int leftId, int rightId) {
	//the TC has been done so leftId and rightId are both equal to T_boolean

	Constant cst;
	if ((cst = left.constant) != NotAConstant) {
		if (cst.booleanValue() == true) { // true || x --> true
			constant = cst; // inlined to constant(false)
		} else { // false || x --> x
			if ((constant = right.constant) == NotAConstant) {
				// compute conditionalConstant
				optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
			}
		}
	} else {
		constant = NotAConstant;
		// compute conditionalConstant
		optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
	}
}

commonMethod: 
(startLine=253 endLine=293 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00056/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodScope.java)
public final int recordInitializationStates(FlowInfo flowInfo) {
	if ((flowInfo == FlowInfo.DeadEnd) || (flowInfo.isFakeReachable())) {
		return -1;
	}
	UnconditionalFlowInfo unconditionalFlowInfo = flowInfo.unconditionalInits();
	long[] extraInits = unconditionalFlowInfo.extraDefiniteInits;
	long inits = unconditionalFlowInfo.definiteInits;
	checkNextEntry : for (int i = lastIndex; --i >= 0;) {
		if (definiteInits[i] == inits) {
			long[] otherInits = extraDefiniteInits[i];
			if ((extraInits != null) && (otherInits != null)) {
				if (extraInits.length == otherInits.length) {
					int j, max;
					for (j = 0, max = extraInits.length; j < max; j++) {
						if (extraInits[j] != otherInits[j]) {
							continue checkNextEntry;
						}
					}
					return i;
				}
			} else {
				if ((extraInits == null) && (otherInits == null)) {
					return i;
				}
			}
		}
	}
	
	// add a new entry
	if (definiteInits.length == lastIndex) {
		// need a resize
		System.arraycopy(definiteInits, 0, (definiteInits = new long[lastIndex + 20]), 0, lastIndex);
		System.arraycopy(extraDefiniteInits, 0, (extraDefiniteInits = new long[lastIndex + 20][]), 0, lastIndex);
	}
	definiteInits[lastIndex] = inits;
	if (extraInits != null) {
		extraDefiniteInits[lastIndex] = new long[extraInits.length];
		System.arraycopy(extraInits, 0, extraDefiniteInits[lastIndex], 0, extraInits.length);
	}
	return lastIndex++;
}


, Instance #
frags: 
(startLine=69 endLine=87 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00055/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
public void computeConstant(BlockScope scope, int leftId, int rightId) {
	//the TC has been done so leftId and rightId are both equal to T_boolean

	Constant cst;
	if ((cst = left.constant) != NotAConstant) {
		if (cst.booleanValue() == false) { // false && x --> false
			constant = cst; // inlined to constant(false)
		} else { // true && x --> x
			if ((constant = right.constant) == NotAConstant) {
				// compute conditionalConstant
				optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
			}
		}
	} else {
		constant = NotAConstant;
		// compute conditionalConstant
		optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
	}
}

(startLine=70 endLine=88 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00055/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
public void computeConstant(BlockScope scope, int leftId, int rightId) {
	//the TC has been done so leftId and rightId are both equal to T_boolean

	Constant cst;
	if ((cst = left.constant) != NotAConstant) {
		if (cst.booleanValue() == true) { // true || x --> true
			constant = cst; // inlined to constant(false)
		} else { // false || x --> x
			if ((constant = right.constant) == NotAConstant) {
				// compute conditionalConstant
				optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
			}
		}
	} else {
		constant = NotAConstant;
		// compute conditionalConstant
		optimizedBooleanConstant(leftId, (bits & OperatorMASK) >> OperatorSHIFT, rightId);
	}
}

commonMethod: 
(startLine=22 endLine=24 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00056/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Statement.java)
public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
	return flowInfo;
}


, Instance #
frags: 
(startLine=1111 endLine=1134 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00088/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java)
		int visibleSize) {
		MethodBinding method = null;
		MethodBinding previous = null;
		nextVisible : for (int i = 0; i < visibleSize; i++) {
			method = visible[i];
			if (previous != null && method.declaringClass != previous.declaringClass)
				break;
			// cannot answer a method farther up the hierarchy than the first method found
			previous = method;
			for (int j = 0; j < visibleSize; j++) {
				if (i == j)
					continue;
				MethodBinding next = visible[j];
				if (!areParametersAssignable(next.parameters, method.parameters))
					continue nextVisible;
			}
			compilationUnitScope().addTypeReferences(method.thrownExceptions);
			return method;
		}
		return new ProblemMethodBinding(
			visible[0].selector,
			visible[0].parameters,
			Ambiguous);
	}

(startLine=1167 endLine=1185 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00088/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java)
		int visibleSize) {
		MethodBinding method = null;
		nextVisible : for (int i = 0; i < visibleSize; i++) {
			method = visible[i];
			for (int j = 0; j < visibleSize; j++) {
				if (i == j)
					continue;
				MethodBinding next = visible[j];
				if (!areParametersAssignable(next.parameters, method.parameters))
					continue nextVisible;
			}
			compilationUnitScope().addTypeReferences(method.thrownExceptions);
			return method;
		}
		return new ProblemMethodBinding(
			visible[0].selector,
			visible[0].parameters,
			Ambiguous);
	}

commonMethod: 
(startLine=430 endLine=446 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00089/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/CompilationUnitScope.java)
void recordReferences(TypeBinding[] types) {
	if (qualifiedReferences == null) return; // we're not recording dependencies
	if (types == null || types == NoExceptions) return;

// Do not think we need to record supertypes of method arguments & thrown exceptions
// If a field/method is retrieved from such a type then a separate call does the job
//	for (int i = 0, max = types.length; i < max; i++)
//		recordTypeReference(types[i]);

	for (int i = 0, max = types.length; i < max; i++) {
		TypeBinding type = types[i];
		if (type.isArrayType())
			type = ((ArrayBinding) type).leafComponentType;
		if (!type.isBaseType())
			recordReference(((ReferenceBinding) type).compoundName);
	}
}


, Instance #
frags: 
(startLine=555 endLine=593 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
		if (this.fieldsCount != otherFieldInfosLength) {
			if (excludesSynthetic) {
				if (orderRequired) {
					if (this.fieldsCount != 0) {
						Arrays.sort(this.fields);
					}
					if (otherFieldInfosLength != 0) {
						Arrays.sort(otherFieldInfos);	
					}
				}
				// remove synthetic fields
				FieldInfo[] otherFieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(otherFieldInfos);
				FieldInfo[] fieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(this.fields);
				int fieldsInfoWithoutSyntheticsLength = fieldsInfoWithoutSynthetics == null ? 0 : fieldsInfoWithoutSynthetics.length;
				int otherFieldsInfoWithoutSyntheticsLength = otherFieldsInfoWithoutSynthetics == null ? 0 : otherFieldsInfoWithoutSynthetics.length;
				if (fieldsInfoWithoutSyntheticsLength != this.fieldsCount || otherFieldsInfoWithoutSyntheticsLength != otherFieldInfosLength) {
					if (fieldsInfoWithoutSyntheticsLength != otherFieldsInfoWithoutSyntheticsLength) {
						return true;
					}
					boolean changedInFields = false;
					if (otherFieldsInfoWithoutSyntheticsLength != 0) {
						for (int i = 0; i < otherFieldsInfoWithoutSyntheticsLength && !changedInFields; i++) {
							changedInFields = hasStructuralFieldChanges(fieldsInfoWithoutSynthetics[i], otherFieldsInfoWithoutSynthetics[i]);
						}
						if (changedInFields) {
							return true;
						} else {
							jumpOverFieldCheck = true;
						}
					} else {
						jumpOverFieldCheck = true;
					}
				} else {
					return true;
				}
			} else {
				return true;
			}
		}

(startLine=600 endLine=638 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
				if (orderRequired) {
					if (this.fieldsCount != 0) {
						Arrays.sort(this.fields);
					}
					if (otherFieldInfosLength != 0) {
						Arrays.sort(otherFieldInfos);	
					}
					changedInFields = false;			
					for (int i = 0; i < otherFieldInfosLength && !changedInFields; i++) {
						changedInFields = hasStructuralFieldChanges(this.fields[i], otherFieldInfos[i]);
					}
					if (changedInFields) {
						if (excludesSynthetic) {
							// remove synthetic fields
							FieldInfo[] otherFieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(otherFieldInfos);
							FieldInfo[] fieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(this.fields);
							int fieldsInfoWithoutSyntheticsLength = fieldsInfoWithoutSynthetics == null ? 0 : fieldsInfoWithoutSynthetics.length;
							int otherFieldsInfoWithoutSyntheticsLength = otherFieldsInfoWithoutSynthetics == null ? 0 : otherFieldsInfoWithoutSynthetics.length;
							if (fieldsInfoWithoutSyntheticsLength != this.fieldsCount || otherFieldsInfoWithoutSyntheticsLength != otherFieldInfosLength) {
								if (fieldsInfoWithoutSyntheticsLength != otherFieldsInfoWithoutSyntheticsLength) {
									return true;
								}
								changedInFields = false;
								if (otherFieldsInfoWithoutSyntheticsLength != 0) {
									for (int i = 0; i < otherFieldsInfoWithoutSyntheticsLength && !changedInFields; i++) {
										changedInFields = hasStructuralFieldChanges(fieldsInfoWithoutSynthetics[i], otherFieldsInfoWithoutSynthetics[i]);
									}
									if (changedInFields) {
										return true;
									}
								}
							} else {
								return true;
							}
						} else {
							return true;
						}
					}
				} else if (excludesSynthetic) {

commonMethod: 
(startLine=606 endLine=630 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00093/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
private boolean hasNonSyntheticFieldChanges(FieldInfo[] currentFieldInfos, FieldInfo[] otherFieldInfos) {
	int length1 = currentFieldInfos == null ? 0 : currentFieldInfos.length;
	int length2 = otherFieldInfos == null ? 0 : otherFieldInfos.length;
	int index1 = 0;
	int index2 = 0;

	end : while (index1 < length1 && index2 < length2) {
		while (currentFieldInfos[index1].isSynthetic()) {
			if (++index1 >= length1) break end;
		}
		while (otherFieldInfos[index2].isSynthetic()) {
			if (++index2 >= length2) break end;
		}
		if (hasStructuralFieldChanges(currentFieldInfos[index1++], otherFieldInfos[index2++]))
			return true;
	}

	while (index1 < length1) {
		if (!currentFieldInfos[index1++].isSynthetic()) return true;
	}
	while (index2 < length2) {
		if (!otherFieldInfos[index2++].isSynthetic()) return true;
	}
	return false;
}


, Instance #
frags: 
(startLine=555 endLine=593 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
		if (this.fieldsCount != otherFieldInfosLength) {
			if (excludesSynthetic) {
				if (orderRequired) {
					if (this.fieldsCount != 0) {
						Arrays.sort(this.fields);
					}
					if (otherFieldInfosLength != 0) {
						Arrays.sort(otherFieldInfos);	
					}
				}
				// remove synthetic fields
				FieldInfo[] otherFieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(otherFieldInfos);
				FieldInfo[] fieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(this.fields);
				int fieldsInfoWithoutSyntheticsLength = fieldsInfoWithoutSynthetics == null ? 0 : fieldsInfoWithoutSynthetics.length;
				int otherFieldsInfoWithoutSyntheticsLength = otherFieldsInfoWithoutSynthetics == null ? 0 : otherFieldsInfoWithoutSynthetics.length;
				if (fieldsInfoWithoutSyntheticsLength != this.fieldsCount || otherFieldsInfoWithoutSyntheticsLength != otherFieldInfosLength) {
					if (fieldsInfoWithoutSyntheticsLength != otherFieldsInfoWithoutSyntheticsLength) {
						return true;
					}
					boolean changedInFields = false;
					if (otherFieldsInfoWithoutSyntheticsLength != 0) {
						for (int i = 0; i < otherFieldsInfoWithoutSyntheticsLength && !changedInFields; i++) {
							changedInFields = hasStructuralFieldChanges(fieldsInfoWithoutSynthetics[i], otherFieldsInfoWithoutSynthetics[i]);
						}
						if (changedInFields) {
							return true;
						} else {
							jumpOverFieldCheck = true;
						}
					} else {
						jumpOverFieldCheck = true;
					}
				} else {
					return true;
				}
			} else {
				return true;
			}
		}

(startLine=600 endLine=638 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
				if (orderRequired) {
					if (this.fieldsCount != 0) {
						Arrays.sort(this.fields);
					}
					if (otherFieldInfosLength != 0) {
						Arrays.sort(otherFieldInfos);	
					}
					changedInFields = false;			
					for (int i = 0; i < otherFieldInfosLength && !changedInFields; i++) {
						changedInFields = hasStructuralFieldChanges(this.fields[i], otherFieldInfos[i]);
					}
					if (changedInFields) {
						if (excludesSynthetic) {
							// remove synthetic fields
							FieldInfo[] otherFieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(otherFieldInfos);
							FieldInfo[] fieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(this.fields);
							int fieldsInfoWithoutSyntheticsLength = fieldsInfoWithoutSynthetics == null ? 0 : fieldsInfoWithoutSynthetics.length;
							int otherFieldsInfoWithoutSyntheticsLength = otherFieldsInfoWithoutSynthetics == null ? 0 : otherFieldsInfoWithoutSynthetics.length;
							if (fieldsInfoWithoutSyntheticsLength != this.fieldsCount || otherFieldsInfoWithoutSyntheticsLength != otherFieldInfosLength) {
								if (fieldsInfoWithoutSyntheticsLength != otherFieldsInfoWithoutSyntheticsLength) {
									return true;
								}
								changedInFields = false;
								if (otherFieldsInfoWithoutSyntheticsLength != 0) {
									for (int i = 0; i < otherFieldsInfoWithoutSyntheticsLength && !changedInFields; i++) {
										changedInFields = hasStructuralFieldChanges(fieldsInfoWithoutSynthetics[i], otherFieldsInfoWithoutSynthetics[i]);
									}
									if (changedInFields) {
										return true;
									}
								}
							} else {
								return true;
							}
						} else {
							return true;
						}
					}
				} else if (excludesSynthetic) {

commonMethod: 
(startLine=670 endLine=694 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00093/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
private boolean hasNonSyntheticMethodChanges(MethodInfo[] currentMethodInfos, MethodInfo[] otherMethodInfos) {
	int length1 = currentMethodInfos == null ? 0 : currentMethodInfos.length;
	int length2 = otherMethodInfos == null ? 0 : otherMethodInfos.length;
	int index1 = 0;
	int index2 = 0;

	end : while (index1 < length1 && index2 < length2) {
		while (currentMethodInfos[index1].isSynthetic()) {
			if (++index1 >= length1) break end;
		}
		while (otherMethodInfos[index2].isSynthetic()) {
			if (++index2 >= length2) break end;
		}
		if (hasStructuralMethodChanges(currentMethodInfos[index1++], otherMethodInfos[index2++]))
			return true;
	}

	while (index1 < length1) {
		if (!currentMethodInfos[index1++].isSynthetic()) return true;
	}
	while (index2 < length2) {
		if (!otherMethodInfos[index2++].isSynthetic()) return true;
	}
	return false;
}


, Instance #
frags: 
(startLine=611 endLine=637 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
					if (changedInFields) {
						if (excludesSynthetic) {
							// remove synthetic fields
							FieldInfo[] otherFieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(otherFieldInfos);
							FieldInfo[] fieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(this.fields);
							int fieldsInfoWithoutSyntheticsLength = fieldsInfoWithoutSynthetics == null ? 0 : fieldsInfoWithoutSynthetics.length;
							int otherFieldsInfoWithoutSyntheticsLength = otherFieldsInfoWithoutSynthetics == null ? 0 : otherFieldsInfoWithoutSynthetics.length;
							if (fieldsInfoWithoutSyntheticsLength != this.fieldsCount || otherFieldsInfoWithoutSyntheticsLength != otherFieldInfosLength) {
								if (fieldsInfoWithoutSyntheticsLength != otherFieldsInfoWithoutSyntheticsLength) {
									return true;
								}
								changedInFields = false;
								if (otherFieldsInfoWithoutSyntheticsLength != 0) {
									for (int i = 0; i < otherFieldsInfoWithoutSyntheticsLength && !changedInFields; i++) {
										changedInFields = hasStructuralFieldChanges(fieldsInfoWithoutSynthetics[i], otherFieldsInfoWithoutSynthetics[i]);
									}
									if (changedInFields) {
										return true;
									}
								}
							} else {
								return true;
							}
						} else {
							return true;
						}
					}

(startLine=638 endLine=660 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
				} else if (excludesSynthetic) {
					// remove synthetic fields
					FieldInfo[] otherFieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(otherFieldInfos);
					FieldInfo[] fieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(this.fields);
					int fieldsInfoWithoutSyntheticsLength = fieldsInfoWithoutSynthetics == null ? 0 : fieldsInfoWithoutSynthetics.length;
					int otherFieldsInfoWithoutSyntheticsLength = otherFieldsInfoWithoutSynthetics == null ? 0 : otherFieldsInfoWithoutSynthetics.length;
					if (fieldsInfoWithoutSyntheticsLength != this.fieldsCount || otherFieldsInfoWithoutSyntheticsLength != otherFieldInfosLength) {
						if (fieldsInfoWithoutSyntheticsLength != otherFieldsInfoWithoutSyntheticsLength) {
							return true;
						}
						changedInFields = false;
						if (otherFieldsInfoWithoutSyntheticsLength != 0) {
							for (int i = 0; i < otherFieldsInfoWithoutSyntheticsLength && !changedInFields; i++) {
								changedInFields = hasStructuralFieldChanges(fieldsInfoWithoutSynthetics[i], otherFieldsInfoWithoutSynthetics[i]);
							}
							if (changedInFields) {
								return true;
							}
						}
					} else {
						return true;
					}
				} else {

commonMethod: 
(startLine=606 endLine=630 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00093/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
private boolean hasNonSyntheticFieldChanges(FieldInfo[] currentFieldInfos, FieldInfo[] otherFieldInfos) {
	int length1 = currentFieldInfos == null ? 0 : currentFieldInfos.length;
	int length2 = otherFieldInfos == null ? 0 : otherFieldInfos.length;
	int index1 = 0;
	int index2 = 0;

	end : while (index1 < length1 && index2 < length2) {
		while (currentFieldInfos[index1].isSynthetic()) {
			if (++index1 >= length1) break end;
		}
		while (otherFieldInfos[index2].isSynthetic()) {
			if (++index2 >= length2) break end;
		}
		if (hasStructuralFieldChanges(currentFieldInfos[index1++], otherFieldInfos[index2++]))
			return true;
	}

	while (index1 < length1) {
		if (!currentFieldInfos[index1++].isSynthetic()) return true;
	}
	while (index2 < length2) {
		if (!otherFieldInfos[index2++].isSynthetic()) return true;
	}
	return false;
}


, Instance #
frags: 
(startLine=611 endLine=637 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
					if (changedInFields) {
						if (excludesSynthetic) {
							// remove synthetic fields
							FieldInfo[] otherFieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(otherFieldInfos);
							FieldInfo[] fieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(this.fields);
							int fieldsInfoWithoutSyntheticsLength = fieldsInfoWithoutSynthetics == null ? 0 : fieldsInfoWithoutSynthetics.length;
							int otherFieldsInfoWithoutSyntheticsLength = otherFieldsInfoWithoutSynthetics == null ? 0 : otherFieldsInfoWithoutSynthetics.length;
							if (fieldsInfoWithoutSyntheticsLength != this.fieldsCount || otherFieldsInfoWithoutSyntheticsLength != otherFieldInfosLength) {
								if (fieldsInfoWithoutSyntheticsLength != otherFieldsInfoWithoutSyntheticsLength) {
									return true;
								}
								changedInFields = false;
								if (otherFieldsInfoWithoutSyntheticsLength != 0) {
									for (int i = 0; i < otherFieldsInfoWithoutSyntheticsLength && !changedInFields; i++) {
										changedInFields = hasStructuralFieldChanges(fieldsInfoWithoutSynthetics[i], otherFieldsInfoWithoutSynthetics[i]);
									}
									if (changedInFields) {
										return true;
									}
								}
							} else {
								return true;
							}
						} else {
							return true;
						}
					}

(startLine=638 endLine=660 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
				} else if (excludesSynthetic) {
					// remove synthetic fields
					FieldInfo[] otherFieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(otherFieldInfos);
					FieldInfo[] fieldsInfoWithoutSynthetics = this.removeSyntheticFieldsInfos(this.fields);
					int fieldsInfoWithoutSyntheticsLength = fieldsInfoWithoutSynthetics == null ? 0 : fieldsInfoWithoutSynthetics.length;
					int otherFieldsInfoWithoutSyntheticsLength = otherFieldsInfoWithoutSynthetics == null ? 0 : otherFieldsInfoWithoutSynthetics.length;
					if (fieldsInfoWithoutSyntheticsLength != this.fieldsCount || otherFieldsInfoWithoutSyntheticsLength != otherFieldInfosLength) {
						if (fieldsInfoWithoutSyntheticsLength != otherFieldsInfoWithoutSyntheticsLength) {
							return true;
						}
						changedInFields = false;
						if (otherFieldsInfoWithoutSyntheticsLength != 0) {
							for (int i = 0; i < otherFieldsInfoWithoutSyntheticsLength && !changedInFields; i++) {
								changedInFields = hasStructuralFieldChanges(fieldsInfoWithoutSynthetics[i], otherFieldsInfoWithoutSynthetics[i]);
							}
							if (changedInFields) {
								return true;
							}
						}
					} else {
						return true;
					}
				} else {

commonMethod: 
(startLine=670 endLine=694 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00093/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
private boolean hasNonSyntheticMethodChanges(MethodInfo[] currentMethodInfos, MethodInfo[] otherMethodInfos) {
	int length1 = currentMethodInfos == null ? 0 : currentMethodInfos.length;
	int length2 = otherMethodInfos == null ? 0 : otherMethodInfos.length;
	int index1 = 0;
	int index2 = 0;

	end : while (index1 < length1 && index2 < length2) {
		while (currentMethodInfos[index1].isSynthetic()) {
			if (++index1 >= length1) break end;
		}
		while (otherMethodInfos[index2].isSynthetic()) {
			if (++index2 >= length2) break end;
		}
		if (hasStructuralMethodChanges(currentMethodInfos[index1++], otherMethodInfos[index2++]))
			return true;
	}

	while (index1 < length1) {
		if (!currentMethodInfos[index1++].isSynthetic()) return true;
	}
	while (index2 < length2) {
		if (!otherMethodInfos[index2++].isSynthetic()) return true;
	}
	return false;
}


, Instance #
frags: 
(startLine=672 endLine=709 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
		if (this.methodsCount != otherMethodInfosLength) {
			if (excludesSynthetic) {
				if (orderRequired) {
					if (this.methodsCount != 0) {
						Arrays.sort(this.methods);
					}
					if (otherMethodInfosLength != 0) {
						Arrays.sort(otherMethodInfos);	
					}
				}
				// remove synthetic fields
				MethodInfo[] otherMethodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(otherMethodInfos);
				MethodInfo[] methodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(this.methods);
				int methodInfosWithoutSyntheticsLength = methodInfosWithoutSynthetics == null ? 0 : methodInfosWithoutSynthetics.length;
				int otherMethodInfosWithoutSyntheticsLength = otherMethodInfosWithoutSynthetics == null ? 0 : otherMethodInfosWithoutSynthetics.length;
				if (methodInfosWithoutSyntheticsLength != this.fieldsCount || otherMethodInfosWithoutSyntheticsLength != otherFieldInfosLength) {
					if (methodInfosWithoutSyntheticsLength != otherMethodInfosWithoutSyntheticsLength) {
						return true;
					}
					if (otherMethodInfosWithoutSyntheticsLength != 0) {
						for (int i = 0; i < otherMethodInfosWithoutSyntheticsLength && !changedInMethods; i++) {
							changedInMethods = hasStructuralMethodChanges(methodInfosWithoutSynthetics[i], otherMethodInfosWithoutSynthetics[i]);
						}
						if (changedInMethods) {
							return true;
						} else {
							jumpOverMethodCheck = true;
						}
					} else {
						jumpOverMethodCheck = true;
					}
				} else {
					return true;
				}
			} else {
				return true;
			}
		}

(startLine=719 endLine=756 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
				if (orderRequired) {
					if (this.methodsCount != 0) {
						Arrays.sort(this.methods);
					}
					if (otherMethodInfosLength != 0) {
						Arrays.sort(otherMethodInfos);
					}
					changedInMethods = false;			
					for (int i = 0; i < otherMethodInfosLength && !changedInMethods; i++) {
						changedInMethods = hasStructuralMethodChanges(this.methods[i], otherMethodInfos[i]);
					}
					if (changedInMethods) {
						if (excludesSynthetic) {
							// remove synthetic fields
							MethodInfo[] otherMethodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(otherMethodInfos);
							MethodInfo[] methodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(this.methods);
							int methodInfosWithoutSyntheticsLength = methodInfosWithoutSynthetics == null ? 0 : methodInfosWithoutSynthetics.length;
							int otherMethodInfosWithoutSyntheticsLength = otherMethodInfosWithoutSynthetics == null ? 0 : otherMethodInfosWithoutSynthetics.length;
							if (methodInfosWithoutSyntheticsLength != this.fieldsCount || otherMethodInfosWithoutSyntheticsLength != otherFieldInfosLength) {
								if (methodInfosWithoutSyntheticsLength != otherMethodInfosWithoutSyntheticsLength) {
									return true;
								}
								if (otherMethodInfosWithoutSyntheticsLength != 0) {
									for (int i = 0; i < otherMethodInfosWithoutSyntheticsLength && !changedInMethods; i++) {
										changedInMethods = hasStructuralMethodChanges(methodInfosWithoutSynthetics[i], otherMethodInfosWithoutSynthetics[i]);
									}
									if (changedInMethods) {
										return true;
									}
								}
							} else {
								return true;
							}
						} else {
							return true;
						}		
					}
				} else if (excludesSynthetic) {

commonMethod: 
(startLine=606 endLine=630 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00093/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
private boolean hasNonSyntheticFieldChanges(FieldInfo[] currentFieldInfos, FieldInfo[] otherFieldInfos) {
	int length1 = currentFieldInfos == null ? 0 : currentFieldInfos.length;
	int length2 = otherFieldInfos == null ? 0 : otherFieldInfos.length;
	int index1 = 0;
	int index2 = 0;

	end : while (index1 < length1 && index2 < length2) {
		while (currentFieldInfos[index1].isSynthetic()) {
			if (++index1 >= length1) break end;
		}
		while (otherFieldInfos[index2].isSynthetic()) {
			if (++index2 >= length2) break end;
		}
		if (hasStructuralFieldChanges(currentFieldInfos[index1++], otherFieldInfos[index2++]))
			return true;
	}

	while (index1 < length1) {
		if (!currentFieldInfos[index1++].isSynthetic()) return true;
	}
	while (index2 < length2) {
		if (!otherFieldInfos[index2++].isSynthetic()) return true;
	}
	return false;
}


, Instance #
frags: 
(startLine=672 endLine=709 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
		if (this.methodsCount != otherMethodInfosLength) {
			if (excludesSynthetic) {
				if (orderRequired) {
					if (this.methodsCount != 0) {
						Arrays.sort(this.methods);
					}
					if (otherMethodInfosLength != 0) {
						Arrays.sort(otherMethodInfos);	
					}
				}
				// remove synthetic fields
				MethodInfo[] otherMethodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(otherMethodInfos);
				MethodInfo[] methodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(this.methods);
				int methodInfosWithoutSyntheticsLength = methodInfosWithoutSynthetics == null ? 0 : methodInfosWithoutSynthetics.length;
				int otherMethodInfosWithoutSyntheticsLength = otherMethodInfosWithoutSynthetics == null ? 0 : otherMethodInfosWithoutSynthetics.length;
				if (methodInfosWithoutSyntheticsLength != this.fieldsCount || otherMethodInfosWithoutSyntheticsLength != otherFieldInfosLength) {
					if (methodInfosWithoutSyntheticsLength != otherMethodInfosWithoutSyntheticsLength) {
						return true;
					}
					if (otherMethodInfosWithoutSyntheticsLength != 0) {
						for (int i = 0; i < otherMethodInfosWithoutSyntheticsLength && !changedInMethods; i++) {
							changedInMethods = hasStructuralMethodChanges(methodInfosWithoutSynthetics[i], otherMethodInfosWithoutSynthetics[i]);
						}
						if (changedInMethods) {
							return true;
						} else {
							jumpOverMethodCheck = true;
						}
					} else {
						jumpOverMethodCheck = true;
					}
				} else {
					return true;
				}
			} else {
				return true;
			}
		}

(startLine=719 endLine=756 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
				if (orderRequired) {
					if (this.methodsCount != 0) {
						Arrays.sort(this.methods);
					}
					if (otherMethodInfosLength != 0) {
						Arrays.sort(otherMethodInfos);
					}
					changedInMethods = false;			
					for (int i = 0; i < otherMethodInfosLength && !changedInMethods; i++) {
						changedInMethods = hasStructuralMethodChanges(this.methods[i], otherMethodInfos[i]);
					}
					if (changedInMethods) {
						if (excludesSynthetic) {
							// remove synthetic fields
							MethodInfo[] otherMethodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(otherMethodInfos);
							MethodInfo[] methodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(this.methods);
							int methodInfosWithoutSyntheticsLength = methodInfosWithoutSynthetics == null ? 0 : methodInfosWithoutSynthetics.length;
							int otherMethodInfosWithoutSyntheticsLength = otherMethodInfosWithoutSynthetics == null ? 0 : otherMethodInfosWithoutSynthetics.length;
							if (methodInfosWithoutSyntheticsLength != this.fieldsCount || otherMethodInfosWithoutSyntheticsLength != otherFieldInfosLength) {
								if (methodInfosWithoutSyntheticsLength != otherMethodInfosWithoutSyntheticsLength) {
									return true;
								}
								if (otherMethodInfosWithoutSyntheticsLength != 0) {
									for (int i = 0; i < otherMethodInfosWithoutSyntheticsLength && !changedInMethods; i++) {
										changedInMethods = hasStructuralMethodChanges(methodInfosWithoutSynthetics[i], otherMethodInfosWithoutSynthetics[i]);
									}
									if (changedInMethods) {
										return true;
									}
								}
							} else {
								return true;
							}
						} else {
							return true;
						}		
					}
				} else if (excludesSynthetic) {

commonMethod: 
(startLine=670 endLine=694 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00093/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
private boolean hasNonSyntheticMethodChanges(MethodInfo[] currentMethodInfos, MethodInfo[] otherMethodInfos) {
	int length1 = currentMethodInfos == null ? 0 : currentMethodInfos.length;
	int length2 = otherMethodInfos == null ? 0 : otherMethodInfos.length;
	int index1 = 0;
	int index2 = 0;

	end : while (index1 < length1 && index2 < length2) {
		while (currentMethodInfos[index1].isSynthetic()) {
			if (++index1 >= length1) break end;
		}
		while (otherMethodInfos[index2].isSynthetic()) {
			if (++index2 >= length2) break end;
		}
		if (hasStructuralMethodChanges(currentMethodInfos[index1++], otherMethodInfos[index2++]))
			return true;
	}

	while (index1 < length1) {
		if (!currentMethodInfos[index1++].isSynthetic()) return true;
	}
	while (index2 < length2) {
		if (!otherMethodInfos[index2++].isSynthetic()) return true;
	}
	return false;
}


, Instance #
frags: 
(startLine=730 endLine=755 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
					if (changedInMethods) {
						if (excludesSynthetic) {
							// remove synthetic fields
							MethodInfo[] otherMethodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(otherMethodInfos);
							MethodInfo[] methodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(this.methods);
							int methodInfosWithoutSyntheticsLength = methodInfosWithoutSynthetics == null ? 0 : methodInfosWithoutSynthetics.length;
							int otherMethodInfosWithoutSyntheticsLength = otherMethodInfosWithoutSynthetics == null ? 0 : otherMethodInfosWithoutSynthetics.length;
							if (methodInfosWithoutSyntheticsLength != this.fieldsCount || otherMethodInfosWithoutSyntheticsLength != otherFieldInfosLength) {
								if (methodInfosWithoutSyntheticsLength != otherMethodInfosWithoutSyntheticsLength) {
									return true;
								}
								if (otherMethodInfosWithoutSyntheticsLength != 0) {
									for (int i = 0; i < otherMethodInfosWithoutSyntheticsLength && !changedInMethods; i++) {
										changedInMethods = hasStructuralMethodChanges(methodInfosWithoutSynthetics[i], otherMethodInfosWithoutSynthetics[i]);
									}
									if (changedInMethods) {
										return true;
									}
								}
							} else {
								return true;
							}
						} else {
							return true;
						}		
					}

(startLine=756 endLine=777 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
				} else if (excludesSynthetic) {
					// remove synthetic fields
					MethodInfo[] otherMethodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(otherMethodInfos);
					MethodInfo[] methodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(this.methods);
					int methodInfosWithoutSyntheticsLength = methodInfosWithoutSynthetics == null ? 0 : methodInfosWithoutSynthetics.length;
					int otherMethodInfosWithoutSyntheticsLength = otherMethodInfosWithoutSynthetics == null ? 0 : otherMethodInfosWithoutSynthetics.length;
					if (methodInfosWithoutSyntheticsLength != this.fieldsCount || otherMethodInfosWithoutSyntheticsLength != otherFieldInfosLength) {
						if (methodInfosWithoutSyntheticsLength != otherMethodInfosWithoutSyntheticsLength) {
							return true;
						}
						if (otherMethodInfosWithoutSyntheticsLength != 0) {
							for (int i = 0; i < otherMethodInfosWithoutSyntheticsLength && !changedInMethods; i++) {
								changedInMethods = hasStructuralMethodChanges(methodInfosWithoutSynthetics[i], otherMethodInfosWithoutSynthetics[i]);
							}
							if (changedInMethods) {
								return true;
							}
						}
					} else {
						return true;
					}
				} else {

commonMethod: 
(startLine=606 endLine=630 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00093/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
private boolean hasNonSyntheticFieldChanges(FieldInfo[] currentFieldInfos, FieldInfo[] otherFieldInfos) {
	int length1 = currentFieldInfos == null ? 0 : currentFieldInfos.length;
	int length2 = otherFieldInfos == null ? 0 : otherFieldInfos.length;
	int index1 = 0;
	int index2 = 0;

	end : while (index1 < length1 && index2 < length2) {
		while (currentFieldInfos[index1].isSynthetic()) {
			if (++index1 >= length1) break end;
		}
		while (otherFieldInfos[index2].isSynthetic()) {
			if (++index2 >= length2) break end;
		}
		if (hasStructuralFieldChanges(currentFieldInfos[index1++], otherFieldInfos[index2++]))
			return true;
	}

	while (index1 < length1) {
		if (!currentFieldInfos[index1++].isSynthetic()) return true;
	}
	while (index2 < length2) {
		if (!otherFieldInfos[index2++].isSynthetic()) return true;
	}
	return false;
}


, Instance #
frags: 
(startLine=730 endLine=755 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
					if (changedInMethods) {
						if (excludesSynthetic) {
							// remove synthetic fields
							MethodInfo[] otherMethodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(otherMethodInfos);
							MethodInfo[] methodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(this.methods);
							int methodInfosWithoutSyntheticsLength = methodInfosWithoutSynthetics == null ? 0 : methodInfosWithoutSynthetics.length;
							int otherMethodInfosWithoutSyntheticsLength = otherMethodInfosWithoutSynthetics == null ? 0 : otherMethodInfosWithoutSynthetics.length;
							if (methodInfosWithoutSyntheticsLength != this.fieldsCount || otherMethodInfosWithoutSyntheticsLength != otherFieldInfosLength) {
								if (methodInfosWithoutSyntheticsLength != otherMethodInfosWithoutSyntheticsLength) {
									return true;
								}
								if (otherMethodInfosWithoutSyntheticsLength != 0) {
									for (int i = 0; i < otherMethodInfosWithoutSyntheticsLength && !changedInMethods; i++) {
										changedInMethods = hasStructuralMethodChanges(methodInfosWithoutSynthetics[i], otherMethodInfosWithoutSynthetics[i]);
									}
									if (changedInMethods) {
										return true;
									}
								}
							} else {
								return true;
							}
						} else {
							return true;
						}		
					}

(startLine=756 endLine=777 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00092/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
				} else if (excludesSynthetic) {
					// remove synthetic fields
					MethodInfo[] otherMethodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(otherMethodInfos);
					MethodInfo[] methodInfosWithoutSynthetics = this.removeSyntheticMethodsInfos(this.methods);
					int methodInfosWithoutSyntheticsLength = methodInfosWithoutSynthetics == null ? 0 : methodInfosWithoutSynthetics.length;
					int otherMethodInfosWithoutSyntheticsLength = otherMethodInfosWithoutSynthetics == null ? 0 : otherMethodInfosWithoutSynthetics.length;
					if (methodInfosWithoutSyntheticsLength != this.fieldsCount || otherMethodInfosWithoutSyntheticsLength != otherFieldInfosLength) {
						if (methodInfosWithoutSyntheticsLength != otherMethodInfosWithoutSyntheticsLength) {
							return true;
						}
						if (otherMethodInfosWithoutSyntheticsLength != 0) {
							for (int i = 0; i < otherMethodInfosWithoutSyntheticsLength && !changedInMethods; i++) {
								changedInMethods = hasStructuralMethodChanges(methodInfosWithoutSynthetics[i], otherMethodInfosWithoutSynthetics[i]);
							}
							if (changedInMethods) {
								return true;
							}
						}
					} else {
						return true;
					}
				} else {

commonMethod: 
(startLine=670 endLine=694 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00093/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/classfmt/ClassFileReader.java)
private boolean hasNonSyntheticMethodChanges(MethodInfo[] currentMethodInfos, MethodInfo[] otherMethodInfos) {
	int length1 = currentMethodInfos == null ? 0 : currentMethodInfos.length;
	int length2 = otherMethodInfos == null ? 0 : otherMethodInfos.length;
	int index1 = 0;
	int index2 = 0;

	end : while (index1 < length1 && index2 < length2) {
		while (currentMethodInfos[index1].isSynthetic()) {
			if (++index1 >= length1) break end;
		}
		while (otherMethodInfos[index2].isSynthetic()) {
			if (++index2 >= length2) break end;
		}
		if (hasStructuralMethodChanges(currentMethodInfos[index1++], otherMethodInfos[index2++]))
			return true;
	}

	while (index1 < length1) {
		if (!currentMethodInfos[index1++].isSynthetic()) return true;
	}
	while (index2 < length2) {
		if (!otherMethodInfos[index2++].isSynthetic()) return true;
	}
	return false;
}


, Instance #
frags: 
(startLine=587 endLine=604 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00104/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
			if (element instanceof IPackageFragment) {
				// add subpackages
				PackageFragmentRoot root = element.getPackageFragmentRoot();
				String name = element.getElementName();
				IResourceDelta[] children = delta.getAffectedChildren();
				for (int i = 0, length = children.length; i < length; i++) {
					IResourceDelta child = children[i];
					IResource resource = child.getResource();
					if (resource instanceof IFolder) {
						String subpkgName = 
							name.length() == 0 ? 
								resource.getName() : 
								name + "." + resource.getName(); //$NON-NLS-1$
						Openable subpkg = (Openable)root.getPackageFragment(subpkgName);
						this.updateCurrentDeltaAndIndex(subpkg, child);
					}
				}
			}

(startLine=612 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00104/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
			if (element instanceof IPackageFragment) {
				// remove subpackages
				PackageFragmentRoot root = element.getPackageFragmentRoot();
				String name = element.getElementName();
				IResourceDelta[] children = delta.getAffectedChildren();
				for (int i = 0, length = children.length; i < length; i++) {
					IResourceDelta child = children[i];
					IResource resource = child.getResource();
					if (resource instanceof IFolder) {
						String subpkgName = 
							name.length() == 0 ? 
								resource.getName() : 
								name + "." + resource.getName(); //$NON-NLS-1$
						Openable subpkg = (Openable)root.getPackageFragment(subpkgName);
						this.updateCurrentDeltaAndIndex(subpkg, child);
					}
				}
			}

commonMethod: 
(startLine=253 endLine=323 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00105/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
	/**
	 * Creates the openables corresponding to this resource.
	 * Returns null if none was found.
	 */
	protected Openable createElement(IResource resource, int elementType) {
		if (resource == null) return null;
		
		// find the element that encloses the resource
		IPath path = resource.getFullPath();
		this.popUntilPrefixOf(path);
		
		IJavaElement element = null;
		if (this.currentElement != null) {
			switch (elementType) {
				case IJavaElement.JAVA_PROJECT:
					element = JavaCore.create((IProject)resource);
					break;
				case IJavaElement.PACKAGE_FRAGMENT_ROOT:
					element = this.currentElement.getJavaProject().getPackageFragmentRoot(resource);
					break;
				case IJavaElement.PACKAGE_FRAGMENT:
					IPackageFragmentRoot root = this.currentElement.getPackageFragmentRoot();
					if (root != null && !Util.conflictsWithOutputLocation(path, (JavaProject)root.getJavaProject())) {
						IPath pkgPath = path.removeFirstSegments(root.getPath().segmentCount());
						String pkg = Util.packageName(pkgPath);
						if (pkg == null) return null;
						element = root.getPackageFragment(pkg);
					}
					break;
				case IJavaElement.COMPILATION_UNIT:
					IPackageFragment pkgFragment = null;
					switch (this.currentElement.getElementType()) {
						case IJavaElement.PACKAGE_FRAGMENT:
							pkgFragment = (IPackageFragment)this.currentElement;
							break;
						case IJavaElement.COMPILATION_UNIT:
						case IJavaElement.CLASS_FILE:
							pkgFragment = (IPackageFragment)this.currentElement.getParent();
							break;
					}
					if (pkgFragment != null) {
						String fileName = path.lastSegment();
						if (!Util.isValidCompilationUnitName(fileName)) return null;
						element = pkgFragment.getCompilationUnit(fileName);
					}
					break;
				case IJavaElement.CLASS_FILE:
					pkgFragment = null;
					switch (this.currentElement.getElementType()) {
						case IJavaElement.PACKAGE_FRAGMENT:
							pkgFragment = (IPackageFragment)this.currentElement;
							break;
						case IJavaElement.COMPILATION_UNIT:
						case IJavaElement.CLASS_FILE:
							pkgFragment = (IPackageFragment)this.currentElement.getParent();
							break;
					}
					if (pkgFragment != null) {
						String fileName = path.lastSegment();
						if (!Util.isValidClassFileName(fileName)) return null;
						element = pkgFragment.getClassFile(fileName);
					}
					break;
			}
		}
		if (element == null) {
			element = JavaCore.create(resource);
		}
		this.currentElement = (Openable)element;
		return this.currentElement;
	}


, Instance #
frags: 
(startLine=592 endLine=603 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00104/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				for (int i = 0, length = children.length; i < length; i++) {
					IResourceDelta child = children[i];
					IResource resource = child.getResource();
					if (resource instanceof IFolder) {
						String subpkgName = 
							name.length() == 0 ? 
								resource.getName() : 
								name + "." + resource.getName(); //$NON-NLS-1$
						Openable subpkg = (Openable)root.getPackageFragment(subpkgName);
						this.updateCurrentDeltaAndIndex(subpkg, child);
					}
				}

(startLine=617 endLine=628 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00104/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				for (int i = 0, length = children.length; i < length; i++) {
					IResourceDelta child = children[i];
					IResource resource = child.getResource();
					if (resource instanceof IFolder) {
						String subpkgName = 
							name.length() == 0 ? 
								resource.getName() : 
								name + "." + resource.getName(); //$NON-NLS-1$
						Openable subpkg = (Openable)root.getPackageFragment(subpkgName);
						this.updateCurrentDeltaAndIndex(subpkg, child);
					}
				}

commonMethod: 
(startLine=253 endLine=323 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00105/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
	/**
	 * Creates the openables corresponding to this resource.
	 * Returns null if none was found.
	 */
	protected Openable createElement(IResource resource, int elementType) {
		if (resource == null) return null;
		
		// find the element that encloses the resource
		IPath path = resource.getFullPath();
		this.popUntilPrefixOf(path);
		
		IJavaElement element = null;
		if (this.currentElement != null) {
			switch (elementType) {
				case IJavaElement.JAVA_PROJECT:
					element = JavaCore.create((IProject)resource);
					break;
				case IJavaElement.PACKAGE_FRAGMENT_ROOT:
					element = this.currentElement.getJavaProject().getPackageFragmentRoot(resource);
					break;
				case IJavaElement.PACKAGE_FRAGMENT:
					IPackageFragmentRoot root = this.currentElement.getPackageFragmentRoot();
					if (root != null && !Util.conflictsWithOutputLocation(path, (JavaProject)root.getJavaProject())) {
						IPath pkgPath = path.removeFirstSegments(root.getPath().segmentCount());
						String pkg = Util.packageName(pkgPath);
						if (pkg == null) return null;
						element = root.getPackageFragment(pkg);
					}
					break;
				case IJavaElement.COMPILATION_UNIT:
					IPackageFragment pkgFragment = null;
					switch (this.currentElement.getElementType()) {
						case IJavaElement.PACKAGE_FRAGMENT:
							pkgFragment = (IPackageFragment)this.currentElement;
							break;
						case IJavaElement.COMPILATION_UNIT:
						case IJavaElement.CLASS_FILE:
							pkgFragment = (IPackageFragment)this.currentElement.getParent();
							break;
					}
					if (pkgFragment != null) {
						String fileName = path.lastSegment();
						if (!Util.isValidCompilationUnitName(fileName)) return null;
						element = pkgFragment.getCompilationUnit(fileName);
					}
					break;
				case IJavaElement.CLASS_FILE:
					pkgFragment = null;
					switch (this.currentElement.getElementType()) {
						case IJavaElement.PACKAGE_FRAGMENT:
							pkgFragment = (IPackageFragment)this.currentElement;
							break;
						case IJavaElement.COMPILATION_UNIT:
						case IJavaElement.CLASS_FILE:
							pkgFragment = (IPackageFragment)this.currentElement.getParent();
							break;
					}
					if (pkgFragment != null) {
						String fileName = path.lastSegment();
						if (!Util.isValidClassFileName(fileName)) return null;
						element = pkgFragment.getClassFile(fileName);
					}
					break;
			}
		}
		if (element == null) {
			element = JavaCore.create(resource);
		}
		this.currentElement = (Openable)element;
		return this.currentElement;
	}


, Instance #
frags: 
(startLine=218 endLine=226 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00129/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java)
			} else {
				tokenizer = new StringTokenizer(subCommandLine, File.pathSeparator + " "); //$NON-NLS-1$
				while (tokenizer.hasMoreTokens()) {
					if (count == argv.length) {
						System.arraycopy(argv, 0, (argv = new String[count * 2]), 0, count);
					}
					argv[count++] = tokenizer.nextToken();
				}
			}

(startLine=247 endLine=255 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00129/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java)
			} else {
				tokenizer = new StringTokenizer(commandLine.substring(startIndex, commandLine.length()), File.pathSeparator + " "); //$NON-NLS-1$
				while (tokenizer.hasMoreTokens()) {
					if (count == argv.length) {
						System.arraycopy(argv, 0, (argv = new String[count * 2]), 0, count);
					}
					argv[count++] = tokenizer.nextToken();
				}
			}

commonMethod: 
(startLine=198 endLine=245 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00130/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java)
public static String[] tokenize(String commandLine){
	int count = 0;
	String[] arguments = new String[10];
	StringTokenizer tokenizer = new StringTokenizer(commandLine, " \"", true); //$NON-NLS-1$
	String token = "",lastToken;
	boolean insideQuotes = false;
	boolean startNewToken = true;
	
	// take care to quotes on the command line
	// 'xxx "aaa bbb";ccc yyy' --->  {"xxx", "aaa bbb;ccc", "yyy" }
	// 'xxx "aaa bbb;ccc" yyy' --->  {"xxx", "aaa bbb;ccc", "yyy" }
	// 'xxx "aaa bbb";"ccc" yyy' --->  {"xxx", "aaa bbb;ccc", "yyy" }
	// 'xxx/"aaa bbb";"ccc" yyy' --->  {"xxx/aaa bbb;ccc", "yyy" }
	while (tokenizer.hasMoreTokens()){
		lastToken = token;
		token = tokenizer.nextToken();

		if (token.equals(" ")){//$NON-NLS-1$
			if (insideQuotes){ 
				arguments[count-1] += token; 	
				startNewToken = false;	
			} else {
				startNewToken = true;
			}
		} else if (token.equals("\"")){//$NON-NLS-1$
			if (!insideQuotes && startNewToken){//$NON-NLS-1$
				if (count == arguments.length) System.arraycopy(arguments, 0, (arguments = new String[count * 2]), 0, count);
				arguments[count++] = "";//$NON-NLS-1$
			}
			insideQuotes = !insideQuotes;
			startNewToken = false;	
		} else {
			if (insideQuotes){
				arguments[count-1] += token; 			
			} else {
				if (token.length() > 0 && !startNewToken){
					arguments[count-1] += token;
				} else {
					if (count == arguments.length) System.arraycopy(arguments, 0, (arguments = new String[count * 2]), 0, count);
					arguments[count++] = token;
				}
			}
			startNewToken = false;	
		}
	}
	System.arraycopy(arguments, 0, arguments = new String[count], 0, count);
	return arguments;	
}	


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=2343 endLine=2354 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iconst_1() {
	countLabels = 0;
	stackDepth++;
	if (stackDepth > stackMax)
		stackMax = stackDepth;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iconst_1;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iconst_1);
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=1496 endLine=1597 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * @param implicitConversionCode int
 */
public void generateImplicitConversion(int implicitConversionCode) {
	switch (implicitConversionCode) {
		case Float2Char :
			this.f2i();
			this.i2c();
			break;
		case Double2Char :
			this.d2i();
			this.i2c();
			break;
		case Int2Char :
		case Short2Char :
		case Byte2Char :
			this.i2c();
			break;
		case Long2Char :
			this.l2i();
			this.i2c();
			break;
		case Char2Float :
		case Short2Float :
		case Int2Float :
		case Byte2Float :
			this.i2f();
			break;
		case Double2Float :
			this.d2f();
			break;
		case Long2Float :
			this.l2f();
			break;
		case Float2Byte :
			this.f2i();
			this.i2b();
			break;
		case Double2Byte :
			this.d2i();
			this.i2b();
			break;
		case Int2Byte :
		case Short2Byte :
		case Char2Byte :
			this.i2b();
			break;
		case Long2Byte :
			this.l2i();
			this.i2b();
			break;
		case Byte2Double :
		case Char2Double :
		case Short2Double :
		case Int2Double :
			this.i2d();
			break;
		case Float2Double :
			this.f2d();
			break;
		case Long2Double :
			this.l2d();
			break;
		case Byte2Short :
		case Char2Short :
		case Int2Short :
			this.i2s();
			break;
		case Double2Short :
			this.d2i();
			this.i2s();
			break;
		case Long2Short :
			this.l2i();
			this.i2s();
			break;
		case Float2Short :
			this.f2i();
			this.i2s();
			break;
		case Double2Int :
			this.d2i();
			break;
		case Float2Int :
			this.f2i();
			break;
		case Long2Int :
			this.l2i();
			break;
		case Int2Long :
		case Char2Long :
		case Byte2Long :
		case Short2Long :
			this.i2l();
			break;
		case Double2Long :
			this.d2l();
			break;
		case Float2Long :
			this.f2l();
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=686 endLine=795 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for >
	 */
	public void generateOptimizedGreaterThan(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 > x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.iflt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifge(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x > 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifgt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifle(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpgt(trueLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.ifgt(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifgt(trueLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.ifgt(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmple(falseLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.ifle(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifle(falseLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.ifle(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=908 endLine=1017 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for <
	 */
	public void generateOptimizedLessThan(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 < x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifgt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifle(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x < 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.iflt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifge(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmplt(trueLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.iflt(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.iflt(trueLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.iflt(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpge(falseLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifge(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifge(falseLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifge(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=3335 endLine=3345 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ireturn() {
	countLabels = 0;
	stackDepth--;
	// the stackDepth should be equal to 0 
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ireturn;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ireturn);
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=2331 endLine=2342 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iconst_0() {
	countLabels = 0;
	stackDepth++;
	if (stackDepth > stackMax)
		stackMax = stackDepth;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iconst_0;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iconst_0);
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=1392 endLine=1502 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for ^
	 */
	public void generateOptimizedLogicalXor(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {
			
		int pc = codeStream.position;
		Constant condConst;
		if ((left.implicitConversion & 0xF) == T_boolean) {
			if ((condConst = left.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// <something equivalent to true> ^ x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						falseLabel,
						trueLabel,
						valueRequired);
				} else {
					// <something equivalent to false> ^ x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if ((bits & OnlyValueRequiredMASK) != 0) {
						right.generateCode(currentScope, codeStream, valueRequired);
					} else {
						right.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			if ((condConst = right.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// x ^ <something equivalent to true>
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						falseLabel,
						trueLabel,
						valueRequired);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				} else {
					// x ^ <something equivalent to false>
					if ((bits & OnlyValueRequiredMASK) != 0) {
						left.generateCode(currentScope, codeStream, valueRequired);
					} else {
						left.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default case
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			codeStream.ixor();
			if ((bits & OnlyValueRequiredMASK) == 0) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifne(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifeq(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=1130 endLine=1260 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for &
	 */
	public void generateOptimizedLogicalAnd(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {
			
		int pc = codeStream.position;
		Constant condConst;
		if ((left.implicitConversion & 0xF) == T_boolean) {
			if ((condConst = left.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// <something equivalent to true> & x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if ((bits & OnlyValueRequiredMASK) != 0) {
						right.generateCode(currentScope, codeStream, valueRequired);
					} else {
						right.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
				} else {
					// <something equivalent to false> & x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_0();
						} else {
							if (falseLabel != null) {
								// implicit falling through the TRUE case
								codeStream.goto_(falseLabel);
							}
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			if ((condConst = right.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// x & <something equivalent to true>
					if ((bits & OnlyValueRequiredMASK) != 0) {
						left.generateCode(currentScope, codeStream, valueRequired);
					} else {
						left.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				} else {
					// x & <something equivalent to false>
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_0();
						} else {
							if (falseLabel != null) {
								// implicit falling through the TRUE case
								codeStream.goto_(falseLabel);
							}
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default case
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			codeStream.iand();
			if ((bits & OnlyValueRequiredMASK) == 0) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifne(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifeq(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=797 endLine=906 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for >=
	 */
	public void generateOptimizedGreaterThanOrEqual(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 >= x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifle(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifgt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x >= 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifge(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.iflt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpge(trueLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.ifge(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifge(trueLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.ifge(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmplt(falseLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.iflt(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.iflt(falseLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.iflt(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=1019 endLine=1128 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for <=
	 */
	public void generateOptimizedLessThanOrEqual(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 <= x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifge(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.iflt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x <= 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifle(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifgt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmple(trueLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifle(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifle(trueLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifle(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpgt(falseLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifgt(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifgt(falseLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifgt(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=1262 endLine=1390 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for |
	 */
	public void generateOptimizedLogicalOr(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {
			
		int pc = codeStream.position;
		Constant condConst;
		if ((left.implicitConversion & 0xF) == T_boolean) {
			if ((condConst = left.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// <something equivalent to true> | x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_1();
						} else {
							if (trueLabel != null) {
								codeStream.goto_(trueLabel);
							}
						}
					}
				} else {
					// <something equivalent to false> | x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if ((bits & OnlyValueRequiredMASK) != 0) {
						right.generateCode(currentScope, codeStream, valueRequired);
					} else {
						right.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			if ((condConst = right.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// x | <something equivalent to true>
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_1();
						} else {
							if (trueLabel != null) {
								codeStream.goto_(trueLabel);
							}
						}
					}
				} else {
					// x | <something equivalent to false>
					if ((bits & OnlyValueRequiredMASK) != 0) {
						left.generateCode(currentScope, codeStream, valueRequired);
					} else {
						left.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default case
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			codeStream.ior();
			if ((bits & OnlyValueRequiredMASK) == 0) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifne(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifeq(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=2137 endLine=2180 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * We didn't call it goto, because there is a conflit with the goto keyword
 */
final public void goto_(Label lbl) {
	if (this.wideMode) {
		this.goto_w(lbl);
		return;
	}
	try {
		lbl.inlineForwardReferencesFromLabelsTargeting(position);
		/*
		 Possible optimization for code such as:
		 public Object foo() {
			boolean b = true;
			if (b) {
				if (b)
					return null;
			} else {
				if (b) {
					return null;
				}
			}
			return null;
		}
		The goto around the else block for the first if will
		be unreachable, because the thenClause of the second if
		returns.
		See inlineForwardReferencesFromLabelsTargeting defined
		on the Label class for the remaining part of this
		optimization.
		 if (!lbl.isBranchTarget(position)) {
			switch(bCodeStream[classFileOffset-1]) {
				case OPC_return :
				case OPC_areturn:
					return;
			}
		}*/
		position++;
		bCodeStream[classFileOffset++] = OPC_goto;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_goto);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=2343 endLine=2354 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iconst_1() {
	countLabels = 0;
	stackDepth++;
	if (stackDepth > stackMax)
		stackMax = stackDepth;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iconst_1;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iconst_1);
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=1496 endLine=1597 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * @param implicitConversionCode int
 */
public void generateImplicitConversion(int implicitConversionCode) {
	switch (implicitConversionCode) {
		case Float2Char :
			this.f2i();
			this.i2c();
			break;
		case Double2Char :
			this.d2i();
			this.i2c();
			break;
		case Int2Char :
		case Short2Char :
		case Byte2Char :
			this.i2c();
			break;
		case Long2Char :
			this.l2i();
			this.i2c();
			break;
		case Char2Float :
		case Short2Float :
		case Int2Float :
		case Byte2Float :
			this.i2f();
			break;
		case Double2Float :
			this.d2f();
			break;
		case Long2Float :
			this.l2f();
			break;
		case Float2Byte :
			this.f2i();
			this.i2b();
			break;
		case Double2Byte :
			this.d2i();
			this.i2b();
			break;
		case Int2Byte :
		case Short2Byte :
		case Char2Byte :
			this.i2b();
			break;
		case Long2Byte :
			this.l2i();
			this.i2b();
			break;
		case Byte2Double :
		case Char2Double :
		case Short2Double :
		case Int2Double :
			this.i2d();
			break;
		case Float2Double :
			this.f2d();
			break;
		case Long2Double :
			this.l2d();
			break;
		case Byte2Short :
		case Char2Short :
		case Int2Short :
			this.i2s();
			break;
		case Double2Short :
			this.d2i();
			this.i2s();
			break;
		case Long2Short :
			this.l2i();
			this.i2s();
			break;
		case Float2Short :
			this.f2i();
			this.i2s();
			break;
		case Double2Int :
			this.d2i();
			break;
		case Float2Int :
			this.f2i();
			break;
		case Long2Int :
			this.l2i();
			break;
		case Int2Long :
		case Char2Long :
		case Byte2Long :
		case Short2Long :
			this.i2l();
			break;
		case Double2Long :
			this.d2l();
			break;
		case Float2Long :
			this.f2l();
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=686 endLine=795 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for >
	 */
	public void generateOptimizedGreaterThan(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 > x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.iflt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifge(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x > 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifgt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifle(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpgt(trueLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.ifgt(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifgt(trueLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.ifgt(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmple(falseLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.ifle(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifle(falseLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.ifle(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=908 endLine=1017 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for <
	 */
	public void generateOptimizedLessThan(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 < x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifgt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifle(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x < 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.iflt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifge(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmplt(trueLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.iflt(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.iflt(trueLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.iflt(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpge(falseLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifge(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifge(falseLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifge(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=735 endLine=759 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmplt(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.iflt(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.iflt(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.iflt(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

(startLine=713 endLine=735 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpge(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifge(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifge(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifge(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

commonMethod: 
(startLine=2500 endLine=2514 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void if_icmple(Label lbl) {
	countLabels = 0;
	stackDepth -= 2;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_if_icmple, lbl);
	} else {	
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_if_icmple;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_if_icmple);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=3335 endLine=3345 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ireturn() {
	countLabels = 0;
	stackDepth--;
	// the stackDepth should be equal to 0 
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_ireturn;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_ireturn);
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=2331 endLine=2342 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iconst_0() {
	countLabels = 0;
	stackDepth++;
	if (stackDepth > stackMax)
		stackMax = stackDepth;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iconst_0;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iconst_0);
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=1392 endLine=1502 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for ^
	 */
	public void generateOptimizedLogicalXor(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {
			
		int pc = codeStream.position;
		Constant condConst;
		if ((left.implicitConversion & 0xF) == T_boolean) {
			if ((condConst = left.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// <something equivalent to true> ^ x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						falseLabel,
						trueLabel,
						valueRequired);
				} else {
					// <something equivalent to false> ^ x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if ((bits & OnlyValueRequiredMASK) != 0) {
						right.generateCode(currentScope, codeStream, valueRequired);
					} else {
						right.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			if ((condConst = right.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// x ^ <something equivalent to true>
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						falseLabel,
						trueLabel,
						valueRequired);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				} else {
					// x ^ <something equivalent to false>
					if ((bits & OnlyValueRequiredMASK) != 0) {
						left.generateCode(currentScope, codeStream, valueRequired);
					} else {
						left.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default case
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			codeStream.ixor();
			if ((bits & OnlyValueRequiredMASK) == 0) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifne(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifeq(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}


, Instance #
frags: 
(startLine=947 endLine=971 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(falseLabel);
						break;
					case T_float :
						codeStream.fcmpg();
						codeStream.ifgt(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(falseLabel);
						break;
					case T_double :
						codeStream.dcmpg();
						codeStream.ifgt(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

(startLine=925 endLine=947 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(trueLabel);
						break;
					case T_float :
						codeStream.fcmpg();
						codeStream.ifle(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(trueLabel);
						break;
					case T_double :
						codeStream.dcmpg();
						codeStream.ifle(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

commonMethod: 
(startLine=2515 endLine=2529 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void if_icmplt(Label lbl) {
	countLabels = 0;
	stackDepth -= 2;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_if_icmplt, lbl);
	} else {
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_if_icmplt;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_if_icmplt);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=1130 endLine=1260 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for &
	 */
	public void generateOptimizedLogicalAnd(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {
			
		int pc = codeStream.position;
		Constant condConst;
		if ((left.implicitConversion & 0xF) == T_boolean) {
			if ((condConst = left.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// <something equivalent to true> & x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if ((bits & OnlyValueRequiredMASK) != 0) {
						right.generateCode(currentScope, codeStream, valueRequired);
					} else {
						right.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
				} else {
					// <something equivalent to false> & x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_0();
						} else {
							if (falseLabel != null) {
								// implicit falling through the TRUE case
								codeStream.goto_(falseLabel);
							}
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			if ((condConst = right.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// x & <something equivalent to true>
					if ((bits & OnlyValueRequiredMASK) != 0) {
						left.generateCode(currentScope, codeStream, valueRequired);
					} else {
						left.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				} else {
					// x & <something equivalent to false>
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_0();
						} else {
							if (falseLabel != null) {
								// implicit falling through the TRUE case
								codeStream.goto_(falseLabel);
							}
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default case
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			codeStream.iand();
			if ((bits & OnlyValueRequiredMASK) == 0) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifne(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifeq(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=797 endLine=906 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for >=
	 */
	public void generateOptimizedGreaterThanOrEqual(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 >= x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifle(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifgt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x >= 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifge(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.iflt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpge(trueLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.ifge(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifge(trueLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.ifge(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmplt(falseLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.iflt(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.iflt(falseLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.iflt(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=947 endLine=971 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(falseLabel);
						break;
					case T_float :
						codeStream.fcmpg();
						codeStream.ifgt(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(falseLabel);
						break;
					case T_double :
						codeStream.dcmpg();
						codeStream.ifgt(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

(startLine=925 endLine=947 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(trueLabel);
						break;
					case T_float :
						codeStream.fcmpg();
						codeStream.ifle(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(trueLabel);
						break;
					case T_double :
						codeStream.dcmpg();
						codeStream.ifle(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

commonMethod: 
(startLine=2470 endLine=2484 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void if_icmpge(Label lbl) {
	countLabels = 0;
	stackDepth -= 2;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_if_icmpge, lbl);
	} else {	
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_if_icmpge;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_if_icmpge);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=1019 endLine=1128 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for <=
	 */
	public void generateOptimizedLessThanOrEqual(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 <= x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifge(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.iflt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x <= 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifle(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifgt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmple(trueLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifle(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifle(trueLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifle(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpgt(falseLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifgt(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifgt(falseLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifgt(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=1262 endLine=1390 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for |
	 */
	public void generateOptimizedLogicalOr(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {
			
		int pc = codeStream.position;
		Constant condConst;
		if ((left.implicitConversion & 0xF) == T_boolean) {
			if ((condConst = left.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// <something equivalent to true> | x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_1();
						} else {
							if (trueLabel != null) {
								codeStream.goto_(trueLabel);
							}
						}
					}
				} else {
					// <something equivalent to false> | x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if ((bits & OnlyValueRequiredMASK) != 0) {
						right.generateCode(currentScope, codeStream, valueRequired);
					} else {
						right.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			if ((condConst = right.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// x | <something equivalent to true>
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_1();
						} else {
							if (trueLabel != null) {
								codeStream.goto_(trueLabel);
							}
						}
					}
				} else {
					// x | <something equivalent to false>
					if ((bits & OnlyValueRequiredMASK) != 0) {
						left.generateCode(currentScope, codeStream, valueRequired);
					} else {
						left.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default case
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			codeStream.ior();
			if ((bits & OnlyValueRequiredMASK) == 0) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifne(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifeq(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}


, Instance #
frags: 
(startLine=735 endLine=759 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmplt(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.iflt(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.iflt(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.iflt(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

(startLine=713 endLine=735 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpge(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifge(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifge(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifge(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

commonMethod: 
(startLine=2485 endLine=2499 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void if_icmpgt(Label lbl) {
	countLabels = 0;
	stackDepth -= 2;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_if_icmpgt, lbl);
	} else {	
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_if_icmpgt;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_if_icmpgt);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=607 endLine=629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (falseLabel == null){
			if (trueLabel != null){
				// implicit falling through the FALSE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmpgt(trueLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifgt(trueLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifgt(trueLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifgt(trueLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		} else {

(startLine=629 endLine=653 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		} else {
			if (trueLabel == null){
				// implicit falling through the TRUE case
				switch(promotedTypeID){
					case T_int :
						codeStream.if_icmple(falseLabel);
						break;
					case T_float :
						codeStream.fcmpl();
						codeStream.ifle(falseLabel);
						break;
					case T_long :
						codeStream.lcmp();
						codeStream.ifle(falseLabel);
						break;
					case T_double :
						codeStream.dcmpl();
						codeStream.ifle(falseLabel);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=2137 endLine=2180 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * We didn't call it goto, because there is a conflit with the goto keyword
 */
final public void goto_(Label lbl) {
	if (this.wideMode) {
		this.goto_w(lbl);
		return;
	}
	try {
		lbl.inlineForwardReferencesFromLabelsTargeting(position);
		/*
		 Possible optimization for code such as:
		 public Object foo() {
			boolean b = true;
			if (b) {
				if (b)
					return null;
			} else {
				if (b) {
					return null;
				}
			}
			return null;
		}
		The goto around the else block for the first if will
		be unreachable, because the thenClause of the second if
		returns.
		See inlineForwardReferencesFromLabelsTargeting defined
		on the Label class for the remaining part of this
		optimization.
		 if (!lbl.isBranchTarget(position)) {
			switch(bCodeStream[classFileOffset-1]) {
				case OPC_return :
				case OPC_areturn:
					return;
			}
		}*/
		position++;
		bCodeStream[classFileOffset++] = OPC_goto;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_goto);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=990 endLine=1004 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// <something equivalent to false> & x
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

(startLine=1017 endLine=1031 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// x & <something equivalent to false>
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

commonMethod: 
(startLine=604 endLine=613 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void dcmpg() {
	countLabels = 0;
	stackDepth -= 3;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_dcmpg;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_dcmpg);
	}
}


, Instance #
frags: 
(startLine=990 endLine=1004 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// <something equivalent to false> & x
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

(startLine=1017 endLine=1031 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// x & <something equivalent to false>
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

commonMethod: 
(startLine=2560 endLine=2574 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ifge(Label lbl) {
	countLabels = 0;
	stackDepth--;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_ifge, lbl);
	} else {
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_ifge;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_ifge);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=1067 endLine=1080 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if (condConst.booleanValue() == true) {
				// <something equivalent to true> | x
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_1();
					} else {
						if (trueLabel != null) {
							codeStream.goto_(trueLabel);
						}
					}
				}
			} else {

(startLine=1093 endLine=1106 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if (condConst.booleanValue() == true) {
				// x | <something equivalent to true>
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_1();
					} else {
						if (trueLabel != null) {
							codeStream.goto_(trueLabel);
						}
					}
				}
			} else {

commonMethod: 
(startLine=2311 endLine=2320 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iand() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iand;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iand);
	}
}


, Instance #
frags: 
(startLine=990 endLine=1004 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// <something equivalent to false> & x
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

(startLine=1017 endLine=1031 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// x & <something equivalent to false>
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

commonMethod: 
(startLine=2590 endLine=2604 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ifle(Label lbl) {
	countLabels = 0;
	stackDepth--;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_ifle, lbl);
	} else {
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_ifle;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_ifle);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=990 endLine=1004 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// <something equivalent to false> & x
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

(startLine=1017 endLine=1031 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// x & <something equivalent to false>
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

commonMethod: 
(startLine=3593 endLine=3602 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void lcmp() {
	countLabels = 0;
	stackDepth -= 3;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_lcmp;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_lcmp);
	}
}


, Instance #
frags: 
(startLine=990 endLine=1004 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// <something equivalent to false> & x
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

(startLine=1017 endLine=1031 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// x & <something equivalent to false>
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

commonMethod: 
(startLine=2575 endLine=2589 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void ifgt(Label lbl) {
	countLabels = 0;
	stackDepth--;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_ifgt, lbl);
	} else {
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_ifgt;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_ifgt);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=990 endLine=1004 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// <something equivalent to false> & x
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

(startLine=1017 endLine=1031 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// x & <something equivalent to false>
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

commonMethod: 
(startLine=2500 endLine=2514 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void if_icmple(Label lbl) {
	countLabels = 0;
	stackDepth -= 2;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_if_icmple, lbl);
	} else {	
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_if_icmple;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_if_icmple);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=990 endLine=1004 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// <something equivalent to false> & x
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

(startLine=1017 endLine=1031 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// x & <something equivalent to false>
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

commonMethod: 
(startLine=2485 endLine=2499 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void if_icmpgt(Label lbl) {
	countLabels = 0;
	stackDepth -= 2;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_if_icmpgt, lbl);
	} else {	
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_if_icmpgt;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_if_icmpgt);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=990 endLine=1004 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// <something equivalent to false> & x
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

(startLine=1017 endLine=1031 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// x & <something equivalent to false>
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

commonMethod: 
(startLine=2605 endLine=2619 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iflt(Label lbl) {
	countLabels = 0;
	stackDepth--;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_iflt, lbl);
	} else {
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_iflt;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_iflt);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=1067 endLine=1080 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if (condConst.booleanValue() == true) {
				// <something equivalent to true> | x
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_1();
					} else {
						if (trueLabel != null) {
							codeStream.goto_(trueLabel);
						}
					}
				}
			} else {

(startLine=1093 endLine=1106 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			if (condConst.booleanValue() == true) {
				// x | <something equivalent to true>
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_1();
					} else {
						if (trueLabel != null) {
							codeStream.goto_(trueLabel);
						}
					}
				}
			} else {

commonMethod: 
(startLine=2331 endLine=2342 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iconst_0() {
	countLabels = 0;
	stackDepth++;
	if (stackDepth > stackMax)
		stackMax = stackDepth;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iconst_0;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iconst_0);
	}
}


, Instance #
frags: 
(startLine=990 endLine=1004 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// <something equivalent to false> & x
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

(startLine=1017 endLine=1031 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			} else {
				// x & <something equivalent to false>
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				right.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
			}

commonMethod: 
(startLine=1047 endLine=1056 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void fcmpg() {
	countLabels = 0;
	stackDepth--;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_fcmpg;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_fcmpg);
	}
}


, Instance #
frags: 
(startLine=560 endLine=579 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.iflt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifge(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=582 endLine=601 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifgt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifle(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=2343 endLine=2354 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iconst_1() {
	countLabels = 0;
	stackDepth++;
	if (stackDepth > stackMax)
		stackMax = stackDepth;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iconst_1;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iconst_1);
	}
}


, Instance #
frags: 
(startLine=560 endLine=579 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.iflt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifge(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=582 endLine=601 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifgt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifle(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=1496 endLine=1597 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * @param implicitConversionCode int
 */
public void generateImplicitConversion(int implicitConversionCode) {
	switch (implicitConversionCode) {
		case Float2Char :
			this.f2i();
			this.i2c();
			break;
		case Double2Char :
			this.d2i();
			this.i2c();
			break;
		case Int2Char :
		case Short2Char :
		case Byte2Char :
			this.i2c();
			break;
		case Long2Char :
			this.l2i();
			this.i2c();
			break;
		case Char2Float :
		case Short2Float :
		case Int2Float :
		case Byte2Float :
			this.i2f();
			break;
		case Double2Float :
			this.d2f();
			break;
		case Long2Float :
			this.l2f();
			break;
		case Float2Byte :
			this.f2i();
			this.i2b();
			break;
		case Double2Byte :
			this.d2i();
			this.i2b();
			break;
		case Int2Byte :
		case Short2Byte :
		case Char2Byte :
			this.i2b();
			break;
		case Long2Byte :
			this.l2i();
			this.i2b();
			break;
		case Byte2Double :
		case Char2Double :
		case Short2Double :
		case Int2Double :
			this.i2d();
			break;
		case Float2Double :
			this.f2d();
			break;
		case Long2Double :
			this.l2d();
			break;
		case Byte2Short :
		case Char2Short :
		case Int2Short :
			this.i2s();
			break;
		case Double2Short :
			this.d2i();
			this.i2s();
			break;
		case Long2Short :
			this.l2i();
			this.i2s();
			break;
		case Float2Short :
			this.f2i();
			this.i2s();
			break;
		case Double2Int :
			this.d2i();
			break;
		case Float2Int :
			this.f2i();
			break;
		case Long2Int :
			this.l2i();
			break;
		case Int2Long :
		case Char2Long :
		case Byte2Long :
		case Short2Long :
			this.i2l();
			break;
		case Double2Long :
			this.d2l();
			break;
		case Float2Long :
			this.f2l();
	}
}


, Instance #
frags: 
(startLine=560 endLine=579 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.iflt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifge(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=582 endLine=601 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifgt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifle(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=686 endLine=795 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for >
	 */
	public void generateOptimizedGreaterThan(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 > x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.iflt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifge(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x > 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifgt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifle(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpgt(trueLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.ifgt(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifgt(trueLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.ifgt(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmple(falseLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.ifle(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifle(falseLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.ifle(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=560 endLine=579 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.iflt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifge(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=582 endLine=601 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifgt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifle(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=908 endLine=1017 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for <
	 */
	public void generateOptimizedLessThan(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 < x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifgt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifle(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x < 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.iflt(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifge(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmplt(trueLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.iflt(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.iflt(trueLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.iflt(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpge(falseLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifge(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifge(falseLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifge(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=666 endLine=685 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifle(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifgt(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=688 endLine=707 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifge(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.iflt(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=2500 endLine=2514 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void if_icmple(Label lbl) {
	countLabels = 0;
	stackDepth -= 2;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_if_icmple, lbl);
	} else {	
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_if_icmple;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_if_icmple);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=560 endLine=579 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.iflt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifge(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=582 endLine=601 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifgt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifle(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=2331 endLine=2342 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void iconst_0() {
	countLabels = 0;
	stackDepth++;
	if (stackDepth > stackMax)
		stackMax = stackDepth;
	try {
		position++;
		bCodeStream[classFileOffset++] = OPC_iconst_0;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_iconst_0);
	}
}


, Instance #
frags: 
(startLine=560 endLine=579 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.iflt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifge(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=582 endLine=601 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifgt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifle(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=1392 endLine=1502 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for ^
	 */
	public void generateOptimizedLogicalXor(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {
			
		int pc = codeStream.position;
		Constant condConst;
		if ((left.implicitConversion & 0xF) == T_boolean) {
			if ((condConst = left.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// <something equivalent to true> ^ x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						falseLabel,
						trueLabel,
						valueRequired);
				} else {
					// <something equivalent to false> ^ x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if ((bits & OnlyValueRequiredMASK) != 0) {
						right.generateCode(currentScope, codeStream, valueRequired);
					} else {
						right.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			if ((condConst = right.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// x ^ <something equivalent to true>
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						falseLabel,
						trueLabel,
						valueRequired);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				} else {
					// x ^ <something equivalent to false>
					if ((bits & OnlyValueRequiredMASK) != 0) {
						left.generateCode(currentScope, codeStream, valueRequired);
					} else {
						left.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default case
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			codeStream.ixor();
			if ((bits & OnlyValueRequiredMASK) == 0) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifne(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifeq(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}


, Instance #
frags: 
(startLine=878 endLine=897 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifge(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.iflt(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=900 endLine=919 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifle(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifgt(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=2515 endLine=2529 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void if_icmplt(Label lbl) {
	countLabels = 0;
	stackDepth -= 2;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_if_icmplt, lbl);
	} else {
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_if_icmplt;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_if_icmplt);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=560 endLine=579 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.iflt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifge(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=582 endLine=601 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifgt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifle(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=1130 endLine=1260 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for &
	 */
	public void generateOptimizedLogicalAnd(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {
			
		int pc = codeStream.position;
		Constant condConst;
		if ((left.implicitConversion & 0xF) == T_boolean) {
			if ((condConst = left.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// <something equivalent to true> & x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if ((bits & OnlyValueRequiredMASK) != 0) {
						right.generateCode(currentScope, codeStream, valueRequired);
					} else {
						right.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
				} else {
					// <something equivalent to false> & x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_0();
						} else {
							if (falseLabel != null) {
								// implicit falling through the TRUE case
								codeStream.goto_(falseLabel);
							}
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			if ((condConst = right.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// x & <something equivalent to true>
					if ((bits & OnlyValueRequiredMASK) != 0) {
						left.generateCode(currentScope, codeStream, valueRequired);
					} else {
						left.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				} else {
					// x & <something equivalent to false>
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_0();
						} else {
							if (falseLabel != null) {
								// implicit falling through the TRUE case
								codeStream.goto_(falseLabel);
							}
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default case
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			codeStream.iand();
			if ((bits & OnlyValueRequiredMASK) == 0) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifne(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifeq(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}


, Instance #
frags: 
(startLine=560 endLine=579 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.iflt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifge(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=582 endLine=601 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifgt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifle(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=797 endLine=906 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for >=
	 */
	public void generateOptimizedGreaterThanOrEqual(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 >= x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifle(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifgt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x >= 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifge(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.iflt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpge(trueLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.ifge(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifge(trueLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.ifge(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmplt(falseLabel);
							break;
						case T_float :
							codeStream.fcmpl();
							codeStream.iflt(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.iflt(falseLabel);
							break;
						case T_double :
							codeStream.dcmpl();
							codeStream.iflt(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=878 endLine=897 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifge(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.iflt(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=900 endLine=919 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifle(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifgt(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=2470 endLine=2484 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void if_icmpge(Label lbl) {
	countLabels = 0;
	stackDepth -= 2;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_if_icmpge, lbl);
	} else {	
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_if_icmpge;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_if_icmpge);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=560 endLine=579 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.iflt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifge(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=582 endLine=601 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifgt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifle(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=1019 endLine=1128 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for <=
	 */
	public void generateOptimizedLessThanOrEqual(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {

		int pc = codeStream.position;
		int promotedTypeID = left.implicitConversion >> 4;
		// both sides got promoted in the same way
		if (promotedTypeID == T_int) {
			// 0 <= x
			if ((left.constant != NotAConstant) && (left.constant.intValue() == 0)) {
				right.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifge(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.iflt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			// x <= 0
			if ((right.constant != NotAConstant) && (right.constant.intValue() == 0)) {
				left.generateCode(currentScope, codeStream, valueRequired);
				if (valueRequired) {
					if (falseLabel == null) {
						if (trueLabel != null) {
							// implicitly falling through the FALSE case
							codeStream.ifle(trueLabel);
						}
					} else {
						if (trueLabel == null) {
							// implicitly falling through the TRUE case
							codeStream.ifgt(falseLabel);
						} else {
							// no implicit fall through TRUE/FALSE --> should never occur
						}
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default comparison
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			if (falseLabel == null) {
				if (trueLabel != null) {
					// implicit falling through the FALSE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmple(trueLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifle(trueLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifle(trueLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifle(trueLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				}
			} else {
				if (trueLabel == null) {
					// implicit falling through the TRUE case
					switch (promotedTypeID) {
						case T_int :
							codeStream.if_icmpgt(falseLabel);
							break;
						case T_float :
							codeStream.fcmpg();
							codeStream.ifgt(falseLabel);
							break;
						case T_long :
							codeStream.lcmp();
							codeStream.ifgt(falseLabel);
							break;
						case T_double :
							codeStream.dcmpg();
							codeStream.ifgt(falseLabel);
					}
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					// no implicit fall through TRUE/FALSE --> should never occur
				}
			}
		}
	}


, Instance #
frags: 
(startLine=560 endLine=579 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.iflt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifge(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=582 endLine=601 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifgt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifle(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=1262 endLine=1390 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
	/**
	 * Boolean generation for |
	 */
	public void generateOptimizedLogicalOr(
		BlockScope currentScope,
		CodeStream codeStream,
		Label trueLabel,
		Label falseLabel,
		boolean valueRequired) {
			
		int pc = codeStream.position;
		Constant condConst;
		if ((left.implicitConversion & 0xF) == T_boolean) {
			if ((condConst = left.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// <something equivalent to true> | x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_1();
						} else {
							if (trueLabel != null) {
								codeStream.goto_(trueLabel);
							}
						}
					}
				} else {
					// <something equivalent to false> | x
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if ((bits & OnlyValueRequiredMASK) != 0) {
						right.generateCode(currentScope, codeStream, valueRequired);
					} else {
						right.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
			if ((condConst = right.conditionalConstant()) != NotAConstant) {
				if (condConst.booleanValue() == true) {
					// x | <something equivalent to true>
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
					if (valueRequired) {
						if ((bits & OnlyValueRequiredMASK) != 0) {
							codeStream.iconst_1();
						} else {
							if (trueLabel != null) {
								codeStream.goto_(trueLabel);
							}
						}
					}
				} else {
					// x | <something equivalent to false>
					if ((bits & OnlyValueRequiredMASK) != 0) {
						left.generateCode(currentScope, codeStream, valueRequired);
					} else {
						left.generateOptimizedBoolean(
							currentScope,
							codeStream,
							trueLabel,
							falseLabel,
							valueRequired);
					}
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						false);
				}
				codeStream.recordPositionsFrom(pc, this.sourceStart);
				return;
			}
		}
		// default case
		left.generateCode(currentScope, codeStream, valueRequired);
		right.generateCode(currentScope, codeStream, valueRequired);
		if (valueRequired) {
			codeStream.ior();
			if ((bits & OnlyValueRequiredMASK) == 0) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifne(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifeq(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}


, Instance #
frags: 
(startLine=666 endLine=685 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifle(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifgt(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=688 endLine=707 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifge(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.iflt(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=2485 endLine=2499 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
final public void if_icmpgt(Label lbl) {
	countLabels = 0;
	stackDepth -= 2;
	if (this.wideMode) {
		generateWideConditionalBranch(OPC_if_icmpgt, lbl);
	} else {	
		try {
			position++;
			bCodeStream[classFileOffset++] = OPC_if_icmpgt;
		} catch (IndexOutOfBoundsException e) {
			resizeByteArray(OPC_if_icmpgt);
		}
		lbl.branch();
	}
}


, Instance #
frags: 
(startLine=560 endLine=579 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (left.constant.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.iflt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifge(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=582 endLine=601 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
			&& (right.constant.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired){
				if (falseLabel == null){
					if (trueLabel != null){
						// implicitly falling through the FALSE case
						codeStream.ifgt(trueLabel);
					}
				} else {
					if (trueLabel == null){
						// implicitly falling through the TRUE case
						codeStream.ifle(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}			

commonMethod: 
(startLine=2137 endLine=2180 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * We didn't call it goto, because there is a conflit with the goto keyword
 */
final public void goto_(Label lbl) {
	if (this.wideMode) {
		this.goto_w(lbl);
		return;
	}
	try {
		lbl.inlineForwardReferencesFromLabelsTargeting(position);
		/*
		 Possible optimization for code such as:
		 public Object foo() {
			boolean b = true;
			if (b) {
				if (b)
					return null;
			} else {
				if (b) {
					return null;
				}
			}
			return null;
		}
		The goto around the else block for the first if will
		be unreachable, because the thenClause of the second if
		returns.
		See inlineForwardReferencesFromLabelsTargeting defined
		on the Label class for the remaining part of this
		optimization.
		 if (!lbl.isBranchTarget(position)) {
			switch(bCodeStream[classFileOffset-1]) {
				case OPC_return :
				case OPC_areturn:
					return;
			}
		}*/
		position++;
		bCodeStream[classFileOffset++] = OPC_goto;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_goto);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=138 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
		{	int result = (ResolveTypeTables[operator][(left<<4)+right]) & 0x0000F;
			if (result != T_undefined)

				//1/ First regular computation then 2/ comparaison
				//with a compile time constant (generated by the compiler)
				//	z0 = s >= s;
				//	if ( z0 != (((short) 5) >= ((short) 5)))
				//		System.out.println(155);

			{	s += "\t\t"+decode.type(result)+"0"+" = "+decode.type(left); //$NON-NLS-1$ //$NON-NLS-3$ //$NON-NLS-2$
				s += " "+decode.operator(operator)+" "+decode.type(right)+";\n"; //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-3$
				String begin = result == T_String ? "\t\tif (! " : "\t\tif ( "; //$NON-NLS-2$ //$NON-NLS-1$
				String test = result == T_String ? ".equals(" : " != (" ; //$NON-NLS-2$ //$NON-NLS-1$
				s += begin	+decode.type(result)+"0"+test //$NON-NLS-1$
							+decode.constant(left)+" " //$NON-NLS-1$
							+decode.operator(operator)+" " //$NON-NLS-1$
							+decode.constant(right)+"))\n"; //$NON-NLS-1$
				s += "\t\t\tSystem.out.println("+ (++error) +");\n"; //$NON-NLS-1$ //$NON-NLS-2$
								
				}}}

(startLine=147 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
			{	s += "\t\t"+decode.type(result)+"0"+" = "+decode.type(left); //$NON-NLS-1$ //$NON-NLS-3$ //$NON-NLS-2$
				s += " "+decode.operator(operator)+" "+decode.type(right)+";\n"; //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-3$
				String begin = result == T_String ? "\t\tif (! " : "\t\tif ( "; //$NON-NLS-2$ //$NON-NLS-1$
				String test = result == T_String ? ".equals(" : " != (" ; //$NON-NLS-2$ //$NON-NLS-1$
				s += begin	+decode.type(result)+"0"+test //$NON-NLS-1$
							+decode.constant(left)+" " //$NON-NLS-1$
							+decode.operator(operator)+" " //$NON-NLS-1$
							+decode.constant(right)+"))\n"; //$NON-NLS-1$
				s += "\t\t\tSystem.out.println("+ (++error) +");\n"; //$NON-NLS-1$ //$NON-NLS-2$
								
				}}}

commonMethod: 
(startLine=22 endLine=41 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
	public static final void classInitialize() {
		ResolveTypeTables[AND] = get_AND();
		ResolveTypeTables[AND_AND] = get_AND_AND();
		ResolveTypeTables[DIVIDE] = get_DIVIDE();
		ResolveTypeTables[EQUAL_EQUAL] = get_EQUAL_EQUAL();
		ResolveTypeTables[GREATER] = get_GREATER();
		ResolveTypeTables[GREATER_EQUAL] = get_GREATER_EQUAL();
		ResolveTypeTables[LEFT_SHIFT] = get_LEFT_SHIFT();
		ResolveTypeTables[LESS] = get_LESS();
		ResolveTypeTables[LESS_EQUAL] = get_LESS_EQUAL();
		ResolveTypeTables[MINUS] = get_MINUS();
		ResolveTypeTables[MULTIPLY] = get_MULTIPLY();
		ResolveTypeTables[OR] = get_OR();
		ResolveTypeTables[OR_OR] = get_OR_OR();
		ResolveTypeTables[PLUS] = get_PLUS();
		ResolveTypeTables[REMAINDER] = get_REMAINDER();
		ResolveTypeTables[RIGHT_SHIFT] = get_RIGHT_SHIFT();
		ResolveTypeTables[UNSIGNED_RIGHT_SHIFT] = get_UNSIGNED_RIGHT_SHIFT();
		ResolveTypeTables[XOR] = get_XOR();
	}


, Instance #
frags: 
(startLine=138 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
		{	int result = (ResolveTypeTables[operator][(left<<4)+right]) & 0x0000F;
			if (result != T_undefined)

				//1/ First regular computation then 2/ comparaison
				//with a compile time constant (generated by the compiler)
				//	z0 = s >= s;
				//	if ( z0 != (((short) 5) >= ((short) 5)))
				//		System.out.println(155);

			{	s += "\t\t"+decode.type(result)+"0"+" = "+decode.type(left); //$NON-NLS-1$ //$NON-NLS-3$ //$NON-NLS-2$
				s += " "+decode.operator(operator)+" "+decode.type(right)+";\n"; //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-3$
				String begin = result == T_String ? "\t\tif (! " : "\t\tif ( "; //$NON-NLS-2$ //$NON-NLS-1$
				String test = result == T_String ? ".equals(" : " != (" ; //$NON-NLS-2$ //$NON-NLS-1$
				s += begin	+decode.type(result)+"0"+test //$NON-NLS-1$
							+decode.constant(left)+" " //$NON-NLS-1$
							+decode.operator(operator)+" " //$NON-NLS-1$
							+decode.constant(right)+"))\n"; //$NON-NLS-1$
				s += "\t\t\tSystem.out.println("+ (++error) +");\n"; //$NON-NLS-1$ //$NON-NLS-2$
								
				}}}

(startLine=147 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
			{	s += "\t\t"+decode.type(result)+"0"+" = "+decode.type(left); //$NON-NLS-1$ //$NON-NLS-3$ //$NON-NLS-2$
				s += " "+decode.operator(operator)+" "+decode.type(right)+";\n"; //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-3$
				String begin = result == T_String ? "\t\tif (! " : "\t\tif ( "; //$NON-NLS-2$ //$NON-NLS-1$
				String test = result == T_String ? ".equals(" : " != (" ; //$NON-NLS-2$ //$NON-NLS-1$
				s += begin	+decode.type(result)+"0"+test //$NON-NLS-1$
							+decode.constant(left)+" " //$NON-NLS-1$
							+decode.operator(operator)+" " //$NON-NLS-1$
							+decode.constant(right)+"))\n"; //$NON-NLS-1$
				s += "\t\t\tSystem.out.println("+ (++error) +");\n"; //$NON-NLS-1$ //$NON-NLS-2$
								
				}}}

commonMethod: 
(startLine=165 endLine=357 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
	public static final int[] get_AND(){
	
		//the code is an int
		// (cast)  left   Op (cast)  rigth --> result
		//  0000   0000       0000   0000      0000
		//  <<16   <<12       <<8    <<4       
		
		int[] table  = new int[16*16] ;
		
		//	table[(T_undefined<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_undefined<<4)+T_byte] 			= T_undefined ;
		//	table[(T_undefined<<4)+T_long] 			= T_undefined ;
		//	table[(T_undefined<<4)+T_short] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_void] 			= T_undefined ;
		//	table[(T_undefined<<4)+T_String] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_Object] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_double] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_float] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_boolean] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_char] 			= T_undefined ;
		//	table[(T_undefined<<4)+T_int] 			= T_undefined ;
		//	table[(T_undefined<<4)+T_null] 			= T_undefined ;
		
		//	table[(T_byte<<4)+T_undefined] 	= T_undefined ;
		table[(T_byte<<4)+T_byte] 		= (Byte2Int<<12) +(Byte2Int<<4) +T_int ;
		table[(T_byte<<4)+T_long]		= (Byte2Long<<12)+(Long2Long<<4)+T_long ;
		table[(T_byte<<4)+T_short] 		= (Byte2Int<<12) +(Short2Int<<4)+T_int;
		//	table[(T_byte<<4)+T_void] 		= T_undefined ;
		//	table[(T_byte<<4)+T_String] 	= T_undefined ;
		//	table[(T_byte<<4)+T_Object] 	= T_undefined ;
		//	table[(T_byte<<4)+T_double] 	= T_undefined ;
		//	table[(T_byte<<4)+T_float] 		= T_undefined ;
		//	table[(T_byte<<4)+T_boolean] 	= T_undefined ;
		table[(T_byte<<4)+T_char] 		= (Byte2Int<<12) +(Char2Int<<4) +T_int ;
		table[(T_byte<<4)+T_int] 		= (Byte2Int<<12) +(Int2Int<<4)  +T_int ;
		//	table[(T_byte<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_long<<4)+T_undefined] 	= T_undefined ;
		table[(T_long<<4)+T_byte] 		= (Long2Long<<12)+(Byte2Long<<4)+T_long;
		table[(T_long<<4)+T_long] 		= (Long2Long<<12)+(Long2Long<<4)+T_long ;
		table[(T_long<<4)+T_short] 		= (Long2Long<<12)+(Short2Long<<4)+T_long; ;
		//	table[(T_long<<4)+T_void] 		= T_undefined ;
		//	table[(T_long<<4)+T_String] 	= T_undefined ;
		//	table[(T_long<<4)+T_Object] 	= T_undefined ;
		//	table[(T_long<<4)+T_double] 	= T_undefined ;
		//	table[(T_long<<4)+T_float] 		= T_undefined ;
		//	table[(T_long<<4)+T_boolean] 	= T_undefined ;
		table[(T_long<<4)+T_char] 		= (Long2Long<<12)+(Char2Long<<4)+T_long ;
		table[(T_long<<4)+T_int] 		= (Long2Long<<12)+(Int2Long<<4)+T_long ;
		//	table[(T_long<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_short<<4)+T_undefined] 	= T_undefined ;
		table[(T_short<<4)+T_byte] 			= (Short2Int<<12)+(Byte2Int<<4)+T_int ;
		table[(T_short<<4)+T_long] 			= (Short2Long<<12)+(Long2Long<<4)+T_long ;
		table[(T_short<<4)+T_short] 		= (Short2Int<<12)+(Short2Int<<4)+T_int ;
		//	table[(T_short<<4)+T_void] 			= T_undefined ;
		//	table[(T_short<<4)+T_String] 		= T_undefined ;
		//	table[(T_short<<4)+T_Object] 		= T_undefined ;
		//	table[(T_short<<4)+T_double] 		= T_undefined ;
		//	table[(T_short<<4)+T_float] 		= T_undefined ;
		//	table[(T_short<<4)+T_boolean] 		= T_undefined ;
		table[(T_short<<4)+T_char] 			= (Short2Int<<12)+(Char2Int<<4)+T_int ;
		table[(T_short<<4)+T_int] 			= (Short2Int<<12)+(Int2Int<<4)+T_int ;
		//	table[(T_short<<4)+T_null] 			= T_undefined ;
		
		//	table[(T_void<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_void<<4)+T_byte] 		= T_undefined ;
		//	table[(T_void<<4)+T_long] 		= T_undefined ;
		//	table[(T_void<<4)+T_short] 		= T_undefined ;
		//	table[(T_void<<4)+T_void] 		= T_undefined ;
		//	table[(T_void<<4)+T_String] 	= T_undefined ;
		//	table[(T_void<<4)+T_Object] 	= T_undefined ;
		//	table[(T_void<<4)+T_double] 	= T_undefined ;
		//	table[(T_void<<4)+T_float] 		= T_undefined ;
		//	table[(T_void<<4)+T_boolean] 	= T_undefined ;
		//	table[(T_void<<4)+T_char] 		= T_undefined ;
		//	table[(T_void<<4)+T_int] 		= T_undefined ;
		//	table[(T_void<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_String<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_String<<4)+T_byte] 		= T_undefined ;
		//	table[(T_String<<4)+T_long] 		= T_undefined ;
		//	table[(T_String<<4)+T_short] 		= T_undefined ;
		//	table[(T_String<<4)+T_void] 		= T_undefined ;
		//	table[(T_String<<4)+T_String] 		= T_undefined ;
		//	table[(T_String<<4)+T_Object] 		= T_undefined ;
		//	table[(T_String<<4)+T_double] 		= T_undefined ;
		//	table[(T_String<<4)+T_float] 		= T_undefined ;
		//	table[(T_String<<4)+T_boolean] 		= T_undefined ;
		//	table[(T_String<<4)+T_char] 		= T_undefined ;
		//	table[(T_String<<4)+T_int] 			= T_undefined ;
		//	table[(T_String<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_Object<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_Object<<4)+T_byte] 		= T_undefined ;
		//	table[(T_Object<<4)+T_long] 		= T_undefined ;
		//	table[(T_Object<<4)+T_short]		= T_undefined ;
		//	table[(T_Object<<4)+T_void] 		= T_undefined ;
		//	table[(T_Object<<4)+T_String] 		= T_undefined ;
		//	table[(T_Object<<4)+T_Object] 		= T_undefined ;
		//	table[(T_Object<<4)+T_double] 		= T_undefined ;
		//	table[(T_Object<<4)+T_float] 		= T_undefined ;
		//	table[(T_Object<<4)+T_boolean]		= T_undefined ;
		//	table[(T_Object<<4)+T_char] 		= T_undefined ;
		//	table[(T_Object<<4)+T_int] 			= T_undefined ;
		//	table[(T_Object<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_double<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_double<<4)+T_byte] 		= T_undefined ;
		//	table[(T_double<<4)+T_long] 		= T_undefined ;
		//	table[(T_double<<4)+T_short] 		= T_undefined ;
		//	table[(T_double<<4)+T_void] 		= T_undefined ;
		//	table[(T_double<<4)+T_String] 		= T_undefined ;
		//	table[(T_double<<4)+T_Object] 		= T_undefined ;
		//	table[(T_double<<4)+T_double] 		= T_undefined ;
		//	table[(T_double<<4)+T_float] 		= T_undefined ;
		//	table[(T_double<<4)+T_boolean] 		= T_undefined ;
		//	table[(T_double<<4)+T_char] 		= T_undefined ;
		//	table[(T_double<<4)+T_int] 			= T_undefined;
		//	table[(T_double<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_float<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_float<<4)+T_byte] 			= T_undefined ;
		//	table[(T_float<<4)+T_long] 			= T_undefined ;
		//	table[(T_float<<4)+T_short] 		= T_undefined ;
		//	table[(T_float<<4)+T_void] 			= T_undefined ;
		//	table[(T_float<<4)+T_String] 		= T_undefined ;
		//	table[(T_float<<4)+T_Object] 		= T_undefined ;
		//	table[(T_float<<4)+T_double] 		= T_undefined ;
		//	table[(T_float<<4)+T_float] 		= T_undefined ;
		//	table[(T_float<<4)+T_boolean] 		= T_undefined ;
		//	table[(T_float<<4)+T_char] 			= T_undefined ;
		//	table[(T_float<<4)+T_int] 			= T_undefined ;
		//	table[(T_float<<4)+T_null] 			= T_undefined ;
		
		//	table[(T_boolean<<4)+T_undefined] 		= T_undefined ;
		//	table[(T_boolean<<4)+T_byte] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_long] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_short] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_void] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_String] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_Object] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_double] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_float] 			= T_undefined ;
		table[(T_boolean<<4)+T_boolean] 		= (Boolean2Boolean << 12)+(Boolean2Boolean << 4)+T_boolean ;
		//	table[(T_boolean<<4)+T_char] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_int] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_null] 			= T_undefined ;
			
		//	table[(T_char<<4)+T_undefined] 		= T_undefined ;
		table[(T_char<<4)+T_byte] 			= (Char2Int<<12)+(Byte2Int<<4)+T_int ;
		table[(T_char<<4)+T_long] 			= (Char2Long<<12)+(Long2Long<<4)+T_long;
		table[(T_char<<4)+T_short] 			= (Char2Int<<12)+(Short2Int<<4)+T_int ;
		//	table[(T_char<<4)+T_void] 			= T_undefined ;
		//	table[(T_char<<4)+T_String] 		= T_undefined ;
		//	table[(T_char<<4)+T_Object] 		= T_undefined ;
		//	table[(T_char<<4)+T_double] 		= T_undefined ;
		//	table[(T_char<<4)+T_float] 			= T_undefined ;
		//	table[(T_char<<4)+T_boolean] 		= T_undefined ;
		table[(T_char<<4)+T_char] 			= (Char2Int<<12)+(Char2Int<<4)+T_int ;
		table[(T_char<<4)+T_int] 			= (Char2Int<<12)+(Int2Int<<4)+T_int ;
		//	table[(T_char<<4)+T_null] 			= T_undefined ;
			
		//	table[(T_int<<4)+T_undefined] 	= T_undefined ;
		table[(T_int<<4)+T_byte] 		= (Int2Int<<12)+(Byte2Int<<4)+T_int ;
		table[(T_int<<4)+T_long] 		= (Int2Long<<12)+(Long2Long<<4)+T_long ;
		table[(T_int<<4)+T_short] 		= (Int2Int<<12)+(Short2Int<<4)+T_int ;
		//	table[(T_int<<4)+T_void] 		= T_undefined ;
		//	table[(T_int<<4)+T_String] 		= T_undefined ;
		//	table[(T_int<<4)+T_Object] 		= T_undefined ;
		//	table[(T_int<<4)+T_double] 		= T_undefined ;
		//	table[(T_int<<4)+T_float] 		= T_undefined ;
		//	table[(T_int<<4)+T_boolean] 	= T_undefined ;
		table[(T_int<<4)+T_char] 		= (Int2Int<<12)+(Char2Int<<4)+T_int ;
		table[(T_int<<4)+T_int] 		= (Int2Int<<12)+(Int2Int<<4)+T_int ;
		//	table[(T_int<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_null<<4)+T_undefined] 		= T_undefined ;
		//	table[(T_null<<4)+T_byte] 			= T_undefined ;
		//	table[(T_null<<4)+T_long] 			= T_undefined ;
		//	table[(T_null<<4)+T_short] 			= T_undefined ;
		//	table[(T_null<<4)+T_void] 			= T_undefined ;
		//	table[(T_null<<4)+T_String] 		= T_undefined ;
		//	table[(T_null<<4)+T_Object] 		= T_undefined ;
		//	table[(T_null<<4)+T_double] 		= T_undefined ;
		//	table[(T_null<<4)+T_float] 			= T_undefined ;
		//	table[(T_null<<4)+T_boolean] 		= T_undefined ;
		//	table[(T_null<<4)+T_char] 			= T_undefined ;
		//	table[(T_null<<4)+T_int] 			= T_undefined ;
		//	table[(T_null<<4)+T_null] 			= T_undefined ;
	
		return table ;
	}


, Instance #
frags: 
(startLine=138 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
		{	int result = (ResolveTypeTables[operator][(left<<4)+right]) & 0x0000F;
			if (result != T_undefined)

				//1/ First regular computation then 2/ comparaison
				//with a compile time constant (generated by the compiler)
				//	z0 = s >= s;
				//	if ( z0 != (((short) 5) >= ((short) 5)))
				//		System.out.println(155);

			{	s += "\t\t"+decode.type(result)+"0"+" = "+decode.type(left); //$NON-NLS-1$ //$NON-NLS-3$ //$NON-NLS-2$
				s += " "+decode.operator(operator)+" "+decode.type(right)+";\n"; //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-3$
				String begin = result == T_String ? "\t\tif (! " : "\t\tif ( "; //$NON-NLS-2$ //$NON-NLS-1$
				String test = result == T_String ? ".equals(" : " != (" ; //$NON-NLS-2$ //$NON-NLS-1$
				s += begin	+decode.type(result)+"0"+test //$NON-NLS-1$
							+decode.constant(left)+" " //$NON-NLS-1$
							+decode.operator(operator)+" " //$NON-NLS-1$
							+decode.constant(right)+"))\n"; //$NON-NLS-1$
				s += "\t\t\tSystem.out.println("+ (++error) +");\n"; //$NON-NLS-1$ //$NON-NLS-2$
								
				}}}

(startLine=147 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
			{	s += "\t\t"+decode.type(result)+"0"+" = "+decode.type(left); //$NON-NLS-1$ //$NON-NLS-3$ //$NON-NLS-2$
				s += " "+decode.operator(operator)+" "+decode.type(right)+";\n"; //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-3$
				String begin = result == T_String ? "\t\tif (! " : "\t\tif ( "; //$NON-NLS-2$ //$NON-NLS-1$
				String test = result == T_String ? ".equals(" : " != (" ; //$NON-NLS-2$ //$NON-NLS-1$
				s += begin	+decode.type(result)+"0"+test //$NON-NLS-1$
							+decode.constant(left)+" " //$NON-NLS-1$
							+decode.operator(operator)+" " //$NON-NLS-1$
							+decode.constant(right)+"))\n"; //$NON-NLS-1$
				s += "\t\t\tSystem.out.println("+ (++error) +");\n"; //$NON-NLS-1$ //$NON-NLS-2$
								
				}}}

commonMethod: 
(startLine=789 endLine=981 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
	public static final int[] get_LEFT_SHIFT(){
	
		//the code is an int
		// (cast)  left   Op (cast)  rigth --> result
		//  0000   0000       0000   0000      0000
		//  <<16   <<12       <<8    <<4       
		
		int[] table  = new int[16*16] ;
		
		//	table[(T_undefined<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_undefined<<4)+T_byte] 			= T_undefined ;
		//	table[(T_undefined<<4)+T_long] 			= T_undefined ;
		//	table[(T_undefined<<4)+T_short] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_void] 			= T_undefined ;
		//	table[(T_undefined<<4)+T_String] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_Object] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_double] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_float] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_boolean] 		= T_undefined ;
		//	table[(T_undefined<<4)+T_char] 			= T_undefined ;
		//	table[(T_undefined<<4)+T_int] 			= T_undefined ;
		//	table[(T_undefined<<4)+T_null] 			= T_undefined ;
			
		//	table[(T_byte<<4)+T_undefined] 	= T_undefined ;
		table[(T_byte<<4)+T_byte] 		= (Byte2Int<<12)+(Byte2Int<<4)+T_int ;
		table[(T_byte<<4)+T_long] 		= (Byte2Int<<12)+(Long2Int<<4)+T_int ;
		table[(T_byte<<4)+T_short] 		= (Byte2Int<<12)+(Short2Int<<4)+T_int ;
		//	table[(T_byte<<4)+T_void] 		= T_undefined ;
		//	table[(T_byte<<4)+T_String] 	= T_undefined ;
		//	table[(T_byte<<4)+T_Object] 	= T_undefined ;
		//	table[(T_byte<<4)+T_double] 	= T_undefined ;
		//	table[(T_byte<<4)+T_float] 		= T_undefined ;
		//	table[(T_byte<<4)+T_boolean] 	= T_undefined ;
		table[(T_byte<<4)+T_char] 		= (Byte2Int<<12)+(Char2Int<<4)+T_int ;
		table[(T_byte<<4)+T_int] 		= (Byte2Int<<12)+(Int2Int<<4)+T_int ;
		//	table[(T_byte<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_long<<4)+T_undefined] 	= T_undefined ;
		table[(T_long<<4)+T_byte] 		= (Long2Long<<12)+(Byte2Int<<4)+T_long;
		table[(T_long<<4)+T_long] 		= (Long2Long<<12)+(Long2Int<<4)+T_long ;
		table[(T_long<<4)+T_short] 		= (Long2Long<<12)+(Short2Int<<4)+T_long ;
		//	table[(T_long<<4)+T_void] 		= T_undefined ;
		//	table[(T_long<<4)+T_String] 	= T_undefined ;
		//	table[(T_long<<4)+T_Object] 	= T_undefined ;
		//	table[(T_long<<4)+T_double] 	= T_undefined ;
		//	table[(T_long<<4)+T_float] 		= T_undefined ;
		//	table[(T_long<<4)+T_boolean] 	= T_undefined ;
		table[(T_long<<4)+T_char] 		= (Long2Long<<12)+(Char2Int<<4)+T_long ;
		table[(T_long<<4)+T_int] 		= (Long2Long<<12)+(Int2Int<<4)+T_long ;
		//	table[(T_long<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_short<<4)+T_undefined] 	= T_undefined ;
		table[(T_short<<4)+T_byte] 			= (Short2Int<<12)+(Byte2Int<<4)+T_int ;
		table[(T_short<<4)+T_long] 			= (Short2Int<<12)+(Long2Int<<4)+T_int ;
		table[(T_short<<4)+T_short] 		= (Short2Int<<12)+(Short2Int<<4)+T_int ;
		//	table[(T_short<<4)+T_void] 			= T_undefined ;
		//	table[(T_short<<4)+T_String] 		= T_undefined ;
		//	table[(T_short<<4)+T_Object] 		= T_undefined ;
		//	table[(T_short<<4)+T_double] 		= T_undefined ;
		//	table[(T_short<<4)+T_float] 		= T_undefined ;
		//	table[(T_short<<4)+T_boolean] 		= T_undefined ;
		table[(T_short<<4)+T_char] 			= (Short2Int<<12)+(Char2Int<<4)+T_int ;
		table[(T_short<<4)+T_int] 			= (Short2Int<<12)+(Int2Int<<4)+T_int ;
		//	table[(T_short<<4)+T_null] 			= T_undefined ;
		
		//	table[(T_void<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_void<<4)+T_byte] 		= T_undefined ;
		//	table[(T_void<<4)+T_long] 		= T_undefined ;
		//	table[(T_void<<4)+T_short] 		= T_undefined ;
		//	table[(T_void<<4)+T_void] 		= T_undefined ;
		//	table[(T_void<<4)+T_String] 	= T_undefined ;
		//	table[(T_void<<4)+T_Object] 	= T_undefined ;
		//	table[(T_void<<4)+T_double] 	= T_undefined ;
		//	table[(T_void<<4)+T_float] 		= T_undefined ;
		//	table[(T_void<<4)+T_boolean] 	= T_undefined ;
		//	table[(T_void<<4)+T_char] 		= T_undefined ;
		//	table[(T_void<<4)+T_int] 		= T_undefined ;
		//	table[(T_void<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_String<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_String<<4)+T_byte] 		= T_undefined ;
		//	table[(T_String<<4)+T_long] 		= T_undefined ;
		//	table[(T_String<<4)+T_short] 		= T_undefined ;
		//	table[(T_String<<4)+T_void] 		= T_undefined ;
		//	table[(T_String<<4)+T_String] 		= T_undefined ;
		//	table[(T_String<<4)+T_Object] 		= T_undefined ;
		//	table[(T_String<<4)+T_double] 		= T_undefined ;
		//	table[(T_String<<4)+T_float] 		= T_undefined ;
		//	table[(T_String<<4)+T_boolean] 		= T_undefined ;
		//	table[(T_String<<4)+T_char] 		= T_undefined ;
		//	table[(T_String<<4)+T_int] 			= T_undefined ;
		//	table[(T_String<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_Object<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_Object<<4)+T_byte] 		= T_undefined ;
		//	table[(T_Object<<4)+T_long] 		= T_undefined ;
		//	table[(T_Object<<4)+T_short]		= T_undefined ;
		//	table[(T_Object<<4)+T_void] 		= T_undefined ;
		//	table[(T_Object<<4)+T_String] 		= T_undefined ;
		//	table[(T_Object<<4)+T_Object] 		= T_undefined ;
		//	table[(T_Object<<4)+T_double] 		= T_undefined ;
		//	table[(T_Object<<4)+T_float] 		= T_undefined ;
		//	table[(T_Object<<4)+T_boolean]		= T_undefined ;
		//	table[(T_Object<<4)+T_char] 		= T_undefined ;
		//	table[(T_Object<<4)+T_int] 			= T_undefined ;
		//	table[(T_Object<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_double<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_double<<4)+T_byte] 		= T_undefined ;
		//	table[(T_double<<4)+T_long] 		= T_undefined ;
		//	table[(T_double<<4)+T_short] 		= T_undefined ;
		//	table[(T_double<<4)+T_void] 		= T_undefined ;
		//	table[(T_double<<4)+T_String] 		= T_undefined ;
		//	table[(T_double<<4)+T_Object] 		= T_undefined ;
		//	table[(T_double<<4)+T_double] 		= T_undefined ;
		//	table[(T_double<<4)+T_float] 		= T_undefined ;
		//	table[(T_double<<4)+T_boolean] 		= T_undefined ;
		//	table[(T_double<<4)+T_char] 		= T_undefined ;
		//	table[(T_double<<4)+T_int] 			= T_undefined;
		//	table[(T_double<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_float<<4)+T_undefined] 	= T_undefined ;
		//	table[(T_float<<4)+T_byte] 			= T_undefined ;
		//	table[(T_float<<4)+T_long] 			= T_undefined ;
		//	table[(T_float<<4)+T_short] 		= T_undefined ;
		//	table[(T_float<<4)+T_void] 			= T_undefined ;
		//	table[(T_float<<4)+T_String] 		= T_undefined ;
		//	table[(T_float<<4)+T_Object] 		= T_undefined ;
		//	table[(T_float<<4)+T_double] 		= T_undefined ;
		//	table[(T_float<<4)+T_float] 		= T_undefined ;
		//	table[(T_float<<4)+T_boolean] 		= T_undefined ;
		//	table[(T_float<<4)+T_char] 			= T_undefined ;
		//	table[(T_float<<4)+T_int] 			= T_undefined ;
		//	table[(T_float<<4)+T_null] 			= T_undefined ;
		
		//	table[(T_boolean<<4)+T_undefined] 		= T_undefined ;
		//	table[(T_boolean<<4)+T_byte] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_long] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_short] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_void] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_String] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_Object] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_double] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_float] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_boolean] 		= T_undefined ;
		//	table[(T_boolean<<4)+T_char] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_int] 			= T_undefined ;
		//	table[(T_boolean<<4)+T_null] 			= T_undefined ;
			
		//	table[(T_char<<4)+T_undefined] 		= T_undefined ;
		table[(T_char<<4)+T_byte] 			= (Char2Int<<12)+(Byte2Int<<4)+T_int ;
		table[(T_char<<4)+T_long] 			= (Char2Int<<12)+(Long2Int<<4)+T_int ;
		table[(T_char<<4)+T_short] 			= (Char2Int<<12)+(Short2Int<<4)+T_int ;
		//	table[(T_char<<4)+T_void] 			= T_undefined ;
		//	table[(T_char<<4)+T_String] 		= T_undefined ;
		//	table[(T_char<<4)+T_Object] 		= T_undefined ;
		//	table[(T_char<<4)+T_double] 		= T_undefined ;
		//	table[(T_char<<4)+T_float] 			= T_undefined ;
		//	table[(T_char<<4)+T_boolean] 		= T_undefined ;
		table[(T_char<<4)+T_char] 			= (Char2Int<<12)+(Char2Int<<4)+T_int ;
		table[(T_char<<4)+T_int] 			= (Char2Int<<12)+(Int2Int<<4)+T_int ;
		//	table[(T_char<<4)+T_null] 			= T_undefined ;
		
		//	table[(T_int<<4)+T_undefined] 	= T_undefined ;
		table[(T_int<<4)+T_byte] 		= (Int2Int<<12)+(Byte2Int<<4)+T_int ;
		table[(T_int<<4)+T_long] 		= (Int2Int<<12)+(Long2Int<<4)+T_int ;
		table[(T_int<<4)+T_short] 		= (Int2Int<<12)+(Short2Int<<4)+T_int ;
		//	table[(T_int<<4)+T_void] 		= T_undefined ;
		//	table[(T_int<<4)+T_String] 		= T_undefined ;
		//	table[(T_int<<4)+T_Object] 		= T_undefined ;
		//	table[(T_int<<4)+T_double] 		= T_undefined ;
		//	table[(T_int<<4)+T_float] 		= T_undefined ;
		//	table[(T_int<<4)+T_boolean] 	= T_undefined ;
		table[(T_int<<4)+T_char] 		= (Int2Int<<12)+(Char2Int<<4)+T_int ;
		table[(T_int<<4)+T_int] 		= (Int2Int<<12)+(Int2Int<<4)+T_int ;
		//	table[(T_int<<4)+T_null] 		= T_undefined ;
		
		//	table[(T_null<<4)+T_undefined] 		= T_undefined ;
		//	table[(T_null<<4)+T_byte] 			= T_undefined ;
		//	table[(T_null<<4)+T_long] 			= T_undefined ;
		//	table[(T_null<<4)+T_short] 			= T_undefined ;
		//	table[(T_null<<4)+T_void] 			= T_undefined ;
		//	table[(T_null<<4)+T_String] 		= T_undefined ;
		//	table[(T_null<<4)+T_Object] 		= T_undefined ;
		//	table[(T_null<<4)+T_double] 		= T_undefined ;
		//	table[(T_null<<4)+T_float] 			= T_undefined ;
		//	table[(T_null<<4)+T_boolean] 		= T_undefined ;
		//	table[(T_null<<4)+T_char] 			= T_undefined ;
		//	table[(T_null<<4)+T_int] 			= T_undefined ;
		//	table[(T_null<<4)+T_null] 			= T_undefined ;
	
		return table ;
	}


, Instance #
frags: 
(startLine=138 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
		{	int result = (ResolveTypeTables[operator][(left<<4)+right]) & 0x0000F;
			if (result != T_undefined)

				//1/ First regular computation then 2/ comparaison
				//with a compile time constant (generated by the compiler)
				//	z0 = s >= s;
				//	if ( z0 != (((short) 5) >= ((short) 5)))
				//		System.out.println(155);

			{	s += "\t\t"+decode.type(result)+"0"+" = "+decode.type(left); //$NON-NLS-1$ //$NON-NLS-3$ //$NON-NLS-2$
				s += " "+decode.operator(operator)+" "+decode.type(right)+";\n"; //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-3$
				String begin = result == T_String ? "\t\tif (! " : "\t\tif ( "; //$NON-NLS-2$ //$NON-NLS-1$
				String test = result == T_String ? ".equals(" : " != (" ; //$NON-NLS-2$ //$NON-NLS-1$
				s += begin	+decode.type(result)+"0"+test //$NON-NLS-1$
							+decode.constant(left)+" " //$NON-NLS-1$
							+decode.operator(operator)+" " //$NON-NLS-1$
							+decode.constant(right)+"))\n"; //$NON-NLS-1$
				s += "\t\t\tSystem.out.println("+ (++error) +");\n"; //$NON-NLS-1$ //$NON-NLS-2$
								
				}}}

(startLine=147 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00135/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
			{	s += "\t\t"+decode.type(result)+"0"+" = "+decode.type(left); //$NON-NLS-1$ //$NON-NLS-3$ //$NON-NLS-2$
				s += " "+decode.operator(operator)+" "+decode.type(right)+";\n"; //$NON-NLS-2$ //$NON-NLS-1$ //$NON-NLS-3$
				String begin = result == T_String ? "\t\tif (! " : "\t\tif ( "; //$NON-NLS-2$ //$NON-NLS-1$
				String test = result == T_String ? ".equals(" : " != (" ; //$NON-NLS-2$ //$NON-NLS-1$
				s += begin	+decode.type(result)+"0"+test //$NON-NLS-1$
							+decode.constant(left)+" " //$NON-NLS-1$
							+decode.operator(operator)+" " //$NON-NLS-1$
							+decode.constant(right)+"))\n"; //$NON-NLS-1$
				s += "\t\t\tSystem.out.println("+ (++error) +");\n"; //$NON-NLS-1$ //$NON-NLS-2$
								
				}}}

commonMethod: 
(startLine=1188 endLine=1228 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00136/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OperatorExpression.java)
	public static final int[] get_MINUS(){
	
		//the code is an int
		// (cast)  left   Op (cast)  rigth --> result
		//  0000   0000       0000   0000      0000
		//  <<16   <<12       <<8    <<4       
		
		int[] table  = new int[16*16] ;
	
		table = (int[]) get_PLUS().clone();

		// customization	
		table[(T_String<<4)+T_byte] 		= T_undefined ;
		table[(T_String<<4)+T_long] 		= T_undefined ;
		table[(T_String<<4)+T_short] 		= T_undefined ;
		table[(T_String<<4)+T_void] 		= T_undefined ;
		table[(T_String<<4)+T_String] 		= T_undefined ;
		table[(T_String<<4)+T_Object] 		= T_undefined ;
		table[(T_String<<4)+T_double] 		= T_undefined ;
		table[(T_String<<4)+T_float] 		= T_undefined ;
		table[(T_String<<4)+T_boolean] 		= T_undefined ;
		table[(T_String<<4)+T_char] 		= T_undefined ;
		table[(T_String<<4)+T_int] 			= T_undefined ;
		table[(T_String<<4)+T_null] 		= T_undefined ;
		
		table[(T_byte<<4)	+T_String] 		= T_undefined ;
		table[(T_long<<4)	+T_String] 		= T_undefined ;
		table[(T_short<<4)	+T_String] 		= T_undefined ;
		table[(T_void<<4)	+T_String] 		= T_undefined ;
		table[(T_Object<<4)	+T_String] 		= T_undefined ;
		table[(T_double<<4)	+T_String] 		= T_undefined ;
		table[(T_float<<4)	+T_String] 		= T_undefined ;
		table[(T_boolean<<4)+T_String] 		= T_undefined ;
		table[(T_char<<4)	+T_String] 		= T_undefined ;
		table[(T_int<<4)	+T_String] 		= T_undefined ;
		table[(T_null<<4)	+T_String] 		= T_undefined ;
		
		table[(T_null<<4)	+T_null] 		= T_undefined ;
	
		return table ;
	}


, Instance #
frags: 
(startLine=112 endLine=124 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00141/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java)
			} else {
				// this is the qualifier
				org.eclipse.jdt.internal.compiler.ast.Expression receiver = messageSend.receiver;
				if (receiver instanceof SingleNameReference) {
					SingleNameReference singleNameReference = (SingleNameReference) receiver;
					if (singleNameReference.isTypeReference()) {
						return this.getTypeBinding((ReferenceBinding)singleNameReference.binding);
					} else {
						// this is a variable or a field
						return this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding)singleNameReference.binding);				
					}
				}
			}

(startLine=125 endLine=138 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00141/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java)
		} else {
			// this is the qualifier
			org.eclipse.jdt.internal.compiler.ast.Expression receiver = messageSend.receiver;
			if (receiver instanceof QualifiedNameReference) {
				QualifiedNameReference qualifiedNameReference = (QualifiedNameReference) receiver;
		
				if (qualifiedNameReference.isTypeReference()) {
					return this.getTypeBinding((ReferenceBinding)qualifiedNameReference.binding);
				} else {
					// this is a variable or a field
					return this.getVariableBinding((org.eclipse.jdt.internal.compiler.lookup.VariableBinding) qualifiedNameReference.binding);				
				}
			}
		}

commonMethod: 
(startLine=577 endLine=583 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00142/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/DefaultBindingResolver.java)
	private IBinding internalResolveNameForThisExpression(Name name) {
		AstNode node = (AstNode) this.newAstToOldAst.get(name);
		if (node instanceof TypeReference) {
			return this.getTypeBinding(((TypeReference) node).binding);
		}
		return null;
	}


, Instance #
frags: 
(startLine=1060 endLine=1077 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00186/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)

(startLine=2618 endLine=2635 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00186/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)

(startLine=2640 endLine=2657 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00186/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)

commonMethod: 
(startLine=2879 endLine=2881 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00187/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)


, Instance #
frags: 
(startLine=1060 endLine=1077 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00186/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)

(startLine=2618 endLine=2635 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00186/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)

(startLine=2640 endLine=2657 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00186/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)

commonMethod: 
(startLine=2635 endLine=2639 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00187/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)


, Instance #
frags: 
(startLine=65 endLine=78 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00195/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexAllProject.java)
			if (index.hasChanged()) {
				try {
					monitor.exitRead(); // free read lock
					monitor.enterWrite(); // ask permission to write
					if (IndexManager.VERBOSE)
						System.out.println("-> merging index : " + index.getIndexFile()); //$NON-NLS-1$
					index.save();
				} catch (IOException e) {
					return FAILED;
				} finally {
					monitor.exitWrite(); // finished writing
					monitor.enterRead(); // reacquire read permission
				}
			}

(startLine=62 endLine=75 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00195/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/indexing/IndexBinaryFolder.java)
			if (index.hasChanged()) {
				try {
					monitor.exitRead(); // free read lock
					monitor.enterWrite(); // ask permission to write
					if (IndexManager.VERBOSE)
						System.out.println("-> merging index : " + index.getIndexFile()); //$NON-NLS-1$
					index.save();
				} catch (IOException e) {
					return FAILED;
				} finally {
					monitor.exitWrite(); // finished writing
					monitor.enterRead(); // reacquire read permission
				}
			}

(startLine=55 endLine=67 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00195/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/SubTypeSearchJob.java)
		if (index.hasChanged()){
			try {
				monitor.exitRead(); // free read lock
				monitor.enterWrite(); // ask permission to write
				if (IndexManager.VERBOSE) System.out.println("-> merging index : "+index.getIndexFile()); //$NON-NLS-1$
				index.save();
			} catch(IOException e){
				return FAILED;
			} finally {
				monitor.exitWrite(); // finished writing
				monitor.enterRead(); // reaquire read permission
			}
		}

(startLine=125 endLine=139 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00195/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/PatternSearchJob.java)
			if (index.hasChanged()) {
				try {
					monitor.exitRead(); // free read lock
					monitor.enterWrite(); // ask permission to write
					if (IndexManager.VERBOSE)
						System.out.println("-> merging index : " + index.getIndexFile());//$NON-NLS-1$
					//$NON-NLS-1$
					index.save();
				} catch (IOException e) {
					return FAILED;
				} finally {
					monitor.exitWrite(); // finished writing
					monitor.enterRead(); // reaquire read permission
				}
			}

commonMethod: 
(startLine=36 endLine=38 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00196/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java)
	public static void log(String log) {
		System.out.println("(" + Thread.currentThread() + ") " + log); //$NON-NLS-1$//$NON-NLS-2$
	}


, Instance #
frags: 
(startLine=44 endLine=85 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00195/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/SubTypeSearchJob.java)
public boolean search(IIndex index, IProgressMonitor progressMonitor) {

	if (progressMonitor != null && progressMonitor.isCanceled()) throw new OperationCanceledException();

	if (index == null) return COMPLETE;		
	ReadWriteMonitor monitor = indexManager.getMonitorFor(index);
	if (monitor == null) return COMPLETE; // index got deleted since acquired
	try {
		monitor.enterRead(); // ask permission to read

		/* if index has changed, commit these before querying */
		if (index.hasChanged()){
			try {
				monitor.exitRead(); // free read lock
				monitor.enterWrite(); // ask permission to write
				if (IndexManager.VERBOSE) System.out.println("-> merging index : "+index.getIndexFile()); //$NON-NLS-1$
				index.save();
			} catch(IOException e){
				return FAILED;
			} finally {
				monitor.exitWrite(); // finished writing
				monitor.enterRead(); // reaquire read permission
			}
		}
		long start = System.currentTimeMillis();

		IndexInput input;
		if ((input = (IndexInput) inputs.get(index)) == null){
			input = new BlocksIndexInput(index.getIndexFile());
			input.open();
			inputs.put(index, input);
			//System.out.println("Acquiring INPUT for "+index);
		}
		pattern.findIndexMatches(input, requestor, detailLevel, progressMonitor, this.scope);
		executionTime += System.currentTimeMillis() - start;
		return COMPLETE;
	} catch(IOException e){
		return FAILED;
	} finally {
		monitor.exitRead(); // finished reading
	}
}

(startLine=111 endLine=154 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00195/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/PatternSearchJob.java)
	public boolean search(IIndex index, IProgressMonitor progressMonitor) {

		if (progressMonitor != null && progressMonitor.isCanceled())
			throw new OperationCanceledException();

		if (index == null)
			return COMPLETE;
		ReadWriteMonitor monitor = indexManager.getMonitorFor(index);
		if (monitor == null)
			return COMPLETE; // index got deleted since acquired
		try {
			monitor.enterRead(); // ask permission to read

			/* if index has changed, commit these before querying */
			if (index.hasChanged()) {
				try {
					monitor.exitRead(); // free read lock
					monitor.enterWrite(); // ask permission to write
					if (IndexManager.VERBOSE)
						System.out.println("-> merging index : " + index.getIndexFile());//$NON-NLS-1$
					//$NON-NLS-1$
					index.save();
				} catch (IOException e) {
					return FAILED;
				} finally {
					monitor.exitWrite(); // finished writing
					monitor.enterRead(); // reaquire read permission
				}
			}
			long start = System.currentTimeMillis();
			pattern.findIndexMatches(
				index,
				requestor,
				detailLevel,
				progressMonitor,
				this.scope);
			executionTime += System.currentTimeMillis() - start;
			return COMPLETE;
		} catch (IOException e) {
			return FAILED;
		} finally {
			monitor.exitRead(); // finished reading
		}
	}

commonMethod: 
(startLine=36 endLine=38 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00196/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/processing/JobManager.java)
	public static void log(String log) {
		System.out.println("(" + Thread.currentThread() + ") " + log); //$NON-NLS-1$//$NON-NLS-2$
	}


, Instance #
frags: 
(startLine=167 endLine=205 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00198/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
	public void acceptClass(char[] packageName, char[] className, int modifiers) {

		char[] fullyQualifiedName = CharOperation.concat(packageName, className, '.');
		char[] completionName = fullyQualifiedName;
		
		if (this.knownTypes.containsKey(completionName)) return;

		this.knownTypes.put(completionName, this);
		
		int relevance = DEFAULTRELEVANCE;
		if (resolvingImports) {
			completionName = CharOperation.concat(completionName, new char[] { ';' });
			if(CharOperation.prefixEquals(token, fullyQualifiedName, true)){
				relevance += CASEMATCHRELEVANCE;
			}
		} else {
			if (!insideQualifiedReference) {
				if (mustQualifyType(packageName, className)) {
					if (packageName == null || packageName.length == 0)
						if (unitScope != null && unitScope.fPackage.compoundName != NoCharChar)
							return; // ignore types from the default package from outside it
				} else {
					completionName = className;
				}
			}
			if(CharOperation.prefixEquals(token, className, true)){
				relevance += CASEMATCHRELEVANCE;
			}
		}

		requestor.acceptClass(
			packageName,
			className,
			completionName,
			modifiers,
			startPosition - offset,
			endPosition - offset,
			relevance);
	}

(startLine=218 endLine=256 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00198/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
		int modifiers) {

		char[] fullyQualifiedName = CharOperation.concat(packageName, interfaceName, '.');
		char[] completionName = fullyQualifiedName;

		if (this.knownTypes.containsKey(completionName)) return;

		this.knownTypes.put(completionName, this);

		int relevance = DEFAULTRELEVANCE;
		if (resolvingImports) {
			completionName = CharOperation.concat(completionName, new char[] { ';' });
			if(CharOperation.prefixEquals(token, fullyQualifiedName, true)){
				relevance += CASEMATCHRELEVANCE;
			}
		} else {
			if (!insideQualifiedReference) {
				if (mustQualifyType(packageName, interfaceName)) {
					if (packageName == null || packageName.length == 0)
						if (unitScope != null && unitScope.fPackage.compoundName != NoCharChar)
							return; // ignore types from the default package from outside it
				} else {
					completionName = interfaceName;
				}
			}
			if(CharOperation.prefixEquals(token, interfaceName, true)){
				relevance += CASEMATCHRELEVANCE;
			}
		}
		
		requestor.acceptInterface(
			packageName,
			interfaceName,
			completionName,
			modifiers,
			startPosition - offset,
			endPosition - offset,
			relevance);
	}

(startLine=294 endLine=331 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00198/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
	public void acceptType(char[] packageName, char[] typeName) {

		char[] fullyQualifiedName = CharOperation.concat(packageName, typeName, '.');
		char[] completionName = fullyQualifiedName;
		
		if (this.knownTypes.containsKey(completionName)) return;

		this.knownTypes.put(completionName, this);

		int relevance = DEFAULTRELEVANCE;
		if (resolvingImports) {
			completionName = CharOperation.concat(completionName, new char[] { ';' });
			if(CharOperation.prefixEquals(token, fullyQualifiedName, true)){
				relevance += CASEMATCHRELEVANCE;
			}
		} else {
			if (!insideQualifiedReference) {
				if (mustQualifyType(packageName, typeName)) {
					if (packageName == null || packageName.length == 0)
						if (unitScope != null && unitScope.fPackage.compoundName != NoCharChar)
							return; // ignore types from the default package from outside it
				} else {
					completionName = typeName;
				}
			}
			if(CharOperation.prefixEquals(token, typeName, true)){
				relevance += CASEMATCHRELEVANCE;
			}
		}
		
		requestor.acceptType(
			packageName,
			typeName,
			completionName,
			startPosition - offset,
			endPosition - offset,
			relevance);
	}

commonMethod: 
(startLine=1736 endLine=1742 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00199/org.eclipse.jdt.core/codeassist/org/eclipse/jdt/internal/codeassist/CompletionEngine.java)
	private int computeRelevanceForCaseMatching(char[] token, char[] proposalName){
		if (CharOperation.prefixEquals(token, proposalName, true /* do not ignore case */)) {
			return  CASEMATCHRELEVANCE;
		} else {
			return 0;
		}
	}


, Instance #
frags: 
(startLine=110 endLine=122 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00209/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java)
	} catch (CoreException e) {
		if (DEBUG){
			System.out.println("Builder handling CoreException"); //$NON-NLS-1$
			 e.printStackTrace();
		}
		try {
			IMarker marker = currentProject.createMarker(ProblemMarkerTag);
			marker.setAttribute(IMarker.MESSAGE, Util.bind("build.inconsistentProject")); //$NON-NLS-1$
			marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
		} catch (CoreException ignore) {
			throw e;
		}
	} catch (ImageBuilderInternalException e) {

(startLine=122 endLine=134 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00209/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java)
	} catch (ImageBuilderInternalException e) {
		if (DEBUG){
			System.out.println("Builder handling ImageBuilderInternalException"); //$NON-NLS-1$
			 e.printStackTrace();
		}
		try {
			IMarker marker = currentProject.createMarker(ProblemMarkerTag);
			marker.setAttribute(IMarker.MESSAGE, Util.bind("build.inconsistentProject")); //$NON-NLS-1$
			marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
		} catch (CoreException ignore) {
			throw e.getThrowable();
		}
	} catch (IncompleteClassPathException e) {

(startLine=134 endLine=142 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00209/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java)
	} catch (IncompleteClassPathException e) {
		if (DEBUG){
			System.out.println("Builder handling IncompleteClassPathException"); //$NON-NLS-1$
			 e.printStackTrace();
		}
		IMarker marker = currentProject.createMarker(ProblemMarkerTag);
		marker.setAttribute(IMarker.MESSAGE, Util.bind("build.incompleteClassPath", e.missingClassFile)); //$NON-NLS-1$
		marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
	} catch (MissingSourceFileException e) {

(startLine=142 endLine=151 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00209/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java)
	} catch (MissingSourceFileException e) {
		if (DEBUG){
			System.out.println("Builder handling MissingSourceFileException"); //$NON-NLS-1$
			 e.printStackTrace();
		}
		removeProblemsFor(currentProject); // make this the only problem for this project
		IMarker marker = currentProject.createMarker(ProblemMarkerTag);
		marker.setAttribute(IMarker.MESSAGE, Util.bind("build.missingSourceFile", e.missingSourceFile)); //$NON-NLS-1$
		marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
	} finally {

commonMethod: 
(startLine=541 endLine=549 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00210/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Util.java)
	public static void log(Throwable e, String message) {
		IStatus status= new Status(
			IStatus.ERROR, 
			JavaCore.getPlugin().getDescriptor().getUniqueIdentifier(), 
			IStatus.ERROR, 
			message, 
			e); 
		JavaCore.getPlugin().getLog().log(status);
	}	


, Instance #
frags: 
(startLine=134 endLine=142 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00209/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java)
	} catch (IncompleteClassPathException e) {
		if (DEBUG){
			System.out.println("Builder handling IncompleteClassPathException"); //$NON-NLS-1$
			 e.printStackTrace();
		}
		IMarker marker = currentProject.createMarker(ProblemMarkerTag);
		marker.setAttribute(IMarker.MESSAGE, Util.bind("build.incompleteClassPath", e.missingClassFile)); //$NON-NLS-1$
		marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
	} catch (MissingSourceFileException e) {

(startLine=142 endLine=151 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00209/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java)
	} catch (MissingSourceFileException e) {
		if (DEBUG){
			System.out.println("Builder handling MissingSourceFileException"); //$NON-NLS-1$
			 e.printStackTrace();
		}
		removeProblemsFor(currentProject); // make this the only problem for this project
		IMarker marker = currentProject.createMarker(ProblemMarkerTag);
		marker.setAttribute(IMarker.MESSAGE, Util.bind("build.missingSourceFile", e.missingSourceFile)); //$NON-NLS-1$
		marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
	} finally {

(startLine=110 endLine=122 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00209/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java)
	} catch (CoreException e) {
		if (DEBUG){
			System.out.println("Builder handling CoreException"); //$NON-NLS-1$
			 e.printStackTrace();
		}
		try {
			IMarker marker = currentProject.createMarker(ProblemMarkerTag);
			marker.setAttribute(IMarker.MESSAGE, Util.bind("build.inconsistentProject")); //$NON-NLS-1$
			marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
		} catch (CoreException ignore) {
			throw e;
		}
	} catch (ImageBuilderInternalException e) {

(startLine=122 endLine=134 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00209/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/builder/JavaBuilder.java)
	} catch (ImageBuilderInternalException e) {
		if (DEBUG){
			System.out.println("Builder handling ImageBuilderInternalException"); //$NON-NLS-1$
			 e.printStackTrace();
		}
		try {
			IMarker marker = currentProject.createMarker(ProblemMarkerTag);
			marker.setAttribute(IMarker.MESSAGE, Util.bind("build.inconsistentProject")); //$NON-NLS-1$
			marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR);
		} catch (CoreException ignore) {
			throw e.getThrowable();
		}
	} catch (IncompleteClassPathException e) {

commonMethod: 
(startLine=541 endLine=549 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00210/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Util.java)
	public static void log(Throwable e, String message) {
		IStatus status= new Status(
			IStatus.ERROR, 
			JavaCore.getPlugin().getDescriptor().getUniqueIdentifier(), 
			IStatus.ERROR, 
			message, 
			e); 
		JavaCore.getPlugin().getLog().log(status);
	}	


, Instance #
frags: 
(startLine=100 endLine=129 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00219/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java)
public void codeComplete(char[] snippet,int insertion,int position,char[][] localVariableTypeNames,char[][] localVariableNames,int[] localVariableModifiers,boolean isStatic,ICompletionRequestor requestor) throws JavaModelException {
	if (requestor == null) {
		throw new IllegalArgumentException(Util.bind("codeAssist.nullRequestor")); //$NON-NLS-1$
	}
	
	SearchableEnvironment environment = (SearchableEnvironment) ((JavaProject) getJavaProject()).getSearchableNameEnvironment();
	NameLookup nameLookup = ((JavaProject) getJavaProject()).getNameLookup();
	CompletionEngine engine = new CompletionEngine(environment, new CompletionRequestorWrapper(requestor,nameLookup), JavaCore.getOptions());
	
	String source = getClassFile().getSource();
	if (source != null && insertion > -1 && insertion < source.length()) {
		String encoding = (String) JavaCore.getOptions().get(CompilerOptions.OPTION_Encoding);
		if ("".equals(encoding)) encoding = null; //$NON-NLS-1$
		
		char[] prefix = CharOperation.concat(source.substring(0, insertion).toCharArray(), new char[]{'{'});
		char[] suffix =  CharOperation.concat(new char[]{'}'}, source.substring(insertion).toCharArray());
		char[] fakeSource = CharOperation.concat(prefix, snippet, suffix);
		
		BasicCompilationUnit cu = 
			new BasicCompilationUnit(
				fakeSource, 
				null,
				getElementName(),
				encoding); 

		engine.complete(cu, prefix.length + position, prefix.length);
	} else {
		engine.complete(this, snippet, position, localVariableTypeNames, localVariableNames, localVariableModifiers, isStatic);
	}
}

(startLine=60 endLine=89 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00219/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java)
public void codeComplete(char[] snippet,int insertion,int position,char[][] localVariableTypeNames,char[][] localVariableNames,int[] localVariableModifiers,boolean isStatic,ICompletionRequestor requestor) throws JavaModelException {
	if (requestor == null) {
		throw new IllegalArgumentException(Util.bind("codeAssist.nullRequestor")); //$NON-NLS-1$
	}
	
	SearchableEnvironment environment = (SearchableEnvironment) ((JavaProject) getJavaProject()).getSearchableNameEnvironment();
	NameLookup nameLookup = ((JavaProject) getJavaProject()).getNameLookup();
	CompletionEngine engine = new CompletionEngine(environment, new CompletionRequestorWrapper(requestor,nameLookup), JavaCore.getOptions());
	
	String source = getCompilationUnit().getSource();
	if (source != null && insertion > -1 && insertion < source.length()) {
		String encoding = (String) JavaCore.getOptions().get(CompilerOptions.OPTION_Encoding);
		if ("".equals(encoding)) encoding = null; //$NON-NLS-1$
		
		char[] prefix = CharOperation.concat(source.substring(0, insertion).toCharArray(), new char[]{'{'});
		char[] suffix = CharOperation.concat(new char[]{'}'}, source.substring(insertion).toCharArray());
		char[] fakeSource = CharOperation.concat(prefix, snippet, suffix);
		
		BasicCompilationUnit cu = 
			new BasicCompilationUnit(
				fakeSource, 
				null,
				getElementName(),
				encoding); 

		engine.complete(cu, prefix.length + position, prefix.length);
	} else {
		engine.complete(this, snippet, position, localVariableTypeNames, localVariableNames, localVariableModifiers, isStatic);
	}
}

commonMethod: 
(startLine=906 endLine=925 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00220/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java)
	/**
	 * Helper method for returning one option value only. Equivalent to <code>(String)JavaCore.getOptions().get(optionName)</code>
	 * Note that it may answer <code>null</code> if this option does not exist.
	 * <p>
	 * For a complete description of the configurable options, see <code>getDefaultOptions</code>.
	 * </p>
	 * 
	 * @param optionName - the String name of an option
	 * @return the String value of a given option
	 * @see JavaCore#getDefaultOptions
	 * @since 2.0
	 */
	public static String getOption(String optionName) {
		
		if (CORE_ENCODING.equals(optionName)){
			return ResourcesPlugin.getEncoding();
		}
		Preferences preferences = getPlugin().getPluginPreferences();
		return preferences.getString(optionName);
	}


, Instance #
frags: 
(startLine=110 endLine=126 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00219/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java)
	if (source != null && insertion > -1 && insertion < source.length()) {
		String encoding = (String) JavaCore.getOptions().get(CompilerOptions.OPTION_Encoding);
		if ("".equals(encoding)) encoding = null; //$NON-NLS-1$
		
		char[] prefix = CharOperation.concat(source.substring(0, insertion).toCharArray(), new char[]{'{'});
		char[] suffix =  CharOperation.concat(new char[]{'}'}, source.substring(insertion).toCharArray());
		char[] fakeSource = CharOperation.concat(prefix, snippet, suffix);
		
		BasicCompilationUnit cu = 
			new BasicCompilationUnit(
				fakeSource, 
				null,
				getElementName(),
				encoding); 

		engine.complete(cu, prefix.length + position, prefix.length);
	} else {

(startLine=70 endLine=86 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00219/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java)
	if (source != null && insertion > -1 && insertion < source.length()) {
		String encoding = (String) JavaCore.getOptions().get(CompilerOptions.OPTION_Encoding);
		if ("".equals(encoding)) encoding = null; //$NON-NLS-1$
		
		char[] prefix = CharOperation.concat(source.substring(0, insertion).toCharArray(), new char[]{'{'});
		char[] suffix = CharOperation.concat(new char[]{'}'}, source.substring(insertion).toCharArray());
		char[] fakeSource = CharOperation.concat(prefix, snippet, suffix);
		
		BasicCompilationUnit cu = 
			new BasicCompilationUnit(
				fakeSource, 
				null,
				getElementName(),
				encoding); 

		engine.complete(cu, prefix.length + position, prefix.length);
	} else {

commonMethod: 
(startLine=906 endLine=925 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00220/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java)
	/**
	 * Helper method for returning one option value only. Equivalent to <code>(String)JavaCore.getOptions().get(optionName)</code>
	 * Note that it may answer <code>null</code> if this option does not exist.
	 * <p>
	 * For a complete description of the configurable options, see <code>getDefaultOptions</code>.
	 * </p>
	 * 
	 * @param optionName - the String name of an option
	 * @return the String value of a given option
	 * @see JavaCore#getDefaultOptions
	 * @since 2.0
	 */
	public static String getOption(String optionName) {
		
		if (CORE_ENCODING.equals(optionName)){
			return ResourcesPlugin.getEncoding();
		}
		Preferences preferences = getPlugin().getPluginPreferences();
		return preferences.getString(optionName);
	}


, Instance #
frags: 
(startLine=138 endLine=173 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00219/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitVisitor.java)
		throws JavaModelException {

		CompilationUnitVisitor compilationUnitVisitor =
			new CompilationUnitVisitor(
				getNameEnvironment(unitElement),
				getHandlingPolicy(),
				JavaCore.getOptions(),
				getRequestor(),
				getProblemFactory(visitor));

		CompilationUnitDeclaration unit = null;
		try {
			String encoding = (String) JavaCore.getOptions().get(CompilerOptions.OPTION_Encoding);
			if ("".equals(encoding)) encoding = null; //$NON-NLS-1$

			IPackageFragment packageFragment = (IPackageFragment)unitElement.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
			char[][] expectedPackageName = null;
			if (packageFragment != null){
				expectedPackageName = CharOperation.splitOn('.', packageFragment.getElementName().toCharArray());
			}
			unit =
				compilationUnitVisitor.resolve(
					new BasicCompilationUnit(
						unitElement.getSource().toCharArray(),
						expectedPackageName,
						unitElement.getElementName(),
						encoding));
			if (unit != null) {
				unit.traverse(visitor, unit.scope);
			}
		} finally {
			if (unit != null) {
				unit.cleanUp();
			}
		}
	}

(startLine=140 endLine=175 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00219/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java)
		throws JavaModelException {

		char[] fileName = unitElement.getElementName().toCharArray();
		
		CompilationUnitProblemFinder problemFinder =
			new CompilationUnitProblemFinder(
				getNameEnvironment(unitElement),
				getHandlingPolicy(),
				JavaCore.getOptions(),
				getRequestor(),
				getProblemFactory(fileName, problemRequestor, monitor));

		CompilationUnitDeclaration unit = null;
		try {
			String encoding = (String) JavaCore.getOptions().get(CompilerOptions.OPTION_Encoding);
			if ("".equals(encoding)) encoding = null; //$NON-NLS-1$
			
			IPackageFragment packageFragment = (IPackageFragment)unitElement.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
			char[][] expectedPackageName = null;
			if (packageFragment != null){
				expectedPackageName = CharOperation.splitOn('.', packageFragment.getElementName().toCharArray());
			}
			unit = problemFinder.resolve(
					new BasicCompilationUnit(
						unitElement.getSource().toCharArray(),
						expectedPackageName,
						new String(fileName),
						encoding));
			return unit;
		} finally {
			if (unit != null) {
				unit.cleanUp();
			}
			problemFinder.lookupEnvironment.reset();			
		}
	}

commonMethod: 
(startLine=906 endLine=925 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00220/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java)
	/**
	 * Helper method for returning one option value only. Equivalent to <code>(String)JavaCore.getOptions().get(optionName)</code>
	 * Note that it may answer <code>null</code> if this option does not exist.
	 * <p>
	 * For a complete description of the configurable options, see <code>getDefaultOptions</code>.
	 * </p>
	 * 
	 * @param optionName - the String name of an option
	 * @return the String value of a given option
	 * @see JavaCore#getDefaultOptions
	 * @since 2.0
	 */
	public static String getOption(String optionName) {
		
		if (CORE_ENCODING.equals(optionName)){
			return ResourcesPlugin.getEncoding();
		}
		Preferences preferences = getPlugin().getPluginPreferences();
		return preferences.getString(optionName);
	}


, Instance #
frags: 
(startLine=149 endLine=168 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00219/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitVisitor.java)
		try {
			String encoding = (String) JavaCore.getOptions().get(CompilerOptions.OPTION_Encoding);
			if ("".equals(encoding)) encoding = null; //$NON-NLS-1$

			IPackageFragment packageFragment = (IPackageFragment)unitElement.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
			char[][] expectedPackageName = null;
			if (packageFragment != null){
				expectedPackageName = CharOperation.splitOn('.', packageFragment.getElementName().toCharArray());
			}
			unit =
				compilationUnitVisitor.resolve(
					new BasicCompilationUnit(
						unitElement.getSource().toCharArray(),
						expectedPackageName,
						unitElement.getElementName(),
						encoding));
			if (unit != null) {
				unit.traverse(visitor, unit.scope);
			}
		} finally {

(startLine=153 endLine=169 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00219/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/CompilationUnitProblemFinder.java)
		try {
			String encoding = (String) JavaCore.getOptions().get(CompilerOptions.OPTION_Encoding);
			if ("".equals(encoding)) encoding = null; //$NON-NLS-1$
			
			IPackageFragment packageFragment = (IPackageFragment)unitElement.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
			char[][] expectedPackageName = null;
			if (packageFragment != null){
				expectedPackageName = CharOperation.splitOn('.', packageFragment.getElementName().toCharArray());
			}
			unit = problemFinder.resolve(
					new BasicCompilationUnit(
						unitElement.getSource().toCharArray(),
						expectedPackageName,
						new String(fileName),
						encoding));
			return unit;
		} finally {

commonMethod: 
(startLine=906 endLine=925 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00220/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaCore.java)
	/**
	 * Helper method for returning one option value only. Equivalent to <code>(String)JavaCore.getOptions().get(optionName)</code>
	 * Note that it may answer <code>null</code> if this option does not exist.
	 * <p>
	 * For a complete description of the configurable options, see <code>getDefaultOptions</code>.
	 * </p>
	 * 
	 * @param optionName - the String name of an option
	 * @return the String value of a given option
	 * @see JavaCore#getDefaultOptions
	 * @since 2.0
	 */
	public static String getOption(String optionName) {
		
		if (CORE_ENCODING.equals(optionName)){
			return ResourcesPlugin.getEncoding();
		}
		Preferences preferences = getPlugin().getPluginPreferences();
		return preferences.getString(optionName);
	}


, Instance #
frags: 
(startLine=761 endLine=777 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00219/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
				if (sharedClasspath != null) {
					try {
						classpath = readPaths(sharedClasspath);
					} catch (IOException e) {
					} catch (RuntimeException e) {
					}
					// extract out the output location
					if (classpath != null && classpath.length > 0) {
						IClasspathEntry entry = classpath[classpath.length - 1];
						if (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {
							outputLocation = entry.getPath();
							IClasspathEntry[] copy = new IClasspathEntry[classpath.length - 1];
							System.arraycopy(classpath, 0, copy, 0, copy.length);
							classpath = copy;
						}
					}
				}

(startLine=1203 endLine=1218 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00219/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
		if (sharedClasspath != null) {
			try {
				classpath = readPaths(sharedClasspath);
			} catch (IOException e) {
			} catch (RuntimeException e) {
			}
			// extract out the output location
			if (classpath != null && classpath.length > 0) {
				IClasspathEntry entry = classpath[classpath.length - 1];
				if (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {
					IClasspathEntry[] copy = new IClasspathEntry[classpath.length - 1];
					System.arraycopy(classpath, 0, copy, 0, copy.length);
					classpath = copy;
				}
			}
		}

commonMethod: 
(startLine=552 endLine=560 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00220/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/Util.java)
	public static void log(Throwable e, String message) {
		IStatus status= new Status(
			IStatus.ERROR, 
			JavaCore.getPlugin().getDescriptor().getUniqueIdentifier(), 
			IStatus.ERROR, 
			message, 
			e); 
		JavaCore.getPlugin().getLog().log(status);
	}	


, Instance #
frags: 
(startLine=208 endLine=234 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00260/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					if (fields[i].isStatic()) {
						staticFieldInfo =
							fields[i].analyseCode(
								staticInitializerScope,
								staticInitializerContext,
								staticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (staticFieldInfo == FlowInfo.DeadEnd) {
							staticInitializerScope.problemReporter().initializerMustCompleteNormally(
								fields[i]);
							staticFieldInfo = FlowInfo.initial(maxFieldCount).markAsFakeReachable(true);
						}
					} else {
						nonStaticFieldInfo =
							fields[i].analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (nonStaticFieldInfo == FlowInfo.DeadEnd) {
							initializerScope.problemReporter().initializerMustCompleteNormally(fields[i]);
							nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).markAsFakeReachable(true);
						}
					}
				}
			}

(startLine=381 endLine=407 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00260/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					if (fields[i].isStatic()) {
						staticFieldInfo =
							fields[i].analyseCode(
								staticInitializerScope,
								staticInitializerContext,
								staticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (staticFieldInfo == FlowInfo.DeadEnd) {
							staticInitializerScope.problemReporter().initializerMustCompleteNormally(
								fields[i]);
							staticFieldInfo = FlowInfo.initial(maxFieldCount).markAsFakeReachable(true);
						}
					} else {
						nonStaticFieldInfo =
							fields[i].analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (nonStaticFieldInfo == FlowInfo.DeadEnd) {
							initializerScope.problemReporter().initializerMustCompleteNormally(fields[i]);
							nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).markAsFakeReachable(true);
						}
					}
				}
			}

commonMethod: 
(startLine=862 endLine=869 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00261/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java)
	public final ReferenceBinding getJavaLangThrowable() {
		compilationUnitScope().recordQualifiedReference(JAVA_LANG_THROWABLE);
		ReferenceBinding type = environment().getType(JAVA_LANG_THROWABLE);
		if (type != null) return type;
	
		problemReporter().isClassPathCorrect(JAVA_LANG_THROWABLE, referenceCompilationUnit());
		return null; // will not get here since the above error aborts the compilation
	}


, Instance #
frags: 
(startLine=208 endLine=234 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00260/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					if (fields[i].isStatic()) {
						staticFieldInfo =
							fields[i].analyseCode(
								staticInitializerScope,
								staticInitializerContext,
								staticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (staticFieldInfo == FlowInfo.DeadEnd) {
							staticInitializerScope.problemReporter().initializerMustCompleteNormally(
								fields[i]);
							staticFieldInfo = FlowInfo.initial(maxFieldCount).markAsFakeReachable(true);
						}
					} else {
						nonStaticFieldInfo =
							fields[i].analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (nonStaticFieldInfo == FlowInfo.DeadEnd) {
							initializerScope.problemReporter().initializerMustCompleteNormally(fields[i]);
							nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).markAsFakeReachable(true);
						}
					}
				}
			}

(startLine=381 endLine=407 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00260/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					if (fields[i].isStatic()) {
						staticFieldInfo =
							fields[i].analyseCode(
								staticInitializerScope,
								staticInitializerContext,
								staticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (staticFieldInfo == FlowInfo.DeadEnd) {
							staticInitializerScope.problemReporter().initializerMustCompleteNormally(
								fields[i]);
							staticFieldInfo = FlowInfo.initial(maxFieldCount).markAsFakeReachable(true);
						}
					} else {
						nonStaticFieldInfo =
							fields[i].analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (nonStaticFieldInfo == FlowInfo.DeadEnd) {
							initializerScope.problemReporter().initializerMustCompleteNormally(fields[i]);
							nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).markAsFakeReachable(true);
						}
					}
				}
			}

commonMethod: 
(startLine=862 endLine=869 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00261/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/Scope.java)
	public final ReferenceBinding getJavaLangThrowable() {
		compilationUnitScope().recordQualifiedReference(JAVA_LANG_THROWABLE);
		ReferenceBinding type = environment().getType(JAVA_LANG_THROWABLE);
		if (type != null) return type;
	
		problemReporter().isClassPathCorrect(JAVA_LANG_THROWABLE, referenceCompilationUnit());
		return null; // will not get here since the above error aborts the compilation
	}


, Instance #
frags: 
(startLine=1211 endLine=1236 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.OPEN) != 0) {
					// project has been opened or closed
					IProject res = (IProject)delta.getResource();
					element = this.createElement(res, elementType, project);
					if (element == null) {
						// resource might be containing shared roots (see bug 19058)
						this.updateRoots(res.getFullPath(), delta);
						throw newInvalidElementType();
					}
					if (res.isOpen()) {
						if (this.hasJavaNature(res)) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						}
					} else {
						JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
						boolean wasJavaProject = javaModel.findJavaProject(res) != null;
						if (wasJavaProject) {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							
						}
					}
					return false; // when a project is open/closed don't process children
				}

(startLine=1237 endLine=1258 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.DESCRIPTION) != 0) {
					IProject res = (IProject)delta.getResource();
					JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
					boolean wasJavaProject = javaModel.findJavaProject(res) != null;
					boolean isJavaProject = this.hasJavaNature(res);
					if (wasJavaProject != isJavaProject) {
						// project's nature has been added or removed
						element = this.createElement(res, elementType, project);
						if (element == null) throw newInvalidElementType(); // note its resources are still visible as roots to other projects
						if (isJavaProject) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						} else {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							// reset the corresponding project built state, since cannot reuse if added back
							this.manager.setLastBuiltState(res, null /*no state*/);
						}
						return false; // when a project's nature is added/removed don't process children
					}
				}

commonMethod: 
(startLine=801 endLine=821 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00272/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
	/**
	 * Remove all markers denoting classpath problems
	 */
	protected void flushClasspathProblemMarkers(boolean flushCycleMarkers, boolean flushClasspathFormatMarkers) {
		try {
			IProject project = getProject();
			if (project.exists()) {
				IMarker[] markers = project.findMarkers(IJavaModelMarker.BUILDPATH_PROBLEM_MARKER, false, IResource.DEPTH_ONE);
				for (int i = 0, length = markers.length; i < length; i++) {
					IMarker marker = markers[i];
					String cycleAttr = (String)marker.getAttribute(IJavaModelMarker.CYCLE_DETECTED);
					String classpathFileFormatAttr =  (String)marker.getAttribute(IJavaModelMarker.CLASSPATH_FILE_FORMAT);
					if ((flushCycleMarkers == (cycleAttr != null && cycleAttr.equals("true"))) //$NON-NLS-1$
						&& (flushClasspathFormatMarkers == (classpathFileFormatAttr != null && classpathFileFormatAttr.equals("true")))){ //$NON-NLS-1$
						marker.delete();
					}
				}
			}
		} catch (CoreException e) {
		}
	}


, Instance #
frags: 
(startLine=1211 endLine=1236 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.OPEN) != 0) {
					// project has been opened or closed
					IProject res = (IProject)delta.getResource();
					element = this.createElement(res, elementType, project);
					if (element == null) {
						// resource might be containing shared roots (see bug 19058)
						this.updateRoots(res.getFullPath(), delta);
						throw newInvalidElementType();
					}
					if (res.isOpen()) {
						if (this.hasJavaNature(res)) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						}
					} else {
						JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
						boolean wasJavaProject = javaModel.findJavaProject(res) != null;
						if (wasJavaProject) {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							
						}
					}
					return false; // when a project is open/closed don't process children
				}

(startLine=1237 endLine=1258 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.DESCRIPTION) != 0) {
					IProject res = (IProject)delta.getResource();
					JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
					boolean wasJavaProject = javaModel.findJavaProject(res) != null;
					boolean isJavaProject = this.hasJavaNature(res);
					if (wasJavaProject != isJavaProject) {
						// project's nature has been added or removed
						element = this.createElement(res, elementType, project);
						if (element == null) throw newInvalidElementType(); // note its resources are still visible as roots to other projects
						if (isJavaProject) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						} else {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							// reset the corresponding project built state, since cannot reuse if added back
							this.manager.setLastBuiltState(res, null /*no state*/);
						}
						return false; // when a project's nature is added/removed don't process children
					}
				}

commonMethod: 
(startLine=1846 endLine=1971 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00272/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
	/**
	 * Returns a collection of <code>IClasspathEntry</code>s from the given
	 * classpath string in XML format.
	 *
	 * @exception IOException if the stream cannot be read 
	 */
	protected IClasspathEntry[] readPaths(String xmlClasspath) throws IOException {

		IPath projectPath = getProject().getFullPath();
		StringReader reader = new StringReader(xmlClasspath);
		Element cpElement;

		try {
			DocumentBuilder parser =
				DocumentBuilderFactory.newInstance().newDocumentBuilder();
			cpElement = parser.parse(new InputSource(reader)).getDocumentElement();
		} catch (SAXException e) {
			throw new IOException(Util.bind("file.badFormat")); //$NON-NLS-1$
		} catch (ParserConfigurationException e) {
			reader.close();
			throw new IOException(Util.bind("file.badFormat")); //$NON-NLS-1$
		} finally {
			reader.close();
		}

		if (!cpElement.getNodeName().equalsIgnoreCase("classpath")) { //$NON-NLS-1$
			throw new IOException(Util.bind("file.badFormat")); //$NON-NLS-1$
		}
		NodeList list = cpElement.getChildNodes();
		ArrayList paths = new ArrayList();
		int length = list.getLength();

		for (int i = 0; i < length; ++i) {
			Node node = list.item(i);
			short type = node.getNodeType();
			if (type == Node.ELEMENT_NODE) {
				Element cpeElement = (Element) node;

				if (cpeElement.getNodeName().equalsIgnoreCase("classpathentry")) { //$NON-NLS-1$
					String cpeElementKind = cpeElement.getAttribute("kind"); //$NON-NLS-1$
					String pathStr = cpeElement.getAttribute("path"); //$NON-NLS-1$
					// ensure path is absolute
					IPath path = new Path(pathStr);
					int kind = kindFromString(cpeElementKind);
					if (kind != IClasspathEntry.CPE_VARIABLE && kind != IClasspathEntry.CPE_CONTAINER && !path.isAbsolute()) {
						path = projectPath.append(path);
					}
					// source attachment info (optional)
					String sourceAttachmentPathStr = cpeElement.getAttribute("sourcepath");	//$NON-NLS-1$
					IPath sourceAttachmentPath =
						sourceAttachmentPathStr.equals("") ? null : new Path(sourceAttachmentPathStr); //$NON-NLS-1$
					String sourceAttachmentRootPathStr = cpeElement.getAttribute("rootpath"); //$NON-NLS-1$
					IPath sourceAttachmentRootPath =
						sourceAttachmentRootPathStr.equals("") //$NON-NLS-1$
							? null
							: new Path(sourceAttachmentRootPathStr);
					
					// exported flag
					boolean isExported = cpeElement.getAttribute("exported").equals("true"); //$NON-NLS-1$ //$NON-NLS-2$

					// recreate the CP entry
					switch (kind) {
			
						case IClasspathEntry.CPE_PROJECT :
							if (!path.isAbsolute()) return null;
							paths.add(JavaCore.newProjectEntry(path, isExported));
							break;
							
						case IClasspathEntry.CPE_LIBRARY :
							if (!path.isAbsolute()) return null;
							paths.add(JavaCore.newLibraryEntry(
															path,
															sourceAttachmentPath,
															sourceAttachmentRootPath,
															isExported));
							break;
							
						case IClasspathEntry.CPE_SOURCE :
							if (!path.isAbsolute()) return null;
							// must be an entry in this project or specify another project
							String projSegment = path.segment(0);
							if (projSegment != null && projSegment.equals(getElementName())) {
								// this project
								paths.add(JavaCore.newSourceEntry(path));
							} else {
								// another project
								paths.add(JavaCore.newProjectEntry(path, isExported));
							}
							break;
			
						case IClasspathEntry.CPE_VARIABLE :
							paths.add(JavaCore.newVariableEntry(
									path,
									sourceAttachmentPath,
									sourceAttachmentRootPath, 
									isExported));
							break;
							
						case IClasspathEntry.CPE_CONTAINER :
							paths.add(JavaCore.newContainerEntry(
									path,
									isExported));
							break;

						case ClasspathEntry.K_OUTPUT :
							if (!path.isAbsolute()) return null;
							paths.add(new ClasspathEntry(
									ClasspathEntry.K_OUTPUT,
									IClasspathEntry.CPE_LIBRARY,
									path,
									null,
									null,
									false));
							break;
					}
				}
			}
		}
		if (paths.size() > 0) {
			IClasspathEntry[] ips = new IClasspathEntry[paths.size()];
			paths.toArray(ips);
			return ips;
		} else {
			return null;
		}
	}


, Instance #
frags: 
(startLine=1211 endLine=1236 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.OPEN) != 0) {
					// project has been opened or closed
					IProject res = (IProject)delta.getResource();
					element = this.createElement(res, elementType, project);
					if (element == null) {
						// resource might be containing shared roots (see bug 19058)
						this.updateRoots(res.getFullPath(), delta);
						throw newInvalidElementType();
					}
					if (res.isOpen()) {
						if (this.hasJavaNature(res)) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						}
					} else {
						JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
						boolean wasJavaProject = javaModel.findJavaProject(res) != null;
						if (wasJavaProject) {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							
						}
					}
					return false; // when a project is open/closed don't process children
				}

(startLine=1237 endLine=1258 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.DESCRIPTION) != 0) {
					IProject res = (IProject)delta.getResource();
					JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
					boolean wasJavaProject = javaModel.findJavaProject(res) != null;
					boolean isJavaProject = this.hasJavaNature(res);
					if (wasJavaProject != isJavaProject) {
						// project's nature has been added or removed
						element = this.createElement(res, elementType, project);
						if (element == null) throw newInvalidElementType(); // note its resources are still visible as roots to other projects
						if (isJavaProject) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						} else {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							// reset the corresponding project built state, since cannot reuse if added back
							this.manager.setLastBuiltState(res, null /*no state*/);
						}
						return false; // when a project's nature is added/removed don't process children
					}
				}

commonMethod: 
(startLine=1681 endLine=1707 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00272/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
	/**
	 * Compare current classpath with given one to see if any different.
	 * Note that the argument classpath contains its binary output.
	 */
	public boolean isClasspathEqualsTo(IClasspathEntry[] newClasspath, IPath newOutputLocation, IClasspathEntry[] otherClasspathWithOutput)
		throws JavaModelException {

		if (otherClasspathWithOutput != null && otherClasspathWithOutput.length > 0) {

			int length = otherClasspathWithOutput.length;
			if (length == newClasspath.length + 1) {
				// output is amongst file entries (last one)

				// compare classpath entries
				for (int i = 0; i < length - 1; i++) {
					if (!otherClasspathWithOutput[i].equals(newClasspath[i]))
						return false;
				}
				// compare binary outputs
				if (otherClasspathWithOutput[length - 1].getContentKind()
					== ClasspathEntry.K_OUTPUT
					&& otherClasspathWithOutput[length - 1].getPath().equals(newOutputLocation))
					return true;
			}
		}
		return false;
	}


, Instance #
frags: 
(startLine=1211 endLine=1236 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.OPEN) != 0) {
					// project has been opened or closed
					IProject res = (IProject)delta.getResource();
					element = this.createElement(res, elementType, project);
					if (element == null) {
						// resource might be containing shared roots (see bug 19058)
						this.updateRoots(res.getFullPath(), delta);
						throw newInvalidElementType();
					}
					if (res.isOpen()) {
						if (this.hasJavaNature(res)) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						}
					} else {
						JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
						boolean wasJavaProject = javaModel.findJavaProject(res) != null;
						if (wasJavaProject) {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							
						}
					}
					return false; // when a project is open/closed don't process children
				}

(startLine=1237 endLine=1258 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.DESCRIPTION) != 0) {
					IProject res = (IProject)delta.getResource();
					JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
					boolean wasJavaProject = javaModel.findJavaProject(res) != null;
					boolean isJavaProject = this.hasJavaNature(res);
					if (wasJavaProject != isJavaProject) {
						// project's nature has been added or removed
						element = this.createElement(res, elementType, project);
						if (element == null) throw newInvalidElementType(); // note its resources are still visible as roots to other projects
						if (isJavaProject) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						} else {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							// reset the corresponding project built state, since cannot reuse if added back
							this.manager.setLastBuiltState(res, null /*no state*/);
						}
						return false; // when a project's nature is added/removed don't process children
					}
				}

commonMethod: 
(startLine=1366 endLine=1405 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00272/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
	/**
	 * @see IJavaProject
	 */
	public IClasspathEntry[] getRawClasspath() throws JavaModelException {

		JavaModelManager.PerProjectInfo perProjectInfo = getJavaModelManager().getPerProjectInfoCheckExistence(fProject);
		IClasspathEntry[] classpath = perProjectInfo.classpath;
		if (classpath != null) return classpath;
		try {
			String sharedClasspath = loadClasspath();
			if (sharedClasspath != null) {
				classpath = readPaths(sharedClasspath);
			}
		} catch(JavaModelException e) {
			if (JavaModelManager.VERBOSE && this.getProject().isAccessible()){
				Util.log(e, 
					"Exception while retrieving "+ this.getPath() //$NON-NLS-1$
					+"/.classpath, will revert to default classpath"); //$NON-NLS-1$
			}
		} catch(IOException e){
			if (JavaModelManager.VERBOSE && this.getProject().isAccessible()){
				Util.log(e, 
					"Exception while retrieving "+ this.getPath() //$NON-NLS-1$
					+"/.classpath, will revert to default classpath"); //$NON-NLS-1$
			}
		}
		// extract out the output location
		if (classpath != null && classpath.length > 0) {
			IClasspathEntry entry = classpath[classpath.length - 1];
			if (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {
				IClasspathEntry[] copy = new IClasspathEntry[classpath.length - 1];
				System.arraycopy(classpath, 0, copy, 0, copy.length);
				classpath = copy;
			}
		}
		if (classpath != null) {
			return classpath;
		}
		return defaultClasspath();
	}


, Instance #
frags: 
(startLine=1211 endLine=1236 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.OPEN) != 0) {
					// project has been opened or closed
					IProject res = (IProject)delta.getResource();
					element = this.createElement(res, elementType, project);
					if (element == null) {
						// resource might be containing shared roots (see bug 19058)
						this.updateRoots(res.getFullPath(), delta);
						throw newInvalidElementType();
					}
					if (res.isOpen()) {
						if (this.hasJavaNature(res)) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						}
					} else {
						JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
						boolean wasJavaProject = javaModel.findJavaProject(res) != null;
						if (wasJavaProject) {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							
						}
					}
					return false; // when a project is open/closed don't process children
				}

(startLine=1237 endLine=1258 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.DESCRIPTION) != 0) {
					IProject res = (IProject)delta.getResource();
					JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
					boolean wasJavaProject = javaModel.findJavaProject(res) != null;
					boolean isJavaProject = this.hasJavaNature(res);
					if (wasJavaProject != isJavaProject) {
						// project's nature has been added or removed
						element = this.createElement(res, elementType, project);
						if (element == null) throw newInvalidElementType(); // note its resources are still visible as roots to other projects
						if (isJavaProject) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						} else {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							// reset the corresponding project built state, since cannot reuse if added back
							this.manager.setLastBuiltState(res, null /*no state*/);
						}
						return false; // when a project's nature is added/removed don't process children
					}
				}

commonMethod: 
(startLine=1128 endLine=1176 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00272/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
	/**
	 * @see IJavaProject
	 */
	public IPath getOutputLocation() throws JavaModelException {

		IPath outputLocation = null;
		if (this.isOpen()) {
			JavaProjectElementInfo info = getJavaProjectElementInfo();
			outputLocation = info.getOutputLocation();
			if (outputLocation != null) {
				return outputLocation;
			}
			return defaultOutputLocation();
		}
		// if not already opened, then read from file (avoid populating the model for CP question)
		if (!this.getProject().exists()){
			throw newNotPresentException();
		}
		IClasspathEntry[] classpath = null;
		try {
			String sharedClasspath = loadClasspath();
			if (sharedClasspath != null) {
				classpath = readPaths(sharedClasspath);
			}
		} catch(JavaModelException e) {
			if (JavaModelManager.VERBOSE && this.getProject().isAccessible()){
				Util.log(e, 
					"Exception while retrieving "+ this.getPath() //$NON-NLS-1$
					+"/.classpath, will revert to default output location"); //$NON-NLS-1$
			}
		} catch(IOException e){
			if (JavaModelManager.VERBOSE && this.getProject().isAccessible()){
				Util.log(e, 
					"Exception while retrieving "+ this.getPath() //$NON-NLS-1$
					+"/.classpath, will revert to default output location"); //$NON-NLS-1$
			}
		}
		// extract out the output location
		if (classpath != null && classpath.length > 0) {
			IClasspathEntry entry = classpath[classpath.length - 1];
			if (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {
				outputLocation = entry.getPath();
			}
		}
		if (outputLocation != null) {
			return outputLocation;
		}
		return defaultOutputLocation();
	}


, Instance #
frags: 
(startLine=1211 endLine=1236 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.OPEN) != 0) {
					// project has been opened or closed
					IProject res = (IProject)delta.getResource();
					element = this.createElement(res, elementType, project);
					if (element == null) {
						// resource might be containing shared roots (see bug 19058)
						this.updateRoots(res.getFullPath(), delta);
						throw newInvalidElementType();
					}
					if (res.isOpen()) {
						if (this.hasJavaNature(res)) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						}
					} else {
						JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
						boolean wasJavaProject = javaModel.findJavaProject(res) != null;
						if (wasJavaProject) {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							
						}
					}
					return false; // when a project is open/closed don't process children
				}

(startLine=1237 endLine=1258 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00271/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
				if ((flags & IResourceDelta.DESCRIPTION) != 0) {
					IProject res = (IProject)delta.getResource();
					JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
					boolean wasJavaProject = javaModel.findJavaProject(res) != null;
					boolean isJavaProject = this.hasJavaNature(res);
					if (wasJavaProject != isJavaProject) {
						// project's nature has been added or removed
						element = this.createElement(res, elementType, project);
						if (element == null) throw newInvalidElementType(); // note its resources are still visible as roots to other projects
						if (isJavaProject) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						} else {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							// reset the corresponding project built state, since cannot reuse if added back
							this.manager.setLastBuiltState(res, null /*no state*/);
						}
						return false; // when a project's nature is added/removed don't process children
					}
				}

commonMethod: 
(startLine=2009 endLine=2044 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00272/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
	/**
	 * Saves the classpath in a shareable format (VCM-wise) if necessary.
	 *  (i.e.&nbsp;semantically different).
	 * Will never write an identical one.
	 * 
	 * @return Return whether the .classpath file was modified.
	 */
	public boolean saveClasspath(IClasspathEntry[] newClasspath, IPath newOutputLocation) throws JavaModelException {

		if (!getProject().exists()) return false;

		try {
			// attempt to prove the classpath has not change
			String fileClasspathString = getSharedProperty(CLASSPATH_FILENAME);
			if (fileClasspathString != null) {
				IClasspathEntry[] fileEntries = readPaths(fileClasspathString);
				if (isClasspathEqualsTo(newClasspath, newOutputLocation, fileEntries)) {
					// no need to save it, it is the same
					return false;
				}
			}
		} catch (IOException e) {
		} catch (RuntimeException e) {
		} catch (CoreException e) {
		}

		// actual file saving
		try {
			setSharedProperty(
				CLASSPATH_FILENAME,
				getClasspathAsXML(newClasspath, newOutputLocation));
			return true;
		} catch (CoreException e) {
			throw new JavaModelException(e);
		}
	}


, Instance #
frags: 
(startLine=836 endLine=899 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00283/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
		IResource underlyingResource)	throws JavaModelException {

		boolean validInfo = false;
		try {
			if (((IProject) getUnderlyingResource()).isOpen()) {
				// put the info now, because setting the classpath requires it
				JavaModelManager.getJavaModelManager().putInfo(this, info);

				// read classpath property (contains actual classpath and output location settings)
				IPath outputLocation = null;
				IClasspathEntry[] classpath = null;

				// read from file
				try {
					String sharedClasspath = loadClasspath();
					if (sharedClasspath != null) {
						classpath = readPaths(sharedClasspath);
					}
				} catch(JavaModelException e) {
					if (JavaModelManager.VERBOSE && this.getProject().isAccessible()){
							Util.log(e, 
								"Exception while retrieving "+ this.getPath() //$NON-NLS-1$
								+"/.classpath, will revert to default classpath"); //$NON-NLS-1$
					}
				} catch(IOException e){
					if (JavaModelManager.VERBOSE && this.getProject().isAccessible()){
						Util.log(e, 
							"Exception while retrieving "+ this.getPath() //$NON-NLS-1$
							+"/.classpath, will revert to default classpath"); //$NON-NLS-1$
					}
				}

				// extract out the output location
				if (classpath != null && classpath.length > 0) {
					IClasspathEntry entry = classpath[classpath.length - 1];
					if (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {
						outputLocation = entry.getPath();
						IClasspathEntry[] copy = new IClasspathEntry[classpath.length - 1];
						System.arraycopy(classpath, 0, copy, 0, copy.length);
						classpath = copy;
					}
				}
				// restore output location				
				if (outputLocation == null) {
					outputLocation = defaultOutputLocation();
				}
				((JavaProjectElementInfo)info).setOutputLocation(outputLocation);

				// restore classpath
				if (classpath == null) {
					classpath = defaultClasspath();
				}
				setRawClasspath0(classpath);

				// only valid if reaches here				
				validInfo = true;
			}
		} catch (JavaModelException e) {
		} finally {
			if (!validInfo)
				JavaModelManager.getJavaModelManager().removeInfo(this);
		}
		return validInfo;
	}

(startLine=1375 endLine=1411 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00283/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
	public IClasspathEntry[] getRawClasspath() throws JavaModelException {

		JavaModelManager.PerProjectInfo perProjectInfo = getJavaModelManager().getPerProjectInfoCheckExistence(fProject);
		IClasspathEntry[] classpath = perProjectInfo.classpath;
		if (classpath != null) return classpath;
		try {
			String sharedClasspath = loadClasspath();
			if (sharedClasspath != null) {
				classpath = readPaths(sharedClasspath);
			}
		} catch(JavaModelException e) {
			if (JavaModelManager.VERBOSE && this.getProject().isAccessible()){
				Util.log(e, 
					"Exception while retrieving "+ this.getPath() //$NON-NLS-1$
					+"/.classpath, will revert to default classpath"); //$NON-NLS-1$
			}
		} catch(IOException e){
			if (JavaModelManager.VERBOSE && this.getProject().isAccessible()){
				Util.log(e, 
					"Exception while retrieving "+ this.getPath() //$NON-NLS-1$
					+"/.classpath, will revert to default classpath"); //$NON-NLS-1$
			}
		}
		// extract out the output location
		if (classpath != null && classpath.length > 0) {
			IClasspathEntry entry = classpath[classpath.length - 1];
			if (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {
				IClasspathEntry[] copy = new IClasspathEntry[classpath.length - 1];
				System.arraycopy(classpath, 0, copy, 0, copy.length);
				classpath = copy;
			}
		}
		if (classpath != null) {
			return classpath;
		}
		return defaultClasspath();
	}

commonMethod: 
(startLine=1818 endLine=1993 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00284/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
	/**
	 * Reads the .classpath file from disk and returns the list of entries it contains (including output location entry)
	 * Returns null if .classfile is not present.
	 * Returns INVALID_CLASSPATH if it has a format problem.
	 */
	protected IClasspathEntry[] readClasspathFile(boolean createMarker, boolean logProblems) {

		ArrayList paths = new ArrayList();
		try {
			String xmlClasspath = getSharedProperty(CLASSPATH_FILENAME);
			if (xmlClasspath == null) return null;
			StringReader reader = new StringReader(xmlClasspath);
			Element cpElement;
	
			try {
				DocumentBuilder parser =
					DocumentBuilderFactory.newInstance().newDocumentBuilder();
				cpElement = parser.parse(new InputSource(reader)).getDocumentElement();
			} catch (SAXException e) {
				throw new IOException(Util.bind("file.badFormat")); //$NON-NLS-1$
			} catch (ParserConfigurationException e) {
				reader.close();
				throw new IOException(Util.bind("file.badFormat")); //$NON-NLS-1$
			} finally {
				reader.close();
			}
	
			if (!cpElement.getNodeName().equalsIgnoreCase("classpath")) { //$NON-NLS-1$
				throw new IOException(Util.bind("file.badFormat")); //$NON-NLS-1$
			}
			IPath projectPath = getProject().getFullPath();
			NodeList list = cpElement.getChildNodes();
			int length = list.getLength();
	
			for (int i = 0; i < length; ++i) {
				Node node = list.item(i);
				short type = node.getNodeType();
				if (type == Node.ELEMENT_NODE) {
					Element cpeElement = (Element) node;
	
					if (cpeElement.getNodeName().equalsIgnoreCase("classpathentry")) { //$NON-NLS-1$
						String cpeElementKind = cpeElement.getAttribute("kind"); //$NON-NLS-1$
						String pathStr = cpeElement.getAttribute("path"); //$NON-NLS-1$
						// ensure path is absolute
						IPath path = new Path(pathStr);
						int kind = kindFromString(cpeElementKind);
						if (kind != IClasspathEntry.CPE_VARIABLE && kind != IClasspathEntry.CPE_CONTAINER && !path.isAbsolute()) {
							path = projectPath.append(path);
						}
						// source attachment info (optional)
						String sourceAttachmentPathStr = cpeElement.getAttribute("sourcepath");	//$NON-NLS-1$
						IPath sourceAttachmentPath =
							sourceAttachmentPathStr.equals("") ? null : new Path(sourceAttachmentPathStr); //$NON-NLS-1$
						String sourceAttachmentRootPathStr = cpeElement.getAttribute("rootpath"); //$NON-NLS-1$
						IPath sourceAttachmentRootPath =
							sourceAttachmentRootPathStr.equals("") //$NON-NLS-1$
								? null
								: new Path(sourceAttachmentRootPathStr);
						
						// exported flag
						boolean isExported = cpeElement.getAttribute("exported").equals("true"); //$NON-NLS-1$ //$NON-NLS-2$
	
						// recreate the CP entry
						switch (kind) {
				
							case IClasspathEntry.CPE_PROJECT :
								if (!path.isAbsolute()) return null;
								paths.add(JavaCore.newProjectEntry(path, isExported));
								break;
								
							case IClasspathEntry.CPE_LIBRARY :
								if (!path.isAbsolute()) return null;
								paths.add(JavaCore.newLibraryEntry(
																path,
																sourceAttachmentPath,
																sourceAttachmentRootPath,
																isExported));
								break;
								
							case IClasspathEntry.CPE_SOURCE :
								if (!path.isAbsolute()) return null;
								// must be an entry in this project or specify another project
								String projSegment = path.segment(0);
								if (projSegment != null && projSegment.equals(getElementName())) {
									// this project
									paths.add(JavaCore.newSourceEntry(path));
								} else {
									// another project
									paths.add(JavaCore.newProjectEntry(path, isExported));
								}
								break;
				
							case IClasspathEntry.CPE_VARIABLE :
								paths.add(JavaCore.newVariableEntry(
										path,
										sourceAttachmentPath,
										sourceAttachmentRootPath, 
										isExported));
								break;
								
							case IClasspathEntry.CPE_CONTAINER :
								paths.add(JavaCore.newContainerEntry(
										path,
										isExported));
								break;
	
							case ClasspathEntry.K_OUTPUT :
								if (!path.isAbsolute()) return null;
								paths.add(new ClasspathEntry(
										ClasspathEntry.K_OUTPUT,
										IClasspathEntry.CPE_LIBRARY,
										path,
										null,
										null,
										false));
								break;
								
							default:
								throw new Assert.AssertionFailedException(Util.bind("classpath.unknownKind", cpeElementKind)); //$NON-NLS-1$
						}
					}
				}
			}
		} catch(CoreException e) {
			// file does not exist (or not accessible)
			if (createMarker && this.getProject().isAccessible()) {
				this.createClasspathProblemMarker(
					Util.bind("classpath.cannotReadClasspathFile", this.getElementName()), //$NON-NLS-1$
					IMarker.SEVERITY_ERROR,
					false,	//  cycle error
					true);	//	file format error
			}
			if (logProblems) {
				Util.log(e, 
					"Exception while retrieving "+ this.getPath() //$NON-NLS-1$
					+"/.classpath, will revert to default classpath"); //$NON-NLS-1$
			}
		} catch (IOException e) {
			// bad format
			if (createMarker && this.getProject().isAccessible()) {
				this.createClasspathProblemMarker(
					Util.bind("classpath.cannotReadClasspathFile", this.getElementName()), //$NON-NLS-1$
					IMarker.SEVERITY_ERROR,
					false,	//  cycle error
					true);	//	file format error
			}
			if (logProblems) {
				Util.log(e, 
					"Exception while retrieving "+ this.getPath() //$NON-NLS-1$
					+"/.classpath, will revert to default classpath"); //$NON-NLS-1$
			}
			return INVALID_CLASSPATH;
		} catch (Assert.AssertionFailedException e) { 
			// failed creating CP entries from file
			if (createMarker && this.getProject().isAccessible()) {
				this.createClasspathProblemMarker(
					Util.bind("classpath.illegalEntryInClasspathFile", this.getElementName(), e.getMessage()), //$NON-NLS-1$
					IMarker.SEVERITY_ERROR,
					false,	//  cycle error
					true);	//	file format error
			}
			if (logProblems) {
				Util.log(e, 
					"Exception while retrieving "+ this.getPath() //$NON-NLS-1$
					+"/.classpath, will mark classpath as invalid"); //$NON-NLS-1$
			}
			return INVALID_CLASSPATH;
		}
		if (paths.size() > 0) {
			IClasspathEntry[] ips = new IClasspathEntry[paths.size()];
			paths.toArray(ips);
			return ips;
		} else {
			return null;
		}
	}


, Instance #
frags: 
(startLine=1248 endLine=1259 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00283/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
						}
					} catch(JavaModelException e) {
						if (project.getProject().isAccessible()) {
							Util.log(e, 
								"Exception while retrieving "+ project.getPath() //$NON-NLS-1$
								+"/.classpath, ignore change"); //$NON-NLS-1$
						}
						project.createClasspathProblemMarker(
							Util.bind("classpath.cannotReadClasspathFile", project.getElementName()), //$NON-NLS-1$
							IMarker.SEVERITY_ERROR,
							false,	//  cycle error
							true);	//	file format error

(startLine=1259 endLine=1270 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00283/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
							true);	//	file format error
					} catch (IOException e) {
						if (project.getProject().isAccessible()) {
							Util.log(e, 
								"Exception while retrieving "+ project.getPath() //$NON-NLS-1$
								+"/.classpath, ignore change"); //$NON-NLS-1$
						}
						project.createClasspathProblemMarker(
							Util.bind("classpath.cannotReadClasspathFile", project.getElementName()), //$NON-NLS-1$
							IMarker.SEVERITY_ERROR,
							false,	//  cycle error
							true);	//	file format error

commonMethod: 
(startLine=79 endLine=94 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00284/org.eclipse.jdt.core/model/org/eclipse/jdt/core/JavaModelException.java)
/**
 * Returns the Java model status object for this exception.
 * Equivalent to <code>(IJavaModelStatus) getStatus()</code>.
 *
 * @return a status object
 */
public IJavaModelStatus getJavaModelStatus() {
	IStatus status = this.getStatus();
	if (status instanceof IJavaModelStatus) {
		return (IJavaModelStatus)status;
	} else {
		// A regular IStatus is created only in the case of a CoreException.
		// See bug 13492 Should handle JavaModelExceptions that contains CoreException more gracefully  
		return new JavaModelStatus(this.nestedCoreException);
	}
}


, Instance #
frags: 
(startLine=1248 endLine=1259 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00283/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
						}
					} catch(JavaModelException e) {
						if (project.getProject().isAccessible()) {
							Util.log(e, 
								"Exception while retrieving "+ project.getPath() //$NON-NLS-1$
								+"/.classpath, ignore change"); //$NON-NLS-1$
						}
						project.createClasspathProblemMarker(
							Util.bind("classpath.cannotReadClasspathFile", project.getElementName()), //$NON-NLS-1$
							IMarker.SEVERITY_ERROR,
							false,	//  cycle error
							true);	//	file format error

(startLine=1259 endLine=1270 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00283/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/DeltaProcessor.java)
							true);	//	file format error
					} catch (IOException e) {
						if (project.getProject().isAccessible()) {
							Util.log(e, 
								"Exception while retrieving "+ project.getPath() //$NON-NLS-1$
								+"/.classpath, ignore change"); //$NON-NLS-1$
						}
						project.createClasspathProblemMarker(
							Util.bind("classpath.cannotReadClasspathFile", project.getElementName()), //$NON-NLS-1$
							IMarker.SEVERITY_ERROR,
							false,	//  cycle error
							true);	//	file format error

commonMethod: 
(startLine=2262 endLine=2285 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00284/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaProject.java)
	/**
	 * NOTE: <code>null</code> specifies default classpath, and an empty
	 * array specifies an empty classpath.
	 *
	 * @exception NotPresentException if this project does not exist.
	 */
	protected void setRawClasspath0(IClasspathEntry[] rawEntries)
		throws JavaModelException {

		JavaModelManager.PerProjectInfo info = getJavaModelManager().getPerProjectInfoCheckExistence(fProject);
	
		synchronized (info) {
			if (rawEntries == null) {
				rawEntries = defaultClasspath();
			}
			// clear cache of resolved classpath
			info.lastResolvedClasspath = null;
			
			info.classpath = rawEntries;
				
			// compute the new roots
			updatePackageFragmentRoots();				
		}
	}


, Instance #
frags: 
(startLine=378 endLine=397 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00313/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java)
		if (left.constant == NullConstant.Default) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifnull(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifnonnull(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=400 endLine=419 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00313/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java)
			&& (inline.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifeq(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifne(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

commonMethod: 
(startLine=2127 endLine=2170 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00314/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * We didn't call it goto, because there is a conflit with the goto keyword
 */
final public void goto_(Label lbl) {
	if (this.wideMode) {
		this.goto_w(lbl);
		return;
	}
	try {
		lbl.inlineForwardReferencesFromLabelsTargeting(position);
		/*
		 Possible optimization for code such as:
		 public Object foo() {
			boolean b = true;
			if (b) {
				if (b)
					return null;
			} else {
				if (b) {
					return null;
				}
			}
			return null;
		}
		The goto around the else block for the first if will
		be unreachable, because the thenClause of the second if
		returns.
		See inlineForwardReferencesFromLabelsTargeting defined
		on the Label class for the remaining part of this
		optimization.
		 if (!lbl.isBranchTarget(position)) {
			switch(bCodeStream[classFileOffset-1]) {
				case OPC_return :
				case OPC_areturn:
					return;
			}
		}*/
		position++;
		bCodeStream[classFileOffset++] = OPC_goto;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_goto);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=332 endLine=375 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00313/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java)
	if ((inline = right.constant) != NotAConstant) {
		// optimized case: x == null
		if (right.constant == NullConstant.Default) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifnull(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifnonnull(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}
		// optimized case: x == 0
		if (((left.implicitConversion >> 4) == T_int) && (inline.intValue() == 0)) {
			left.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifeq(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifne(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}
	}

(startLine=376 endLine=420 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00313/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java)
	if ((inline = left.constant) != NotAConstant) {
		// optimized case: null == x
		if (left.constant == NullConstant.Default) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifnull(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifnonnull(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}
		// optimized case: 0 == x
		if (((left.implicitConversion >> 4) == T_int)
			&& (inline.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifeq(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifne(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}
	}

commonMethod: 
(startLine=2127 endLine=2170 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00314/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * We didn't call it goto, because there is a conflit with the goto keyword
 */
final public void goto_(Label lbl) {
	if (this.wideMode) {
		this.goto_w(lbl);
		return;
	}
	try {
		lbl.inlineForwardReferencesFromLabelsTargeting(position);
		/*
		 Possible optimization for code such as:
		 public Object foo() {
			boolean b = true;
			if (b) {
				if (b)
					return null;
			} else {
				if (b) {
					return null;
				}
			}
			return null;
		}
		The goto around the else block for the first if will
		be unreachable, because the thenClause of the second if
		returns.
		See inlineForwardReferencesFromLabelsTargeting defined
		on the Label class for the remaining part of this
		optimization.
		 if (!lbl.isBranchTarget(position)) {
			switch(bCodeStream[classFileOffset-1]) {
				case OPC_return :
				case OPC_areturn:
					return;
			}
		}*/
		position++;
		bCodeStream[classFileOffset++] = OPC_goto;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_goto);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=378 endLine=397 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00313/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java)
		if (left.constant == NullConstant.Default) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifnull(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifnonnull(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

(startLine=400 endLine=419 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00313/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java)
			&& (inline.intValue() == 0)) {
			right.generateCode(currentScope, codeStream, valueRequired);
			if (valueRequired) {
				if (falseLabel == null) {
					if (trueLabel != null) {
						// implicit falling through the FALSE case
						codeStream.ifeq(trueLabel);
					}
				} else {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.ifne(falseLabel);
					} else {
						// no implicit fall through TRUE/FALSE --> should never occur
					}
				}
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		}

commonMethod: 
(startLine=2127 endLine=2170 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00314/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
/**
 * We didn't call it goto, because there is a conflit with the goto keyword
 */
final public void goto_(Label lbl) {
	if (this.wideMode) {
		this.goto_w(lbl);
		return;
	}
	try {
		lbl.inlineForwardReferencesFromLabelsTargeting(position);
		/*
		 Possible optimization for code such as:
		 public Object foo() {
			boolean b = true;
			if (b) {
				if (b)
					return null;
			} else {
				if (b) {
					return null;
				}
			}
			return null;
		}
		The goto around the else block for the first if will
		be unreachable, because the thenClause of the second if
		returns.
		See inlineForwardReferencesFromLabelsTargeting defined
		on the Label class for the remaining part of this
		optimization.
		 if (!lbl.isBranchTarget(position)) {
			switch(bCodeStream[classFileOffset-1]) {
				case OPC_return :
				case OPC_areturn:
					return;
			}
		}*/
		position++;
		bCodeStream[classFileOffset++] = OPC_goto;
	} catch (IndexOutOfBoundsException e) {
		resizeByteArray(OPC_goto);
	}
	lbl.branch();
}


, Instance #
frags: 
(startLine=141 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					FieldDeclaration field = fields[i];
					/*if (field.isField() && !this.binding.isAnonymousType()){
						initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2, except for anonymous
					} else {*/
					initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					fieldInfo = field.analyseCode(initializerScope, initializerContext, fieldInfo);
					if (fieldInfo == FlowInfo.DEAD_END) {
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						initializerScope.problemReporter().initializerMustCompleteNormally(field);
						fieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				}
			}

(startLine=298 endLine=317 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					FieldDeclaration field = fields[i];
					/*if (field.isField()){
						initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
					initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					if (!fields[i].isStatic()) {
						fieldInfo =
							field.analyseCode(initializerScope, initializerContext, fieldInfo);
						if (fieldInfo == FlowInfo.DEAD_END) {
							// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
							// branch, since the previous initializer already got the blame.
							initializerScope.problemReporter().initializerMustCompleteNormally(field);
							fieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
						}
					}
				}
			}

commonMethod: 
(startLine=782 endLine=866 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00350/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
	/**
	 *	Common flow analysis for all types
	 *
	 */
	public void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {

		if (this.binding.isPrivate() && !this.binding.isPrivateUsed()) {
			if (!scope.referenceCompilationUnit().compilationResult.hasSyntaxError()) {
				scope.problemReporter().unusedPrivateType(this);
			}
		}

		ReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception
		InitializationFlowContext initializerContext = new InitializationFlowContext(null, this, initializerScope);
		InitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, staticInitializerScope);
		FlowInfo nonStaticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		FlowInfo staticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		if (fields != null) {
			for (int i = 0, count = fields.length; i < count; i++) {
				FieldDeclaration field = fields[i];
				if (field.isStatic()) {
					/*if (field.isField()){
						staticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
					staticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					staticFieldInfo =
						field.analyseCode(
							staticInitializerScope,
							staticInitializerContext,
							staticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (staticFieldInfo == FlowInfo.DEAD_END) {
						staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
						staticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				} else {
					/*if (field.isField()){
						initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
						initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					nonStaticFieldInfo =
						field.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
						initializerScope.problemReporter().initializerMustCompleteNormally(field);
						nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				}
			}
		}
		if (memberTypes != null) {
			for (int i = 0, count = memberTypes.length; i < count; i++) {
				if (flowContext != null){ // local type
					memberTypes[i].analyseCode(scope, flowContext, nonStaticFieldInfo.copy());
				} else {
					memberTypes[i].analyseCode(scope);
				}
			}
		}
		if (methods != null) {
			UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
			FlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
			for (int i = 0, count = methods.length; i < count; i++) {
				AbstractMethodDeclaration method = methods[i];
				if (method.ignoreFurtherInvestigation)
					continue;
				if (method.isInitializationMethod()) {
					if (method.isStatic()) { // <clinit>
						((Clinit)method).analyseCode(
							scope, 
							staticInitializerContext, 
							staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
					} else { // constructor
						((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
					}
				} else { // regular method
					((MethodDeclaration)method).analyseCode(scope, null, flowInfo.copy());
				}
			}
		}
	}


, Instance #
frags: 
(startLine=163 endLine=176 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (methods != null) {
				UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
				FlowInfo constructorInfo = fieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
				for (int i = 0, count = methods.length; i < count; i++) {
					AbstractMethodDeclaration method = methods[i];
					if (method.ignoreFurtherInvestigation)
						continue;
					if (method.isConstructor()) { // constructor
						((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
					} else { // regular method
						method.analyseCode(scope, null, flowInfo.copy());
					}
				}
			}

(startLine=323 endLine=337 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (methods != null) {
				UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
				FlowInfo constructorInfo = fieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
				for (int i = 0, count = methods.length; i < count; i++) {
					AbstractMethodDeclaration method = methods[i];
					if (method.ignoreFurtherInvestigation)
						continue;

					if (method.isConstructor()) { // constructor
						((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
					} else { // regular method
						method.analyseCode(scope, null, flowInfo.copy());
					}
				}
			}

commonMethod: 
(startLine=782 endLine=866 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00350/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
	/**
	 *	Common flow analysis for all types
	 *
	 */
	public void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {

		if (this.binding.isPrivate() && !this.binding.isPrivateUsed()) {
			if (!scope.referenceCompilationUnit().compilationResult.hasSyntaxError()) {
				scope.problemReporter().unusedPrivateType(this);
			}
		}

		ReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception
		InitializationFlowContext initializerContext = new InitializationFlowContext(null, this, initializerScope);
		InitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, staticInitializerScope);
		FlowInfo nonStaticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		FlowInfo staticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		if (fields != null) {
			for (int i = 0, count = fields.length; i < count; i++) {
				FieldDeclaration field = fields[i];
				if (field.isStatic()) {
					/*if (field.isField()){
						staticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
					staticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					staticFieldInfo =
						field.analyseCode(
							staticInitializerScope,
							staticInitializerContext,
							staticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (staticFieldInfo == FlowInfo.DEAD_END) {
						staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
						staticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				} else {
					/*if (field.isField()){
						initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
						initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					nonStaticFieldInfo =
						field.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
						initializerScope.problemReporter().initializerMustCompleteNormally(field);
						nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				}
			}
		}
		if (memberTypes != null) {
			for (int i = 0, count = memberTypes.length; i < count; i++) {
				if (flowContext != null){ // local type
					memberTypes[i].analyseCode(scope, flowContext, nonStaticFieldInfo.copy());
				} else {
					memberTypes[i].analyseCode(scope);
				}
			}
		}
		if (methods != null) {
			UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
			FlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
			for (int i = 0, count = methods.length; i < count; i++) {
				AbstractMethodDeclaration method = methods[i];
				if (method.ignoreFurtherInvestigation)
					continue;
				if (method.isInitializationMethod()) {
					if (method.isStatic()) { // <clinit>
						((Clinit)method).analyseCode(
							scope, 
							staticInitializerContext, 
							staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
					} else { // constructor
						((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
					}
				} else { // regular method
					((MethodDeclaration)method).analyseCode(scope, null, flowInfo.copy());
				}
			}
		}
	}


, Instance #
frags: 
(startLine=187 endLine=270 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
	public void analyseCode(ClassScope classScope1) {

		if (ignoreFurtherInvestigation)
			return;
		try {
			// propagate down the max field count
			updateMaxFieldCount();
			FlowInfo flowInfo = FlowInfo.initial(maxFieldCount); // start fresh init info

			ReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception
			InitializationFlowContext initializerContext =
				new InitializationFlowContext(null, this, initializerScope);
			InitializationFlowContext staticInitializerContext =
				new InitializationFlowContext(null, this, staticInitializerScope);

			FlowInfo nonStaticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
			FlowInfo staticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();

			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					FieldDeclaration field = fields[i];
					if (field.isStatic()) {
						/*if (field.isField()){
							staticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
						} else {*/
						staticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
						/*}*/
						staticFieldInfo =
							field.analyseCode(
								staticInitializerScope,
								staticInitializerContext,
								staticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (staticFieldInfo == FlowInfo.DEAD_END) {
							staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
							staticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
						}
					} else {
						/*if (field.isField()){
							initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
						} else {*/
							initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
						/*}*/
						nonStaticFieldInfo = field.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
							initializerScope.problemReporter().initializerMustCompleteNormally(field);
							nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
						}
					}
				}
			}
			if (memberTypes != null) {
				for (int i = 0, count = memberTypes.length; i < count; i++) {
					memberTypes[i].analyseCode(scope);
				}
			}
			if (methods != null) {
				UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
				FlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
				for (int i = 0, count = methods.length; i < count; i++) {
					AbstractMethodDeclaration method = methods[i];
					if (method.ignoreFurtherInvestigation)
						continue;
					if (method.isInitializationMethod()) {
						if (method.isStatic()) { // <clinit>
							((Clinit)method).analyseCode(
								scope, 
								staticInitializerContext, 
								staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
						} else { // constructor
							((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
						}
					} else { // regular method
						method.analyseCode(scope, null, FlowInfo.initial(maxFieldCount));
					}
				}
			}
		} catch (AbortType e) {
			this.ignoreFurtherInvestigation = true;
		};
	}

(startLine=347 endLine=426 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
	public void analyseCode(CompilationUnitScope unitScope) {

		if (ignoreFurtherInvestigation)
			return;
		try {
			FlowInfo flowInfo = FlowInfo.initial(maxFieldCount); // start fresh init info
			ReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception
			InitializationFlowContext initializerContext =
				new InitializationFlowContext(null, this, initializerScope);
			InitializationFlowContext staticInitializerContext =
				new InitializationFlowContext(null, this, staticInitializerScope);
			FlowInfo nonStaticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
			FlowInfo staticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					FieldDeclaration field = fields[i];
					if (field.isStatic()) {
						/*if (field.isField()){
							staticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
						} else {*/
						staticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
						/*}*/
						staticFieldInfo =
							field.analyseCode(
								staticInitializerScope,
								staticInitializerContext,
								staticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (staticFieldInfo == FlowInfo.DEAD_END) {
							staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
							staticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
						}
					} else {
						/*if (field.isField()){
							initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
						} else {*/
							initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
						/*}*/
						nonStaticFieldInfo =
							field.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
							initializerScope.problemReporter().initializerMustCompleteNormally(field);
							nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
						}
					}
				}
			}
			if (memberTypes != null) {
				for (int i = 0, count = memberTypes.length; i < count; i++) {
					memberTypes[i].analyseCode(scope);
				}
			}
			if (methods != null) {
				UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
				FlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
				for (int i = 0, count = methods.length; i < count; i++) {
					AbstractMethodDeclaration method = methods[i];
					if (method.ignoreFurtherInvestigation)
						continue;
					if (method.isInitializationMethod()) {
						if (method.isStatic()) { // <clinit>
							((Clinit)method).analyseCode(
								scope, 
								staticInitializerContext, 
								staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
						} else { // constructor
							((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
						}
					} else { // regular method
						method.analyseCode(scope, null, FlowInfo.initial(maxFieldCount));
					}
				}
			}
		} catch (AbortType e) {
			this.ignoreFurtherInvestigation = true;
		};
	}

commonMethod: 
(startLine=782 endLine=866 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00350/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
	/**
	 *	Common flow analysis for all types
	 *
	 */
	public void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {

		if (this.binding.isPrivate() && !this.binding.isPrivateUsed()) {
			if (!scope.referenceCompilationUnit().compilationResult.hasSyntaxError()) {
				scope.problemReporter().unusedPrivateType(this);
			}
		}

		ReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception
		InitializationFlowContext initializerContext = new InitializationFlowContext(null, this, initializerScope);
		InitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, staticInitializerScope);
		FlowInfo nonStaticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		FlowInfo staticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		if (fields != null) {
			for (int i = 0, count = fields.length; i < count; i++) {
				FieldDeclaration field = fields[i];
				if (field.isStatic()) {
					/*if (field.isField()){
						staticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
					staticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					staticFieldInfo =
						field.analyseCode(
							staticInitializerScope,
							staticInitializerContext,
							staticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (staticFieldInfo == FlowInfo.DEAD_END) {
						staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
						staticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				} else {
					/*if (field.isField()){
						initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
						initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					nonStaticFieldInfo =
						field.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
						initializerScope.problemReporter().initializerMustCompleteNormally(field);
						nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				}
			}
		}
		if (memberTypes != null) {
			for (int i = 0, count = memberTypes.length; i < count; i++) {
				if (flowContext != null){ // local type
					memberTypes[i].analyseCode(scope, flowContext, nonStaticFieldInfo.copy());
				} else {
					memberTypes[i].analyseCode(scope);
				}
			}
		}
		if (methods != null) {
			UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
			FlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
			for (int i = 0, count = methods.length; i < count; i++) {
				AbstractMethodDeclaration method = methods[i];
				if (method.ignoreFurtherInvestigation)
					continue;
				if (method.isInitializationMethod()) {
					if (method.isStatic()) { // <clinit>
						((Clinit)method).analyseCode(
							scope, 
							staticInitializerContext, 
							staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
					} else { // constructor
						((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
					}
				} else { // regular method
					((MethodDeclaration)method).analyseCode(scope, null, flowInfo.copy());
				}
			}
		}
	}


, Instance #
frags: 
(startLine=205 endLine=240 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					FieldDeclaration field = fields[i];
					if (field.isStatic()) {
						/*if (field.isField()){
							staticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
						} else {*/
						staticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
						/*}*/
						staticFieldInfo =
							field.analyseCode(
								staticInitializerScope,
								staticInitializerContext,
								staticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (staticFieldInfo == FlowInfo.DEAD_END) {
							staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
							staticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
						}
					} else {
						/*if (field.isField()){
							initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
						} else {*/
							initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
						/*}*/
						nonStaticFieldInfo = field.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
							initializerScope.problemReporter().initializerMustCompleteNormally(field);
							nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
						}
					}
				}
			}

(startLine=360 endLine=396 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					FieldDeclaration field = fields[i];
					if (field.isStatic()) {
						/*if (field.isField()){
							staticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
						} else {*/
						staticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
						/*}*/
						staticFieldInfo =
							field.analyseCode(
								staticInitializerScope,
								staticInitializerContext,
								staticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (staticFieldInfo == FlowInfo.DEAD_END) {
							staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
							staticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
						}
					} else {
						/*if (field.isField()){
							initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
						} else {*/
							initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
						/*}*/
						nonStaticFieldInfo =
							field.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
							initializerScope.problemReporter().initializerMustCompleteNormally(field);
							nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
						}
					}
				}
			}

commonMethod: 
(startLine=782 endLine=866 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00350/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
	/**
	 *	Common flow analysis for all types
	 *
	 */
	public void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {

		if (this.binding.isPrivate() && !this.binding.isPrivateUsed()) {
			if (!scope.referenceCompilationUnit().compilationResult.hasSyntaxError()) {
				scope.problemReporter().unusedPrivateType(this);
			}
		}

		ReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception
		InitializationFlowContext initializerContext = new InitializationFlowContext(null, this, initializerScope);
		InitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, staticInitializerScope);
		FlowInfo nonStaticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		FlowInfo staticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		if (fields != null) {
			for (int i = 0, count = fields.length; i < count; i++) {
				FieldDeclaration field = fields[i];
				if (field.isStatic()) {
					/*if (field.isField()){
						staticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
					staticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					staticFieldInfo =
						field.analyseCode(
							staticInitializerScope,
							staticInitializerContext,
							staticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (staticFieldInfo == FlowInfo.DEAD_END) {
						staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
						staticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				} else {
					/*if (field.isField()){
						initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
						initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					nonStaticFieldInfo =
						field.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
						initializerScope.problemReporter().initializerMustCompleteNormally(field);
						nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				}
			}
		}
		if (memberTypes != null) {
			for (int i = 0, count = memberTypes.length; i < count; i++) {
				if (flowContext != null){ // local type
					memberTypes[i].analyseCode(scope, flowContext, nonStaticFieldInfo.copy());
				} else {
					memberTypes[i].analyseCode(scope);
				}
			}
		}
		if (methods != null) {
			UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
			FlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
			for (int i = 0, count = methods.length; i < count; i++) {
				AbstractMethodDeclaration method = methods[i];
				if (method.ignoreFurtherInvestigation)
					continue;
				if (method.isInitializationMethod()) {
					if (method.isStatic()) { // <clinit>
						((Clinit)method).analyseCode(
							scope, 
							staticInitializerContext, 
							staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
					} else { // constructor
						((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
					}
				} else { // regular method
					((MethodDeclaration)method).analyseCode(scope, null, flowInfo.copy());
				}
			}
		}
	}


, Instance #
frags: 
(startLine=246 endLine=266 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (methods != null) {
				UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
				FlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
				for (int i = 0, count = methods.length; i < count; i++) {
					AbstractMethodDeclaration method = methods[i];
					if (method.ignoreFurtherInvestigation)
						continue;
					if (method.isInitializationMethod()) {
						if (method.isStatic()) { // <clinit>
							((Clinit)method).analyseCode(
								scope, 
								staticInitializerContext, 
								staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
						} else { // constructor
							((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
						}
					} else { // regular method
						method.analyseCode(scope, null, FlowInfo.initial(maxFieldCount));
					}
				}
			}

(startLine=402 endLine=422 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
			if (methods != null) {
				UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
				FlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
				for (int i = 0, count = methods.length; i < count; i++) {
					AbstractMethodDeclaration method = methods[i];
					if (method.ignoreFurtherInvestigation)
						continue;
					if (method.isInitializationMethod()) {
						if (method.isStatic()) { // <clinit>
							((Clinit)method).analyseCode(
								scope, 
								staticInitializerContext, 
								staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
						} else { // constructor
							((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
						}
					} else { // regular method
						method.analyseCode(scope, null, FlowInfo.initial(maxFieldCount));
					}
				}
			}

commonMethod: 
(startLine=782 endLine=866 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00350/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
	/**
	 *	Common flow analysis for all types
	 *
	 */
	public void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {

		if (this.binding.isPrivate() && !this.binding.isPrivateUsed()) {
			if (!scope.referenceCompilationUnit().compilationResult.hasSyntaxError()) {
				scope.problemReporter().unusedPrivateType(this);
			}
		}

		ReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception
		InitializationFlowContext initializerContext = new InitializationFlowContext(null, this, initializerScope);
		InitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, staticInitializerScope);
		FlowInfo nonStaticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		FlowInfo staticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		if (fields != null) {
			for (int i = 0, count = fields.length; i < count; i++) {
				FieldDeclaration field = fields[i];
				if (field.isStatic()) {
					/*if (field.isField()){
						staticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
					staticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					staticFieldInfo =
						field.analyseCode(
							staticInitializerScope,
							staticInitializerContext,
							staticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (staticFieldInfo == FlowInfo.DEAD_END) {
						staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
						staticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				} else {
					/*if (field.isField()){
						initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
						initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					nonStaticFieldInfo =
						field.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
						initializerScope.problemReporter().initializerMustCompleteNormally(field);
						nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				}
			}
		}
		if (memberTypes != null) {
			for (int i = 0, count = memberTypes.length; i < count; i++) {
				if (flowContext != null){ // local type
					memberTypes[i].analyseCode(scope, flowContext, nonStaticFieldInfo.copy());
				} else {
					memberTypes[i].analyseCode(scope);
				}
			}
		}
		if (methods != null) {
			UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
			FlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
			for (int i = 0, count = methods.length; i < count; i++) {
				AbstractMethodDeclaration method = methods[i];
				if (method.ignoreFurtherInvestigation)
					continue;
				if (method.isInitializationMethod()) {
					if (method.isStatic()) { // <clinit>
						((Clinit)method).analyseCode(
							scope, 
							staticInitializerContext, 
							staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
					} else { // constructor
						((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
					}
				} else { // regular method
					((MethodDeclaration)method).analyseCode(scope, null, flowInfo.copy());
				}
			}
		}
	}


, Instance #
frags: 
(startLine=249 endLine=265 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
				for (int i = 0, count = methods.length; i < count; i++) {
					AbstractMethodDeclaration method = methods[i];
					if (method.ignoreFurtherInvestigation)
						continue;
					if (method.isInitializationMethod()) {
						if (method.isStatic()) { // <clinit>
							((Clinit)method).analyseCode(
								scope, 
								staticInitializerContext, 
								staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
						} else { // constructor
							((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
						}
					} else { // regular method
						method.analyseCode(scope, null, FlowInfo.initial(maxFieldCount));
					}
				}

(startLine=405 endLine=421 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00349/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
				for (int i = 0, count = methods.length; i < count; i++) {
					AbstractMethodDeclaration method = methods[i];
					if (method.ignoreFurtherInvestigation)
						continue;
					if (method.isInitializationMethod()) {
						if (method.isStatic()) { // <clinit>
							((Clinit)method).analyseCode(
								scope, 
								staticInitializerContext, 
								staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
						} else { // constructor
							((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
						}
					} else { // regular method
						method.analyseCode(scope, null, FlowInfo.initial(maxFieldCount));
					}
				}

commonMethod: 
(startLine=782 endLine=866 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00350/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/TypeDeclaration.java)
	/**
	 *	Common flow analysis for all types
	 *
	 */
	public void internalAnalyseCode(FlowContext flowContext, FlowInfo flowInfo) {

		if (this.binding.isPrivate() && !this.binding.isPrivateUsed()) {
			if (!scope.referenceCompilationUnit().compilationResult.hasSyntaxError()) {
				scope.problemReporter().unusedPrivateType(this);
			}
		}

		ReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception
		InitializationFlowContext initializerContext = new InitializationFlowContext(null, this, initializerScope);
		InitializationFlowContext staticInitializerContext = new InitializationFlowContext(null, this, staticInitializerScope);
		FlowInfo nonStaticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		FlowInfo staticFieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
		if (fields != null) {
			for (int i = 0, count = fields.length; i < count; i++) {
				FieldDeclaration field = fields[i];
				if (field.isStatic()) {
					/*if (field.isField()){
						staticInitializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
					staticInitializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					staticFieldInfo =
						field.analyseCode(
							staticInitializerScope,
							staticInitializerContext,
							staticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (staticFieldInfo == FlowInfo.DEAD_END) {
						staticInitializerScope.problemReporter().initializerMustCompleteNormally(field);
						staticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				} else {
					/*if (field.isField()){
						initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {*/
						initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					/*}*/
					nonStaticFieldInfo =
						field.analyseCode(initializerScope, initializerContext, nonStaticFieldInfo);
					// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
					// branch, since the previous initializer already got the blame.
					if (nonStaticFieldInfo == FlowInfo.DEAD_END) {
						initializerScope.problemReporter().initializerMustCompleteNormally(field);
						nonStaticFieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				}
			}
		}
		if (memberTypes != null) {
			for (int i = 0, count = memberTypes.length; i < count; i++) {
				if (flowContext != null){ // local type
					memberTypes[i].analyseCode(scope, flowContext, nonStaticFieldInfo.copy());
				} else {
					memberTypes[i].analyseCode(scope);
				}
			}
		}
		if (methods != null) {
			UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
			FlowInfo constructorInfo = nonStaticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
			for (int i = 0, count = methods.length; i < count; i++) {
				AbstractMethodDeclaration method = methods[i];
				if (method.ignoreFurtherInvestigation)
					continue;
				if (method.isInitializationMethod()) {
					if (method.isStatic()) { // <clinit>
						((Clinit)method).analyseCode(
							scope, 
							staticInitializerContext, 
							staticFieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo));
					} else { // constructor
						((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
					}
				} else { // regular method
					((MethodDeclaration)method).analyseCode(scope, null, flowInfo.copy());
				}
			}
		}
	}


, Instance #
frags: 
(startLine=723 endLine=739 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00379/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
				}
				final ElementChangedEvent extraEvent = new ElementChangedEvent(deltaToNotify, ElementChangedEvent.PRE_AUTO_BUILD);
				for (int i= 0; i < listenerCount; i++) {
					if ((listenerMask[i] & ElementChangedEvent.PRE_AUTO_BUILD) != 0){
						final IElementChangedListener listener = listeners[i];
						if (DeltaProcessor.VERBOSE) {
							System.out.println("Listener #" + (i+1) + "=" + listener.toString());//$NON-NLS-1$//$NON-NLS-2$
						}
						// wrap callbacks with Safe runnable for subsequent listeners to be called when some are causing grief
						Platform.run(new ISafeRunnable() {
							public void handleException(Throwable exception) {
								Util.log(exception, "Exception occurred in listener of Java element change notification"); //$NON-NLS-1$
							}
							public void run() throws Exception {
								listener.elementChanged(extraEvent);
							}
						});

(startLine=759 endLine=775 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00379/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
			}
			final ElementChangedEvent event = new ElementChangedEvent(deltaToNotify, eventType);
			for (int i= 0; i < listenerCount; i++) {
				if ((listenerMask[i] & eventType) != 0){
					// wrap callbacks with Safe runnable for subsequent listeners to be called when some are causing grief
					final IElementChangedListener listener = listeners[i];
					if (DeltaProcessor.VERBOSE) {
						System.out.println("Listener #" + (i+1) + "=" + listener.toString());//$NON-NLS-1$//$NON-NLS-2$
					}
					Platform.run(new ISafeRunnable() {
						public void handleException(Throwable exception) {
							Util.log(exception, "Exception occurred in listener of Java element change notification"); //$NON-NLS-1$
						}
						public void run() throws Exception {
							listener.elementChanged(event);
						}
					});

commonMethod: 
(startLine=722 endLine=735 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00380/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
	private void firePreAutoBuildDelta(
		IJavaElementDelta deltaToNotify,
		IElementChangedListener[] listeners,
		int[] listenerMask,
		int listenerCount) {
			
		if (DeltaProcessor.VERBOSE){
			System.out.println("FIRING PRE_AUTO_BUILD Delta ["+Thread.currentThread()+"]:"); //$NON-NLS-1$//$NON-NLS-2$
			System.out.println(deltaToNotify == null ? "<NONE>" : deltaToNotify.toString()); //$NON-NLS-1$
		}
		if (deltaToNotify != null) {
			notifyListeners(deltaToNotify, ElementChangedEvent.PRE_AUTO_BUILD, listeners, listenerMask, listenerCount);
		}
	}


, Instance #
frags: 
(startLine=723 endLine=739 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00379/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
				}
				final ElementChangedEvent extraEvent = new ElementChangedEvent(deltaToNotify, ElementChangedEvent.PRE_AUTO_BUILD);
				for (int i= 0; i < listenerCount; i++) {
					if ((listenerMask[i] & ElementChangedEvent.PRE_AUTO_BUILD) != 0){
						final IElementChangedListener listener = listeners[i];
						if (DeltaProcessor.VERBOSE) {
							System.out.println("Listener #" + (i+1) + "=" + listener.toString());//$NON-NLS-1$//$NON-NLS-2$
						}
						// wrap callbacks with Safe runnable for subsequent listeners to be called when some are causing grief
						Platform.run(new ISafeRunnable() {
							public void handleException(Throwable exception) {
								Util.log(exception, "Exception occurred in listener of Java element change notification"); //$NON-NLS-1$
							}
							public void run() throws Exception {
								listener.elementChanged(extraEvent);
							}
						});

(startLine=759 endLine=775 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00379/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
			}
			final ElementChangedEvent event = new ElementChangedEvent(deltaToNotify, eventType);
			for (int i= 0; i < listenerCount; i++) {
				if ((listenerMask[i] & eventType) != 0){
					// wrap callbacks with Safe runnable for subsequent listeners to be called when some are causing grief
					final IElementChangedListener listener = listeners[i];
					if (DeltaProcessor.VERBOSE) {
						System.out.println("Listener #" + (i+1) + "=" + listener.toString());//$NON-NLS-1$//$NON-NLS-2$
					}
					Platform.run(new ISafeRunnable() {
						public void handleException(Throwable exception) {
							Util.log(exception, "Exception occurred in listener of Java element change notification"); //$NON-NLS-1$
						}
						public void run() throws Exception {
							listener.elementChanged(event);
						}
					});

commonMethod: 
(startLine=737 endLine=754 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00380/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
	private void firePostChangeDelta(
		IJavaElementDelta deltaToNotify,
		IElementChangedListener[] listeners,
		int[] listenerMask,
		int listenerCount) {
			
		// post change deltas
		if (DeltaProcessor.VERBOSE){
			System.out.println("FIRING POST_CHANGE Delta ["+Thread.currentThread()+"]:"); //$NON-NLS-1$//$NON-NLS-2$
			System.out.println(deltaToNotify == null ? "<NONE>" : deltaToNotify.toString()); //$NON-NLS-1$
		}
		if (deltaToNotify != null) {
			// flush now so as to keep listener reactions to post their own deltas for subsequent iteration
			this.flush();
			
			notifyListeners(deltaToNotify, ElementChangedEvent.POST_CHANGE, listeners, listenerMask, listenerCount);
		} 
	}		


, Instance #
frags: 
(startLine=723 endLine=739 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00379/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
				}
				final ElementChangedEvent extraEvent = new ElementChangedEvent(deltaToNotify, ElementChangedEvent.PRE_AUTO_BUILD);
				for (int i= 0; i < listenerCount; i++) {
					if ((listenerMask[i] & ElementChangedEvent.PRE_AUTO_BUILD) != 0){
						final IElementChangedListener listener = listeners[i];
						if (DeltaProcessor.VERBOSE) {
							System.out.println("Listener #" + (i+1) + "=" + listener.toString());//$NON-NLS-1$//$NON-NLS-2$
						}
						// wrap callbacks with Safe runnable for subsequent listeners to be called when some are causing grief
						Platform.run(new ISafeRunnable() {
							public void handleException(Throwable exception) {
								Util.log(exception, "Exception occurred in listener of Java element change notification"); //$NON-NLS-1$
							}
							public void run() throws Exception {
								listener.elementChanged(extraEvent);
							}
						});

(startLine=759 endLine=775 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00379/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
			}
			final ElementChangedEvent event = new ElementChangedEvent(deltaToNotify, eventType);
			for (int i= 0; i < listenerCount; i++) {
				if ((listenerMask[i] & eventType) != 0){
					// wrap callbacks with Safe runnable for subsequent listeners to be called when some are causing grief
					final IElementChangedListener listener = listeners[i];
					if (DeltaProcessor.VERBOSE) {
						System.out.println("Listener #" + (i+1) + "=" + listener.toString());//$NON-NLS-1$//$NON-NLS-2$
					}
					Platform.run(new ISafeRunnable() {
						public void handleException(Throwable exception) {
							Util.log(exception, "Exception occurred in listener of Java element change notification"); //$NON-NLS-1$
						}
						public void run() throws Exception {
							listener.elementChanged(event);
						}
					});

commonMethod: 
(startLine=755 endLine=772 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00380/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
	private void fireReconcileDelta(
		IElementChangedListener[] listeners,
		int[] listenerMask,
		int listenerCount) {


		IJavaElementDelta deltaToNotify = mergeDeltas(this.reconcileDeltas.values());
		if (DeltaProcessor.VERBOSE){
			System.out.println("FIRING POST_RECONCILE Delta ["+Thread.currentThread()+"]:"); //$NON-NLS-1$//$NON-NLS-2$
			System.out.println(deltaToNotify == null ? "<NONE>" : deltaToNotify.toString()); //$NON-NLS-1$
		}
		if (deltaToNotify != null) {
			// flush now so as to keep listener reactions to post their own deltas for subsequent iteration
			this.reconcileDeltas = new HashMap();
		
			notifyListeners(deltaToNotify, ElementChangedEvent.POST_RECONCILE, listeners, listenerMask, listenerCount);
		} 
	}


, Instance #
frags: 
(startLine=723 endLine=739 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00379/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
				}
				final ElementChangedEvent extraEvent = new ElementChangedEvent(deltaToNotify, ElementChangedEvent.PRE_AUTO_BUILD);
				for (int i= 0; i < listenerCount; i++) {
					if ((listenerMask[i] & ElementChangedEvent.PRE_AUTO_BUILD) != 0){
						final IElementChangedListener listener = listeners[i];
						if (DeltaProcessor.VERBOSE) {
							System.out.println("Listener #" + (i+1) + "=" + listener.toString());//$NON-NLS-1$//$NON-NLS-2$
						}
						// wrap callbacks with Safe runnable for subsequent listeners to be called when some are causing grief
						Platform.run(new ISafeRunnable() {
							public void handleException(Throwable exception) {
								Util.log(exception, "Exception occurred in listener of Java element change notification"); //$NON-NLS-1$
							}
							public void run() throws Exception {
								listener.elementChanged(extraEvent);
							}
						});

(startLine=759 endLine=775 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00379/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
			}
			final ElementChangedEvent event = new ElementChangedEvent(deltaToNotify, eventType);
			for (int i= 0; i < listenerCount; i++) {
				if ((listenerMask[i] & eventType) != 0){
					// wrap callbacks with Safe runnable for subsequent listeners to be called when some are causing grief
					final IElementChangedListener listener = listeners[i];
					if (DeltaProcessor.VERBOSE) {
						System.out.println("Listener #" + (i+1) + "=" + listener.toString());//$NON-NLS-1$//$NON-NLS-2$
					}
					Platform.run(new ISafeRunnable() {
						public void handleException(Throwable exception) {
							Util.log(exception, "Exception occurred in listener of Java element change notification"); //$NON-NLS-1$
						}
						public void run() throws Exception {
							listener.elementChanged(event);
						}
					});

commonMethod: 
(startLine=774 endLine=793 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00380/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
	public void notifyListeners(IJavaElementDelta deltaToNotify, int eventType, IElementChangedListener[] listeners, int[] listenerMask, int listenerCount) {
		final ElementChangedEvent extraEvent = new ElementChangedEvent(deltaToNotify, eventType);
		for (int i= 0; i < listenerCount; i++) {
			if ((listenerMask[i] & eventType) != 0){
				final IElementChangedListener listener = listeners[i];
				if (DeltaProcessor.VERBOSE) {
					System.out.println("Listener #" + (i+1) + "=" + listener.toString());//$NON-NLS-1$//$NON-NLS-2$
				}
				// wrap callbacks with Safe runnable for subsequent listeners to be called when some are causing grief
				Platform.run(new ISafeRunnable() {
					public void handleException(Throwable exception) {
						Util.log(exception, "Exception occurred in listener of Java element change notification"); //$NON-NLS-1$
					}
					public void run() throws Exception {
						listener.elementChanged(extraEvent);
					}
				});
			}
		}
	}


, Instance #
frags: 
(startLine=1856 endLine=1943 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00415/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java)
public void testCycleDetectionThroughContainers() throws CoreException {
	
	IJavaProject[] p = null;
	try {

		p = new IJavaProject[]{
			this.createJavaProject("P0", new String[] {""}, ""),
			this.createJavaProject("P1", new String[] {""}, ""),
			this.createJavaProject("P2", new String[] {""}, ""),
			this.createJavaProject("P3", new String[] {""}, ""),
			this.createJavaProject("P4", new String[] {""}, ""),
		};

		IClasspathContainer[] containers = new IClasspathContainer[]{ 
			new TestContainer(
				new Path("container0/default"), 
				new IClasspathEntry[]{ JavaCore.newProjectEntry(p[3].getPath()) }),
			new TestContainer(
				new Path("container1/default"), 
				new IClasspathEntry[]{ JavaCore.newProjectEntry(p[1].getPath()) }),
			new TestContainer(
				new Path("container2/default"), 
				new IClasspathEntry[]{ JavaCore.newProjectEntry(p[4].getPath()) }),
		};

		IClasspathEntry[][] extraEntries = new IClasspathEntry[][]{ 
			{ JavaCore.newProjectEntry(p[1].getPath()), JavaCore.newContainerEntry(containers[0].getPath()) },
			{ JavaCore.newProjectEntry(p[2].getPath()), JavaCore.newProjectEntry(p[3].getPath()) },
			{ JavaCore.newContainerEntry(containers[1].getPath()) }, 
			{ JavaCore.newContainerEntry(containers[2].getPath())}, 
			{ JavaCore.newProjectEntry(p[3].getPath()), JavaCore.newProjectEntry(p[0].getPath()) } 
		}; 

		int[][] expectedCycleParticipants = new int[][] {
			{ 0, 0, 0, 0, 0 }, // after setting CP p[0]
			{ 0, 0, 0, 0, 0 }, // after setting CP p[1]
			{ 0, 0, 0, 0, 0 }, // after setting CP p[2]
			{ 0, 0, 0, 0, 0 }, // after setting CP p[3]
			{ 1, 1, 1, 1, 1 }, // after setting CP p[4]
		};
		
		for (int i = 0; i < p.length; i++){

			// append project references			
			IClasspathEntry[] oldClasspath = p[i].getRawClasspath();
			IClasspathEntry[] newClasspath = new IClasspathEntry[oldClasspath.length+extraEntries[i].length];
			System.arraycopy(oldClasspath, 0 , newClasspath, 0, oldClasspath.length);
			for (int j = 0; j < extraEntries[i].length; j++){
				newClasspath[oldClasspath.length+j] = extraEntries[i][j];
			}			
			// set classpath
			p[i].setRawClasspath(newClasspath, null);

			// update container paths
			if (i == p.length - 1){
				JavaCore.setClasspathContainer(
					containers[0].getPath(),
					new IJavaProject[]{ p[0] },
					new IClasspathContainer[] { containers[0] },
					null);

				JavaCore.setClasspathContainer(
					containers[1].getPath(),
					new IJavaProject[]{ p[2] },
					new IClasspathContainer[] { containers[1] },
					null);

				JavaCore.setClasspathContainer(
					containers[2].getPath(),
					new IJavaProject[]{ p[3] },
					new IClasspathContainer[] { containers[2] },
					null);
			}
			
			// check cycle markers
			this.assertCycleMarkers(p[i], p, expectedCycleParticipants[i]);
		}
		//this.startDeltas();
		
	} finally {
		//this.stopDeltas();
		if (p != null){
			for (int i = 0; i < p.length; i++){
				this.deleteProject(p[i].getElementName());
			}
		}
	}
}

(startLine=1944 endLine=2032 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00415/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java)
public void testCycleDetectionThroughContainerVariants() throws CoreException {
	
	IJavaProject[] p = null;
	try {

		p = new IJavaProject[]{
			this.createJavaProject("P0", new String[] {""}, ""),
			this.createJavaProject("P1", new String[] {""}, ""),
			this.createJavaProject("P2", new String[] {""}, ""),
			this.createJavaProject("P3", new String[] {""}, ""),
			this.createJavaProject("P4", new String[] {""}, ""),
		};

		class TestContainer implements IClasspathContainer {
			IPath path;
			IClasspathEntry[] entries;
			TestContainer(IPath path, IClasspathEntry[] entries){
				this.path = path;
				this.entries = entries;
			}
			public IPath getPath() { return this.path; }
			public IClasspathEntry[] getClasspathEntries() { return this.entries;	}
			public String getDescription() { return null; 	}
			public int getKind() { return 0; }
		};

		IClasspathContainer[] containers = new IClasspathContainer[]{ 
			new TestContainer(
				new Path("container0/default"), 
				new IClasspathEntry[]{ JavaCore.newProjectEntry(p[3].getPath()) }),
			new TestContainer(
				new Path("container0/default"), 
				new IClasspathEntry[]{ JavaCore.newProjectEntry(p[1].getPath()) }),
			new TestContainer(
				new Path("container0/default"), 
				new IClasspathEntry[]{ JavaCore.newProjectEntry(p[4].getPath()) }),
		};

		IClasspathEntry[][] extraEntries = new IClasspathEntry[][]{ 
			{ JavaCore.newProjectEntry(p[1].getPath()), JavaCore.newContainerEntry(containers[0].getPath()) },
			{ JavaCore.newProjectEntry(p[2].getPath()), JavaCore.newProjectEntry(p[3].getPath()) },
			{ JavaCore.newContainerEntry(containers[1].getPath()) }, 
			{ JavaCore.newContainerEntry(containers[2].getPath())}, 
			{ JavaCore.newProjectEntry(p[3].getPath()), JavaCore.newProjectEntry(p[0].getPath()) } 
		}; 

		int[][] expectedCycleParticipants = new int[][] {
			{ 0, 0, 0, 0, 0 }, // after setting CP p[0]
			{ 0, 0, 0, 0, 0 }, // after setting CP p[1]
			{ 0, 0, 0, 0, 0 }, // after setting CP p[2]
			{ 0, 0, 0, 0, 0 }, // after setting CP p[3]
			{ 1, 1, 1, 1, 1 }, // after setting CP p[4]
		};
		
		for (int i = 0; i < p.length; i++){

			// append project references			
			IClasspathEntry[] oldClasspath = p[i].getRawClasspath();
			IClasspathEntry[] newClasspath = new IClasspathEntry[oldClasspath.length+extraEntries[i].length];
			System.arraycopy(oldClasspath, 0 , newClasspath, 0, oldClasspath.length);
			for (int j = 0; j < extraEntries[i].length; j++){
				newClasspath[oldClasspath.length+j] = extraEntries[i][j];
			}			
			// set classpath
			p[i].setRawClasspath(newClasspath, null);

			// update same container path for multiple projects
			if (i == p.length - 1){
				JavaCore.setClasspathContainer(
					containers[0].getPath(),
					new IJavaProject[]{ p[0], p[2], p[3] },
					new IClasspathContainer[] { containers[0], containers[1], containers[2] },
					null);
			}
			
			// check cycle markers
			this.assertCycleMarkers(p[i], p, expectedCycleParticipants[i]);
		}
		//this.startDeltas();
		
	} finally {
		//this.stopDeltas();
		if (p != null){
			for (int i = 0; i < p.length; i++){
				this.deleteProject(p[i].getElementName());
			}
		}
	}
}

commonMethod: 
(startLine=460 endLine=475 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00416/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java)
/**
 * Batch deletion of projects
 */
protected void deleteProjects(final String[] projectNames) throws CoreException {
	ResourcesPlugin.getWorkspace().run(new IWorkspaceRunnable() {
		public void run(IProgressMonitor monitor) throws CoreException {
			if (projectNames != null){
				for (int i = 0, max = projectNames.length; i < max; i++){
					if (projectNames[i] != null)
						deleteProject(projectNames[i]);
				}
			}
		}
	},
	null);
}


, Instance #
frags: 
(startLine=1730 endLine=1784 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00415/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java)
public void testCycleDetection() throws CoreException {
	
	IJavaProject[] p = null;
	try {

		p = new IJavaProject[]{
			this.createJavaProject("P0", new String[] {""}, ""),
			this.createJavaProject("P1", new String[] {""}, ""),
			this.createJavaProject("P2", new String[] {""}, ""),
			this.createJavaProject("P3", new String[] {""}, ""),
			this.createJavaProject("P4", new String[] {""}, ""),
		};
		
		IClasspathEntry[][] extraEntries = new IClasspathEntry[][]{ 
			{ JavaCore.newProjectEntry(p[1].getPath()), JavaCore.newProjectEntry(p[3].getPath()) },
			{ JavaCore.newProjectEntry(p[2].getPath()), JavaCore.newProjectEntry(p[3].getPath()) },
			{ JavaCore.newProjectEntry(p[1].getPath()) }, 
			{ JavaCore.newProjectEntry(p[4].getPath())}, 
			{ JavaCore.newProjectEntry(p[3].getPath()), JavaCore.newProjectEntry(p[0].getPath()) } 
		}; 

		int[][] expectedCycleParticipants = new int[][] {
			{ 0, 0, 0, 0, 0 }, // after setting CP p[0]
			{ 0, 0, 0, 0, 0 }, // after setting CP p[1]
			{ 0, 1, 1, 0, 0 }, // after setting CP p[2]
			{ 0, 1, 1, 0, 0 }, // after setting CP p[3]
			{ 1, 1, 1, 1, 1 }, // after setting CP p[4]
		};
		
		for (int i = 0; i < p.length; i++){

			// append project references			
			IClasspathEntry[] oldClasspath = p[i].getRawClasspath();
			IClasspathEntry[] newClasspath = new IClasspathEntry[oldClasspath.length+extraEntries[i].length];
			System.arraycopy(oldClasspath, 0 , newClasspath, 0, oldClasspath.length);
			for (int j = 0; j < extraEntries[i].length; j++){
				newClasspath[oldClasspath.length+j] = extraEntries[i][j];
			}			
			// set classpath
			p[i].setRawClasspath(newClasspath, null);

			// check cycle markers
			this.assertCycleMarkers(p[i], p, expectedCycleParticipants[i]);
		}
		//this.startDeltas();
		
	} finally {
		//this.stopDeltas();
		if (p != null){
			for (int i = 0; i < p.length; i++){
				this.deleteProject(p[i].getElementName());
			}
		}
	}
}

(startLine=2033 endLine=2087 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00415/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java)
public void testCycleDetection2() throws CoreException {
	
	IJavaProject[] p = null;
	try {

		p = new IJavaProject[]{
			this.createJavaProject("P0", new String[] {""}, ""),
			this.createJavaProject("P1", new String[] {""}, ""),
			this.createJavaProject("P2", new String[] {""}, ""),
			this.createJavaProject("P3", new String[] {""}, ""),
			this.createJavaProject("P4", new String[] {""}, ""),
		};
		
		IClasspathEntry[][] extraEntries = new IClasspathEntry[][]{ 
			{ JavaCore.newProjectEntry(p[1].getPath()), JavaCore.newProjectEntry(p[3].getPath()) },
			{ JavaCore.newProjectEntry(p[2].getPath()) },
			{ JavaCore.newProjectEntry(p[0].getPath()) }, 
			{ JavaCore.newProjectEntry(p[4].getPath())}, 
			{ JavaCore.newProjectEntry(p[0].getPath()) } 
		}; 

		int[][] expectedCycleParticipants = new int[][] {
			{ 0, 0, 0, 0, 0 }, // after setting CP p[0]
			{ 0, 0, 0, 0, 0 }, // after setting CP p[1]
			{ 1, 1, 1, 0, 0 }, // after setting CP p[2]
			{ 1, 1, 1, 0, 0 }, // after setting CP p[3]
			{ 1, 1, 1, 1, 1 }, // after setting CP p[4]
		};
		
		for (int i = 0; i < p.length; i++){

			// append project references			
			IClasspathEntry[] oldClasspath = p[i].getRawClasspath();
			IClasspathEntry[] newClasspath = new IClasspathEntry[oldClasspath.length+extraEntries[i].length];
			System.arraycopy(oldClasspath, 0 , newClasspath, 0, oldClasspath.length);
			for (int j = 0; j < extraEntries[i].length; j++){
				newClasspath[oldClasspath.length+j] = extraEntries[i][j];
			}			
			// set classpath
			p[i].setRawClasspath(newClasspath, null);

			// check cycle markers
			this.assertCycleMarkers(p[i], p, expectedCycleParticipants[i]);
		}
		//this.startDeltas();
		
	} finally {
		//this.stopDeltas();
		if (p != null){
			for (int i = 0; i < p.length; i++){
				this.deleteProject(p[i].getElementName());
			}
		}
	}
}

(startLine=2089 endLine=2146 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00415/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java)
public void testCycleDetection3() throws CoreException {
	
	IJavaProject[] p = null;
	try {

		p = new IJavaProject[]{
			this.createJavaProject("P0", new String[] {""}, ""),
			this.createJavaProject("P1", new String[] {""}, ""),
			this.createJavaProject("P2", new String[] {""}, ""),
			this.createJavaProject("P3", new String[] {""}, ""),
			this.createJavaProject("P4", new String[] {""}, ""),
			this.createJavaProject("P5", new String[] {""}, ""),
		};
		
		IClasspathEntry[][] extraEntries = new IClasspathEntry[][]{ 
			{ JavaCore.newProjectEntry(p[2].getPath()), JavaCore.newProjectEntry(p[4].getPath()) },
			{ JavaCore.newProjectEntry(p[0].getPath()) },
			{ JavaCore.newProjectEntry(p[3].getPath()) }, 
			{ JavaCore.newProjectEntry(p[1].getPath())}, 
			{ JavaCore.newProjectEntry(p[5].getPath()) }, 
			{ JavaCore.newProjectEntry(p[1].getPath()) } 
		}; 

		int[][] expectedCycleParticipants = new int[][] {
			{ 0, 0, 0, 0, 0, 0 }, // after setting CP p[0]
			{ 0, 0, 0, 0, 0, 0 }, // after setting CP p[1]
			{ 0, 0, 0, 0, 0, 0 }, // after setting CP p[2]
			{ 1, 1, 1, 1, 0, 0 }, // after setting CP p[3]
			{ 1, 1, 1, 1, 0, 0 }, // after setting CP p[4]
			{ 1, 1, 1, 1, 1 , 1}, // after setting CP p[5]
		};
		
		for (int i = 0; i < p.length; i++){

			// append project references			
			IClasspathEntry[] oldClasspath = p[i].getRawClasspath();
			IClasspathEntry[] newClasspath = new IClasspathEntry[oldClasspath.length+extraEntries[i].length];
			System.arraycopy(oldClasspath, 0 , newClasspath, 0, oldClasspath.length);
			for (int j = 0; j < extraEntries[i].length; j++){
				newClasspath[oldClasspath.length+j] = extraEntries[i][j];
			}			
			// set classpath
			p[i].setRawClasspath(newClasspath, null);

			// check cycle markers
			this.assertCycleMarkers(p[i], p, expectedCycleParticipants[i]);
		}
		//this.startDeltas();
		
	} finally {
		//this.stopDeltas();
		if (p != null){
			for (int i = 0; i < p.length; i++){
				this.deleteProject(p[i].getElementName());
			}
		}
	}
}

commonMethod: 
(startLine=460 endLine=475 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00416/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java)
/**
 * Batch deletion of projects
 */
protected void deleteProjects(final String[] projectNames) throws CoreException {
	ResourcesPlugin.getWorkspace().run(new IWorkspaceRunnable() {
		public void run(IProgressMonitor monitor) throws CoreException {
			if (projectNames != null){
				for (int i = 0, max = projectNames.length; i < max; i++){
					if (projectNames[i] != null)
						deleteProject(projectNames[i]);
				}
			}
		}
	},
	null);
}


, Instance #
frags: 
(startLine=2186 endLine=2241 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00415/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java)
private void denseCycleDetection(final int numberOfParticipants) throws CoreException {
	
	final IJavaProject[] projects = new IJavaProject[numberOfParticipants];
	final int[] allProjectsInCycle = new int[numberOfParticipants];

	final long[] start = new long[1];
	final long[] time = new long[1];
	

	try {
		JavaCore.run(new IWorkspaceRunnable() {
			public void run(IProgressMonitor monitor) throws CoreException {
				for (int i = 0; i < numberOfParticipants; i++){
					projects[i] = createJavaProject("P"+i, new String[]{""}, "");
					allProjectsInCycle[i] = 1;
				}		
				for (int i = 0; i < numberOfParticipants; i++){
					IClasspathEntry[] extraEntries = new IClasspathEntry[numberOfParticipants-1];
					int index = 0;
					for (int j = 0; j < numberOfParticipants; j++){
						if (i == j) continue;
						extraEntries[index++] = JavaCore.newProjectEntry(projects[j].getPath());
					}
					// append project references			
					IClasspathEntry[] oldClasspath = projects[i].getRawClasspath();
					IClasspathEntry[] newClasspath = new IClasspathEntry[oldClasspath.length+extraEntries.length];
					System.arraycopy(oldClasspath, 0 , newClasspath, 0, oldClasspath.length);
					for (int j = 0; j < extraEntries.length; j++){
						newClasspath[oldClasspath.length+j] = extraEntries[j];
					}			
					// set classpath
					long innerStart = System.currentTimeMillis(); // time spent in individual CP setting
					projects[i].setRawClasspath(newClasspath, null);
					time[0] += System.currentTimeMillis() - innerStart;
				};
				start[0] = System.currentTimeMillis(); // time spent in delta refresh
			}
		}, 
		null);
		time[0] += System.currentTimeMillis()-start[0];
		System.out.println("Dense cycle check ("+numberOfParticipants+" participants) : "+ time[0]+" ms");
		
		for (int i = 0; i < numberOfParticipants; i++){
			// check cycle markers
			this.assertCycleMarkers(projects[i], projects, allProjectsInCycle);
		}
		
	} finally {
		if (projects != null){
			for (int i = 0; i < numberOfParticipants; i++){
				if (projects[i] != null)
					this.deleteProject(projects[i].getElementName());
			}
		}
	}
}

(startLine=2248 endLine=2303 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00415/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ClasspathTests.java)
private void noCycleDetection(final int numberOfParticipants, final boolean useForwardReferences) throws CoreException {
	
	final IJavaProject[] projects = new IJavaProject[numberOfParticipants];
	final int[] allProjectsInCycle = new int[numberOfParticipants];
	
	final long[] start = new long[1];
	final long[] time = new long[1];
	
	try {
		JavaCore.run(new IWorkspaceRunnable() {
			public void run(IProgressMonitor monitor) throws CoreException {
				for (int i = 0; i < numberOfParticipants; i++){
					projects[i] = createJavaProject("P"+i, new String[]{""}, "");
					allProjectsInCycle[i] = 0;
				}		
				for (int i = 0; i < numberOfParticipants; i++){
					IClasspathEntry[] extraEntries = new IClasspathEntry[useForwardReferences ? numberOfParticipants - i -1 : i];
					int index = 0;
					for (int j = useForwardReferences ? i+1 : 0; 
						useForwardReferences ? (j < numberOfParticipants) : (j < i); 
						j++){
						extraEntries[index++] = JavaCore.newProjectEntry(projects[j].getPath());
					}
					// append project references			
					IClasspathEntry[] oldClasspath = projects[i].getRawClasspath();
					IClasspathEntry[] newClasspath = new IClasspathEntry[oldClasspath.length+extraEntries.length];
					System.arraycopy(oldClasspath, 0 , newClasspath, 0, oldClasspath.length);
					for (int j = 0; j < extraEntries.length; j++){
						newClasspath[oldClasspath.length+j] = extraEntries[j];
					}			
					// set classpath
					long innerStart = System.currentTimeMillis(); // time spent in individual CP setting
					projects[i].setRawClasspath(newClasspath, null);
					time[0] += System.currentTimeMillis() - innerStart;
				}
				start[0] = System.currentTimeMillis(); // time spent in delta refresh
			}
		}, 
		null);
		time[0] += System.currentTimeMillis()-start[0];
		System.out.println("No cycle check ("+numberOfParticipants+" participants) : "+ time[0]+" ms, "+ (useForwardReferences ? "forward references" : "backward references"));
		
		for (int i = 0; i < numberOfParticipants; i++){
			// check cycle markers
			this.assertCycleMarkers(projects[i], projects, allProjectsInCycle);
		}
		
	} finally {
		if (projects != null){
			for (int i = 0; i < numberOfParticipants; i++){
				if (projects[i] != null)
					this.deleteProject(projects[i].getElementName());
			}
		}
	}
}

commonMethod: 
(startLine=460 endLine=475 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00416/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java)
/**
 * Batch deletion of projects
 */
protected void deleteProjects(final String[] projectNames) throws CoreException {
	ResourcesPlugin.getWorkspace().run(new IWorkspaceRunnable() {
		public void run(IProgressMonitor monitor) throws CoreException {
			if (projectNames != null){
				for (int i = 0, max = projectNames.length; i < max; i++){
					if (projectNames[i] != null)
						deleteProject(projectNames[i]);
				}
			}
		}
	},
	null);
}


, Instance #
frags: 
(startLine=120 endLine=137 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00417/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java)
	if (subroutines != null) {
		for (int i = 0, max = subroutines.length; i < max; i++) {
			AstNode sub;
			if ((sub = subroutines[i]) instanceof SynchronizedStatement) {
				codeStream.load(((SynchronizedStatement) sub).synchroVariable);
				codeStream.monitorexit();
			} else {
				TryStatement trySub = (TryStatement) sub;
				if (trySub.subRoutineCannotReturn) {
					codeStream.goto_(trySub.subRoutineStartLabel);
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					codeStream.jsr(trySub.subRoutineStartLabel);
				}
			}
		}
	}

(startLine=42 endLine=59 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00417/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BranchStatement.java)
	if (subroutines != null){
		for (int i = 0, max = subroutines.length; i < max; i++){
			AstNode sub;
			if ((sub = subroutines[i]) instanceof SynchronizedStatement){
				codeStream.load(((SynchronizedStatement)sub).synchroVariable);
				codeStream.monitorexit(); 
			} else {
				TryStatement trySub = (TryStatement) sub;
				if (trySub.subRoutineCannotReturn)	{
					codeStream.goto_(trySub.subRoutineStartLabel);
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					codeStream.jsr(trySub.subRoutineStartLabel);
				}
			}
		}
	}

commonMethod: 
(startLine=41 endLine=49 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00418/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SubRoutineStatement.java)
	public void exitAnyExceptionHandler() {
		if (this.anyExceptionLabelsCount == 0) return;
		ExceptionLabel currentLabel = this.anyExceptionLabels[this.anyExceptionLabelsCount-1];
		if (currentLabel.start == currentLabel.codeStream.position) {
			// discard empty exception handler
			this.anyExceptionLabels[this.anyExceptionLabelsCount--] = null;
		}
		currentLabel.placeEnd();
	}


, Instance #
frags: 
(startLine=120 endLine=137 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00417/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java)
	if (subroutines != null) {
		for (int i = 0, max = subroutines.length; i < max; i++) {
			AstNode sub;
			if ((sub = subroutines[i]) instanceof SynchronizedStatement) {
				codeStream.load(((SynchronizedStatement) sub).synchroVariable);
				codeStream.monitorexit();
			} else {
				TryStatement trySub = (TryStatement) sub;
				if (trySub.subRoutineCannotReturn) {
					codeStream.goto_(trySub.subRoutineStartLabel);
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					codeStream.jsr(trySub.subRoutineStartLabel);
				}
			}
		}
	}

(startLine=42 endLine=59 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00417/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BranchStatement.java)
	if (subroutines != null){
		for (int i = 0, max = subroutines.length; i < max; i++){
			AstNode sub;
			if ((sub = subroutines[i]) instanceof SynchronizedStatement){
				codeStream.load(((SynchronizedStatement)sub).synchroVariable);
				codeStream.monitorexit(); 
			} else {
				TryStatement trySub = (TryStatement) sub;
				if (trySub.subRoutineCannotReturn)	{
					codeStream.goto_(trySub.subRoutineStartLabel);
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					codeStream.jsr(trySub.subRoutineStartLabel);
				}
			}
		}
	}

commonMethod: 
(startLine=58 endLine=64 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00418/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SubRoutineStatement.java)
	public static void reenterExceptionHandlers(SubRoutineStatement[] subroutines, int max, CodeStream codeStream) {
		if (subroutines == null) return;
		if (max < 0) max = subroutines.length;
		for (int i = 0; i < max; i++) {
			subroutines[i].enterAnyExceptionHandler(codeStream); 
		}	
	}


, Instance #
frags: 
(startLine=43 endLine=58 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00417/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BranchStatement.java)
		for (int i = 0, max = subroutines.length; i < max; i++){
			AstNode sub;
			if ((sub = subroutines[i]) instanceof SynchronizedStatement){
				codeStream.load(((SynchronizedStatement)sub).synchroVariable);
				codeStream.monitorexit(); 
			} else {
				TryStatement trySub = (TryStatement) sub;
				if (trySub.subRoutineCannotReturn)	{
					codeStream.goto_(trySub.subRoutineStartLabel);
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					codeStream.jsr(trySub.subRoutineStartLabel);
				}
			}
		}

(startLine=121 endLine=136 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00417/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java)
		for (int i = 0, max = subroutines.length; i < max; i++) {
			AstNode sub;
			if ((sub = subroutines[i]) instanceof SynchronizedStatement) {
				codeStream.load(((SynchronizedStatement) sub).synchroVariable);
				codeStream.monitorexit();
			} else {
				TryStatement trySub = (TryStatement) sub;
				if (trySub.subRoutineCannotReturn) {
					codeStream.goto_(trySub.subRoutineStartLabel);
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					codeStream.jsr(trySub.subRoutineStartLabel);
				}
			}
		}

commonMethod: 
(startLine=41 endLine=49 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00418/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SubRoutineStatement.java)
	public void exitAnyExceptionHandler() {
		if (this.anyExceptionLabelsCount == 0) return;
		ExceptionLabel currentLabel = this.anyExceptionLabels[this.anyExceptionLabelsCount-1];
		if (currentLabel.start == currentLabel.codeStream.position) {
			// discard empty exception handler
			this.anyExceptionLabels[this.anyExceptionLabelsCount--] = null;
		}
		currentLabel.placeEnd();
	}


, Instance #
frags: 
(startLine=43 endLine=58 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00417/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BranchStatement.java)
		for (int i = 0, max = subroutines.length; i < max; i++){
			AstNode sub;
			if ((sub = subroutines[i]) instanceof SynchronizedStatement){
				codeStream.load(((SynchronizedStatement)sub).synchroVariable);
				codeStream.monitorexit(); 
			} else {
				TryStatement trySub = (TryStatement) sub;
				if (trySub.subRoutineCannotReturn)	{
					codeStream.goto_(trySub.subRoutineStartLabel);
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					codeStream.jsr(trySub.subRoutineStartLabel);
				}
			}
		}

(startLine=121 endLine=136 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00417/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ReturnStatement.java)
		for (int i = 0, max = subroutines.length; i < max; i++) {
			AstNode sub;
			if ((sub = subroutines[i]) instanceof SynchronizedStatement) {
				codeStream.load(((SynchronizedStatement) sub).synchroVariable);
				codeStream.monitorexit();
			} else {
				TryStatement trySub = (TryStatement) sub;
				if (trySub.subRoutineCannotReturn) {
					codeStream.goto_(trySub.subRoutineStartLabel);
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;
				} else {
					codeStream.jsr(trySub.subRoutineStartLabel);
				}
			}
		}

commonMethod: 
(startLine=58 endLine=64 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00418/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/SubRoutineStatement.java)
	public static void reenterExceptionHandlers(SubRoutineStatement[] subroutines, int max, CodeStream codeStream) {
		if (subroutines == null) return;
		if (max < 0) max = subroutines.length;
		for (int i = 0; i < max; i++) {
			subroutines[i].enterAnyExceptionHandler(codeStream); 
		}	
	}


, Instance #
frags: 
(startLine=1686 endLine=1716 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
		IConstantPoolEntry constantInterfaceMethodref) {

		char[] methodDescriptor = constantInterfaceMethodref.getMethodDescriptor();
		CharOperation.replace(methodDescriptor, '/', '.');
		char[] returnType = Signature.getReturnType(methodDescriptor);
		CharOperation.replace(returnType, '/', '.');
		
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.INVOKEINTERFACE])
			.append(Util.bind("classformat.nargs")) //$NON-NLS-1$
			.append(nargs)
			.append(Util.bind("classformat.interfacemethodrefindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("classformat.invokeinterfacemethod")) //$NON-NLS-1$
			.append(returnDeclaringClassName(constantInterfaceMethodref))
			.append(Util.bind("disassembler.classmemberseparator")) //$NON-NLS-1$
			.append(
				Signature.toCharArray(
					methodDescriptor,
					constantInterfaceMethodref.getMethodName(),
					getParameterNames(methodDescriptor),
					true,
					false))
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(Signature.toCharArray(returnType))
			.append(Util.bind("classformat.invokeinterfacemethodclose")); //$NON-NLS-1$
		writeNewLine();
	}

(startLine=1777 endLine=1805 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _invokestatic(int pc, int index, IConstantPoolEntry constantMethodref) {

		char[] methodDescriptor = constantMethodref.getMethodDescriptor();
		CharOperation.replace(methodDescriptor, '/', '.');
		char[] returnType = Signature.getReturnType(methodDescriptor);
		CharOperation.replace(returnType, '/', '.');
		
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.INVOKESTATIC])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("classformat.invokestaticmethod")) //$NON-NLS-1$
			.append(returnDeclaringClassName(constantMethodref))
			.append(Util.bind("disassembler.classmemberseparator")) //$NON-NLS-1$
			.append(
				Signature.toCharArray(
					methodDescriptor,
					constantMethodref.getMethodName(),
					getParameterNames(methodDescriptor),
					true,
					false))
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(Signature.toCharArray(returnType))
			.append(Util.bind("classformat.invokestaticmethodclose")); //$NON-NLS-1$
		writeNewLine();
	}

(startLine=1810 endLine=1838 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _invokevirtual(int pc, int index, IConstantPoolEntry constantMethodref) {

		char[] methodDescriptor = constantMethodref.getMethodDescriptor();
		CharOperation.replace(methodDescriptor, '/', '.');
		char[] returnType = Signature.getReturnType(methodDescriptor);
		CharOperation.replace(returnType, '/', '.');
		
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.INVOKEVIRTUAL])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("classformat.invokevirtualmethod")) //$NON-NLS-1$
			.append(returnDeclaringClassName(constantMethodref))
			.append(Util.bind("disassembler.classmemberseparator")) //$NON-NLS-1$
			.append(
				Signature.toCharArray(
					methodDescriptor,
					constantMethodref.getMethodName(),
					getParameterNames(methodDescriptor),
					true,
					false))
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(Signature.toCharArray(returnType))
			.append(Util.bind("classformat.invokevirtualmethodclose")); //$NON-NLS-1$
		writeNewLine();
	}

commonMethod: 
(startLine=55 endLine=66 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00420/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	private void dumpPcNumber(int pc) {
		writeTabs();
		int digitForPC = 0;
		if (pc != 0) {
			digitForPC = (int) (Math.log(pc) / Math.log(10));
		}
		for (int i = 0, max = this.digitNumberForPC - digitForPC; i < max; i++) {
			buffer.append(' ');
		}
		buffer.append(pc);
		buffer.append(Util.bind("disassembler.identation")); //$NON-NLS-1$
	}


, Instance #
frags: 
(startLine=2149 endLine=2169 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _ldc_w(int pc, int index, IConstantPoolEntry constantPoolEntry) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC_W])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("disassembler.space")); //$NON-NLS-1$
		switch (constantPoolEntry.getKind()) {
			case IConstantPoolConstant.CONSTANT_Float :
				appendOutputforConstantFloat(constantPoolEntry);
				break;
			case IConstantPoolConstant.CONSTANT_Integer :
				appendOutputforConstantInteger(constantPoolEntry);
				break;
			case IConstantPoolConstant.CONSTANT_String :
				appendOutputForConstantString(constantPoolEntry);
		}
		writeNewLine();
	}

(startLine=2174 endLine=2194 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _ldc(int pc, int index, IConstantPoolEntry constantPoolEntry) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LDC])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("disassembler.space")); //$NON-NLS-1$
		switch (constantPoolEntry.getKind()) {
			case IConstantPoolConstant.CONSTANT_Float :
				appendOutputforConstantFloat(constantPoolEntry);
				break;
			case IConstantPoolConstant.CONSTANT_Integer :
				appendOutputforConstantInteger(constantPoolEntry);
				break;
			case IConstantPoolConstant.CONSTANT_String :
				appendOutputForConstantString(constantPoolEntry);
		}
		writeNewLine();
	}

commonMethod: 
(startLine=55 endLine=66 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00420/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	private void dumpPcNumber(int pc) {
		writeTabs();
		int digitForPC = 0;
		if (pc != 0) {
			digitForPC = (int) (Math.log(pc) / Math.log(10));
		}
		for (int i = 0, max = this.digitNumberForPC - digitForPC; i < max; i++) {
			buffer.append(' ');
		}
		buffer.append(pc);
		buffer.append(Util.bind("disassembler.identation")); //$NON-NLS-1$
	}


, Instance #
frags: 
(startLine=1054 endLine=1070 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _getfield(int pc, int index, IConstantPoolEntry constantFieldref) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.GETFIELD])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("classformat.getfield")) //$NON-NLS-1$
			.append(returnDeclaringClassName(constantFieldref))
			.append(Util.bind("disassembler.classmemberseparator")) //$NON-NLS-1$
			.append(constantFieldref.getFieldName())
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(returnFieldrefDescriptor(constantFieldref))
			.append(Util.bind("classformat.getfieldclose")); //$NON-NLS-1$
		writeNewLine();
	}

(startLine=1075 endLine=1091 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _getstatic(int pc, int index, IConstantPoolEntry constantFieldref) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.GETSTATIC])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("classformat.getstatic")) //$NON-NLS-1$
			.append(returnDeclaringClassName(constantFieldref))
			.append(Util.bind("disassembler.classmemberseparator")) //$NON-NLS-1$
			.append(constantFieldref.getFieldName())
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(returnFieldrefDescriptor(constantFieldref))
			.append(Util.bind("classformat.getstaticclose")); //$NON-NLS-1$
		writeNewLine();
	}

(startLine=2613 endLine=2629 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _putfield(int pc, int index, IConstantPoolEntry constantFieldref) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.PUTFIELD])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("classformat.putfield"))			 //$NON-NLS-1$
			.append(returnDeclaringClassName(constantFieldref))
			.append(Util.bind("disassembler.classmemberseparator")) //$NON-NLS-1$
			.append(constantFieldref.getFieldName())
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(returnFieldrefDescriptor(constantFieldref))
			.append(Util.bind("classformat.putfieldclose")); //$NON-NLS-1$
		writeNewLine();
	}

(startLine=2634 endLine=2650 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _putstatic(int pc, int index, IConstantPoolEntry constantFieldref) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.PUTSTATIC])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("classformat.putstatic")) //$NON-NLS-1$
			.append(returnDeclaringClassName(constantFieldref))
			.append(Util.bind("disassembler.classmemberseparator")) //$NON-NLS-1$
			.append(constantFieldref.getFieldName())
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(returnFieldrefDescriptor(constantFieldref))
			.append(Util.bind("classformat.putstaticclose")); //$NON-NLS-1$
		writeNewLine();
	}

commonMethod: 
(startLine=55 endLine=66 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00420/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	private void dumpPcNumber(int pc) {
		writeTabs();
		int digitForPC = 0;
		if (pc != 0) {
			digitForPC = (int) (Math.log(pc) / Math.log(10));
		}
		for (int i = 0, max = this.digitNumberForPC - digitForPC; i < max; i++) {
			buffer.append(' ');
		}
		buffer.append(pc);
		buffer.append(Util.bind("disassembler.identation")); //$NON-NLS-1$
	}


, Instance #
frags: 
(startLine=2319 endLine=2337 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _lookupswitch(int pc, int defaultoffset, int npairs, int[][] offset_pairs) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.LOOKUPSWITCH])
			.append("default:") //$NON-NLS-1$
			.append(defaultoffset + pc);
		writeNewLine();
		for (int i = 0; i < npairs; i++) {
			writeExtraTabs(1);
			buffer
				.append("case") //$NON-NLS-1$
				.append(offset_pairs[i][0])
				.append(":") //$NON-NLS-1$
				.append(offset_pairs[i][1] + pc);
			writeNewLine();
		}
	}

(startLine=2742 endLine=2761 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
		int[] jump_offsets) {

		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.TABLESWITCH])
			.append("default:") //$NON-NLS-1$
			.append(defaultoffset + pc);
		writeNewLine();
		for (int i = low; i < high + 1; i++) {
			writeExtraTabs(1);
			buffer
				.append("case") //$NON-NLS-1$
				.append(i)
				.append(":") //$NON-NLS-1$
				.append(jump_offsets[i - low] + pc);
			writeNewLine();
		}
	}

commonMethod: 
(startLine=55 endLine=66 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00420/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	private void dumpPcNumber(int pc) {
		writeTabs();
		int digitForPC = 0;
		if (pc != 0) {
			digitForPC = (int) (Math.log(pc) / Math.log(10));
		}
		for (int i = 0, max = this.digitNumberForPC - digitForPC; i < max; i++) {
			buffer.append(' ');
		}
		buffer.append(pc);
		buffer.append(Util.bind("disassembler.identation")); //$NON-NLS-1$
	}


, Instance #
frags: 
(startLine=146 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _anewarray(int pc, int index, IConstantPoolEntry constantClass) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.ANEWARRAY])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(returnConstantClassName(constantClass));
		writeNewLine();
	}

(startLine=322 endLine=333 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _checkcast(int pc, int index, IConstantPoolEntry constantClass) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.CHECKCAST])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(returnConstantClassName(constantClass));
		writeNewLine();
	}

(startLine=1564 endLine=1575 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _iinc(int pc, int index, int _const) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.IINC])
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(_const);
		writeNewLine();
	}

(startLine=1666 endLine=1677 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _instanceof(int pc, int index, IConstantPoolEntry constantClass) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.INSTANCEOF])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(returnConstantClassName(constantClass));
		writeNewLine();
	}

(startLine=2528 endLine=2540 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
		IConstantPoolEntry constantClass) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.MULTIANEWARRAY])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(returnConstantClassName(constantClass));
		appendDimensions(dimensions);
		writeNewLine();
	}

(startLine=2545 endLine=2556 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _new(int pc, int index, IConstantPoolEntry constantClass) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NEW])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(index)
			.append(Util.bind("disassembler.space")) //$NON-NLS-1$
			.append(returnConstantClassName(constantClass));
		writeNewLine();
	}

(startLine=2561 endLine=2572 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00419/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	public void _newarray(int pc, int atype) {
		writeTabs();
		buffer
			.append(pc)
			.append(Util.bind("disassembler.tab")) //$NON-NLS-1$
			.append(OpcodeStringValues.BYTECODE_NAMES[IOpcodeMnemonics.NEWARRAY])
			.append(Util.bind("disassembler.constantpoolindex")) //$NON-NLS-1$
			.append(atype)
			.append(Util.bind("disassembler.space")); //$NON-NLS-1$
		appendGetArrayType(atype);
		writeNewLine();
	}

commonMethod: 
(startLine=55 endLine=66 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00420/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/util/DefaultBytecodeVisitor.java)
	private void dumpPcNumber(int pc) {
		writeTabs();
		int digitForPC = 0;
		if (pc != 0) {
			digitForPC = (int) (Math.log(pc) / Math.log(10));
		}
		for (int i = 0, max = this.digitNumberForPC - digitForPC; i < max; i++) {
			buffer.append(' ');
		}
		buffer.append(pc);
		buffer.append(Util.bind("disassembler.identation")); //$NON-NLS-1$
	}


, Instance #
frags: 
(startLine=274 endLine=285 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00429/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_TargetPlatform)){
				if (optionValue.equals(VERSION_1_1)) {
					this.targetJDK = JDK1_1;
				} else if (optionValue.equals(VERSION_1_2)) {
					this.targetJDK = JDK1_2;
				} else if (optionValue.equals(VERSION_1_3)) {
					this.targetJDK = JDK1_3;
				} else if (optionValue.equals(VERSION_1_4)) {
					this.targetJDK = JDK1_4;
				}
				continue;
			} 

(startLine=287 endLine=298 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00429/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_Compliance)){
				if (optionValue.equals(VERSION_1_1)) {
					this.complianceLevel = JDK1_1;
				} else if (optionValue.equals(VERSION_1_2)) {
					this.complianceLevel = JDK1_2;
				} else if (optionValue.equals(VERSION_1_3)) {
					this.complianceLevel = JDK1_3;
				} else if (optionValue.equals(VERSION_1_4)) {
					this.complianceLevel = JDK1_4;
				}
				continue;
			} 

commonMethod: 
(startLine=842 endLine=855 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00430/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
	public static long versionToJdkLevel(String versionID) {
		if (versionID.equals(VERSION_1_1)) {
			return JDK1_1;
		} else if (versionID.equals(VERSION_1_2)) {
			return JDK1_2;
		} else if (versionID.equals(VERSION_1_3)) {
			return JDK1_3;
		} else if (versionID.equals(VERSION_1_4)) {
			return JDK1_4;
		} else if (versionID.equals(VERSION_1_5)) {
			return JDK1_5;
		}
		return 0; // unknown
	}


, Instance #
frags: 
(startLine=323 endLine=354 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00438/org.eclipse.jdt.core.tests.model/workspace/Converter/junit/awtui/TestRunner.java)
	public void rerun() {
		int index= fFailureList.getSelectedIndex();
		if (index == -1)
			return;
	
		Test test= (Test)fFailedTests.elementAt(index);
		if (!(test instanceof TestCase)) {
			showInfo("Could not reload "+ test.toString());
			return;
		}
		Test reloadedTest= null;
		try {
			Class reloadedTestClass= getLoader().reload(test.getClass());
			Class[] classArgs= { String.class };
			Constructor constructor= reloadedTestClass.getConstructor(classArgs);
			Object[] args= new Object[]{((TestCase)test).getName()};
			reloadedTest=(Test)constructor.newInstance(args);
		} catch(Exception e) {
			showInfo("Could not reload "+ test.toString());
			return;
		}
		TestResult result= new TestResult();
		reloadedTest.run(result);
		
		String message= reloadedTest.toString();
		if(result.wasSuccessful())
			showInfo(message+" was successful");
		else if (result.errorCount() == 1)
			showStatus(message+" had an error");
		else
			showStatus(message+" had a failure");
	}

(startLine=554 endLine=580 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00438/org.eclipse.jdt.core.tests.model/workspace/Converter/junit/swingui/TestRunner.java)
	private void rerunTest(Test test) {
		if (!(test instanceof TestCase)) {
			showInfo("Could not reload "+ test.toString());
			return;
		}
		Test reloadedTest= null;
		try {
			Class reloadedTestClass= getLoader().reload(test.getClass());
			Class[] classArgs= { String.class };
			Object[] args= new Object[]{((TestCase)test).getName()};
			Constructor constructor= reloadedTestClass.getConstructor(classArgs);
			reloadedTest=(Test)constructor.newInstance(args);
		} catch(Exception e) {
			showInfo("Could not reload "+ test.toString());
			return;
		}
		TestResult result= new TestResult();
		reloadedTest.run(result);
		
		String message= reloadedTest.toString();
		if(result.wasSuccessful())
			showInfo(message+" was successful");
		else if (result.errorCount() == 1) 
			showStatus(message+" had an error"); 
		else 
			showStatus(message+" had a failure");
	}

commonMethod: 
(startLine=117 endLine=145 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00439/org.eclipse.jdt.core.tests.model/workspace/Converter/junit/framework/TestSuite.java)


, Instance #
frags: 
(startLine=618 endLine=652 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00445/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	 */
	public String format(String string, int[] positions, AstNode[] nodes) {
		// reset the scribe
		this.scribe.reset();
		
		long startTime = System.currentTimeMillis();

		final char[] compilationUnitSource = string.toCharArray();
		
		this.scribe.scanner.setSource(compilationUnitSource);
		this.localScanner.setSource(compilationUnitSource);
		this.scribe.scannerEndPosition = compilationUnitSource.length;
		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);
		if (nodes == null) {
			return string;
		}

		this.lastLocalDeclarationSourceStart = 0;
		try {
			if (nodes != null) {
				formatClassBodyDeclarations(nodes);
			}
		} catch(AbortFormatting e){
			StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());
			buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());
			if (DEBUG) {
				System.out.println("COULD NOT FORMAT \n" + this.scribe.scanner); //$NON-NLS-1$
				System.out.println(this.scribe);
			}
			return buffer.toString();
		}
		if (DEBUG){
			System.out.println("Formatting time: " + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$
		}
		return this.scribe.toString();

(startLine=658 endLine=690 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00445/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	 */
	public String format(String string, int[] positions, CompilationUnitDeclaration compilationUnitDeclaration) {
		// reset the scribe
		this.scribe.reset();
		
		long startTime = System.currentTimeMillis();

		final char[] compilationUnitSource = string.toCharArray();
		
		this.scribe.scanner.setSource(compilationUnitSource);
		this.localScanner.setSource(compilationUnitSource);
		this.scribe.scannerEndPosition = compilationUnitSource.length;
		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);
		if (compilationUnitDeclaration == null || compilationUnitDeclaration.ignoreFurtherInvestigation) {
			return string;
		}

		this.lastLocalDeclarationSourceStart = 0;
		try {
			compilationUnitDeclaration.traverse(this, compilationUnitDeclaration.scope);
		} catch(AbortFormatting e){
			StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());
			buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());
			if (DEBUG) {
				System.out.println("COULD NOT FORMAT \n" + this.scribe.scanner); //$NON-NLS-1$
				System.out.println(this.scribe);
			}
			return buffer.toString();
		}
		if (DEBUG){
			System.out.println("Formatting time: " + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$
		}
		return this.scribe.toString();

(startLine=696 endLine=728 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00445/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	 */
	public String format(String string, int[] positions, Expression expression) {
		// reset the scribe
		this.scribe.reset();
		
		long startTime = System.currentTimeMillis();

		final char[] compilationUnitSource = string.toCharArray();
		
		this.scribe.scanner.setSource(compilationUnitSource);
		this.localScanner.setSource(compilationUnitSource);
		this.scribe.scannerEndPosition = compilationUnitSource.length;
		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);
		if (expression == null) {
			return string;
		}

		this.lastLocalDeclarationSourceStart = 0;
		try {
			expression.traverse(this, null);
		} catch(AbortFormatting e){
			StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());
			buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());
			if (DEBUG) {
				System.out.println("COULD NOT FORMAT \n" + this.scribe.scanner); //$NON-NLS-1$
				System.out.println(this.scribe);
			}
			return buffer.toString();
		}
		if (DEBUG){
			System.out.println("Formatting time: " + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$
		}
		return this.scribe.toString();

(startLine=734 endLine=773 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00445/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	 */
	public String format(String string, int[] positions, ConstructorDeclaration constructorDeclaration) {
		// reset the scribe
		this.scribe.reset();
		
		long startTime = System.currentTimeMillis();

		final char[] compilationUnitSource = string.toCharArray();
		
		this.scribe.scanner.setSource(compilationUnitSource);
		this.localScanner.setSource(compilationUnitSource);
		this.scribe.scannerEndPosition = compilationUnitSource.length;
		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);
		if (constructorDeclaration == null) {
			return string;
		}

		this.lastLocalDeclarationSourceStart = 0;
		try {
			ExplicitConstructorCall explicitConstructorCall = constructorDeclaration.constructorCall;
			if (explicitConstructorCall != SuperReference.implicitSuperConstructorCall()) {
				explicitConstructorCall.traverse(this, null);
			}
			Statement[] statements = constructorDeclaration.statements;
			if (statements != null) {
				formatStatements(null, statements);
			}
		} catch(AbortFormatting e){
			StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());
			buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());
			if (DEBUG) {
				System.out.println("COULD NOT FORMAT \n" + this.scribe.scanner); //$NON-NLS-1$
				System.out.println(this.scribe);
			}
			return buffer.toString();
		}
		if (DEBUG){
			System.out.println("Formatting time: " + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$
		}
		return this.scribe.toString();

commonMethod: 
(startLine=649 endLine=657 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00446/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	private String failedToFormat(final char[] compilationUnitSource) {
		StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());
		buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());
		System.out.println("COULD NOT FORMAT \n" + this.scribe.scanner); //$NON-NLS-1$
		if (DEBUG) {
			System.out.println(this.scribe);
		}
		return buffer.toString();
	}


, Instance #
frags: 
(startLine=639 endLine=647 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00445/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
			}
		} catch(AbortFormatting e){
			StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());
			buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());
			if (DEBUG) {
				System.out.println("COULD NOT FORMAT \n" + this.scribe.scanner); //$NON-NLS-1$
				System.out.println(this.scribe);
			}
			return buffer.toString();

(startLine=677 endLine=685 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00445/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
			compilationUnitDeclaration.traverse(this, compilationUnitDeclaration.scope);
		} catch(AbortFormatting e){
			StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());
			buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());
			if (DEBUG) {
				System.out.println("COULD NOT FORMAT \n" + this.scribe.scanner); //$NON-NLS-1$
				System.out.println(this.scribe);
			}
			return buffer.toString();

(startLine=715 endLine=723 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00445/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
			expression.traverse(this, null);
		} catch(AbortFormatting e){
			StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());
			buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());
			if (DEBUG) {
				System.out.println("COULD NOT FORMAT \n" + this.scribe.scanner); //$NON-NLS-1$
				System.out.println(this.scribe);
			}
			return buffer.toString();

(startLine=760 endLine=768 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00445/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
			}
		} catch(AbortFormatting e){
			StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());
			buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());
			if (DEBUG) {
				System.out.println("COULD NOT FORMAT \n" + this.scribe.scanner); //$NON-NLS-1$
				System.out.println(this.scribe);
			}
			return buffer.toString();

commonMethod: 
(startLine=649 endLine=657 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00446/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	private String failedToFormat(final char[] compilationUnitSource) {
		StringBuffer buffer = new StringBuffer(this.scribe.formattedSource());
		buffer.append(compilationUnitSource, this.scribe.scanner.getCurrentTokenEndPosition(), this.scribe.scannerEndPosition - this.scribe.scanner.getCurrentTokenEndPosition());
		System.out.println("COULD NOT FORMAT \n" + this.scribe.scanner); //$NON-NLS-1$
		if (DEBUG) {
			System.out.println(this.scribe);
		}
		return buffer.toString();
	}


, Instance #
frags: 
(startLine=64 endLine=79 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00454/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java)
	if (source != null && insertion > -1 && insertion < source.length()) {
		String encoding = project.getOption(JavaCore.CORE_ENCODING, true); 
		
		char[] prefix = CharOperation.concat(source.substring(0, insertion).toCharArray(), new char[]{'{'});
		char[] suffix =  CharOperation.concat(new char[]{'}'}, source.substring(insertion).toCharArray());
		char[] fakeSource = CharOperation.concat(prefix, snippet, suffix);
		
		BasicCompilationUnit cu = 
			new BasicCompilationUnit(
				fakeSource, 
				null,
				getElementName(),
				encoding); 

		engine.complete(cu, prefix.length + position, prefix.length);
	} else {

(startLine=60 endLine=75 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00454/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java)
	if (source != null && insertion > -1 && insertion < source.length()) {
		String encoding = project.getOption(JavaCore.CORE_ENCODING, true);
		
		char[] prefix = CharOperation.concat(source.substring(0, insertion).toCharArray(), new char[]{'{'});
		char[] suffix = CharOperation.concat(new char[]{'}'}, source.substring(insertion).toCharArray());
		char[] fakeSource = CharOperation.concat(prefix, snippet, suffix);
		
		BasicCompilationUnit cu = 
			new BasicCompilationUnit(
				fakeSource, 
				null,
				getElementName(),
				encoding); 

		engine.complete(cu, prefix.length + position, prefix.length);
	} else {

commonMethod: 
(startLine=754 endLine=777 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00455/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/NameLookup.java)
/**
 * Remembers a set of compilation units that will be looked inside
 * when looking up a type. If they are working copies, they take
 * precedence over their compilation units.
 * <code>null</code> means that no special compilation units should be used.
 */
public void setUnitsToLookInside(IWorkingCopy[] unitsToLookInside) {
	
	if (unitsToLookInside == null) {
		this.unitsToLookInside.setCurrent(null); 
	} else {
		HashMap workingCopies = new HashMap();
		this.unitsToLookInside.setCurrent(workingCopies);
		for (int i = 0, length = unitsToLookInside.length; i < length; i++) {
			IWorkingCopy unitToLookInside = unitsToLookInside[i];
			ICompilationUnit original = (ICompilationUnit)unitToLookInside.getOriginalElement();
			if (original != null) {
				workingCopies.put(original, unitToLookInside);
			} else {
				workingCopies.put(unitToLookInside, unitToLookInside);
			}
		}
	}
}


, Instance #
frags: 
(startLine=64 endLine=79 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00454/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/BinaryType.java)
	if (source != null && insertion > -1 && insertion < source.length()) {
		String encoding = project.getOption(JavaCore.CORE_ENCODING, true); 
		
		char[] prefix = CharOperation.concat(source.substring(0, insertion).toCharArray(), new char[]{'{'});
		char[] suffix =  CharOperation.concat(new char[]{'}'}, source.substring(insertion).toCharArray());
		char[] fakeSource = CharOperation.concat(prefix, snippet, suffix);
		
		BasicCompilationUnit cu = 
			new BasicCompilationUnit(
				fakeSource, 
				null,
				getElementName(),
				encoding); 

		engine.complete(cu, prefix.length + position, prefix.length);
	} else {

(startLine=60 endLine=75 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00454/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/SourceType.java)
	if (source != null && insertion > -1 && insertion < source.length()) {
		String encoding = project.getOption(JavaCore.CORE_ENCODING, true);
		
		char[] prefix = CharOperation.concat(source.substring(0, insertion).toCharArray(), new char[]{'{'});
		char[] suffix = CharOperation.concat(new char[]{'}'}, source.substring(insertion).toCharArray());
		char[] fakeSource = CharOperation.concat(prefix, snippet, suffix);
		
		BasicCompilationUnit cu = 
			new BasicCompilationUnit(
				fakeSource, 
				null,
				getElementName(),
				encoding); 

		engine.complete(cu, prefix.length + position, prefix.length);
	} else {

commonMethod: 
(startLine=985 endLine=1003 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00455/org.eclipse.jdt.core/model/org/eclipse/jdt/internal/core/JavaModelManager.java)
	public ICompilationUnit[] getWorkingCopies(WorkingCopyOwner owner, boolean addPrimary) {
		synchronized(perWorkingCopyInfos) {
			ICompilationUnit[] primaryWCs = addPrimary && owner != DefaultWorkingCopyOwner.PRIMARY 
				? getWorkingCopies(DefaultWorkingCopyOwner.PRIMARY, false) 
				: NoWorkingCopy;
			Map pathToPerWorkingCopyInfos = (Map)perWorkingCopyInfos.get(owner);
			if (pathToPerWorkingCopyInfos == null) return primaryWCs;
			int primaryLength = primaryWCs.length;
			int size = pathToPerWorkingCopyInfos.size(); // note size is > 0 otherwise pathToPerWorkingCopyInfos would be null
			ICompilationUnit[] result = new ICompilationUnit[primaryLength + size];
			System.arraycopy(primaryWCs, 0, result, 0, primaryLength);
			Iterator iterator = pathToPerWorkingCopyInfos.values().iterator();
			int index = primaryLength;
			while(iterator.hasNext()) {
				result[index++] = ((JavaModelManager.PerWorkingCopyInfo)iterator.next()).getWorkingCopy();
			}
			return result;
		}		
	}


, Instance #
frags: 
(startLine=813 endLine=827 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java)
			if (currentArg.startsWith("-nowarn")) { //$NON-NLS-1$
				Object[] entries = options.entrySet().toArray();
				for (int i = 0, max = entries.length; i < max; i++) {
					Map.Entry entry = (Map.Entry) entries[i];
					if (!(entry.getKey() instanceof String))
						continue;
					if (!(entry.getValue() instanceof String))
						continue;
					if (((String) entry.getValue()).equals(CompilerOptions.WARNING)) {
						options.put((String) entry.getKey(), CompilerOptions.IGNORE);
					}
				}
				mode = Default;
				continue;
			}

(startLine=832 endLine=845 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java)
				if (length == 10 && warningOption.equals("-warn:none")) { //$NON-NLS-1$
					Object[] entries = options.entrySet().toArray();
					for (int i = 0, max = entries.length; i < max; i++) {
						Map.Entry entry = (Map.Entry) entries[i];
						if (!(entry.getKey() instanceof String))
							continue;
						if (!(entry.getValue() instanceof String))
							continue;
						if (((String) entry.getValue()).equals(CompilerOptions.WARNING)) {
							options.put((String) entry.getKey(), CompilerOptions.IGNORE);
						}
					}
					continue;
				}

commonMethod: 
(startLine=1205 endLine=1218 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00465/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java)
	private void disableWarnings() {
		Object[] entries = options.entrySet().toArray();
		for (int i = 0, max = entries.length; i < max; i++) {
			Map.Entry entry = (Map.Entry) entries[i];
			if (!(entry.getKey() instanceof String))
				continue;
			if (!(entry.getValue() instanceof String))
				continue;
			if (((String) entry.getValue()).equals(CompilerOptions.WARNING)) {
				options.put((String) entry.getKey(), CompilerOptions.IGNORE);
			}
		}
		options.put(CompilerOptions.OPTION_TaskTags, ""); //$NON-NLS-1$
	}


, Instance #
frags: 
(startLine=815 endLine=824 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java)
				for (int i = 0, max = entries.length; i < max; i++) {
					Map.Entry entry = (Map.Entry) entries[i];
					if (!(entry.getKey() instanceof String))
						continue;
					if (!(entry.getValue() instanceof String))
						continue;
					if (((String) entry.getValue()).equals(CompilerOptions.WARNING)) {
						options.put((String) entry.getKey(), CompilerOptions.IGNORE);
					}
				}

(startLine=834 endLine=843 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java)
					for (int i = 0, max = entries.length; i < max; i++) {
						Map.Entry entry = (Map.Entry) entries[i];
						if (!(entry.getKey() instanceof String))
							continue;
						if (!(entry.getValue() instanceof String))
							continue;
						if (((String) entry.getValue()).equals(CompilerOptions.WARNING)) {
							options.put((String) entry.getKey(), CompilerOptions.IGNORE);
						}
					}

commonMethod: 
(startLine=1205 endLine=1218 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00465/org.eclipse.jdt.core/batch/org/eclipse/jdt/internal/compiler/batch/Main.java)
	private void disableWarnings() {
		Object[] entries = options.entrySet().toArray();
		for (int i = 0, max = entries.length; i < max; i++) {
			Map.Entry entry = (Map.Entry) entries[i];
			if (!(entry.getKey() instanceof String))
				continue;
			if (!(entry.getValue() instanceof String))
				continue;
			if (((String) entry.getValue()).equals(CompilerOptions.WARNING)) {
				options.put((String) entry.getKey(), CompilerOptions.IGNORE);
			}
		}
		options.put(CompilerOptions.OPTION_TaskTags, ""); //$NON-NLS-1$
	}


, Instance #
frags: 
(startLine=240 endLine=252 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportUnreachableCode)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= UnreachableCode;
					this.warningThreshold &= ~UnreachableCode;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~UnreachableCode;
					this.warningThreshold |= UnreachableCode;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~UnreachableCode;
					this.warningThreshold &= ~UnreachableCode;
				}
				continue;
			} 

(startLine=254 endLine=266 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportInvalidImport)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= ImportProblem;
					this.warningThreshold &= ~ImportProblem;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~ImportProblem;
					this.warningThreshold |= ImportProblem;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~ImportProblem;
					this.warningThreshold &= ~ImportProblem;
				}
				continue;
			} 

(startLine=286 endLine=298 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportMethodWithConstructorName)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= MethodWithConstructorName;
					this.warningThreshold &= ~MethodWithConstructorName;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~MethodWithConstructorName;
					this.warningThreshold |= MethodWithConstructorName;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~MethodWithConstructorName;
					this.warningThreshold &= ~MethodWithConstructorName;
				}
				continue;
			} 

(startLine=300 endLine=312 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportOverridingPackageDefaultMethod)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= OverriddenPackageDefaultMethod;
					this.warningThreshold &= ~OverriddenPackageDefaultMethod;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~OverriddenPackageDefaultMethod;
					this.warningThreshold |= OverriddenPackageDefaultMethod;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~OverriddenPackageDefaultMethod;
					this.warningThreshold &= ~OverriddenPackageDefaultMethod;
				}
				continue;
			} 

(startLine=314 endLine=326 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportDeprecation)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= UsingDeprecatedAPI;
					this.warningThreshold &= ~UsingDeprecatedAPI;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~UsingDeprecatedAPI;
					this.warningThreshold |= UsingDeprecatedAPI;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~UsingDeprecatedAPI;
					this.warningThreshold &= ~UsingDeprecatedAPI;
				}
				continue;
			} 

(startLine=337 endLine=349 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportHiddenCatchBlock)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= MaskedCatchBlock;
					this.warningThreshold &= ~MaskedCatchBlock;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~MaskedCatchBlock;
					this.warningThreshold |= MaskedCatchBlock;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~MaskedCatchBlock;
					this.warningThreshold &= ~MaskedCatchBlock;
				}
				continue;
			} 

(startLine=351 endLine=363 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportUnusedLocal)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= UnusedLocalVariable;
					this.warningThreshold &= ~UnusedLocalVariable;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~UnusedLocalVariable;
					this.warningThreshold |= UnusedLocalVariable;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~UnusedLocalVariable;
					this.warningThreshold &= ~UnusedLocalVariable;
				}
				continue;
			}

(startLine=365 endLine=377 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if (optionID.equals(OPTION_ReportNoImplicitStringConversion)) {
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= NoImplicitStringConversion;
					this.warningThreshold &= ~NoImplicitStringConversion;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~NoImplicitStringConversion;
					this.warningThreshold |= NoImplicitStringConversion;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~NoImplicitStringConversion;
					this.warningThreshold &= ~NoImplicitStringConversion;
				}
				continue;
			}

(startLine=379 endLine=391 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportUnusedParameter)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= UnusedArgument;
					this.warningThreshold &= ~UnusedArgument;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~UnusedArgument;
					this.warningThreshold |= UnusedArgument;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~UnusedArgument;
					this.warningThreshold &= ~UnusedArgument;
				}
				continue;
			} 

(startLine=411 endLine=423 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportUnusedImport)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= UnusedImport;
					this.warningThreshold &= ~UnusedImport;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~UnusedImport;
					this.warningThreshold |= UnusedImport;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~UnusedImport;
					this.warningThreshold &= ~UnusedImport;
				}
				continue;
			} 

(startLine=425 endLine=437 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportSyntheticAccessEmulation)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= AccessEmulation;
					this.warningThreshold &= ~AccessEmulation;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~AccessEmulation;
					this.warningThreshold |= AccessEmulation;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~AccessEmulation;
					this.warningThreshold &= ~AccessEmulation;
				}
				continue;
			}

(startLine=439 endLine=451 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportLocalVariableHiding)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= LocalVariableHiding;
					this.warningThreshold &= ~LocalVariableHiding;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~LocalVariableHiding;
					this.warningThreshold |= LocalVariableHiding;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~LocalVariableHiding;
					this.warningThreshold &= ~LocalVariableHiding;
				}
				continue;
			}

(startLine=453 endLine=465 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportFieldHiding)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= FieldHiding;
					this.warningThreshold &= ~FieldHiding;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~FieldHiding;
					this.warningThreshold |= FieldHiding;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~FieldHiding;
					this.warningThreshold &= ~FieldHiding;
				}
				continue;
			}

(startLine=476 endLine=488 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportPossibleAccidentalBooleanAssignment)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= AccidentalBooleanAssign;
					this.warningThreshold &= ~AccidentalBooleanAssign;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~AccidentalBooleanAssign;
					this.warningThreshold |= AccidentalBooleanAssign;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~AccidentalBooleanAssign;
					this.warningThreshold &= ~AccidentalBooleanAssign;
				}
				continue;
			}

(startLine=490 endLine=502 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportSuperfluousSemicolon)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= SuperfluousSemicolon;
					this.warningThreshold &= ~SuperfluousSemicolon;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~SuperfluousSemicolon;
					this.warningThreshold |= SuperfluousSemicolon;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~SuperfluousSemicolon;
					this.warningThreshold &= ~SuperfluousSemicolon;
				}
				continue;
			}

(startLine=504 endLine=516 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportNonExternalizedStringLiteral)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= NonExternalizedString;
					this.warningThreshold &= ~NonExternalizedString;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~NonExternalizedString;
					this.warningThreshold |= NonExternalizedString;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~NonExternalizedString;
					this.warningThreshold &= ~NonExternalizedString;
				}
				continue;
			}

(startLine=518 endLine=530 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportAssertIdentifier)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= AssertUsedAsAnIdentifier;
					this.warningThreshold &= ~AssertUsedAsAnIdentifier;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~AssertUsedAsAnIdentifier;
					this.warningThreshold |= AssertUsedAsAnIdentifier;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~AssertUsedAsAnIdentifier;
					this.warningThreshold &= ~AssertUsedAsAnIdentifier;
				}
				continue;
			}

(startLine=560 endLine=572 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportStaticAccessReceiver)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= StaticAccessReceiver;
					this.warningThreshold &= ~StaticAccessReceiver;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~StaticAccessReceiver;
					this.warningThreshold |= StaticAccessReceiver;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~StaticAccessReceiver;
					this.warningThreshold &= ~StaticAccessReceiver;
				}
				continue;
			} 

(startLine=574 endLine=586 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportIncompatibleNonInheritedInterfaceMethod)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= IncompatibleNonInheritedInterfaceMethod;
					this.warningThreshold &= ~IncompatibleNonInheritedInterfaceMethod;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~IncompatibleNonInheritedInterfaceMethod;
					this.warningThreshold |= IncompatibleNonInheritedInterfaceMethod;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~IncompatibleNonInheritedInterfaceMethod;
					this.warningThreshold &= ~IncompatibleNonInheritedInterfaceMethod;
				}
				continue;
			} 

(startLine=588 endLine=600 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportUnusedPrivateMember)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= UnusedPrivateMember;
					this.warningThreshold &= ~UnusedPrivateMember;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~UnusedPrivateMember;
					this.warningThreshold |= UnusedPrivateMember;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~UnusedPrivateMember;
					this.warningThreshold &= ~UnusedPrivateMember;
				}
				continue;
			} 

(startLine=611 endLine=623 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00464/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
			if(optionID.equals(OPTION_ReportNoEffectAssignment)){
				if (optionValue.equals(ERROR)) {
					this.errorThreshold |= NoEffectAssignment;
					this.warningThreshold &= ~NoEffectAssignment;
				} else if (optionValue.equals(WARNING)) {
					this.errorThreshold &= ~NoEffectAssignment;
					this.warningThreshold |= NoEffectAssignment;
				} else if (optionValue.equals(IGNORE)) {
					this.errorThreshold &= ~NoEffectAssignment;
					this.warningThreshold &= ~NoEffectAssignment;
				}
				continue;
			}

commonMethod: 
(startLine=563 endLine=574 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00465/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/CompilerOptions.java)
	void updateSeverity(long irritant, String severityString) {
		if (severityString.equals(ERROR)) {
			this.errorThreshold |= irritant;
			this.warningThreshold &= ~irritant;
		} else if (severityString.equals(WARNING)) {
			this.errorThreshold &= ~irritant;
			this.warningThreshold |= irritant;
		} else if (severityString.equals(IGNORE)) {
			this.errorThreshold &= ~irritant;
			this.warningThreshold &= ~irritant;
		}
	}				


, Instance #
frags: 
(startLine=1746 endLine=1758 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00476/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/BinaryExpression.java)
		if (unnecessaryLeftCast || unnecessaryRightCast) {
			int alternateLeftId = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType.id : leftId;
			int alternateRightId = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType.id : rightId;
			int alternateResult = ResolveTypeTables[operator][(alternateLeftId << 4) + alternateRightId];
			// (cast)  left   Op (cast)  right --> result
			//  1111   0000       1111   0000     1111
			//  <<16   <<12       <<8    <<4       <<0
			final int CompareMASK = (0xF<<16) + (0xF<<8) + 0xF; // mask hiding compile-time types
			if ((result & CompareMASK) == (alternateResult & CompareMASK)) { // same promotions and result
				if (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); 
				if (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);
			}
		}

(startLine=532 endLine=544 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00476/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/EqualExpression.java)
		if (unnecessaryLeftCast || unnecessaryRightCast) {
			int alternateLeftId = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType.id : leftType.id;
			int alternateRightId = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType.id : rightType.id;
			int alternateResult = ResolveTypeTables[EQUAL_EQUAL][(alternateLeftId << 4) + alternateRightId];
			// (cast)  left   Op (cast)  right --> result
			//  1111   0000       1111   0000     1111
			//  <<16   <<12       <<8    <<4       <<0
			final int CompareMASK = (0xF<<16) + (0xF<<8) + 0xF; // mask hiding compile-time types
			if ((result & CompareMASK) == (alternateResult & CompareMASK)) { // same promotions and result
				if (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); 
				if (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);
			}
		}		

commonMethod: 
(startLine=272 endLine=305 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00477/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java)
	/**
	 * Check binary operator casted arguments 
	 */
	public static void checkNeedForArgumentCasts(BlockScope scope, int operator, int operatorSignature, Expression left, int leftTypeId, Expression right, int rightTypeId) {

		if (scope.environment().options.getSeverity(CompilerOptions.UnnecessaryTypeCheck) == ProblemSeverities.Ignore) return;

		// check need for operand cast
		boolean unnecessaryLeftCast = (left.bits & UnnecessaryCastMask) != 0;
		int alternateLeftTypeId = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType.id : leftTypeId;
		if (unnecessaryLeftCast && alternateLeftTypeId == leftTypeId) {
			// obvious identity cast
			scope.problemReporter().unnecessaryCast((CastExpression)left); 
			unnecessaryLeftCast = false;
		}
		boolean unnecessaryRightCast = (right.bits & UnnecessaryCastMask) != 0;
		int alternateRightTypeId = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType.id : rightTypeId;
		if (unnecessaryRightCast && alternateRightTypeId == rightTypeId) {
			// obvious identity cast
			scope.problemReporter().unnecessaryCast((CastExpression)right); 
			unnecessaryRightCast = false;
		}
		if (unnecessaryLeftCast || unnecessaryRightCast) {
			int alternateOperatorSignature = OperatorExpression.OperatorSignatures[operator][(alternateLeftTypeId << 4) + alternateRightTypeId];
			// (cast)  left   Op (cast)  right --> result
			//  1111   0000       1111   0000     1111
			//  <<16   <<12       <<8    <<4       <<0
			final int CompareMASK = (0xF<<16) + (0xF<<8) + 0xF; // mask hiding compile-time types
			if ((operatorSignature & CompareMASK) == (alternateOperatorSignature & CompareMASK)) { // same promotions and result
				if (unnecessaryLeftCast) scope.problemReporter().unnecessaryCastForArgument((CastExpression)left,  TypeBinding.wellKnownType(scope, left.implicitConversion >> 4)); 
				if (unnecessaryRightCast) scope.problemReporter().unnecessaryCastForArgument((CastExpression)right, TypeBinding.wellKnownType(scope,  right.implicitConversion >> 4));
			}
		}
	}


, Instance #
frags: 
(startLine=233 endLine=249 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00478/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java)
		for (int i = 0; i < length; i++) {
			Expression argument = arguments[i];
			if ((argument.bits & UnnecessaryCastMask) != 0) {
				TypeBinding castedExpressionType = ((CastExpression)argument).expression.resolvedType;
				// obvious identity cast
				if (castedExpressionType == parameterTypes[i]) { 
					scope.problemReporter().unnecessaryCast((CastExpression)argument);
				// widening cast, will need to check later whether it would affect method lookup
				} else {
					if (rawArgumentTypes == argumentTypes) {
						System.arraycopy(rawArgumentTypes, 0, rawArgumentTypes = new TypeBinding[length], 0, length);
					}
					// only retain widened argument types, since narrowing are thought to be ok
					rawArgumentTypes[i] = castedExpressionType; 
				}
			}
		}

(startLine=257 endLine=266 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00478/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/CastExpression.java)
		for (int i = 0; i < length; i++) {
			Expression argument = arguments[i];
			if (argument instanceof CastExpression && (argument.bits & UnnecessaryCastMask) == 0) {
				TypeBinding castedExpressionType = ((CastExpression)argument).expression.resolvedType;
				if (rawArgumentTypes == argumentTypes) {
					System.arraycopy(rawArgumentTypes, 0, rawArgumentTypes = new TypeBinding[length], 0, length);
				}
				rawArgumentTypes[i] = castedExpressionType; 
			}
		}

commonMethod: 
(startLine=66 endLine=68 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00479/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java)
public final boolean isBaseType() {
	return (tagBits & IsBaseType) != 0;
}


, Instance #
frags: 
(startLine=758 endLine=771 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveFieldDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveFieldDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "foo";
	String selection = "foo";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one field", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IField);	
}

(startLine=775 endLine=788 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveTypeDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveTypeDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "OtherType";
	String selection = "OtherType";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("OtherType") &&
		elements[0] instanceof IType);	
}

(startLine=845 endLine=858 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveInnerClassAsParamater() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveInnerClassAsParamater.java");
	
	String str = cu.getSource();
	String selectAt = "foo";
	String selection = "foo";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod);
}

commonMethod: 
(startLine=545 endLine=556 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00507/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java)
/**
 * Returns the specified compilation unit in the given project, root, and
 * package fragment or <code>null</code> if it does not exist.
 */
public IClassFile getClassFile(String projectName, String rootPath, String packageName, String className) throws JavaModelException {
	IPackageFragment pkg= getPackageFragment(projectName, rootPath, packageName);
	if (pkg == null) {
		return null;
	} else {
		return pkg.getClassFile(className);
	}
}


, Instance #
frags: 
(startLine=212 endLine=225 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMethodWithInnerTypeInClassFile() throws JavaModelException {
	IClassFile cu = getClassFile("Resolve", "zzz.jar", "", "MyClass$Inner.class");

	String str = cu.getSource();
	String selectAt = "test";
	String selection = "test";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("test") &&
		elements[0] instanceof IMethod);	
}

(startLine=287 endLine=300 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveConstructorCallOfMemberType() throws JavaModelException {
	IClassFile cf = getClassFile("Resolve", "class-folder", "", "ResolveConstructorCallOfMemberType.class");
	
	String str = cf.getSource();
	String selectAt = "Inner";
	String selection = "Inner";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cf.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("Inner") &&
		elements[0] instanceof IMethod);	
}

(startLine=896 endLine=909 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveStaticClassConstructor() throws JavaModelException {
	IClassFile cu = getClassFile("Resolve", "test25888.jar", "", "ResolveStaticClassConstructor.class");

	String str = cu.getSource();
	String selectAt = "StaticInnerClass";
	String selection = "StaticInnerClass";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one method", elements.length == 1 &&
		elements[0].getElementName().equals("StaticInnerClass") &&
		elements[0] instanceof IMethod);
}

commonMethod: 
(startLine=557 endLine=568 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00507/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java)
/**
 * Returns the specified compilation unit in the given project, root, and
 * package fragment or <code>null</code> if it does not exist.
 */
public ICompilationUnit getCompilationUnit(String projectName, String rootPath, String packageName, String cuName) throws JavaModelException {
	IPackageFragment pkg= getPackageFragment(projectName, rootPath, packageName);
	if (pkg == null) {
		return null;
	} else {
		return pkg.getCompilationUnit(cuName);
	}
}


, Instance #
frags: 
(startLine=112 endLine=125 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveEmptySelection2() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveTypeEmptySelection2.java");

	String str = cu.getSource();
	String selectAt = "Obj";
	String selection = "";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Object") &&
		elements[0] instanceof IType);	
}

(startLine=129 endLine=142 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveEmptySelectionOnMethod() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveEmptySelectionOnMethod.java");

	String str = cu.getSource();
	String selectAt = "oo";
	String selection = "";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod);	
}

(startLine=212 endLine=225 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMethodWithInnerTypeInClassFile() throws JavaModelException {
	IClassFile cu = getClassFile("Resolve", "zzz.jar", "", "MyClass$Inner.class");

	String str = cu.getSource();
	String selectAt = "test";
	String selection = "test";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("test") &&
		elements[0] instanceof IMethod);	
}

(startLine=270 endLine=283 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveImport() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveImport.java");

	String str = cu.getSource();
	String selectAt = "ImportedClass";
	String selection = "ImportedClass";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("ImportedClass") &&
		elements[0] instanceof IType);	
}

(startLine=287 endLine=300 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveConstructorCallOfMemberType() throws JavaModelException {
	IClassFile cf = getClassFile("Resolve", "class-folder", "", "ResolveConstructorCallOfMemberType.class");
	
	String str = cf.getSource();
	String selectAt = "Inner";
	String selection = "Inner";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cf.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("Inner") &&
		elements[0] instanceof IMethod);	
}

(startLine=304 endLine=317 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveLocalName1() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveLocalName.java");

	String str = cu.getSource();
	String selectAt = "var1";
	String selection = "var1";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Object") &&
		elements[0] instanceof IType);	
}

(startLine=336 endLine=349 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveArgumentName1() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveArgumentName.java");

	String str = cu.getSource();
	String selectAt = "var1";
	String selection = "var1";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Object") &&
		elements[0] instanceof IType);	
}

(startLine=369 endLine=382 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveCatchArgumentName1() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveCatchArgumentName.java");

	String str = cu.getSource();
	String selectAt = "var1";
	String selection = "var1";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Object") &&
		elements[0] instanceof IType);	
}

(startLine=414 endLine=428 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveConstructor() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveConstructor.java");
	
	String str = cu.getSource();
	String selectAt = "ResolveConstructor(\"";
	String selection = "ResolveConstructor";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("ResolveConstructor") &&
		elements[0] instanceof IMethod &&
		((IMethod)elements[0]).getParameterTypes()[0].equals("QString;"));	
}

(startLine=432 endLine=447 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMethod() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveMethod.java");
	
	String str = cu.getSource();
	String selectAt = "foo(\"";
	String selection = "foo";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one method of 'foo'",
		elements.length == 1 &&
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod &&
		((IMethod)elements[0]).getParameterTypes()[0].equals("QString;"));		
}

(startLine=451 endLine=465 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveField() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveField.java");
	
	String str = cu.getSource();
	String selectAt = "foo =";
	String selection = "foo";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one field of 'foo'",
			elements.length == 1 &&
			elements[0].getElementName().equals("foo") &&
			elements[0] instanceof IField);	
}

(startLine=469 endLine=483 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolvePackage() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolvePackage.java");
	
	String str = cu.getSource();
	String selectAt = "lang";
	String selection = "lang";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one package of 'java.lang'",
		elements.length == 1 &&
		elements[0].getElementName().equals("java.lang") &&
		elements[0] instanceof IPackageFragment);	
}

(startLine=487 endLine=500 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass1() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass1.java");
	
	String str = cu.getSource();
	String selectAt = "X";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=504 endLine=517 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass2() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass2.java");
	
	String str = cu.getSource();
	String selectAt = "X";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=521 endLine=534 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass3() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass3.java");
	
	String str = cu.getSource();
	String selectAt = "X[]{";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=538 endLine=551 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass4() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass4.java");
	
	String str = cu.getSource();
	String selectAt = "X";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=555 endLine=568 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass5() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass5.java");
	
	String str = cu.getSource();
	String selectAt = "X";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=572 endLine=585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass6() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass6.java");
	
	String str = cu.getSource();
	String selectAt = "X";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=589 endLine=602 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveInterface() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveInterface.java");
	
	String str = cu.getSource();
	String selectAt = "Y";
	String selection = "Y";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one interface", elements.length == 1 && 
		elements[0].getElementName().equals("Y") &&
		elements[0] instanceof IType);	
}

(startLine=722 endLine=736 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveConstructorDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveConstructorDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "ResolveConstructorDeclaration(i";
	String selection = "ResolveConstructorDeclaration";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("ResolveConstructorDeclaration") &&
		elements[0] instanceof IMethod &&
		((IMethod)elements[0]).getParameterTypes()[0].equals("I"));	
}

(startLine=740 endLine=754 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMethodDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveMethodDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "foo(i";
	String selection = "foo";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod &&
		((IMethod)elements[0]).getParameterTypes()[0].equals("I"));	
}

(startLine=758 endLine=771 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveFieldDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveFieldDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "foo";
	String selection = "foo";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one field", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IField);	
}

(startLine=775 endLine=788 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveTypeDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveTypeDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "OtherType";
	String selection = "OtherType";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("OtherType") &&
		elements[0] instanceof IType);	
}

(startLine=792 endLine=805 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMemberTypeDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveMemberTypeDeclaration1.java");
	
	String str = cu.getSource();
	String selectAt = "MemberInterface";
	String selection = "MemberInterface";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("MemberInterface") &&
		elements[0] instanceof IType);	
}

(startLine=827 endLine=841 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveAbstractMethod() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveAbstractMethod.java");
	
	String str = cu.getSource();
	String selectAt = "foo";
	String selection = "foo";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod &&
		((IMethod)elements[0]).getDeclaringType().getElementName().equals("SuperInterface"));
}

(startLine=845 endLine=858 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveInnerClassAsParamater() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveInnerClassAsParamater.java");
	
	String str = cu.getSource();
	String selectAt = "foo";
	String selection = "foo";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod);
}

(startLine=862 endLine=875 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveCatchArgumentType1() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveCatchArgumentType1.java");
	
	String str = cu.getSource();
	String selectAt = "Y1";
	String selection = "Y1";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Y1") &&
		elements[0] instanceof IType);
}

(startLine=879 endLine=892 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveCatchArgumentType2() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveCatchArgumentType2.java");
	
	String str = cu.getSource();
	String selectAt = "Y1";
	String selection = "Y1";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Y1") &&
		elements[0] instanceof IType);
}

(startLine=896 endLine=909 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveStaticClassConstructor() throws JavaModelException {
	IClassFile cu = getClassFile("Resolve", "test25888.jar", "", "ResolveStaticClassConstructor.class");

	String str = cu.getSource();
	String selectAt = "StaticInnerClass";
	String selection = "StaticInnerClass";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one method", elements.length == 1 &&
		elements[0].getElementName().equals("StaticInnerClass") &&
		elements[0] instanceof IMethod);
}

commonMethod: 
(startLine=83 endLine=101 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00507/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java)
protected void assertElementsEqual(String message, String expected, IJavaElement[] elements) {
	StringBuffer buffer = new StringBuffer();
	if (elements != null) {
		for (int i = 0, length = elements.length; i < length; i++){
			buffer.append(((JavaElement)elements[i]).toStringWithAncestors());
			if (i != length-1) buffer.append("\n");
		}
	} else {
		buffer.append("<null>");
	}
	if (!expected.equals(buffer.toString())) {
		System.out.println(org.eclipse.jdt.core.tests.util.Util.displayString(buffer.toString(), 2));
	}
	assertEquals(
		message,
		expected,
		buffer.toString()
	);
}


, Instance #
frags: 
(startLine=758 endLine=771 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveFieldDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveFieldDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "foo";
	String selection = "foo";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one field", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IField);	
}

(startLine=775 endLine=788 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveTypeDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveTypeDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "OtherType";
	String selection = "OtherType";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("OtherType") &&
		elements[0] instanceof IType);	
}

(startLine=845 endLine=858 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveInnerClassAsParamater() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveInnerClassAsParamater.java");
	
	String str = cu.getSource();
	String selectAt = "foo";
	String selection = "foo";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod);
}

commonMethod: 
(startLine=545 endLine=556 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00507/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java)
/**
 * Returns the specified compilation unit in the given project, root, and
 * package fragment or <code>null</code> if it does not exist.
 */
public IClassFile getClassFile(String projectName, String rootPath, String packageName, String className) throws JavaModelException {
	IPackageFragment pkg= getPackageFragment(projectName, rootPath, packageName);
	if (pkg == null) {
		return null;
	} else {
		return pkg.getClassFile(className);
	}
}


, Instance #
frags: 
(startLine=95 endLine=108 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveEmptySelection() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveTypeEmptySelection.java");

	String str = cu.getSource();
	String selectAt = "ect";
	String selection = "";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Object") &&
		elements[0] instanceof IType);	
}

(startLine=163 endLine=176 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveExplicitSuperConstructorCall() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveExplicitSuperConstructorCall.java");

	String str = cu.getSource();
	String selectAt = "super(";
	String selection = "super";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("SuperClass") &&
		elements[0] instanceof IMethod);	
}

(startLine=180 endLine=193 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveExplicitThisConstructorCall() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveExplicitThisConstructorCall.java");

	String str = cu.getSource();
	String selectAt = "this(";
	String selection = "this";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("ResolveExplicitThisConstructorCall") &&
		elements[0] instanceof IMethod);	
}

(startLine=253 endLine=266 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveTypeInComment() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveTypeInComment.java");

	String str = cu.getSource();
	String selectAt = "X */";
	String selection = "X";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 &&
		elements[0] instanceof IType &&
		((IType)elements[0]).getFullyQualifiedName().equals("p2.X"));	
}

(startLine=432 endLine=447 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMethod() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveMethod.java");
	
	String str = cu.getSource();
	String selectAt = "foo(\"";
	String selection = "foo";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one method of 'foo'",
		elements.length == 1 &&
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod &&
		((IMethod)elements[0]).getParameterTypes()[0].equals("QString;"));		
}

(startLine=758 endLine=771 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveFieldDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveFieldDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "foo";
	String selection = "foo";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one field", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IField);	
}

(startLine=775 endLine=788 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveTypeDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveTypeDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "OtherType";
	String selection = "OtherType";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("OtherType") &&
		elements[0] instanceof IType);	
}

(startLine=809 endLine=822 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMemberTypeDeclaration2() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveMemberTypeDeclaration2.java");
	
	String str = cu.getSource();
	String selectAt = "MemberOfMember";
	String selection = "MemberOfMember";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("MemberOfMember") &&
		elements[0] instanceof IType);	
}

(startLine=845 endLine=858 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveInnerClassAsParamater() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveInnerClassAsParamater.java");
	
	String str = cu.getSource();
	String selectAt = "foo";
	String selection = "foo";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod);
}

commonMethod: 
(startLine=83 endLine=101 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00507/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java)
protected void assertElementsEqual(String message, String expected, IJavaElement[] elements) {
	StringBuffer buffer = new StringBuffer();
	if (elements != null) {
		for (int i = 0, length = elements.length; i < length; i++){
			buffer.append(((JavaElement)elements[i]).toStringWithAncestors());
			if (i != length-1) buffer.append("\n");
		}
	} else {
		buffer.append("<null>");
	}
	if (!expected.equals(buffer.toString())) {
		System.out.println(org.eclipse.jdt.core.tests.util.Util.displayString(buffer.toString(), 2));
	}
	assertEquals(
		message,
		expected,
		buffer.toString()
	);
}


, Instance #
frags: 
(startLine=212 endLine=225 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMethodWithInnerTypeInClassFile() throws JavaModelException {
	IClassFile cu = getClassFile("Resolve", "zzz.jar", "", "MyClass$Inner.class");

	String str = cu.getSource();
	String selectAt = "test";
	String selection = "test";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("test") &&
		elements[0] instanceof IMethod);	
}

(startLine=287 endLine=300 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveConstructorCallOfMemberType() throws JavaModelException {
	IClassFile cf = getClassFile("Resolve", "class-folder", "", "ResolveConstructorCallOfMemberType.class");
	
	String str = cf.getSource();
	String selectAt = "Inner";
	String selection = "Inner";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cf.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("Inner") &&
		elements[0] instanceof IMethod);	
}

(startLine=896 endLine=909 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveStaticClassConstructor() throws JavaModelException {
	IClassFile cu = getClassFile("Resolve", "test25888.jar", "", "ResolveStaticClassConstructor.class");

	String str = cu.getSource();
	String selectAt = "StaticInnerClass";
	String selection = "StaticInnerClass";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one method", elements.length == 1 &&
		elements[0].getElementName().equals("StaticInnerClass") &&
		elements[0] instanceof IMethod);
}

commonMethod: 
(startLine=557 endLine=568 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00507/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java)
/**
 * Returns the specified compilation unit in the given project, root, and
 * package fragment or <code>null</code> if it does not exist.
 */
public ICompilationUnit getCompilationUnit(String projectName, String rootPath, String packageName, String cuName) throws JavaModelException {
	IPackageFragment pkg= getPackageFragment(projectName, rootPath, packageName);
	if (pkg == null) {
		return null;
	} else {
		return pkg.getCompilationUnit(cuName);
	}
}


, Instance #
frags: 
(startLine=95 endLine=108 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveEmptySelection() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveTypeEmptySelection.java");

	String str = cu.getSource();
	String selectAt = "ect";
	String selection = "";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Object") &&
		elements[0] instanceof IType);	
}

(startLine=112 endLine=125 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveEmptySelection2() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveTypeEmptySelection2.java");

	String str = cu.getSource();
	String selectAt = "Obj";
	String selection = "";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Object") &&
		elements[0] instanceof IType);	
}

(startLine=129 endLine=142 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveEmptySelectionOnMethod() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveEmptySelectionOnMethod.java");

	String str = cu.getSource();
	String selectAt = "oo";
	String selection = "";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod);	
}

(startLine=163 endLine=176 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveExplicitSuperConstructorCall() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveExplicitSuperConstructorCall.java");

	String str = cu.getSource();
	String selectAt = "super(";
	String selection = "super";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("SuperClass") &&
		elements[0] instanceof IMethod);	
}

(startLine=180 endLine=193 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveExplicitThisConstructorCall() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveExplicitThisConstructorCall.java");

	String str = cu.getSource();
	String selectAt = "this(";
	String selection = "this";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("ResolveExplicitThisConstructorCall") &&
		elements[0] instanceof IMethod);	
}

(startLine=212 endLine=225 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMethodWithInnerTypeInClassFile() throws JavaModelException {
	IClassFile cu = getClassFile("Resolve", "zzz.jar", "", "MyClass$Inner.class");

	String str = cu.getSource();
	String selectAt = "test";
	String selection = "test";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("test") &&
		elements[0] instanceof IMethod);	
}

(startLine=253 endLine=266 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveTypeInComment() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveTypeInComment.java");

	String str = cu.getSource();
	String selectAt = "X */";
	String selection = "X";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 &&
		elements[0] instanceof IType &&
		((IType)elements[0]).getFullyQualifiedName().equals("p2.X"));	
}

(startLine=270 endLine=283 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveImport() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveImport.java");

	String str = cu.getSource();
	String selectAt = "ImportedClass";
	String selection = "ImportedClass";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("ImportedClass") &&
		elements[0] instanceof IType);	
}

(startLine=287 endLine=300 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveConstructorCallOfMemberType() throws JavaModelException {
	IClassFile cf = getClassFile("Resolve", "class-folder", "", "ResolveConstructorCallOfMemberType.class");
	
	String str = cf.getSource();
	String selectAt = "Inner";
	String selection = "Inner";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cf.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("Inner") &&
		elements[0] instanceof IMethod);	
}

(startLine=304 endLine=317 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveLocalName1() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveLocalName.java");

	String str = cu.getSource();
	String selectAt = "var1";
	String selection = "var1";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Object") &&
		elements[0] instanceof IType);	
}

(startLine=336 endLine=349 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveArgumentName1() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveArgumentName.java");

	String str = cu.getSource();
	String selectAt = "var1";
	String selection = "var1";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Object") &&
		elements[0] instanceof IType);	
}

(startLine=369 endLine=382 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveCatchArgumentName1() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveCatchArgumentName.java");

	String str = cu.getSource();
	String selectAt = "var1";
	String selection = "var1";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Object") &&
		elements[0] instanceof IType);	
}

(startLine=414 endLine=428 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveConstructor() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveConstructor.java");
	
	String str = cu.getSource();
	String selectAt = "ResolveConstructor(\"";
	String selection = "ResolveConstructor";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("ResolveConstructor") &&
		elements[0] instanceof IMethod &&
		((IMethod)elements[0]).getParameterTypes()[0].equals("QString;"));	
}

(startLine=432 endLine=447 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMethod() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveMethod.java");
	
	String str = cu.getSource();
	String selectAt = "foo(\"";
	String selection = "foo";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one method of 'foo'",
		elements.length == 1 &&
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod &&
		((IMethod)elements[0]).getParameterTypes()[0].equals("QString;"));		
}

(startLine=451 endLine=465 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveField() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveField.java");
	
	String str = cu.getSource();
	String selectAt = "foo =";
	String selection = "foo";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one field of 'foo'",
			elements.length == 1 &&
			elements[0].getElementName().equals("foo") &&
			elements[0] instanceof IField);	
}

(startLine=469 endLine=483 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolvePackage() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolvePackage.java");
	
	String str = cu.getSource();
	String selectAt = "lang";
	String selection = "lang";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one package of 'java.lang'",
		elements.length == 1 &&
		elements[0].getElementName().equals("java.lang") &&
		elements[0] instanceof IPackageFragment);	
}

(startLine=487 endLine=500 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass1() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass1.java");
	
	String str = cu.getSource();
	String selectAt = "X";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=504 endLine=517 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass2() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass2.java");
	
	String str = cu.getSource();
	String selectAt = "X";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=521 endLine=534 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass3() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass3.java");
	
	String str = cu.getSource();
	String selectAt = "X[]{";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=538 endLine=551 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass4() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass4.java");
	
	String str = cu.getSource();
	String selectAt = "X";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=555 endLine=568 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass5() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass5.java");
	
	String str = cu.getSource();
	String selectAt = "X";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=572 endLine=585 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveClass6() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveClass6.java");
	
	String str = cu.getSource();
	String selectAt = "X";
	String selection = "X";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one class", elements.length == 1 && 
		elements[0].getElementName().equals("X") &&
		elements[0] instanceof IType);
}

(startLine=589 endLine=602 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveInterface() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveInterface.java");
	
	String str = cu.getSource();
	String selectAt = "Y";
	String selection = "Y";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one interface", elements.length == 1 && 
		elements[0].getElementName().equals("Y") &&
		elements[0] instanceof IType);	
}

(startLine=722 endLine=736 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveConstructorDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveConstructorDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "ResolveConstructorDeclaration(i";
	String selection = "ResolveConstructorDeclaration";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("ResolveConstructorDeclaration") &&
		elements[0] instanceof IMethod &&
		((IMethod)elements[0]).getParameterTypes()[0].equals("I"));	
}

(startLine=740 endLine=754 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMethodDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveMethodDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "foo(i";
	String selection = "foo";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod &&
		((IMethod)elements[0]).getParameterTypes()[0].equals("I"));	
}

(startLine=775 endLine=788 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveTypeDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveTypeDeclaration.java");
	
	String str = cu.getSource();
	String selectAt = "OtherType";
	String selection = "OtherType";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("OtherType") &&
		elements[0] instanceof IType);	
}

(startLine=792 endLine=805 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMemberTypeDeclaration() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveMemberTypeDeclaration1.java");
	
	String str = cu.getSource();
	String selectAt = "MemberInterface";
	String selection = "MemberInterface";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("MemberInterface") &&
		elements[0] instanceof IType);	
}

(startLine=809 endLine=822 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveMemberTypeDeclaration2() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveMemberTypeDeclaration2.java");
	
	String str = cu.getSource();
	String selectAt = "MemberOfMember";
	String selection = "MemberOfMember";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("MemberOfMember") &&
		elements[0] instanceof IType);	
}

(startLine=827 endLine=841 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveAbstractMethod() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveAbstractMethod.java");
	
	String str = cu.getSource();
	String selectAt = "foo";
	String selection = "foo";
	int start = str.indexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one method", elements.length == 1 && 
		elements[0].getElementName().equals("foo") &&
		elements[0] instanceof IMethod &&
		((IMethod)elements[0]).getDeclaringType().getElementName().equals("SuperInterface"));
}

(startLine=862 endLine=875 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveCatchArgumentType1() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveCatchArgumentType1.java");
	
	String str = cu.getSource();
	String selectAt = "Y1";
	String selection = "Y1";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Y1") &&
		elements[0] instanceof IType);
}

(startLine=879 endLine=892 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveCatchArgumentType2() throws JavaModelException {
	ICompilationUnit cu = getCompilationUnit("Resolve", "src", "", "ResolveCatchArgumentType2.java");
	
	String str = cu.getSource();
	String selectAt = "Y1";
	String selection = "Y1";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);
	
	assertTrue("should have one type", elements.length == 1 && 
		elements[0].getElementName().equals("Y1") &&
		elements[0] instanceof IType);
}

(startLine=896 endLine=909 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00506/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/ResolveTests.java)
public void testResolveStaticClassConstructor() throws JavaModelException {
	IClassFile cu = getClassFile("Resolve", "test25888.jar", "", "ResolveStaticClassConstructor.class");

	String str = cu.getSource();
	String selectAt = "StaticInnerClass";
	String selection = "StaticInnerClass";
	int start = str.lastIndexOf(selectAt);
	int length = selection.length();
	IJavaElement[] elements = cu.codeSelect(start, length);

	assertTrue("should have one method", elements.length == 1 &&
		elements[0].getElementName().equals("StaticInnerClass") &&
		elements[0] instanceof IMethod);
}

commonMethod: 
(startLine=83 endLine=101 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00507/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/AbstractJavaModelTests.java)
protected void assertElementsEqual(String message, String expected, IJavaElement[] elements) {
	StringBuffer buffer = new StringBuffer();
	if (elements != null) {
		for (int i = 0, length = elements.length; i < length; i++){
			buffer.append(((JavaElement)elements[i]).toStringWithAncestors());
			if (i != length-1) buffer.append("\n");
		}
	} else {
		buffer.append("<null>");
	}
	if (!expected.equals(buffer.toString())) {
		System.out.println(org.eclipse.jdt.core.tests.util.Util.displayString(buffer.toString(), 2));
	}
	assertEquals(
		message,
		expected,
		buffer.toString()
	);
}


, Instance #
frags: 
(startLine=1124 endLine=1131 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00523/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
		if (nodes != null) {
			for (int i = 0, l = nodes.length; i < l; i++) {
				AstNode node = nodes[i];
				Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);
				if ((this.matchContainer & PatternLocator.METHOD_CONTAINER) != 0)
					reportReference(node, method, parent, level.intValue());
			}
		}

(startLine=1218 endLine=1225 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00523/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
		if (nodes != null) {
			for (int i = 0, l = nodes.length; i < l; i++) {
				AstNode node = nodes[i];
				Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);
				if ((this.matchContainer & PatternLocator.FIELD_CONTAINER) != 0)
					reportReference(node, type, field, parent, level.intValue());
			}
		}

commonMethod: 
(startLine=902 endLine=916 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00524/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
protected void report(int sourceStart, int sourceEnd, IJavaElement element, int accuracy) throws CoreException {
	if (this.scope.encloses(element)) {
		if (SearchEngine.VERBOSE) {
			IResource res = this.currentPossibleMatch.resource;
			System.out.println("Reporting match"); //$NON-NLS-1$
			System.out.println("\tResource: " + (res == null ? " <unknown> " : res.getFullPath().toString())); //$NON-NLS-2$//$NON-NLS-1$
			System.out.println("\tPositions: [" + sourceStart + ", " + sourceEnd + "]"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
			System.out.println("\tJava element: " + ((JavaElement)element).toStringWithAncestors()); //$NON-NLS-1$
			System.out.println(accuracy == IJavaSearchResultCollector.EXACT_MATCH
				? "\tAccuracy: EXACT_MATCH" //$NON-NLS-1$
				: "\tAccuracy: POTENTIAL_MATCH"); //$NON-NLS-1$
		}
		report(this.currentPossibleMatch.resource, sourceStart, sourceEnd, element, accuracy);
	}
}


, Instance #
frags: 
(startLine=1124 endLine=1131 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00523/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
		if (nodes != null) {
			for (int i = 0, l = nodes.length; i < l; i++) {
				AstNode node = nodes[i];
				Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);
				if ((this.matchContainer & PatternLocator.METHOD_CONTAINER) != 0)
					reportReference(node, method, parent, level.intValue());
			}
		}

(startLine=1218 endLine=1225 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00523/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
		if (nodes != null) {
			for (int i = 0, l = nodes.length; i < l; i++) {
				AstNode node = nodes[i];
				Integer level = (Integer) nodeSet.matchingNodes.removeKey(node);
				if ((this.matchContainer & PatternLocator.FIELD_CONTAINER) != 0)
					reportReference(node, type, field, parent, level.intValue());
			}
		}

commonMethod: 
(startLine=190 endLine=196 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00524/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/PatternLocator.java)
/**
 * Reports the match of the given reference.
 */
protected void matchReportReference(AstNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException {
	// default is to report a match on the whole node.
	locator.report(reference.sourceStart, reference.sourceEnd, element, accuracy);
}


, Instance #
frags: 
(startLine=652 endLine=680 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00524/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	public String format(String string, int[] positions, AstNode[] nodes) {
		// reset the scribe
		this.scribe.reset(positions);
		
		long startTime = System.currentTimeMillis();

		final char[] compilationUnitSource = string.toCharArray();
		
		this.scribe.scanner.setSource(compilationUnitSource);
		this.localScanner.setSource(compilationUnitSource);
		this.scribe.scannerEndPosition = compilationUnitSource.length;
		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);
		if (nodes == null) {
			return string;
		}

		this.lastLocalDeclarationSourceStart = -1;
		try {
			if (nodes != null) {
				formatClassBodyDeclarations(nodes);
			}
		} catch(AbortFormatting e){
			return failedToFormat();
		}
		if (DEBUG){
			System.out.println("Formatting time: " + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$
		}
		return this.scribe.toString();
	}

(startLine=685 endLine=712 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00524/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	public String format(String string, int[] positions, CompilationUnitDeclaration compilationUnitDeclaration) {
		// reset the scribe
		this.scribe.reset(positions);
		
		if (compilationUnitDeclaration == null || compilationUnitDeclaration.ignoreFurtherInvestigation) {
			return failedToFormat();
		}

		long startTime = System.currentTimeMillis();

		final char[] compilationUnitSource = string.toCharArray();
		
		this.scribe.scanner.setSource(compilationUnitSource);
		this.localScanner.setSource(compilationUnitSource);
		this.scribe.scannerEndPosition = compilationUnitSource.length;
		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);

		this.lastLocalDeclarationSourceStart = -1;
		try {
			compilationUnitDeclaration.traverse(this, compilationUnitDeclaration.scope);
		} catch(AbortFormatting e){
			return failedToFormat();
		}
		if (DEBUG){
			System.out.println("Formatting time: " + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$
		}
		return this.scribe.toString();
	}

(startLine=756 endLine=783 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00524/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	public String format(String string, int[] positions, Expression expression) {
		// reset the scribe
		this.scribe.reset(positions);
		
		long startTime = System.currentTimeMillis();

		final char[] compilationUnitSource = string.toCharArray();
		
		this.scribe.scanner.setSource(compilationUnitSource);
		this.localScanner.setSource(compilationUnitSource);
		this.scribe.scannerEndPosition = compilationUnitSource.length;
		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);
		if (expression == null) {
			return string;
		}

		this.lastLocalDeclarationSourceStart = -1;
		try {
			expression.traverse(this, null);
			this.scribe.printLastComment();
		} catch(AbortFormatting e){
			return failedToFormat();
		}
		if (DEBUG){
			System.out.println("Formatting time: " + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$
		}
		return this.scribe.toString();
	}

commonMethod: 
(startLine=275 endLine=282 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00525/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java)
	public TextEdit getRootEdit() {
		MultiTextEdit edit = new MultiTextEdit(this.textRegionStart, this.textRegionEnd - this.textRegionStart + 1);
		for (int i= 0, max = this.editsIndex; i < max; i++) {
			OptimizedReplaceEdit currentEdit = edits[i];
			edit.addChild(new ReplaceEdit(currentEdit.offset, currentEdit.length, currentEdit.replacement));
		}
		return edit;
	}


, Instance #
frags: 
(startLine=652 endLine=680 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00524/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	public String format(String string, int[] positions, AstNode[] nodes) {
		// reset the scribe
		this.scribe.reset(positions);
		
		long startTime = System.currentTimeMillis();

		final char[] compilationUnitSource = string.toCharArray();
		
		this.scribe.scanner.setSource(compilationUnitSource);
		this.localScanner.setSource(compilationUnitSource);
		this.scribe.scannerEndPosition = compilationUnitSource.length;
		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);
		if (nodes == null) {
			return string;
		}

		this.lastLocalDeclarationSourceStart = -1;
		try {
			if (nodes != null) {
				formatClassBodyDeclarations(nodes);
			}
		} catch(AbortFormatting e){
			return failedToFormat();
		}
		if (DEBUG){
			System.out.println("Formatting time: " + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$
		}
		return this.scribe.toString();
	}

(startLine=685 endLine=712 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00524/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	public String format(String string, int[] positions, CompilationUnitDeclaration compilationUnitDeclaration) {
		// reset the scribe
		this.scribe.reset(positions);
		
		if (compilationUnitDeclaration == null || compilationUnitDeclaration.ignoreFurtherInvestigation) {
			return failedToFormat();
		}

		long startTime = System.currentTimeMillis();

		final char[] compilationUnitSource = string.toCharArray();
		
		this.scribe.scanner.setSource(compilationUnitSource);
		this.localScanner.setSource(compilationUnitSource);
		this.scribe.scannerEndPosition = compilationUnitSource.length;
		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);

		this.lastLocalDeclarationSourceStart = -1;
		try {
			compilationUnitDeclaration.traverse(this, compilationUnitDeclaration.scope);
		} catch(AbortFormatting e){
			return failedToFormat();
		}
		if (DEBUG){
			System.out.println("Formatting time: " + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$
		}
		return this.scribe.toString();
	}

(startLine=756 endLine=783 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00524/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	public String format(String string, int[] positions, Expression expression) {
		// reset the scribe
		this.scribe.reset(positions);
		
		long startTime = System.currentTimeMillis();

		final char[] compilationUnitSource = string.toCharArray();
		
		this.scribe.scanner.setSource(compilationUnitSource);
		this.localScanner.setSource(compilationUnitSource);
		this.scribe.scannerEndPosition = compilationUnitSource.length;
		this.scribe.scanner.resetTo(0, this.scribe.scannerEndPosition);
		if (expression == null) {
			return string;
		}

		this.lastLocalDeclarationSourceStart = -1;
		try {
			expression.traverse(this, null);
			this.scribe.printLastComment();
		} catch(AbortFormatting e){
			return failedToFormat();
		}
		if (DEBUG){
			System.out.println("Formatting time: " + (System.currentTimeMillis() - startTime));  //$NON-NLS-1$
		}
		return this.scribe.toString();
	}

commonMethod: 
(startLine=322 endLine=333 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00525/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/Scribe.java)
	/**
	 * @param compilationUnitSource
	 */
	public void initializeScanner(char[] compilationUnitSource) {
		this.scanner.setSource(compilationUnitSource);
		this.scannerEndPosition = compilationUnitSource.length;
		this.scanner.resetTo(0, this.scannerEndPosition);
		if (this.textRegionEnd == -1) {
			this.textRegionEnd = this.scannerEndPosition;
		}
		this.edits = new OptimizedReplaceEdit[INITIAL_SIZE];
	}	


, Instance #
frags: 
(startLine=226 endLine=239 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00555/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeReferenceLocator.java)
	if (tokens == null) {
		tokens = binding == null || binding instanceof ProblemBinding
			? new char[][] {this.pattern.simpleName}
			: qNameRef.tokens;
		if (!this.isCaseSensitive) {
			int length = tokens.length;
			char[][] lowerCaseTokens = new char[length][];
			for (int i = 0; i < length; i++) {
				char[] token = tokens[i];
				lowerCaseTokens[i] = CharOperation.toLowerCase(token);
			}
			tokens = lowerCaseTokens;
		}
	}

(startLine=264 endLine=278 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00555/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeReferenceLocator.java)
	if (tokens == null) {
		if (typeBinding == null || typeBinding instanceof ProblemReferenceBinding)
			tokens = new char[][] {this.pattern.simpleName};
		else
			tokens = qTypeRef.tokens;
		if (!this.isCaseSensitive) {
			int length = tokens.length;
			char[][] lowerCaseTokens = new char[length][];
			for (int i = 0; i < length; i++) {
				char[] token = tokens[i];
				lowerCaseTokens[i] = CharOperation.toLowerCase(token);
			}
			tokens = lowerCaseTokens;
		}
	}

(startLine=146 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00555/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeReferenceLocator.java)
	if (tokens == null) {
		tokens = typeBinding == null || typeBinding instanceof ProblemReferenceBinding
			? new char[][] {this.pattern.simpleName}
			: importRef.tokens;
		if (!this.isCaseSensitive) {
			int length = tokens.length;
			char[][] lowerCaseTokens = new char[length][];
			for (int i = 0; i < length; i++)
				lowerCaseTokens[i] = CharOperation.toLowerCase(tokens[i]);
			tokens = lowerCaseTokens;
		}
	}

commonMethod: 
(startLine=926 endLine=928 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00556/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
protected void report(long start, long end, IJavaElement element, int accuracy) throws CoreException {
	report((int) (start >> 32), (int) (end & 0xFFFFF), element, accuracy); // extract the start and end from the encoded long positions
}


, Instance #
frags: 
(startLine=226 endLine=239 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00555/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeReferenceLocator.java)
	if (tokens == null) {
		tokens = binding == null || binding instanceof ProblemBinding
			? new char[][] {this.pattern.simpleName}
			: qNameRef.tokens;
		if (!this.isCaseSensitive) {
			int length = tokens.length;
			char[][] lowerCaseTokens = new char[length][];
			for (int i = 0; i < length; i++) {
				char[] token = tokens[i];
				lowerCaseTokens[i] = CharOperation.toLowerCase(token);
			}
			tokens = lowerCaseTokens;
		}
	}

(startLine=264 endLine=278 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00555/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeReferenceLocator.java)
	if (tokens == null) {
		if (typeBinding == null || typeBinding instanceof ProblemReferenceBinding)
			tokens = new char[][] {this.pattern.simpleName};
		else
			tokens = qTypeRef.tokens;
		if (!this.isCaseSensitive) {
			int length = tokens.length;
			char[][] lowerCaseTokens = new char[length][];
			for (int i = 0; i < length; i++) {
				char[] token = tokens[i];
				lowerCaseTokens[i] = CharOperation.toLowerCase(token);
			}
			tokens = lowerCaseTokens;
		}
	}

(startLine=146 endLine=157 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00555/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/TypeReferenceLocator.java)
	if (tokens == null) {
		tokens = typeBinding == null || typeBinding instanceof ProblemReferenceBinding
			? new char[][] {this.pattern.simpleName}
			: importRef.tokens;
		if (!this.isCaseSensitive) {
			int length = tokens.length;
			char[][] lowerCaseTokens = new char[length][];
			for (int i = 0; i < length; i++)
				lowerCaseTokens[i] = CharOperation.toLowerCase(tokens[i]);
			tokens = lowerCaseTokens;
		}
	}

commonMethod: 
(startLine=926 endLine=928 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00556/org.eclipse.jdt.core/search/org/eclipse/jdt/internal/core/search/matching/MatchLocator.java)
protected void report(long start, long end, IJavaElement element, int accuracy) throws CoreException {
	report((int) (start >> 32), (int) (end & 0xFFFFF), element, accuracy); // extract the start and end from the encoded long positions
}


, Instance #
frags: 
(startLine=674 endLine=685 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00557/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchTests.java)
public void testDeclarationOfReferencedTypes3() throws CoreException {
	ICompilationUnit unit = getCompilationUnit("JavaSearch", "src", "c1", "A.java");
	JavaSearchResultCollector resultCollector = new JavaSearchResultCollector();
	new SearchEngine().searchDeclarationsOfReferencedTypes(
		getWorkspace(), 
		unit,
		resultCollector
	);
	assertEquals(
		"src/c1/I.java c1.I [I]", 
		resultCollector.toString());
}

(startLine=690 endLine=701 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00557/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchTests.java)
public void testDeclarationOfReferencedTypes4() throws CoreException {
	ICompilationUnit unit = getCompilationUnit("JavaSearch", "src", "c1", "B.java");
	JavaSearchResultCollector resultCollector = new JavaSearchResultCollector();
	new SearchEngine().searchDeclarationsOfReferencedTypes(
		getWorkspace(), 
		unit,
		resultCollector
	);
	assertEquals(
		"src/c1/I.java c1.I [I]", 
		resultCollector.toString());
}

commonMethod: 
(startLine=176 endLine=178 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00558/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchTests.java)
protected void assertSearchResults(String expected, Object collector) {
	assertSearchResults("Unexpected search results", expected, collector);
}


, Instance #
frags: 
(startLine=493 endLine=506 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00557/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchTests.java)
public void testConstructorReferenceImplicitConstructorCall1() throws JavaModelException, CoreException {
	IType type = getCompilationUnit("JavaSearch", "src", "c7", "X.java").getType("X");
	IMethod method = type.getMethod("X", new String[] {});
	JavaSearchResultCollector resultCollector = new JavaSearchResultCollector();
	new SearchEngine().search(
		getWorkspace(), 
		method, 
		REFERENCES, 
		getJavaSearchScope(), 
		resultCollector);
	assertEquals(
		"src/c7/Y.java c7.Y() [Y]", 
		resultCollector.toString());
}

(startLine=2280 endLine=2293 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00557/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchTests.java)
public void testStaticMethodReference1() throws JavaModelException, CoreException {
	IType type = getCompilationUnit("JavaSearch", "src", "p", "Y.java").getType("Y");
	IMethod method = type.getMethod("bar", new String[] {});
	JavaSearchResultCollector resultCollector = new JavaSearchResultCollector();
	new SearchEngine().search(
		getWorkspace(), 
		method, 
		REFERENCES, 
		getJavaSearchScope(), 
		resultCollector);
	assertEquals(
		"src/Test.java Test.main(String[]) -> void [bar()]", 
		resultCollector.toString());
}

commonMethod: 
(startLine=176 endLine=178 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00558/org.eclipse.jdt.core.tests.model/src/org/eclipse/jdt/core/tests/model/JavaSearchTests.java)
protected void assertSearchResults(String expected, Object collector) {
	assertSearchResults("Unexpected search results", expected, collector);
}


, Instance #
frags: 
(startLine=141 endLine=190 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
		if ((condConst = left.optimizedBooleanConstant()) != NotAConstant) {
			if (condConst.booleanValue() == true) {
				// <something equivalent to true> && x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				if ((bits & OnlyValueRequiredMASK) != 0) {
					right.generateCode(currentScope, codeStream, valueRequired);
				} else {
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
			} else {
				// <something equivalent to false> && x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
				// reposition the endPC
				codeStream.updateLastRecordedEndPC(codeStream.position);
			}
			if (mergedInitStateIndex != -1) {
				codeStream.removeNotDefinitelyAssignedVariables(
					currentScope,
					mergedInitStateIndex);
			}
			return;
		}

(startLine=142 endLine=190 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
		if ((condConst = left.optimizedBooleanConstant()) != NotAConstant) {
			if (condConst.booleanValue() == true) {
				// <something equivalent to true> || x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_1();
					} else {
						if (trueLabel != null) {
							codeStream.goto_(trueLabel);
						}
					}
				}
				// reposition the endPC
				codeStream.updateLastRecordedEndPC(codeStream.position);					
			} else {
				// <something equivalent to false> || x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				if ((bits & OnlyValueRequiredMASK) != 0) {
					right.generateCode(currentScope, codeStream, valueRequired);
				} else {
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
			}
			if (mergedInitStateIndex != -1) {
				codeStream.removeNotDefinitelyAssignedVariables(
					currentScope,
					mergedInitStateIndex);
			}
			return;
		}

commonMethod: 
(startLine=4829 endLine=4926 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public void recordPositionsFrom(int startPC, int sourcePos) {

	/* Record positions in the table, only if nothing has 
	 * already been recorded. Since we output them on the way 
	 * up (children first for more specific info)
	 * The pcToSourceMap table is always sorted.
	 */

	if (!generateLineNumberAttributes)
		return;
	if (sourcePos == 0)
		return;

	// no code generated for this node. e.g. field without any initialization
	if (position == startPC)
		return;

	// Widening an existing entry that already has the same source positions
	if (pcToSourceMapSize + 4 > pcToSourceMap.length) {
		// resize the array pcToSourceMap
		System.arraycopy(pcToSourceMap, 0, (pcToSourceMap = new int[pcToSourceMapSize << 1]), 0, pcToSourceMapSize);
	}
	int newLine = ClassFile.searchLineNumber(lineSeparatorPositions, sourcePos);
	// lastEntryPC represents the endPC of the lastEntry.
	if (pcToSourceMapSize > 0) {
		// in this case there is already an entry in the table
		if (pcToSourceMap[pcToSourceMapSize - 1] != newLine) {
			if (startPC < lastEntryPC) {
				// we forgot to add an entry.
				// search if an existing entry exists for startPC
				int insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);
				if (insertionIndex != -1) {
					// there is no existing entry starting with startPC.
					int existingEntryIndex = indexOfSameLineEntrySincePC(startPC, newLine); // index for PC
					/* the existingEntryIndex corresponds to en entry with the same line and a PC >= startPC.
						in this case it is relevant to widen this entry instead of creating a new one.
						line1: this(a,
						  b,
						  c);
						with this code we generate each argument. We generate a aload0 to invoke the constructor. There is no entry for this
						aload0 bytecode. The first entry is the one for the argument a.
						But we want the constructor call to start at the aload0 pc and not just at the pc of the first argument.
						So we widen the existing entry (if there is one) or we create a new entry with the startPC.
					*/
					if (existingEntryIndex != -1) {
						// widen existing entry
						pcToSourceMap[existingEntryIndex] = startPC;
					} else {
						// we have to add an entry that won't be sorted. So we sort the pcToSourceMap.
						System.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - insertionIndex);
						pcToSourceMap[insertionIndex++] = startPC;
						pcToSourceMap[insertionIndex] = newLine;
						pcToSourceMapSize += 2;
					}
				}
				if (position != lastEntryPC) { // no bytecode since last entry pc
					pcToSourceMap[pcToSourceMapSize++] = lastEntryPC;
					pcToSourceMap[pcToSourceMapSize++] = newLine;
				}
			} else {
				// we can safely add the new entry. The endPC of the previous entry is not in conflit with the startPC of the new entry.
				pcToSourceMap[pcToSourceMapSize++] = startPC;
				pcToSourceMap[pcToSourceMapSize++] = newLine;
			}
		} else {
			/* the last recorded entry is on the same line. But it could be relevant to widen this entry.
			   we want to extend this entry forward in case we generated some bytecode before the last entry that are not related to any statement
			*/	
			if (startPC < pcToSourceMap[pcToSourceMapSize - 2]) {
				int insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);
				if (insertionIndex != -1) {
					// widen the existing entry
					// we have to figure out if we need to move the last entry at another location to keep a sorted table
					/* First we need to check if at the insertion position there is not an existing entry
					 * that includes the one we want to insert. This is the case if pcToSourceMap[insertionIndex - 1] == newLine.
					 * In this case we don't want to change the table. If not, we want to insert a new entry. Prior to insertion
					 * we want to check if it is worth doing an arraycopy. If not we simply update the recorded pc.
					 */
					if (!((insertionIndex > 1) && (pcToSourceMap[insertionIndex - 1] == newLine))) {
						if ((pcToSourceMapSize > 4) && (pcToSourceMap[pcToSourceMapSize - 4] > startPC)) {
							System.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - 2 - insertionIndex);
							pcToSourceMap[insertionIndex++] = startPC;
							pcToSourceMap[insertionIndex] = newLine;						
						} else {
							pcToSourceMap[pcToSourceMapSize - 2] = startPC;
						}
					}
				}
			}
		}
		lastEntryPC = position;
	} else {
		// record the first entry
		pcToSourceMap[pcToSourceMapSize++] = startPC;
		pcToSourceMap[pcToSourceMapSize++] = newLine;
		lastEntryPC = position;
	}
}


, Instance #
frags: 
(startLine=100 endLine=117 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
		if (falseLabel.hasForwardReferences()) {
			if (valueRequired) {
				codeStream.iconst_1();
				if ((bits & ValueForReturnMASK) != 0) {
					codeStream.ireturn();
					falseLabel.place();
					codeStream.iconst_0();
				} else {
					codeStream.goto_(endLabel = new Label(codeStream));
					codeStream.decrStackSize(1);
					falseLabel.place();
					codeStream.iconst_0();
					endLabel.place();
				}
			} else {
				falseLabel.place();
			}
		}

(startLine=103 endLine=120 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
		if (falseLabel.hasForwardReferences()) {
			if (valueRequired) {
				codeStream.iconst_1();
				if ((bits & ValueForReturnMASK) != 0) {
					codeStream.ireturn();
					falseLabel.place();
					codeStream.iconst_0();
				} else {
					codeStream.goto_(endLabel = new Label(codeStream));
					codeStream.decrStackSize(1);
					falseLabel.place();
					codeStream.iconst_0();
					endLabel.place();
				}
			} else {
				falseLabel.place();
			}
		}

commonMethod: 
(startLine=4939 endLine=4963 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public final void removeNotDefinitelyAssignedVariables(Scope scope, int initStateIndex) {
	// given some flow info, make sure we did not loose some variables initialization
	// if this happens, then we must update their pc entries to reflect it in debug attributes
	if (!generateLocalVariableTableAttributes)
		return;
/*	if (initStateIndex == lastInitStateIndexWhenRemovingInits)
		return;
		
	lastInitStateIndexWhenRemovingInits = initStateIndex;
	if (lastInitStateIndexWhenAddingInits != initStateIndex){
		lastInitStateIndexWhenAddingInits = -2;// reinitialize add index 
		// add(1)-remove(1)-add(1) -> ignore second add
		// add(1)-remove(2)-add(1) -> perform second add
	}*/
	for (int i = 0; i < visibleLocalsCount; i++) {
		LocalVariableBinding localBinding = visibleLocals[i];
		if (localBinding != null) {
			if (initStateIndex == -1 || !isDefinitelyAssigned(scope, initStateIndex, localBinding)) {
				if (localBinding.initializationCount > 0) {
					localBinding.recordInitializationEndPC(position);
				}
			}
		}
	}
}


, Instance #
frags: 
(startLine=100 endLine=117 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
		if (falseLabel.hasForwardReferences()) {
			if (valueRequired) {
				codeStream.iconst_1();
				if ((bits & ValueForReturnMASK) != 0) {
					codeStream.ireturn();
					falseLabel.place();
					codeStream.iconst_0();
				} else {
					codeStream.goto_(endLabel = new Label(codeStream));
					codeStream.decrStackSize(1);
					falseLabel.place();
					codeStream.iconst_0();
					endLabel.place();
				}
			} else {
				falseLabel.place();
			}
		}

(startLine=103 endLine=120 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
		if (falseLabel.hasForwardReferences()) {
			if (valueRequired) {
				codeStream.iconst_1();
				if ((bits & ValueForReturnMASK) != 0) {
					codeStream.ireturn();
					falseLabel.place();
					codeStream.iconst_0();
				} else {
					codeStream.goto_(endLabel = new Label(codeStream));
					codeStream.decrStackSize(1);
					falseLabel.place();
					codeStream.iconst_0();
					endLabel.place();
				}
			} else {
				falseLabel.place();
			}
		}

commonMethod: 
(startLine=227 endLine=248 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/Expression.java)
	/**
	 * Every expression is responsible for generating its implicit conversion when necessary.
	 *
	 * @param currentScope org.eclipse.jdt.internal.compiler.lookup.BlockScope
	 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
	 * @param valueRequired boolean
	 */
	public void generateCode(
		BlockScope currentScope,
		CodeStream codeStream,
		boolean valueRequired) {

		if (constant != NotAConstant) {
			// generate a constant expression
			int pc = codeStream.position;
			codeStream.generateConstant(constant, implicitConversion);
			codeStream.recordPositionsFrom(pc, this.sourceStart);
		} else {
			// actual non-constant code generation
			throw new ShouldNotImplement(Util.bind("ast.missingCode")); //$NON-NLS-1$
		}
	}


, Instance #
frags: 
(startLine=100 endLine=117 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
		if (falseLabel.hasForwardReferences()) {
			if (valueRequired) {
				codeStream.iconst_1();
				if ((bits & ValueForReturnMASK) != 0) {
					codeStream.ireturn();
					falseLabel.place();
					codeStream.iconst_0();
				} else {
					codeStream.goto_(endLabel = new Label(codeStream));
					codeStream.decrStackSize(1);
					falseLabel.place();
					codeStream.iconst_0();
					endLabel.place();
				}
			} else {
				falseLabel.place();
			}
		}

(startLine=103 endLine=120 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
		if (falseLabel.hasForwardReferences()) {
			if (valueRequired) {
				codeStream.iconst_1();
				if ((bits & ValueForReturnMASK) != 0) {
					codeStream.ireturn();
					falseLabel.place();
					codeStream.iconst_0();
				} else {
					codeStream.goto_(endLabel = new Label(codeStream));
					codeStream.decrStackSize(1);
					falseLabel.place();
					codeStream.iconst_0();
					endLabel.place();
				}
			} else {
				falseLabel.place();
			}
		}

commonMethod: 
(startLine=26 endLine=29 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/impl/Constant.java)
	public boolean booleanValue() {

		throw new ShouldNotImplement(Util.bind("constant.cannotCastedInto",typeName(),"boolean")); //$NON-NLS-1$ //$NON-NLS-2$
	}


, Instance #
frags: 
(startLine=100 endLine=117 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
		if (falseLabel.hasForwardReferences()) {
			if (valueRequired) {
				codeStream.iconst_1();
				if ((bits & ValueForReturnMASK) != 0) {
					codeStream.ireturn();
					falseLabel.place();
					codeStream.iconst_0();
				} else {
					codeStream.goto_(endLabel = new Label(codeStream));
					codeStream.decrStackSize(1);
					falseLabel.place();
					codeStream.iconst_0();
					endLabel.place();
				}
			} else {
				falseLabel.place();
			}
		}

(startLine=103 endLine=120 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
		if (falseLabel.hasForwardReferences()) {
			if (valueRequired) {
				codeStream.iconst_1();
				if ((bits & ValueForReturnMASK) != 0) {
					codeStream.ireturn();
					falseLabel.place();
					codeStream.iconst_0();
				} else {
					codeStream.goto_(endLabel = new Label(codeStream));
					codeStream.decrStackSize(1);
					falseLabel.place();
					codeStream.iconst_0();
					endLabel.place();
				}
			} else {
				falseLabel.place();
			}
		}

commonMethod: 
(startLine=113 endLine=146 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public final void addDefinitelyAssignedVariables(Scope scope, int initStateIndex) {
	// Required to fix 1PR0XVS: LFRE:WINNT - Compiler: variable table for method appears incorrect
	if (!generateLocalVariableTableAttributes)
		return;
/*	if (initStateIndex == lastInitStateIndexWhenAddingInits)
		return;
	lastInitStateIndexWhenAddingInits = initStateIndex;
	if (lastInitStateIndexWhenRemovingInits != initStateIndex){
		lastInitStateIndexWhenRemovingInits = -2; // reinitialize remove index 
		// remove(1)-add(1)-remove(1) -> ignore second remove
		// remove(1)-add(2)-remove(1) -> perform second remove
	}
	
*/	for (int i = 0; i < visibleLocalsCount; i++) {
		LocalVariableBinding localBinding = visibleLocals[i];
		if (localBinding != null) {
			// Check if the local is definitely assigned
			if ((initStateIndex != -1) && isDefinitelyAssigned(scope, initStateIndex, localBinding)) {
				if ((localBinding.initializationCount == 0) || (localBinding.initializationPCs[((localBinding.initializationCount - 1) << 1) + 1] != -1)) {
					/* There are two cases:
					 * 1) there is no initialization interval opened ==> add an opened interval
					 * 2) there is already some initialization intervals but the last one is closed ==> add an opened interval
					 * An opened interval means that the value at localBinding.initializationPCs[localBinding.initializationCount - 1][1]
					 * is equals to -1.
					 * initializationPCs is a collection of pairs of int:
					 * 	first value is the startPC and second value is the endPC. -1 one for the last value means that the interval
					 * 	is not closed yet.
					 */
					localBinding.recordInitializationStartPC(position);
				}
			}
		}
	}
}


, Instance #
frags: 
(startLine=134 endLine=296 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
		boolean valueRequired) {
			
		if (constant != Constant.NotAConstant) {
			super.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
			return;
		}
		Constant condConst;
		if ((condConst = left.optimizedBooleanConstant()) != NotAConstant) {
			if (condConst.booleanValue() == true) {
				// <something equivalent to true> && x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				if ((bits & OnlyValueRequiredMASK) != 0) {
					right.generateCode(currentScope, codeStream, valueRequired);
				} else {
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
			} else {
				// <something equivalent to false> && x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
				// reposition the endPC
				codeStream.updateLastRecordedEndPC(codeStream.position);
			}
			if (mergedInitStateIndex != -1) {
				codeStream.removeNotDefinitelyAssignedVariables(
					currentScope,
					mergedInitStateIndex);
			}
			return;
		}
		if ((condConst = right.optimizedBooleanConstant()) != NotAConstant) {
			if (condConst.booleanValue() == true) {
				// x && <something equivalent to true>
				if ((bits & OnlyValueRequiredMASK) != 0) {
					left.generateCode(currentScope, codeStream, valueRequired);
				} else {
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
			} else {
				// x && <something equivalent to false>
				Label internalFalseLabel = new Label(codeStream);
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					null,
					internalFalseLabel, 
					true);
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				internalFalseLabel.place();
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
				// reposition the endPC
				codeStream.updateLastRecordedEndPC(codeStream.position);
			}
			if (mergedInitStateIndex != -1) {
				codeStream.removeNotDefinitelyAssignedVariables(
					currentScope,
					mergedInitStateIndex);
			}
			return;
		}
		// default case
		if (falseLabel == null) {
			if (trueLabel != null) {
				// implicit falling through the FALSE case
				Label internalFalseLabel = new Label(codeStream);
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					null,
					internalFalseLabel,
					true); // need value, e.g. if (a == 1 && ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a!=1
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					null,
					valueRequired);
				internalFalseLabel.place();
			}
		} else {
			// implicit falling through the TRUE case
			if (trueLabel == null) {
				left.generateOptimizedBoolean(currentScope, codeStream, null, falseLabel, true); // need value, e.g. if (a == 1 && ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a!=1
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					null,
					falseLabel,
					valueRequired);
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}
		if (mergedInitStateIndex != -1) {
			codeStream.removeNotDefinitelyAssignedVariables(
				currentScope,
				mergedInitStateIndex);
		}
	}

(startLine=136 endLine=295 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
		boolean valueRequired) {
		if (constant != Constant.NotAConstant) {
			super.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
			return;
		}
		Constant condConst;
		if ((condConst = left.optimizedBooleanConstant()) != NotAConstant) {
			if (condConst.booleanValue() == true) {
				// <something equivalent to true> || x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_1();
					} else {
						if (trueLabel != null) {
							codeStream.goto_(trueLabel);
						}
					}
				}
				// reposition the endPC
				codeStream.updateLastRecordedEndPC(codeStream.position);					
			} else {
				// <something equivalent to false> || x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				if ((bits & OnlyValueRequiredMASK) != 0) {
					right.generateCode(currentScope, codeStream, valueRequired);
				} else {
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
			}
			if (mergedInitStateIndex != -1) {
				codeStream.removeNotDefinitelyAssignedVariables(
					currentScope,
					mergedInitStateIndex);
			}
			return;
		}
		if ((condConst = right.optimizedBooleanConstant()) != NotAConstant) {
			if (condConst.booleanValue() == true) {
				// x || <something equivalent to true>
				Label internalTrueLabel = new Label(codeStream);
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					internalTrueLabel,
					null,
					true); 
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				internalTrueLabel.place();
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_1();
					} else {
						if (trueLabel != null) {
							codeStream.goto_(trueLabel);
						}
					}
				}
				// reposition the endPC
				codeStream.updateLastRecordedEndPC(codeStream.position);					
			} else {
				// x || <something equivalent to false>
				if ((bits & OnlyValueRequiredMASK) != 0) {
					left.generateCode(currentScope, codeStream, valueRequired);
				} else {
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
			}
			if (mergedInitStateIndex != -1) {
				codeStream.removeNotDefinitelyAssignedVariables(
					currentScope,
					mergedInitStateIndex);
			}
			return;
		}
		// default case
		if (falseLabel == null) {
			if (trueLabel != null) {
				// implicit falling through the FALSE case
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, null, true); // need value, e.g. if (a == 1 || ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a==1
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					null,
					valueRequired);
			}
		} else {
			// implicit falling through the TRUE case
			if (trueLabel == null) {
				Label internalTrueLabel = new Label(codeStream);
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					internalTrueLabel,
					null,
					true);// need value, e.g. if (a == 1 || ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a==1
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					null,
					falseLabel,
					valueRequired);
				internalTrueLabel.place();
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}
		if (mergedInitStateIndex != -1) {
			codeStream.removeNotDefinitelyAssignedVariables(
				currentScope,
				mergedInitStateIndex);
		}
	}

commonMethod: 
(startLine=4829 endLine=4926 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public void recordPositionsFrom(int startPC, int sourcePos) {

	/* Record positions in the table, only if nothing has 
	 * already been recorded. Since we output them on the way 
	 * up (children first for more specific info)
	 * The pcToSourceMap table is always sorted.
	 */

	if (!generateLineNumberAttributes)
		return;
	if (sourcePos == 0)
		return;

	// no code generated for this node. e.g. field without any initialization
	if (position == startPC)
		return;

	// Widening an existing entry that already has the same source positions
	if (pcToSourceMapSize + 4 > pcToSourceMap.length) {
		// resize the array pcToSourceMap
		System.arraycopy(pcToSourceMap, 0, (pcToSourceMap = new int[pcToSourceMapSize << 1]), 0, pcToSourceMapSize);
	}
	int newLine = ClassFile.searchLineNumber(lineSeparatorPositions, sourcePos);
	// lastEntryPC represents the endPC of the lastEntry.
	if (pcToSourceMapSize > 0) {
		// in this case there is already an entry in the table
		if (pcToSourceMap[pcToSourceMapSize - 1] != newLine) {
			if (startPC < lastEntryPC) {
				// we forgot to add an entry.
				// search if an existing entry exists for startPC
				int insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);
				if (insertionIndex != -1) {
					// there is no existing entry starting with startPC.
					int existingEntryIndex = indexOfSameLineEntrySincePC(startPC, newLine); // index for PC
					/* the existingEntryIndex corresponds to en entry with the same line and a PC >= startPC.
						in this case it is relevant to widen this entry instead of creating a new one.
						line1: this(a,
						  b,
						  c);
						with this code we generate each argument. We generate a aload0 to invoke the constructor. There is no entry for this
						aload0 bytecode. The first entry is the one for the argument a.
						But we want the constructor call to start at the aload0 pc and not just at the pc of the first argument.
						So we widen the existing entry (if there is one) or we create a new entry with the startPC.
					*/
					if (existingEntryIndex != -1) {
						// widen existing entry
						pcToSourceMap[existingEntryIndex] = startPC;
					} else {
						// we have to add an entry that won't be sorted. So we sort the pcToSourceMap.
						System.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - insertionIndex);
						pcToSourceMap[insertionIndex++] = startPC;
						pcToSourceMap[insertionIndex] = newLine;
						pcToSourceMapSize += 2;
					}
				}
				if (position != lastEntryPC) { // no bytecode since last entry pc
					pcToSourceMap[pcToSourceMapSize++] = lastEntryPC;
					pcToSourceMap[pcToSourceMapSize++] = newLine;
				}
			} else {
				// we can safely add the new entry. The endPC of the previous entry is not in conflit with the startPC of the new entry.
				pcToSourceMap[pcToSourceMapSize++] = startPC;
				pcToSourceMap[pcToSourceMapSize++] = newLine;
			}
		} else {
			/* the last recorded entry is on the same line. But it could be relevant to widen this entry.
			   we want to extend this entry forward in case we generated some bytecode before the last entry that are not related to any statement
			*/	
			if (startPC < pcToSourceMap[pcToSourceMapSize - 2]) {
				int insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);
				if (insertionIndex != -1) {
					// widen the existing entry
					// we have to figure out if we need to move the last entry at another location to keep a sorted table
					/* First we need to check if at the insertion position there is not an existing entry
					 * that includes the one we want to insert. This is the case if pcToSourceMap[insertionIndex - 1] == newLine.
					 * In this case we don't want to change the table. If not, we want to insert a new entry. Prior to insertion
					 * we want to check if it is worth doing an arraycopy. If not we simply update the recorded pc.
					 */
					if (!((insertionIndex > 1) && (pcToSourceMap[insertionIndex - 1] == newLine))) {
						if ((pcToSourceMapSize > 4) && (pcToSourceMap[pcToSourceMapSize - 4] > startPC)) {
							System.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - 2 - insertionIndex);
							pcToSourceMap[insertionIndex++] = startPC;
							pcToSourceMap[insertionIndex] = newLine;						
						} else {
							pcToSourceMap[pcToSourceMapSize - 2] = startPC;
						}
					}
				}
			}
		}
		lastEntryPC = position;
	} else {
		// record the first entry
		pcToSourceMap[pcToSourceMapSize++] = startPC;
		pcToSourceMap[pcToSourceMapSize++] = newLine;
		lastEntryPC = position;
	}
}


, Instance #
frags: 
(startLine=134 endLine=296 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
		boolean valueRequired) {
			
		if (constant != Constant.NotAConstant) {
			super.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
			return;
		}
		Constant condConst;
		if ((condConst = left.optimizedBooleanConstant()) != NotAConstant) {
			if (condConst.booleanValue() == true) {
				// <something equivalent to true> && x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				if ((bits & OnlyValueRequiredMASK) != 0) {
					right.generateCode(currentScope, codeStream, valueRequired);
				} else {
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
			} else {
				// <something equivalent to false> && x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
				// reposition the endPC
				codeStream.updateLastRecordedEndPC(codeStream.position);
			}
			if (mergedInitStateIndex != -1) {
				codeStream.removeNotDefinitelyAssignedVariables(
					currentScope,
					mergedInitStateIndex);
			}
			return;
		}
		if ((condConst = right.optimizedBooleanConstant()) != NotAConstant) {
			if (condConst.booleanValue() == true) {
				// x && <something equivalent to true>
				if ((bits & OnlyValueRequiredMASK) != 0) {
					left.generateCode(currentScope, codeStream, valueRequired);
				} else {
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
			} else {
				// x && <something equivalent to false>
				Label internalFalseLabel = new Label(codeStream);
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					null,
					internalFalseLabel, 
					true);
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				internalFalseLabel.place();
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_0();
					} else {
						if (falseLabel != null) {
							// implicit falling through the TRUE case
							codeStream.goto_(falseLabel);
						}
					}
				}
				// reposition the endPC
				codeStream.updateLastRecordedEndPC(codeStream.position);
			}
			if (mergedInitStateIndex != -1) {
				codeStream.removeNotDefinitelyAssignedVariables(
					currentScope,
					mergedInitStateIndex);
			}
			return;
		}
		// default case
		if (falseLabel == null) {
			if (trueLabel != null) {
				// implicit falling through the FALSE case
				Label internalFalseLabel = new Label(codeStream);
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					null,
					internalFalseLabel,
					true); // need value, e.g. if (a == 1 && ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a!=1
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					null,
					valueRequired);
				internalFalseLabel.place();
			}
		} else {
			// implicit falling through the TRUE case
			if (trueLabel == null) {
				left.generateOptimizedBoolean(currentScope, codeStream, null, falseLabel, true); // need value, e.g. if (a == 1 && ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a!=1
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					null,
					falseLabel,
					valueRequired);
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}
		if (mergedInitStateIndex != -1) {
			codeStream.removeNotDefinitelyAssignedVariables(
				currentScope,
				mergedInitStateIndex);
		}
	}

(startLine=136 endLine=295 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
		boolean valueRequired) {
		if (constant != Constant.NotAConstant) {
			super.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
			return;
		}
		Constant condConst;
		if ((condConst = left.optimizedBooleanConstant()) != NotAConstant) {
			if (condConst.booleanValue() == true) {
				// <something equivalent to true> || x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_1();
					} else {
						if (trueLabel != null) {
							codeStream.goto_(trueLabel);
						}
					}
				}
				// reposition the endPC
				codeStream.updateLastRecordedEndPC(codeStream.position);					
			} else {
				// <something equivalent to false> || x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				if ((bits & OnlyValueRequiredMASK) != 0) {
					right.generateCode(currentScope, codeStream, valueRequired);
				} else {
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
			}
			if (mergedInitStateIndex != -1) {
				codeStream.removeNotDefinitelyAssignedVariables(
					currentScope,
					mergedInitStateIndex);
			}
			return;
		}
		if ((condConst = right.optimizedBooleanConstant()) != NotAConstant) {
			if (condConst.booleanValue() == true) {
				// x || <something equivalent to true>
				Label internalTrueLabel = new Label(codeStream);
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					internalTrueLabel,
					null,
					true); 
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				internalTrueLabel.place();
				if (valueRequired) {
					if ((bits & OnlyValueRequiredMASK) != 0) {
						codeStream.iconst_1();
					} else {
						if (trueLabel != null) {
							codeStream.goto_(trueLabel);
						}
					}
				}
				// reposition the endPC
				codeStream.updateLastRecordedEndPC(codeStream.position);					
			} else {
				// x || <something equivalent to false>
				if ((bits & OnlyValueRequiredMASK) != 0) {
					left.generateCode(currentScope, codeStream, valueRequired);
				} else {
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
			}
			if (mergedInitStateIndex != -1) {
				codeStream.removeNotDefinitelyAssignedVariables(
					currentScope,
					mergedInitStateIndex);
			}
			return;
		}
		// default case
		if (falseLabel == null) {
			if (trueLabel != null) {
				// implicit falling through the FALSE case
				left.generateOptimizedBoolean(currentScope, codeStream, trueLabel, null, true); // need value, e.g. if (a == 1 || ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a==1
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					null,
					valueRequired);
			}
		} else {
			// implicit falling through the TRUE case
			if (trueLabel == null) {
				Label internalTrueLabel = new Label(codeStream);
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					internalTrueLabel,
					null,
					true);// need value, e.g. if (a == 1 || ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a==1
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					null,
					falseLabel,
					valueRequired);
				internalTrueLabel.place();
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}
		if (mergedInitStateIndex != -1) {
			codeStream.removeNotDefinitelyAssignedVariables(
				currentScope,
				mergedInitStateIndex);
		}
	}

commonMethod: 
(startLine=4829 endLine=4926 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public void recordPositionsFrom(int startPC, int sourcePos) {

	/* Record positions in the table, only if nothing has 
	 * already been recorded. Since we output them on the way 
	 * up (children first for more specific info)
	 * The pcToSourceMap table is always sorted.
	 */

	if (!generateLineNumberAttributes)
		return;
	if (sourcePos == 0)
		return;

	// no code generated for this node. e.g. field without any initialization
	if (position == startPC)
		return;

	// Widening an existing entry that already has the same source positions
	if (pcToSourceMapSize + 4 > pcToSourceMap.length) {
		// resize the array pcToSourceMap
		System.arraycopy(pcToSourceMap, 0, (pcToSourceMap = new int[pcToSourceMapSize << 1]), 0, pcToSourceMapSize);
	}
	int newLine = ClassFile.searchLineNumber(lineSeparatorPositions, sourcePos);
	// lastEntryPC represents the endPC of the lastEntry.
	if (pcToSourceMapSize > 0) {
		// in this case there is already an entry in the table
		if (pcToSourceMap[pcToSourceMapSize - 1] != newLine) {
			if (startPC < lastEntryPC) {
				// we forgot to add an entry.
				// search if an existing entry exists for startPC
				int insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);
				if (insertionIndex != -1) {
					// there is no existing entry starting with startPC.
					int existingEntryIndex = indexOfSameLineEntrySincePC(startPC, newLine); // index for PC
					/* the existingEntryIndex corresponds to en entry with the same line and a PC >= startPC.
						in this case it is relevant to widen this entry instead of creating a new one.
						line1: this(a,
						  b,
						  c);
						with this code we generate each argument. We generate a aload0 to invoke the constructor. There is no entry for this
						aload0 bytecode. The first entry is the one for the argument a.
						But we want the constructor call to start at the aload0 pc and not just at the pc of the first argument.
						So we widen the existing entry (if there is one) or we create a new entry with the startPC.
					*/
					if (existingEntryIndex != -1) {
						// widen existing entry
						pcToSourceMap[existingEntryIndex] = startPC;
					} else {
						// we have to add an entry that won't be sorted. So we sort the pcToSourceMap.
						System.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - insertionIndex);
						pcToSourceMap[insertionIndex++] = startPC;
						pcToSourceMap[insertionIndex] = newLine;
						pcToSourceMapSize += 2;
					}
				}
				if (position != lastEntryPC) { // no bytecode since last entry pc
					pcToSourceMap[pcToSourceMapSize++] = lastEntryPC;
					pcToSourceMap[pcToSourceMapSize++] = newLine;
				}
			} else {
				// we can safely add the new entry. The endPC of the previous entry is not in conflit with the startPC of the new entry.
				pcToSourceMap[pcToSourceMapSize++] = startPC;
				pcToSourceMap[pcToSourceMapSize++] = newLine;
			}
		} else {
			/* the last recorded entry is on the same line. But it could be relevant to widen this entry.
			   we want to extend this entry forward in case we generated some bytecode before the last entry that are not related to any statement
			*/	
			if (startPC < pcToSourceMap[pcToSourceMapSize - 2]) {
				int insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);
				if (insertionIndex != -1) {
					// widen the existing entry
					// we have to figure out if we need to move the last entry at another location to keep a sorted table
					/* First we need to check if at the insertion position there is not an existing entry
					 * that includes the one we want to insert. This is the case if pcToSourceMap[insertionIndex - 1] == newLine.
					 * In this case we don't want to change the table. If not, we want to insert a new entry. Prior to insertion
					 * we want to check if it is worth doing an arraycopy. If not we simply update the recorded pc.
					 */
					if (!((insertionIndex > 1) && (pcToSourceMap[insertionIndex - 1] == newLine))) {
						if ((pcToSourceMapSize > 4) && (pcToSourceMap[pcToSourceMapSize - 4] > startPC)) {
							System.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - 2 - insertionIndex);
							pcToSourceMap[insertionIndex++] = startPC;
							pcToSourceMap[insertionIndex] = newLine;						
						} else {
							pcToSourceMap[pcToSourceMapSize - 2] = startPC;
						}
					}
				}
			}
		}
		lastEntryPC = position;
	} else {
		// record the first entry
		pcToSourceMap[pcToSourceMapSize++] = startPC;
		pcToSourceMap[pcToSourceMapSize++] = newLine;
		lastEntryPC = position;
	}
}


, Instance #
frags: 
(startLine=142 endLine=163 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
			if (condConst.booleanValue() == true) {
				// <something equivalent to true> && x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				if ((bits & OnlyValueRequiredMASK) != 0) {
					right.generateCode(currentScope, codeStream, valueRequired);
				} else {
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
			} else {

(startLine=192 endLine=213 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
			if (condConst.booleanValue() == true) {
				// x && <something equivalent to true>
				if ((bits & OnlyValueRequiredMASK) != 0) {
					left.generateCode(currentScope, codeStream, valueRequired);
				} else {
					left.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
			} else {

(startLine=162 endLine=183 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
			} else {
				// <something equivalent to false> || x
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					falseLabel,
					false);
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				if ((bits & OnlyValueRequiredMASK) != 0) {
					right.generateCode(currentScope, codeStream, valueRequired);
				} else {
					right.generateOptimizedBoolean(
						currentScope,
						codeStream,
						trueLabel,
						falseLabel,
						valueRequired);
				}
			}

commonMethod: 
(startLine=4829 endLine=4926 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public void recordPositionsFrom(int startPC, int sourcePos) {

	/* Record positions in the table, only if nothing has 
	 * already been recorded. Since we output them on the way 
	 * up (children first for more specific info)
	 * The pcToSourceMap table is always sorted.
	 */

	if (!generateLineNumberAttributes)
		return;
	if (sourcePos == 0)
		return;

	// no code generated for this node. e.g. field without any initialization
	if (position == startPC)
		return;

	// Widening an existing entry that already has the same source positions
	if (pcToSourceMapSize + 4 > pcToSourceMap.length) {
		// resize the array pcToSourceMap
		System.arraycopy(pcToSourceMap, 0, (pcToSourceMap = new int[pcToSourceMapSize << 1]), 0, pcToSourceMapSize);
	}
	int newLine = ClassFile.searchLineNumber(lineSeparatorPositions, sourcePos);
	// lastEntryPC represents the endPC of the lastEntry.
	if (pcToSourceMapSize > 0) {
		// in this case there is already an entry in the table
		if (pcToSourceMap[pcToSourceMapSize - 1] != newLine) {
			if (startPC < lastEntryPC) {
				// we forgot to add an entry.
				// search if an existing entry exists for startPC
				int insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);
				if (insertionIndex != -1) {
					// there is no existing entry starting with startPC.
					int existingEntryIndex = indexOfSameLineEntrySincePC(startPC, newLine); // index for PC
					/* the existingEntryIndex corresponds to en entry with the same line and a PC >= startPC.
						in this case it is relevant to widen this entry instead of creating a new one.
						line1: this(a,
						  b,
						  c);
						with this code we generate each argument. We generate a aload0 to invoke the constructor. There is no entry for this
						aload0 bytecode. The first entry is the one for the argument a.
						But we want the constructor call to start at the aload0 pc and not just at the pc of the first argument.
						So we widen the existing entry (if there is one) or we create a new entry with the startPC.
					*/
					if (existingEntryIndex != -1) {
						// widen existing entry
						pcToSourceMap[existingEntryIndex] = startPC;
					} else {
						// we have to add an entry that won't be sorted. So we sort the pcToSourceMap.
						System.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - insertionIndex);
						pcToSourceMap[insertionIndex++] = startPC;
						pcToSourceMap[insertionIndex] = newLine;
						pcToSourceMapSize += 2;
					}
				}
				if (position != lastEntryPC) { // no bytecode since last entry pc
					pcToSourceMap[pcToSourceMapSize++] = lastEntryPC;
					pcToSourceMap[pcToSourceMapSize++] = newLine;
				}
			} else {
				// we can safely add the new entry. The endPC of the previous entry is not in conflit with the startPC of the new entry.
				pcToSourceMap[pcToSourceMapSize++] = startPC;
				pcToSourceMap[pcToSourceMapSize++] = newLine;
			}
		} else {
			/* the last recorded entry is on the same line. But it could be relevant to widen this entry.
			   we want to extend this entry forward in case we generated some bytecode before the last entry that are not related to any statement
			*/	
			if (startPC < pcToSourceMap[pcToSourceMapSize - 2]) {
				int insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);
				if (insertionIndex != -1) {
					// widen the existing entry
					// we have to figure out if we need to move the last entry at another location to keep a sorted table
					/* First we need to check if at the insertion position there is not an existing entry
					 * that includes the one we want to insert. This is the case if pcToSourceMap[insertionIndex - 1] == newLine.
					 * In this case we don't want to change the table. If not, we want to insert a new entry. Prior to insertion
					 * we want to check if it is worth doing an arraycopy. If not we simply update the recorded pc.
					 */
					if (!((insertionIndex > 1) && (pcToSourceMap[insertionIndex - 1] == newLine))) {
						if ((pcToSourceMapSize > 4) && (pcToSourceMap[pcToSourceMapSize - 4] > startPC)) {
							System.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - 2 - insertionIndex);
							pcToSourceMap[insertionIndex++] = startPC;
							pcToSourceMap[insertionIndex] = newLine;						
						} else {
							pcToSourceMap[pcToSourceMapSize - 2] = startPC;
						}
					}
				}
			}
		}
		lastEntryPC = position;
	} else {
		// record the first entry
		pcToSourceMap[pcToSourceMapSize++] = startPC;
		pcToSourceMap[pcToSourceMapSize++] = newLine;
		lastEntryPC = position;
	}
}


, Instance #
frags: 
(startLine=253 endLine=274 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AND_AND_Expression.java)
		if (falseLabel == null) {
			if (trueLabel != null) {
				// implicit falling through the FALSE case
				Label internalFalseLabel = new Label(codeStream);
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					null,
					internalFalseLabel,
					true); // need value, e.g. if (a == 1 && ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a!=1
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					trueLabel,
					null,
					valueRequired);
				internalFalseLabel.place();
			}
		} else {

(startLine=266 endLine=289 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00587/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/OR_OR_Expression.java)
		} else {
			// implicit falling through the TRUE case
			if (trueLabel == null) {
				Label internalTrueLabel = new Label(codeStream);
				left.generateOptimizedBoolean(
					currentScope,
					codeStream,
					internalTrueLabel,
					null,
					true);// need value, e.g. if (a == 1 || ((b = 2) > 0)) {} -> shouldn't initialize 'b' if a==1
				if (rightInitStateIndex != -1) {
					codeStream.addDefinitelyAssignedVariables(currentScope, rightInitStateIndex);
				}
				right.generateOptimizedBoolean(
					currentScope,
					codeStream,
					null,
					falseLabel,
					valueRequired);
				internalTrueLabel.place();
			} else {
				// no implicit fall through TRUE/FALSE --> should never occur
			}
		}

commonMethod: 
(startLine=4829 endLine=4926 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java)
public void recordPositionsFrom(int startPC, int sourcePos) {

	/* Record positions in the table, only if nothing has 
	 * already been recorded. Since we output them on the way 
	 * up (children first for more specific info)
	 * The pcToSourceMap table is always sorted.
	 */

	if (!generateLineNumberAttributes)
		return;
	if (sourcePos == 0)
		return;

	// no code generated for this node. e.g. field without any initialization
	if (position == startPC)
		return;

	// Widening an existing entry that already has the same source positions
	if (pcToSourceMapSize + 4 > pcToSourceMap.length) {
		// resize the array pcToSourceMap
		System.arraycopy(pcToSourceMap, 0, (pcToSourceMap = new int[pcToSourceMapSize << 1]), 0, pcToSourceMapSize);
	}
	int newLine = ClassFile.searchLineNumber(lineSeparatorPositions, sourcePos);
	// lastEntryPC represents the endPC of the lastEntry.
	if (pcToSourceMapSize > 0) {
		// in this case there is already an entry in the table
		if (pcToSourceMap[pcToSourceMapSize - 1] != newLine) {
			if (startPC < lastEntryPC) {
				// we forgot to add an entry.
				// search if an existing entry exists for startPC
				int insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);
				if (insertionIndex != -1) {
					// there is no existing entry starting with startPC.
					int existingEntryIndex = indexOfSameLineEntrySincePC(startPC, newLine); // index for PC
					/* the existingEntryIndex corresponds to en entry with the same line and a PC >= startPC.
						in this case it is relevant to widen this entry instead of creating a new one.
						line1: this(a,
						  b,
						  c);
						with this code we generate each argument. We generate a aload0 to invoke the constructor. There is no entry for this
						aload0 bytecode. The first entry is the one for the argument a.
						But we want the constructor call to start at the aload0 pc and not just at the pc of the first argument.
						So we widen the existing entry (if there is one) or we create a new entry with the startPC.
					*/
					if (existingEntryIndex != -1) {
						// widen existing entry
						pcToSourceMap[existingEntryIndex] = startPC;
					} else {
						// we have to add an entry that won't be sorted. So we sort the pcToSourceMap.
						System.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - insertionIndex);
						pcToSourceMap[insertionIndex++] = startPC;
						pcToSourceMap[insertionIndex] = newLine;
						pcToSourceMapSize += 2;
					}
				}
				if (position != lastEntryPC) { // no bytecode since last entry pc
					pcToSourceMap[pcToSourceMapSize++] = lastEntryPC;
					pcToSourceMap[pcToSourceMapSize++] = newLine;
				}
			} else {
				// we can safely add the new entry. The endPC of the previous entry is not in conflit with the startPC of the new entry.
				pcToSourceMap[pcToSourceMapSize++] = startPC;
				pcToSourceMap[pcToSourceMapSize++] = newLine;
			}
		} else {
			/* the last recorded entry is on the same line. But it could be relevant to widen this entry.
			   we want to extend this entry forward in case we generated some bytecode before the last entry that are not related to any statement
			*/	
			if (startPC < pcToSourceMap[pcToSourceMapSize - 2]) {
				int insertionIndex = insertionIndex(pcToSourceMap, pcToSourceMapSize, startPC);
				if (insertionIndex != -1) {
					// widen the existing entry
					// we have to figure out if we need to move the last entry at another location to keep a sorted table
					/* First we need to check if at the insertion position there is not an existing entry
					 * that includes the one we want to insert. This is the case if pcToSourceMap[insertionIndex - 1] == newLine.
					 * In this case we don't want to change the table. If not, we want to insert a new entry. Prior to insertion
					 * we want to check if it is worth doing an arraycopy. If not we simply update the recorded pc.
					 */
					if (!((insertionIndex > 1) && (pcToSourceMap[insertionIndex - 1] == newLine))) {
						if ((pcToSourceMapSize > 4) && (pcToSourceMap[pcToSourceMapSize - 4] > startPC)) {
							System.arraycopy(pcToSourceMap, insertionIndex, pcToSourceMap, insertionIndex + 2, pcToSourceMapSize - 2 - insertionIndex);
							pcToSourceMap[insertionIndex++] = startPC;
							pcToSourceMap[insertionIndex] = newLine;						
						} else {
							pcToSourceMap[pcToSourceMapSize - 2] = startPC;
						}
					}
				}
			}
		}
		lastEntryPC = position;
	} else {
		// record the first entry
		pcToSourceMap[pcToSourceMapSize++] = startPC;
		pcToSourceMap[pcToSourceMapSize++] = newLine;
		lastEntryPC = position;
	}
}


, Instance #
frags: 
(startLine=138 endLine=168 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test002() {
		try {
			String sourceA002 =
				"public class A002 {\n" +
				"	public static void main(String[] args) {\n" +
				"		System.out.println(); /* \\u000d: CARRIAGE RETURN */\n" +
				"		System.out.println();\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA002, "A002");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A002.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 3, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 6, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 12, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
		} finally {
			removeTempClass("A002");
		}
	}

(startLine=173 endLine=205 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test003() {
		try {
			String sourceA003 =
				"public class A003 {\n" +
				"\n" +
				"	public int bar() {\n" +
				"		return 0;\n" +
				"	}\n" +
				"	\n" +
				"	public void foo() {\n" +
				"		System.out.println(bar());\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA003, "A003");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A003.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 3, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[2];
			assertEquals("wrong name", "foo", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 2, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 8, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 10, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 9, lineNumberTable[1][1]);
		} finally {
			removeTempClass("A003");
		}
	}

(startLine=210 endLine=250 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test004() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   && !b) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 6, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 5, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 11, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 15, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 7, lineNumberTable[4][1]);
			assertEquals("wrong pc[5]", 22, lineNumberTable[5][0]);
			assertEquals("wrong line[5]", 9, lineNumberTable[5][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=255 endLine=290 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test005() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   && true) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 9, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=295 endLine=328 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test006() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   && false) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 3, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 9, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 8, lineNumberTable[2][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=333 endLine=368 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test007() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (true\n" +
				"		   && !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 6, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 12, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=373 endLine=404 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test008() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (false\n" +
				"		   && !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 2, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 8, lineNumberTable[1][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=409 endLine=449 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test009() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   || !b) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 6, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 5, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 11, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 15, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 7, lineNumberTable[4][1]);
			assertEquals("wrong pc[5]", 22, lineNumberTable[5][0]);
			assertEquals("wrong line[5]", 9, lineNumberTable[5][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=454 endLine=489 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test010() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   || true) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 9, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=494 endLine=529 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test011() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   || false) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 9, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=534 endLine=567 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test012() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (true\n" +
				"		   || !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 3, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 6, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 8, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 8, lineNumberTable[2][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=572 endLine=607 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test013() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (false\n" +
				"		   || !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 6, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 12, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=612 endLine=652 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test014() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   == !b) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 6, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 5, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 28, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 7, lineNumberTable[4][1]);
			assertEquals("wrong pc[5]", 35, lineNumberTable[5][0]);
			assertEquals("wrong line[5]", 9, lineNumberTable[5][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=657 endLine=692 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test015() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   == true) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 9, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=697 endLine=732 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test016() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   == false) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 9, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=737 endLine=772 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test017() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (true\n" +
				"		   == !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 6, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 12, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=777 endLine=812 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test018() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (false\n" +
				"		   == !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 6, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 12, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=818 endLine=858 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test019() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		int i = 6;\n" +
				"		if ((i == 5)\n" +
				"			? b : !b) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 6, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 5, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 10, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 21, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 7, lineNumberTable[4][1]);
			assertEquals("wrong pc[5]", 28, lineNumberTable[5][0]);
			assertEquals("wrong line[5]", 9, lineNumberTable[5][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=863 endLine=900 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test020() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (i\n" +
				"			>= 5) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 5, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 4, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 8, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 15, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 8, lineNumberTable[4][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=905 endLine=940 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test021() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (i\n" +
				"			>= 0) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 7, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 14, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=945 endLine=980 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test022() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (0\n" +
				"			>= i) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 7, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 14, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=985 endLine=1020 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test023() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (i\n" +
				"			> 0) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 7, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 14, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1025 endLine=1060 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test024() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (0\n" +
				"			> i) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 7, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 14, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1065 endLine=1102 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test025() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (i\n" +
				"			> 5) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 5, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 4, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 8, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 15, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 8, lineNumberTable[4][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1108 endLine=1143 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test026() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (i\n" +
				"			< 0) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 7, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 14, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1149 endLine=1184 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test027() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (0\n" +
				"			< i) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 7, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 14, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=1189 endLine=1226 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test028() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (i\n" +
				"			< 5) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 5, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 4, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 8, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 15, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 8, lineNumberTable[4][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=1231 endLine=1266 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test029() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (i\n" +
				"			<= 0) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 7, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 14, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=1272 endLine=1307 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test030() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (0\n" +
				"			<= i) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 7, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 14, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1312 endLine=1349 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test031() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (i\n" +
				"			<= 5) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 5, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 4, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 8, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 15, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 8, lineNumberTable[4][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=1354 endLine=1391 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test032() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if (i\n" +
				"			<= 5) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 5, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 4, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 8, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 15, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 8, lineNumberTable[4][1]);
		} finally {
			removeTempClass("A");
		}
	}		

(startLine=1396 endLine=1436 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test033() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   & !b) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 6, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 5, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 29, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 7, lineNumberTable[4][1]);
			assertEquals("wrong pc[5]", 36, lineNumberTable[5][0]);
			assertEquals("wrong line[5]", 9, lineNumberTable[5][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=1441 endLine=1476 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test034() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   & true) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 9, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1481 endLine=1512 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test035() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   & false) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 2, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 8, lineNumberTable[1][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=1517 endLine=1552 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test036() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (true\n" +
				"		   & !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 6, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 12, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1557 endLine=1588 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test037() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (false\n" +
				"		   & !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 2, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 8, lineNumberTable[1][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=1593 endLine=1633 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test038() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   | !b) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 6, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 5, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 29, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 7, lineNumberTable[4][1]);
			assertEquals("wrong pc[5]", 36, lineNumberTable[5][0]);
			assertEquals("wrong line[5]", 9, lineNumberTable[5][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=1638 endLine=1671 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test039() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   | true) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 3, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 6, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 10, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 8, lineNumberTable[2][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1676 endLine=1711 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test040() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   | false) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 9, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1716 endLine=1749 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test041() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (true\n" +
				"		   | !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 3, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 6, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 8, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 8, lineNumberTable[2][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1754 endLine=1789 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test042() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (false\n" +
				"		   | !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 6, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 12, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1794 endLine=1834 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test043() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   ^ !b) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 6, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 5, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 5, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 6, lineNumberTable[3][1]);
			assertEquals("wrong pc[4]", 29, lineNumberTable[4][0]);
			assertEquals("wrong line[4]", 7, lineNumberTable[4][1]);
			assertEquals("wrong pc[5]", 36, lineNumberTable[5][0]);
			assertEquals("wrong line[5]", 9, lineNumberTable[5][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=1839 endLine=1874 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test044() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   ^ true) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 9, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1879 endLine=1914 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test045() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		int i = 6;\n" +
				"		if ((i == 6) \n" +
				"		   ^ false) {   	\n" +
				"		   	System.out.println(i);\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 3, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 4, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 9, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 16, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}	

(startLine=1919 endLine=1954 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test046() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (true\n" +
				"		   ^ !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 6, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 12, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

(startLine=1959 endLine=1994 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00588/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	public void test047() {
		try {
			String sourceA =
				"public class A {\n" +
				"	public static void main(String[] args) {\n" +
				"		boolean b = false;\n" +
				"		if (false\n" +
				"		   ^ !b) {   	\n" +
				"		   	System.out.println();\n" +
				"		   }\n" +
				"	}\n" +
				"}";
			compileAndDeploy(sourceA, "A");
			IClassFileReader classFileReader = ToolFactory.createDefaultClassFileReader(EVAL_DIRECTORY + File.separator + "A.class", IClassFileReader.ALL);
			IMethodInfo[] methodInfos = classFileReader.getMethodInfos();
			assertEquals("wrong size", 2, methodInfos.length);
			IMethodInfo methodInfo = methodInfos[1];
			assertEquals("wrong name", "main", new String(methodInfo.getName()));
			ICodeAttribute codeAttribute = methodInfo.getCodeAttribute();
			assertNotNull("No code attribute", codeAttribute);
			ILineNumberAttribute lineNumberAttribute = codeAttribute.getLineNumberAttribute();
			assertNotNull("No code line number attribute", lineNumberAttribute);
			int[][] lineNumberTable = lineNumberAttribute.getLineNumberTable();
			assertEquals("wrong size", 4, lineNumberTable.length);
			assertEquals("wrong pc[0]", 0, lineNumberTable[0][0]);
			assertEquals("wrong line[0]", 3, lineNumberTable[0][1]);
			assertEquals("wrong pc[1]", 2, lineNumberTable[1][0]);
			assertEquals("wrong line[1]", 5, lineNumberTable[1][1]);
			assertEquals("wrong pc[2]", 6, lineNumberTable[2][0]);
			assertEquals("wrong line[2]", 6, lineNumberTable[2][1]);
			assertEquals("wrong pc[3]", 12, lineNumberTable[3][0]);
			assertEquals("wrong line[3]", 8, lineNumberTable[3][1]);
		} finally {
			removeTempClass("A");
		}
	}

commonMethod: 
(startLine=39 endLine=57 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00589/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/ClassFileReaderTest.java)
	private void checkClassFile(String className, String source, String expectedOutput) {
		compileAndDeploy(source, className);
		try {
			File f = new File(EVAL_DIRECTORY + File.separator + className + ".class");
			byte[] classFileBytes = org.eclipse.jdt.internal.compiler.util.Util.getFileByteContent(f);
			ClassFileBytesDisassembler disassembler = ToolFactory.createDefaultClassFileBytesDisassembler();
			String result = disassembler.disassemble(classFileBytes, "\n", ClassFileBytesDisassembler.DETAILED);
			if (!result.equals(expectedOutput)) {
				System.out.println(Util.displayString(result, 3));
			}
			assertEquals("Wrong contents", expectedOutput, result);
		} catch (org.eclipse.jdt.core.util.ClassFormatException e) {
			assertTrue(false);
		} catch (IOException e) {
			assertTrue(false);
		} finally {
			removeTempClass(className);
		}
	}


, Instance #
frags: 
(startLine=1812 endLine=1836 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00597/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
				do {
					try {
						this.scribe.alignFragment(arrayInitializerAlignment, 0);
						if (this.preferences.insert_space_before_first_initializer) {
							this.scribe.space();
						}
						expressions[0].traverse(this, scope);
						for (int i = 1; i < expressionsLength; i++) {
							this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
							this.scribe.alignFragment(arrayInitializerAlignment, i);
							if (this.preferences.insert_space_after_comma_in_array_initializer) {
								this.scribe.space();
							}
							expressions[i].traverse(this, scope);
							if (i == expressionsLength - 1) {
								if (isComma()) {
									this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
								}
							}
						}
						ok = true;
					} catch (AlignmentException e) {
						this.scribe.redoAlignment(e);
					}
				} while (!ok);

(startLine=1838 endLine=1862 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00597/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
			} else {
				// we don't need to use an alignment
				if (this.preferences.insert_space_before_first_initializer) {
					this.scribe.space();
				}
				expressions[0].traverse(this, scope);
				if (expressionsLength == 1) {
					if (isComma()) {
						this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
					}
				} else {
					for (int i = 1; i < expressionsLength; i++) {
						this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
						if (this.preferences.insert_space_after_comma_in_array_initializer) {
							this.scribe.space();
						}
						expressions[i].traverse(this, scope);
						if (i == expressionsLength - 1) {
							if (isComma()) {
								this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
							}
						}
					}
				}
			}

commonMethod: 
(startLine=919 endLine=1017 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00598/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	private void formatArrayInitializer(ArrayInitializer arrayInitializer, BlockScope scope, boolean insertSpaceBeforeOpeningBrace) {
		final int numberOfParens = (arrayInitializer.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;
		if (numberOfParens > 0) {
			manageOpeningParenthesizedExpression(arrayInitializer, numberOfParens);
		}
		
		String array_initializer_brace_position = this.preferences.array_initializer_brace_position;
		formatOpeningBrace(array_initializer_brace_position, insertSpaceBeforeOpeningBrace);

		if (this.preferences.insert_new_line_after_opening_brace_in_array_initializer) {
			this.scribe.printNewLine();
			for (int i = this.preferences.array_initializer_continuation_indentation; i > 0; i--) {
				this.scribe.indent();
			}
		}

		final Expression[] expressions = arrayInitializer.expressions;
		if (expressions != null) {
			int expressionsLength = expressions.length;
			if (expressionsLength > 1) {
				Alignment arrayInitializerAlignment =this.scribe.createAlignment(
						"array_initializer",//$NON-NLS-1$
						this.preferences.array_initializer_expressions_alignment,
						Alignment.R_OUTERMOST,
						expressionsLength,
						this.scribe.scanner.currentPosition,
						this.preferences.insert_new_line_after_opening_brace_in_array_initializer ? 0 : this.preferences.array_initializer_continuation_indentation,
						true);
				this.scribe.enterAlignment(arrayInitializerAlignment);
				boolean ok = false;
				do {
					try {
						this.scribe.alignFragment(arrayInitializerAlignment, 0);
						if (this.preferences.insert_space_before_first_initializer) {
							this.scribe.space();
						}
						expressions[0].traverse(this, scope);
						for (int i = 1; i < expressionsLength; i++) {
							this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
							this.scribe.alignFragment(arrayInitializerAlignment, i);
							if (this.preferences.insert_space_after_comma_in_array_initializer) {
								this.scribe.space();
							}
							expressions[i].traverse(this, scope);
							if (i == expressionsLength - 1) {
								if (isComma()) {
									this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
								}
							}
						}
						ok = true;
					} catch (AlignmentException e) {
						this.scribe.redoAlignment(e);
					}
				} while (!ok);
				this.scribe.exitAlignment(arrayInitializerAlignment, true);
			} else {
				// we don't need to use an alignment
				if (this.preferences.insert_space_before_first_initializer) {
					this.scribe.space();
				}
				expressions[0].traverse(this, scope);
				if (expressionsLength == 1) {
					if (isComma()) {
						this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
					}
				} else {
					for (int i = 1; i < expressionsLength; i++) {
						this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
						if (this.preferences.insert_space_after_comma_in_array_initializer) {
							this.scribe.space();
						}
						expressions[i].traverse(this, scope);
						if (i == expressionsLength - 1) {
							if (isComma()) {
								this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
							}
						}
					}
				}
			}
		}
		if (this.preferences.insert_new_line_after_opening_brace_in_array_initializer) {
			for (int i = this.preferences.array_initializer_continuation_indentation; i > 0; i--) {
				this.scribe.unIndent();
			}			
		}
		if (this.preferences.insert_new_line_before_closing_brace_in_array_initializer) {
			this.scribe.printNewLine();
		}
		this.scribe.printNextToken(TerminalTokens.TokenNameRBRACE, this.preferences.insert_space_before_closing_brace_in_array_initializer, true); 
		if (array_initializer_brace_position.equals(DefaultCodeFormatterConstants.NEXT_LINE_SHIFTED)) {
			this.scribe.unIndent();
		}	
	
		if (numberOfParens > 0) {
			manageClosingParenthesizedExpression(arrayInitializer, numberOfParens);
		}
	}


, Instance #
frags: 
(startLine=1819 endLine=1831 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00597/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
						for (int i = 1; i < expressionsLength; i++) {
							this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
							this.scribe.alignFragment(arrayInitializerAlignment, i);
							if (this.preferences.insert_space_after_comma_in_array_initializer) {
								this.scribe.space();
							}
							expressions[i].traverse(this, scope);
							if (i == expressionsLength - 1) {
								if (isComma()) {
									this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
								}
							}
						}

(startLine=1848 endLine=1861 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00597/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
				} else {
					for (int i = 1; i < expressionsLength; i++) {
						this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
						if (this.preferences.insert_space_after_comma_in_array_initializer) {
							this.scribe.space();
						}
						expressions[i].traverse(this, scope);
						if (i == expressionsLength - 1) {
							if (isComma()) {
								this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
							}
						}
					}
				}

commonMethod: 
(startLine=919 endLine=1017 srcPath=/home/sonia/NewExperiment/eclipse.jdt.coreFilter/00598/org.eclipse.jdt.core/formatter/org/eclipse/jdt/internal/formatter/CodeFormatterVisitor.java)
	private void formatArrayInitializer(ArrayInitializer arrayInitializer, BlockScope scope, boolean insertSpaceBeforeOpeningBrace) {
		final int numberOfParens = (arrayInitializer.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT;
		if (numberOfParens > 0) {
			manageOpeningParenthesizedExpression(arrayInitializer, numberOfParens);
		}
		
		String array_initializer_brace_position = this.preferences.array_initializer_brace_position;
		formatOpeningBrace(array_initializer_brace_position, insertSpaceBeforeOpeningBrace);

		if (this.preferences.insert_new_line_after_opening_brace_in_array_initializer) {
			this.scribe.printNewLine();
			for (int i = this.preferences.array_initializer_continuation_indentation; i > 0; i--) {
				this.scribe.indent();
			}
		}

		final Expression[] expressions = arrayInitializer.expressions;
		if (expressions != null) {
			int expressionsLength = expressions.length;
			if (expressionsLength > 1) {
				Alignment arrayInitializerAlignment =this.scribe.createAlignment(
						"array_initializer",//$NON-NLS-1$
						this.preferences.array_initializer_expressions_alignment,
						Alignment.R_OUTERMOST,
						expressionsLength,
						this.scribe.scanner.currentPosition,
						this.preferences.insert_new_line_after_opening_brace_in_array_initializer ? 0 : this.preferences.array_initializer_continuation_indentation,
						true);
				this.scribe.enterAlignment(arrayInitializerAlignment);
				boolean ok = false;
				do {
					try {
						this.scribe.alignFragment(arrayInitializerAlignment, 0);
						if (this.preferences.insert_space_before_first_initializer) {
							this.scribe.space();
						}
						expressions[0].traverse(this, scope);
						for (int i = 1; i < expressionsLength; i++) {
							this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
							this.scribe.alignFragment(arrayInitializerAlignment, i);
							if (this.preferences.insert_space_after_comma_in_array_initializer) {
								this.scribe.space();
							}
							expressions[i].traverse(this, scope);
							if (i == expressionsLength - 1) {
								if (isComma()) {
									this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
								}
							}
						}
						ok = true;
					} catch (AlignmentException e) {
						this.scribe.redoAlignment(e);
					}
				} while (!ok);
				this.scribe.exitAlignment(arrayInitializerAlignment, true);
			} else {
				// we don't need to use an alignment
				if (this.preferences.insert_space_before_first_initializer) {
					this.scribe.space();
				}
				expressions[0].traverse(this, scope);
				if (expressionsLength == 1) {
					if (isComma()) {
						this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
					}
				} else {
					for (int i = 1; i < expressionsLength; i++) {
						this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
						if (this.preferences.insert_space_after_comma_in_array_initializer) {
							this.scribe.space();
						}
						expressions[i].traverse(this, scope);
						if (i == expressionsLength - 1) {
							if (isComma()) {
								this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_array_initializer);
							}
						}
					}
				}
			}
		}
		if (this.preferences.insert_new_line_after_opening_brace_in_array_initializer) {
			for (int i = this.preferences.array_initializer_continuation_indentation; i > 0; i--) {
				this.scribe.unIndent();
			}			
		}
		if (this.preferences.insert_new_line_before_closing_brace_in_array_initializer) {
			this.scribe.printNewLine();
		}
		this.scribe.printNextToken(TerminalTokens.TokenNameRBRACE, this.preferences.insert_space_before_closing_brace_in_array_initializer, true); 
		if (array_initializer_brace_position.equals(DefaultCodeFormatterConstants.NEXT_LINE_SHIFTED)) {
			this.scribe.unIndent();
		}	
	
		if (numberOfParens > 0) {
			manageClosingParenthesizedExpression(arrayInitializer, numberOfParens);
		}
	}


]