[Instance #
frags: 
(startLine=173 endLine=227 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java)
    public void finish(int docCount) throws IOException {
      final IndexOutput datOut = getDataOut();
      boolean success = false;
      try {
        final int size = hash.size();
        final BytesRef bytesRef = new BytesRef();
        for (int i = 0; i < size; i++) {
          hash.get(i, bytesRef);
          writePrefixLength(datOut, bytesRef);
          datOut.writeBytes(bytesRef.bytes, bytesRef.offset, bytesRef.length);
        }
        success = true;
      } finally {
        hash.close();
        if (success) {
          IOUtils.close(datOut);
        } else {
          IOUtils.closeWhileHandlingException(datOut);
        }
      }
      
      final IndexOutput idxOut = getIndexOut();
      success = false;
      try {
        idxOut.writeInt(address - 1);
        // write index
        // TODO(simonw): -- allow forcing fixed array (not -1)
        // TODO(simonw): check the address calculation / make it more intuitive
        final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount,
            PackedInts.bitsRequired(address - 1));
        final int limit;
        if (docCount > docToAddress.length) {
          limit = docToAddress.length;
        } else {
          limit = docCount;
        }
        for (int i = 0; i < limit; i++) {
          w.add(docToAddress[i]);
        }
        for (int i = limit; i < docCount; i++) {
          w.add(0);
        }
        w.finish();
        success = true;
      } finally {
        if (success) {
          IOUtils.close(idxOut);
        } else {
          IOUtils.closeWhileHandlingException(idxOut);
        }
        bytesUsed.addAndGet(RamUsageEstimator.NUM_BYTES_INT
            * (-docToAddress.length));
        docToAddress = null;
      }
    }

(startLine=100 endLine=150 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java)
    public void finish(int docCount) throws IOException {
      boolean success = false;
      final int numValues = hash.size();
      final IndexOutput datOut = getDataOut();
      try {
        datOut.writeInt(size);
        if (size != -1) {
          final BytesRef bytesRef = new BytesRef(size);
          for (int i = 0; i < numValues; i++) {
            hash.get(i, bytesRef);
            datOut.writeBytes(bytesRef.bytes, bytesRef.offset, bytesRef.length);
          }
        }
        success = true;
      } finally {
        if (success) {
          IOUtils.close(datOut);
        } else {
          IOUtils.closeWhileHandlingException(datOut);
        }
        hash.close();
      }
      success = false;
      final IndexOutput idxOut = getIndexOut();
      try {
        final int count = 1 + numValues;
        idxOut.writeInt(count - 1);
        // write index
        final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount,
            PackedInts.bitsRequired(count - 1));
        final int limit = docCount > docToID.length ? docToID.length : docCount;
        for (int i = 0; i < limit; i++) {
          w.add(docToID[i]);
        }
        // fill up remaining doc with zeros
        for (int i = limit; i < docCount; i++) {
          w.add(0);
        }
        w.finish();
        success = true;
      } finally {
        if (success) {
          IOUtils.close(idxOut);
        } else {
          IOUtils.closeWhileHandlingException(idxOut);
        }
        bytesUsed
            .addAndGet((-docToID.length) * RamUsageEstimator.NUM_BYTES_INT);
        docToID = null;
      }
    }

commonMethod: 
(startLine=443 endLine=458 srcPath=/home/sonia/NewExperiment/luceneFilter/01155/lucene/src/java/org/apache/lucene/index/values/Bytes.java)
    protected IndexOutput getOrCreateIndexOut() throws IOException {
      boolean success = false;
      try {
        if (idxOut == null) {
          idxOut = dir.createOutput(IndexFileNames.segmentFileName(id, "",
              INDEX_EXTENSION), context);
          CodecUtil.writeHeader(idxOut, codecName, version);
        }
        success = true;
      } finally {
        if (!success) {
          IOUtils.closeWhileHandlingException(idxOut);
        }
      }
      return idxOut;
    }


, Instance #
frags: 
(startLine=173 endLine=227 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java)
    public void finish(int docCount) throws IOException {
      final IndexOutput datOut = getDataOut();
      boolean success = false;
      try {
        final int size = hash.size();
        final BytesRef bytesRef = new BytesRef();
        for (int i = 0; i < size; i++) {
          hash.get(i, bytesRef);
          writePrefixLength(datOut, bytesRef);
          datOut.writeBytes(bytesRef.bytes, bytesRef.offset, bytesRef.length);
        }
        success = true;
      } finally {
        hash.close();
        if (success) {
          IOUtils.close(datOut);
        } else {
          IOUtils.closeWhileHandlingException(datOut);
        }
      }
      
      final IndexOutput idxOut = getIndexOut();
      success = false;
      try {
        idxOut.writeInt(address - 1);
        // write index
        // TODO(simonw): -- allow forcing fixed array (not -1)
        // TODO(simonw): check the address calculation / make it more intuitive
        final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount,
            PackedInts.bitsRequired(address - 1));
        final int limit;
        if (docCount > docToAddress.length) {
          limit = docToAddress.length;
        } else {
          limit = docCount;
        }
        for (int i = 0; i < limit; i++) {
          w.add(docToAddress[i]);
        }
        for (int i = limit; i < docCount; i++) {
          w.add(0);
        }
        w.finish();
        success = true;
      } finally {
        if (success) {
          IOUtils.close(idxOut);
        } else {
          IOUtils.closeWhileHandlingException(idxOut);
        }
        bytesUsed.addAndGet(RamUsageEstimator.NUM_BYTES_INT
            * (-docToAddress.length));
        docToAddress = null;
      }
    }

(startLine=100 endLine=150 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java)
    public void finish(int docCount) throws IOException {
      boolean success = false;
      final int numValues = hash.size();
      final IndexOutput datOut = getDataOut();
      try {
        datOut.writeInt(size);
        if (size != -1) {
          final BytesRef bytesRef = new BytesRef(size);
          for (int i = 0; i < numValues; i++) {
            hash.get(i, bytesRef);
            datOut.writeBytes(bytesRef.bytes, bytesRef.offset, bytesRef.length);
          }
        }
        success = true;
      } finally {
        if (success) {
          IOUtils.close(datOut);
        } else {
          IOUtils.closeWhileHandlingException(datOut);
        }
        hash.close();
      }
      success = false;
      final IndexOutput idxOut = getIndexOut();
      try {
        final int count = 1 + numValues;
        idxOut.writeInt(count - 1);
        // write index
        final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount,
            PackedInts.bitsRequired(count - 1));
        final int limit = docCount > docToID.length ? docToID.length : docCount;
        for (int i = 0; i < limit; i++) {
          w.add(docToID[i]);
        }
        // fill up remaining doc with zeros
        for (int i = limit; i < docCount; i++) {
          w.add(0);
        }
        w.finish();
        success = true;
      } finally {
        if (success) {
          IOUtils.close(idxOut);
        } else {
          IOUtils.closeWhileHandlingException(idxOut);
        }
        bytesUsed
            .addAndGet((-docToID.length) * RamUsageEstimator.NUM_BYTES_INT);
        docToID = null;
      }
    }

commonMethod: 
(startLine=418 endLine=433 srcPath=/home/sonia/NewExperiment/luceneFilter/01155/lucene/src/java/org/apache/lucene/index/values/Bytes.java)
    protected IndexOutput getOrCreateDataOut() throws IOException {
      if (datOut == null) {
        boolean success = false;
        try {
          datOut = dir.createOutput(IndexFileNames.segmentFileName(id, "",
              DATA_EXTENSION), context);
          CodecUtil.writeHeader(datOut, codecName, version);
          success = true;
        } finally {
          if (!success) {
            IOUtils.closeWhileHandlingException(datOut);
          }
        }
      }
      return datOut;
    }


, Instance #
frags: 
(startLine=176 endLine=185 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java)
      try {
        final int size = hash.size();
        final BytesRef bytesRef = new BytesRef();
        for (int i = 0; i < size; i++) {
          hash.get(i, bytesRef);
          writePrefixLength(datOut, bytesRef);
          datOut.writeBytes(bytesRef.bytes, bytesRef.offset, bytesRef.length);
        }
        success = true;
      } finally {

(startLine=104 endLine=114 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java)
      try {
        datOut.writeInt(size);
        if (size != -1) {
          final BytesRef bytesRef = new BytesRef(size);
          for (int i = 0; i < numValues; i++) {
            hash.get(i, bytesRef);
            datOut.writeBytes(bytesRef.bytes, bytesRef.offset, bytesRef.length);
          }
        }
        success = true;
      } finally {

commonMethod: 
(startLine=443 endLine=458 srcPath=/home/sonia/NewExperiment/luceneFilter/01155/lucene/src/java/org/apache/lucene/index/values/Bytes.java)
    protected IndexOutput getOrCreateIndexOut() throws IOException {
      boolean success = false;
      try {
        if (idxOut == null) {
          idxOut = dir.createOutput(IndexFileNames.segmentFileName(id, "",
              INDEX_EXTENSION), context);
          CodecUtil.writeHeader(idxOut, codecName, version);
        }
        success = true;
      } finally {
        if (!success) {
          IOUtils.closeWhileHandlingException(idxOut);
        }
      }
      return idxOut;
    }


, Instance #
frags: 
(startLine=176 endLine=185 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java)
      try {
        final int size = hash.size();
        final BytesRef bytesRef = new BytesRef();
        for (int i = 0; i < size; i++) {
          hash.get(i, bytesRef);
          writePrefixLength(datOut, bytesRef);
          datOut.writeBytes(bytesRef.bytes, bytesRef.offset, bytesRef.length);
        }
        success = true;
      } finally {

(startLine=104 endLine=114 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java)
      try {
        datOut.writeInt(size);
        if (size != -1) {
          final BytesRef bytesRef = new BytesRef(size);
          for (int i = 0; i < numValues; i++) {
            hash.get(i, bytesRef);
            datOut.writeBytes(bytesRef.bytes, bytesRef.offset, bytesRef.length);
          }
        }
        success = true;
      } finally {

commonMethod: 
(startLine=418 endLine=433 srcPath=/home/sonia/NewExperiment/luceneFilter/01155/lucene/src/java/org/apache/lucene/index/values/Bytes.java)
    protected IndexOutput getOrCreateDataOut() throws IOException {
      if (datOut == null) {
        boolean success = false;
        try {
          datOut = dir.createOutput(IndexFileNames.segmentFileName(id, "",
              DATA_EXTENSION), context);
          CodecUtil.writeHeader(datOut, codecName, version);
          success = true;
        } finally {
          if (!success) {
            IOUtils.closeWhileHandlingException(datOut);
          }
        }
      }
      return datOut;
    }


, Instance #
frags: 
(startLine=196 endLine=217 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java)
      try {
        idxOut.writeInt(address - 1);
        // write index
        // TODO(simonw): -- allow forcing fixed array (not -1)
        // TODO(simonw): check the address calculation / make it more intuitive
        final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount,
            PackedInts.bitsRequired(address - 1));
        final int limit;
        if (docCount > docToAddress.length) {
          limit = docToAddress.length;
        } else {
          limit = docCount;
        }
        for (int i = 0; i < limit; i++) {
          w.add(docToAddress[i]);
        }
        for (int i = limit; i < docCount; i++) {
          w.add(0);
        }
        w.finish();
        success = true;
      } finally {

(startLine=124 endLine=140 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java)
      try {
        final int count = 1 + numValues;
        idxOut.writeInt(count - 1);
        // write index
        final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount,
            PackedInts.bitsRequired(count - 1));
        final int limit = docCount > docToID.length ? docToID.length : docCount;
        for (int i = 0; i < limit; i++) {
          w.add(docToID[i]);
        }
        // fill up remaining doc with zeros
        for (int i = limit; i < docCount; i++) {
          w.add(0);
        }
        w.finish();
        success = true;
      } finally {

commonMethod: 
(startLine=443 endLine=458 srcPath=/home/sonia/NewExperiment/luceneFilter/01155/lucene/src/java/org/apache/lucene/index/values/Bytes.java)
    protected IndexOutput getOrCreateIndexOut() throws IOException {
      boolean success = false;
      try {
        if (idxOut == null) {
          idxOut = dir.createOutput(IndexFileNames.segmentFileName(id, "",
              INDEX_EXTENSION), context);
          CodecUtil.writeHeader(idxOut, codecName, version);
        }
        success = true;
      } finally {
        if (!success) {
          IOUtils.closeWhileHandlingException(idxOut);
        }
      }
      return idxOut;
    }


, Instance #
frags: 
(startLine=196 endLine=217 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java)
      try {
        idxOut.writeInt(address - 1);
        // write index
        // TODO(simonw): -- allow forcing fixed array (not -1)
        // TODO(simonw): check the address calculation / make it more intuitive
        final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount,
            PackedInts.bitsRequired(address - 1));
        final int limit;
        if (docCount > docToAddress.length) {
          limit = docToAddress.length;
        } else {
          limit = docCount;
        }
        for (int i = 0; i < limit; i++) {
          w.add(docToAddress[i]);
        }
        for (int i = limit; i < docCount; i++) {
          w.add(0);
        }
        w.finish();
        success = true;
      } finally {

(startLine=124 endLine=140 srcPath=/home/sonia/NewExperiment/luceneFilter/01154/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java)
      try {
        final int count = 1 + numValues;
        idxOut.writeInt(count - 1);
        // write index
        final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount,
            PackedInts.bitsRequired(count - 1));
        final int limit = docCount > docToID.length ? docToID.length : docCount;
        for (int i = 0; i < limit; i++) {
          w.add(docToID[i]);
        }
        // fill up remaining doc with zeros
        for (int i = limit; i < docCount; i++) {
          w.add(0);
        }
        w.finish();
        success = true;
      } finally {

commonMethod: 
(startLine=418 endLine=433 srcPath=/home/sonia/NewExperiment/luceneFilter/01155/lucene/src/java/org/apache/lucene/index/values/Bytes.java)
    protected IndexOutput getOrCreateDataOut() throws IOException {
      if (datOut == null) {
        boolean success = false;
        try {
          datOut = dir.createOutput(IndexFileNames.segmentFileName(id, "",
              DATA_EXTENSION), context);
          CodecUtil.writeHeader(datOut, codecName, version);
          success = true;
        } finally {
          if (!success) {
            IOUtils.closeWhileHandlingException(datOut);
          }
        }
      }
      return datOut;
    }


, Instance #
frags: 
(startLine=75 endLine=88 srcPath=/home/sonia/NewExperiment/luceneFilter/01163/lucene/src/java/org/apache/lucene/index/values/IndexDocValuesArray.java)
    if (isFloat) {
      return new SourceEnum(attrSource, type(), this, maxDocID + 1) {

        @Override
        public int advance(int target) throws IOException {
          if (target >= numDocs) {
            return pos = NO_MORE_DOCS;
          }
          floatsRef.floats[intsRef.offset] = IndexDocValuesArray.this
              .getFloat(target);
          return pos = target;
        }
      };
    } else {

(startLine=88 endLine=102 srcPath=/home/sonia/NewExperiment/luceneFilter/01163/lucene/src/java/org/apache/lucene/index/values/IndexDocValuesArray.java)
    } else {
      return new SourceEnum(attrSource, type(), this, maxDocID + 1) {

        @Override
        public int advance(int target) throws IOException {
          if (target >= numDocs) {
            return pos = NO_MORE_DOCS;
          }
          intsRef.ints[intsRef.offset] = IndexDocValuesArray.this
              .getInt(target);
          return pos = target;
        }

      };
    }

commonMethod: 
(startLine=256 endLine=269 srcPath=/home/sonia/NewExperiment/luceneFilter/01164/lucene/src/java/org/apache/lucene/util/BytesRef.java)
  /**
   * Copies the given long value and encodes it as 8 byte Big-Endian.
   * <p>
   * NOTE: this method resets the offset to 0, length to 8 and resizes the reference array
   * if needed.
   */
  public void copy(long value) {
    if (bytes.length < 8) {
      bytes = new byte[8];
    }
    copyInternal((int) (value >> 32), offset = 0);
    copyInternal((int) value, 4);
    length = 8;
  }


, Instance #
frags: 
(startLine=193 endLine=214 srcPath=/home/sonia/NewExperiment/luceneFilter/01267/lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java)
    public void put(IndexReader reader, Entry key, Object value) {
      final Object readerKey = reader.getCoreCacheKey();
      synchronized (readerCache) {
        Map<Entry,Object> innerCache = readerCache.get(readerKey);
        if (innerCache == null) {
          // First time this reader is using FieldCache
          innerCache = new HashMap<Entry,Object>();
          readerCache.put(readerKey, innerCache);
          if (reader instanceof SegmentReader) {
            ((SegmentReader) reader).addCoreClosedListener(wrapper.purgeCore);
          } else {
            reader.addReaderClosedListener(wrapper.purgeReader);
          }
        }
        if (innerCache.get(key) == null) {
          innerCache.put(key, value);
        } else {
          // Another thread beat us to it; leave the current
          // value
        }
      }
    }

(startLine=220 endLine=239 srcPath=/home/sonia/NewExperiment/luceneFilter/01267/lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      synchronized (readerCache) {
        innerCache = readerCache.get(readerKey);
        if (innerCache == null) {
          // First time this reader is using FieldCache
          innerCache = new HashMap<Entry,Object>();
          readerCache.put(readerKey, innerCache);
          if (reader instanceof SegmentReader) {
            ((SegmentReader) reader).addCoreClosedListener(wrapper.purgeCore);
          } else {
            reader.addReaderClosedListener(wrapper.purgeReader);           
          }
          value = null;
        } else {
          value = innerCache.get(key);
        }
        if (value == null) {
          value = new CreationPlaceholder();
          innerCache.put(key, value);
        }
      }

commonMethod: 
(startLine=165 endLine=181 srcPath=/home/sonia/NewExperiment/luceneFilter/01268/lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java)
  private void initReader(IndexReader reader) {
    if (reader instanceof SegmentReader) {
      ((SegmentReader) reader).addCoreClosedListener(purgeCore);
    } else if (reader.getSequentialSubReaders() != null) {
      throw new UnsupportedOperationException("Please use SlowMultiReaderWrapper, if you really need a top level FieldCache");
    } else {
      // we have a slow reader of some sort, try to register a purge event
      // rather than relying on gc:
      Object key = reader.getCoreCacheKey();
      if (key instanceof IndexReader) {
        ((IndexReader)key).addReaderClosedListener(purgeReader); 
      } else {
        // last chance
        reader.addReaderClosedListener(purgeReader);                 
      }
    }
  }


, Instance #
frags: 
(startLine=1241 endLine=1267 srcPath=/home/sonia/NewExperiment/luceneFilter/01278/solr/core/src/java/org/apache/solr/core/SolrCore.java)
      if (currSearcher==null && firstSearcherListeners.size() > 0) {
        try {
          future = searcherExecutor.submit(
                  new Callable() {
                    public Object call() throws Exception {
                      try {
                        for (SolrEventListener listener : firstSearcherListeners) {
                          listener.newSearcher(newSearcher,null);
                        }
                      } catch (Throwable e) {
                        SolrException.log(log, null, e);
                      }
                      return null;
                    }
                  }
          );
        } catch(Exception e) {
          // if submit fails, newSearchHolder does not get decref'd
          if (newSearchHolder != null) {
            newSearchHolder.decref();
            if (returnSearcher) {
              newSearchHolder.decref();
            }
          }
          throw e;
        }
      }

(startLine=1269 endLine=1295 srcPath=/home/sonia/NewExperiment/luceneFilter/01278/solr/core/src/java/org/apache/solr/core/SolrCore.java)
      if (currSearcher!=null && newSearcherListeners.size() > 0) {
        try {
          future = searcherExecutor.submit(
                  new Callable() {
                    public Object call() throws Exception {
                      try {
                        for (SolrEventListener listener : newSearcherListeners) {
                          listener.newSearcher(newSearcher, currSearcher);
                        }
                      } catch (Throwable e) {
                        SolrException.log(log, null, e);
                      }
                      return null;
                    }
                  }
          );
      } catch(Exception e) {
        // if submit fails, newSearchHolder does not get decref'd
        if (newSearchHolder != null) {
          newSearchHolder.decref();
          if (returnSearcher) {
            newSearchHolder.decref();
          }
        }
        throw e;
      }
      }

(startLine=1215 endLine=1239 srcPath=/home/sonia/NewExperiment/luceneFilter/01278/solr/core/src/java/org/apache/solr/core/SolrCore.java)
      if (currSearcher != null) {
        try {
          future = searcherExecutor.submit(
                  new Callable() {
                    public Object call() throws Exception {
                      try {
                        newSearcher.warm(currSearcher);
                      } catch (Throwable e) {
                        SolrException.log(log, null, e);
                      }
                      return null;
                    }
                  }
          );
        } catch(Exception e) {
          // if submit fails, newSearchHolder does not get decref'd
          if (newSearchHolder != null) {
            newSearchHolder.decref();
            if (returnSearcher) {
              newSearchHolder.decref();
            }
          }
          throw e;
        }
      }

commonMethod: 
(startLine=1038 endLine=1139 srcPath=/home/sonia/NewExperiment/luceneFilter/01279/solr/core/src/java/org/apache/solr/core/SolrCore.java)
  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.
   *
   * "realtime" means that we need to open quickly for a realtime view of the index, hence don't do any
   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't
   * be used for autowarming by a future normal searcher).  A "realtime" searcher will currently never
   * become "registered" (since it currently lacks caching).
   *
   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of "realtime".
   *
   * This method aquires openSearcherLock - do not call with searckLock held!
   */
  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {
    SolrIndexSearcher tmp;
    RefCounted<SolrIndexSearcher> newestSearcher = null;
    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;

    openSearcherLock.lock();
    try {
      String newIndexDir = null;
      File indexDirFile = null;
      File newIndexDirFile = null;

      // if it's not a normal near-realtime update, check that paths haven't changed.
      if (!nrt) {
        indexDirFile = new File(getIndexDir()).getCanonicalFile();
        newIndexDir = getNewIndexDir();
        newIndexDirFile = new File(newIndexDir).getCanonicalFile();
      }

      synchronized (searcherLock) {
        newestSearcher = realtimeSearcher;
        if (newestSearcher != null) {
          newestSearcher.incref();      // the matching decref is in the finally block
        }
      }

      if (newestSearcher != null && solrConfig.reopenReaders
          && (nrt || indexDirFile.equals(newIndexDirFile))) {

        IndexReader newReader;
        IndexReader currentReader = newestSearcher.get().getIndexReader();

        if (updateHandlerReopens) {
          // SolrCore.verbose("start reopen from",previousSearcher,"writer=",writer);
          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);
          newReader = IndexReader.openIfChanged(currentReader, writer, true);

        } else {
          // verbose("start reopen without writer, reader=", currentReader);
          newReader = IndexReader.openIfChanged(currentReader);
          // verbose("reopen result", newReader);
        }

        if (newReader == null) {
          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.
          if (realtime) {
            newestSearcher.incref();
            return newestSearcher;
          }

          currentReader.incRef();
          newReader = currentReader;
        }

       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)
        tmp = new SolrIndexSearcher(this, schema, (realtime ? "realtime":"main"), newReader, true, !realtime, true, directoryFactory);

      } else {
        // verbose("non-reopen START:");
        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, "main", true, directoryFactory);
        // verbose("non-reopen DONE: searcher=",tmp);
      }

      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;
      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1

      // Increment reference again for "realtimeSearcher" variable.  It should be at 2 after.
      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,
      // it will be closed.
      newSearcher.incref();

      synchronized (searcherLock) {
        if (realtimeSearcher != null) {
          realtimeSearcher.decref();
        }
        realtimeSearcher = newSearcher;
        searcherList.add(realtimeSearcher);
      }

      return newSearcher;

    } catch (Exception e) {
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Error opening new searcher", e);
    }
    finally {
      openSearcherLock.unlock();
      if (newestSearcher != null) {
        newestSearcher.decref();
      }
    }

  }


, Instance #
frags: 
(startLine=1242 endLine=1257 srcPath=/home/sonia/NewExperiment/luceneFilter/01278/solr/core/src/java/org/apache/solr/core/SolrCore.java)
        try {
          future = searcherExecutor.submit(
                  new Callable() {
                    public Object call() throws Exception {
                      try {
                        for (SolrEventListener listener : firstSearcherListeners) {
                          listener.newSearcher(newSearcher,null);
                        }
                      } catch (Throwable e) {
                        SolrException.log(log, null, e);
                      }
                      return null;
                    }
                  }
          );
        } catch(Exception e) {

(startLine=1270 endLine=1285 srcPath=/home/sonia/NewExperiment/luceneFilter/01278/solr/core/src/java/org/apache/solr/core/SolrCore.java)
        try {
          future = searcherExecutor.submit(
                  new Callable() {
                    public Object call() throws Exception {
                      try {
                        for (SolrEventListener listener : newSearcherListeners) {
                          listener.newSearcher(newSearcher, currSearcher);
                        }
                      } catch (Throwable e) {
                        SolrException.log(log, null, e);
                      }
                      return null;
                    }
                  }
          );
      } catch(Exception e) {

commonMethod: 
(startLine=1038 endLine=1139 srcPath=/home/sonia/NewExperiment/luceneFilter/01279/solr/core/src/java/org/apache/solr/core/SolrCore.java)
  /** Opens a new searcher and returns a RefCounted<SolrIndexSearcher> with it's reference incremented.
   *
   * "realtime" means that we need to open quickly for a realtime view of the index, hence don't do any
   * autowarming and add to the _realtimeSearchers queue rather than the _searchers queue (so it won't
   * be used for autowarming by a future normal searcher).  A "realtime" searcher will currently never
   * become "registered" (since it currently lacks caching).
   *
   * realtimeSearcher is updated to the latest opened searcher, regardless of the value of "realtime".
   *
   * This method aquires openSearcherLock - do not call with searckLock held!
   */
  public RefCounted<SolrIndexSearcher> openNewSearcher(boolean updateHandlerReopens, boolean realtime) {
    SolrIndexSearcher tmp;
    RefCounted<SolrIndexSearcher> newestSearcher = null;
    boolean nrt = solrConfig.reopenReaders && updateHandlerReopens;

    openSearcherLock.lock();
    try {
      String newIndexDir = null;
      File indexDirFile = null;
      File newIndexDirFile = null;

      // if it's not a normal near-realtime update, check that paths haven't changed.
      if (!nrt) {
        indexDirFile = new File(getIndexDir()).getCanonicalFile();
        newIndexDir = getNewIndexDir();
        newIndexDirFile = new File(newIndexDir).getCanonicalFile();
      }

      synchronized (searcherLock) {
        newestSearcher = realtimeSearcher;
        if (newestSearcher != null) {
          newestSearcher.incref();      // the matching decref is in the finally block
        }
      }

      if (newestSearcher != null && solrConfig.reopenReaders
          && (nrt || indexDirFile.equals(newIndexDirFile))) {

        IndexReader newReader;
        IndexReader currentReader = newestSearcher.get().getIndexReader();

        if (updateHandlerReopens) {
          // SolrCore.verbose("start reopen from",previousSearcher,"writer=",writer);
          IndexWriter writer = getUpdateHandler().getSolrCoreState().getIndexWriter(this);
          newReader = IndexReader.openIfChanged(currentReader, writer, true);

        } else {
          // verbose("start reopen without writer, reader=", currentReader);
          newReader = IndexReader.openIfChanged(currentReader);
          // verbose("reopen result", newReader);
        }

        if (newReader == null) {
          // if this is a request for a realtime searcher, just return the same searcher if there haven't been any changes.
          if (realtime) {
            newestSearcher.incref();
            return newestSearcher;
          }

          currentReader.incRef();
          newReader = currentReader;
        }

       // for now, turn off caches if this is for a realtime reader (caches take a little while to instantiate)
        tmp = new SolrIndexSearcher(this, schema, (realtime ? "realtime":"main"), newReader, true, !realtime, true, directoryFactory);

      } else {
        // verbose("non-reopen START:");
        tmp = new SolrIndexSearcher(this, newIndexDir, schema, getSolrConfig().mainIndexConfig, "main", true, directoryFactory);
        // verbose("non-reopen DONE: searcher=",tmp);
      }

      List<RefCounted<SolrIndexSearcher>> searcherList = realtime ? _realtimeSearchers : _searchers;
      RefCounted<SolrIndexSearcher> newSearcher = newHolder(tmp, searcherList);    // refcount now at 1

      // Increment reference again for "realtimeSearcher" variable.  It should be at 2 after.
      // When it's decremented by both the caller of this method, and by realtimeSearcher being replaced,
      // it will be closed.
      newSearcher.incref();

      synchronized (searcherLock) {
        if (realtimeSearcher != null) {
          realtimeSearcher.decref();
        }
        realtimeSearcher = newSearcher;
        searcherList.add(realtimeSearcher);
      }

      return newSearcher;

    } catch (Exception e) {
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Error opening new searcher", e);
    }
    finally {
      openSearcherLock.unlock();
      if (newestSearcher != null) {
        newestSearcher.decref();
      }
    }

  }


, Instance #
frags: 
(startLine=264 endLine=274 srcPath=/home/sonia/NewExperiment/luceneFilter/01278/solr/core/src/test/org/apache/solr/search/TestRealTimeGet.java)
              if (oper < commitPercent + deletePercent) {
                if (VERBOSE) {
                  verbose("deleting id",id,"val=",nextVal);
                }

                assertU("<delete><id>" + id + "</id></delete>");
                model.put(id, -nextVal);
                if (VERBOSE) {
                  verbose("deleting id", id, "val=",nextVal,"DONE");
                }
              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {

(startLine=274 endLine=284 srcPath=/home/sonia/NewExperiment/luceneFilter/01278/solr/core/src/test/org/apache/solr/search/TestRealTimeGet.java)
              } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {
                if (VERBOSE) {
                  verbose("deleteByQuery id ",id, "val=",nextVal);
                }

                assertU("<delete><query>id:" + id + "</query></delete>");
                model.put(id, -nextVal);
                if (VERBOSE) {
                  verbose("deleteByQuery id",id, "val=",nextVal,"DONE");
                }
              } else {

commonMethod: 
(startLine=266 endLine=278 srcPath=/home/sonia/NewExperiment/luceneFilter/01279/solr/core/src/test/org/apache/solr/search/TestRealTimeGet.java)
  private void initModel(int ndocs) {
    snapshotCount = 0;
    committedModelClock = 0;
    lastId = 0;

    syncArr = new Object[ndocs];

    for (int i=0; i<ndocs; i++) {
      model.put(i, new DocInfo(0, -1L));
      syncArr[i] = new Object();
    }
    committedModel.putAll(model);
  }


, Instance #
frags: 
(startLine=66 endLine=129 srcPath=/home/sonia/NewExperiment/luceneFilter/01305/solr/core/src/java/org/apache/solr/search/grouping/distributed/requestfactory/TopGroupsShardRequestFactory.java)
  private ShardRequest[] createRequestForSpecificShards(ResponseBuilder rb) {
    // Determine all unique shards to query for TopGroups
    Set<String> shards = new HashSet<String>();
    for (String command : rb.searchGroupToShard.keySet()) {
      Map<SearchGroup<BytesRef>, String> groupsToShard = rb.searchGroupToShard.get(command);
      shards.addAll(groupsToShard.values());
    }

    ShardRequest[] sreqs = new ShardRequest[shards.size()];
    int i = 0;
    for (String shard : shards) {
      ShardRequest sreq = new ShardRequest();
      sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;
      sreq.actualShards = new String[] {shard};
      sreq.params = new ModifiableSolrParams(rb.req.getParams());

      // If group.format=simple group.offset doesn't make sense
      Grouping.Format responseFormat = rb.getGroupingSpec().getResponseFormat();
      if (responseFormat == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {
        sreq.params.remove(GroupParams.GROUP_OFFSET);
      }

      sreq.params.remove(ShardParams.SHARDS);

      // set the start (offset) to 0 for each shard request so we can properly merge
      // results from the start.
      if(rb.shards_start > -1) {
        // if the client set shards.start set this explicitly
        sreq.params.set(CommonParams.START,rb.shards_start);
      } else {
        sreq.params.set(CommonParams.START, "0");
      }
      if(rb.shards_rows > -1) {
        // if the client set shards.rows set this explicity
        sreq.params.set(CommonParams.ROWS,rb.shards_rows);
      } else {
        sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());
      }

      sreq.params.set("group.distibuted.second","true");
      for (Map.Entry<String, Collection<SearchGroup<BytesRef>>> entry : rb.mergedSearchGroups.entrySet()) {
        for (SearchGroup<BytesRef> searchGroup : entry.getValue()) {
          String groupValue;
          if (searchGroup.groupValue != null) {
            String rawGroupValue = searchGroup.groupValue.utf8ToString();
            FieldType fieldType = rb.req.getSearcher().getSchema().getField(entry.getKey()).getType();
            groupValue = fieldType.indexedToReadable(rawGroupValue);
          } else {
            groupValue = GROUP_NULL_VALUE;
          }
          sreq.params.add("group.topgroups." + entry.getKey(), groupValue);
        }
      }

      if ((rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore()) {
        sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + ",score");
      } else {
        sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());
      }
      sreqs[i++] = sreq;
    }

    return sreqs;
  }

(startLine=131 endLine=180 srcPath=/home/sonia/NewExperiment/luceneFilter/01305/solr/core/src/java/org/apache/solr/search/grouping/distributed/requestfactory/TopGroupsShardRequestFactory.java)
  private ShardRequest[] createRequestForAllShards(ResponseBuilder rb) {
    ShardRequest sreq = new ShardRequest();
    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;

    sreq.params = new ModifiableSolrParams(rb.req.getParams());
    // If group.format=simple group.offset doesn't make sense
    Grouping.Format responseFormat = rb.getGroupingSpec().getResponseFormat();
    if (responseFormat == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {
      sreq.params.remove(GroupParams.GROUP_OFFSET);
    }
    sreq.params.remove(ShardParams.SHARDS);

    // set the start (offset) to 0 for each shard request so we can properly merge
    // results from the start.
    if(rb.shards_start > -1) {
      // if the client set shards.start set this explicitly
      sreq.params.set(CommonParams.START,rb.shards_start);
    } else {
      sreq.params.set(CommonParams.START, "0");
    }
    if(rb.shards_rows > -1) {
      // if the client set shards.rows set this explicity
      sreq.params.set(CommonParams.ROWS,rb.shards_rows);
    } else {
      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());
    }

    sreq.params.set("group.distibuted.second","true");
    for (Map.Entry<String, Collection<SearchGroup<BytesRef>>> entry : rb.mergedSearchGroups.entrySet()) {
      for (SearchGroup<BytesRef> searchGroup : entry.getValue()) {
        String groupValue;
        if (searchGroup.groupValue != null) {
         String rawGroupValue = searchGroup.groupValue.utf8ToString();
          FieldType fieldType = rb.req.getSearcher().getSchema().getField(entry.getKey()).getType();
          groupValue = fieldType.indexedToReadable(rawGroupValue);
        } else {
          groupValue = GROUP_NULL_VALUE;
        }
        sreq.params.add("group.topgroups." + entry.getKey(), groupValue);
      }
    }

    if ( (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES)!=0 || rb.getSortSpec().includesScore()) {
      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + ",score");
    } else {
      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());
    }

    return new ShardRequest[] {sreq};
  }

commonMethod: 
(startLine=83 endLine=135 srcPath=/home/sonia/NewExperiment/luceneFilter/01306/solr/core/src/java/org/apache/solr/search/grouping/distributed/requestfactory/TopGroupsShardRequestFactory.java)
  private ShardRequest[] createRequest(ResponseBuilder rb, String[] shards)
  {
    ShardRequest sreq = new ShardRequest();
    sreq.shards = shards;
    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;
    sreq.params = new ModifiableSolrParams(rb.req.getParams());

    // If group.format=simple group.offset doesn't make sense
    Grouping.Format responseFormat = rb.getGroupingSpec().getResponseFormat();
    if (responseFormat == Grouping.Format.simple || rb.getGroupingSpec().isMain()) {
      sreq.params.remove(GroupParams.GROUP_OFFSET);
    }

    sreq.params.remove(ShardParams.SHARDS);

    // set the start (offset) to 0 for each shard request so we can properly merge
    // results from the start.
    if (rb.shards_start > -1) {
      // if the client set shards.start set this explicitly
      sreq.params.set(CommonParams.START, rb.shards_start);
    } else {
      sreq.params.set(CommonParams.START, "0");
    }
    if (rb.shards_rows > -1) {
      // if the client set shards.rows set this explicity
      sreq.params.set(CommonParams.ROWS, rb.shards_rows);
    } else {
      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());
    }

    sreq.params.set("group.distributed.second", "true");
    for (Map.Entry<String, Collection<SearchGroup<BytesRef>>> entry : rb.mergedSearchGroups.entrySet()) {
      for (SearchGroup<BytesRef> searchGroup : entry.getValue()) {
        String groupValue;
        if (searchGroup.groupValue != null) {
          String rawGroupValue = searchGroup.groupValue.utf8ToString();
          FieldType fieldType = rb.req.getSearcher().getSchema().getField(entry.getKey()).getType();
          groupValue = fieldType.indexedToReadable(rawGroupValue);
        } else {
          groupValue = GROUP_NULL_VALUE;
        }
        sreq.params.add("group.topgroups." + entry.getKey(), groupValue);
      }
    }

    if ((rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore()) {
      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName() + ",score");
    } else {
      sreq.params.set(CommonParams.FL, rb.req.getSchema().getUniqueKeyField().getName());
    }

    return new ShardRequest[] {sreq};
  }


, Instance #
frags: 
(startLine=495 endLine=512 srcPath=/home/sonia/NewExperiment/luceneFilter/01378/modules/analysis/common/src/test/org/apache/lucene/analysis/charfilter/HTMLStripCharFilterTest.java)
  public void testRandom() throws Exception {
    Analyzer analyzer = new Analyzer() {

      @Override
      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
        Tokenizer tokenizer = new MockTokenizer(reader, MockTokenizer.WHITESPACE, false);
        return new TokenStreamComponents(tokenizer, tokenizer);
      }

      @Override
      protected Reader initReader(Reader reader) {
        return new HTMLStripCharFilter(CharReader.get(reader));
      }
    };
    
    int numRounds = RANDOM_MULTIPLIER * 10000;
    checkRandomData(random, analyzer, numRounds);
  }

(startLine=514 endLine=531 srcPath=/home/sonia/NewExperiment/luceneFilter/01378/modules/analysis/common/src/test/org/apache/lucene/analysis/charfilter/HTMLStripCharFilterTest.java)
  public void testRandomHugeStrings() throws Exception {
    Analyzer analyzer = new Analyzer() {

      @Override
      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
        Tokenizer tokenizer = new MockTokenizer(reader, MockTokenizer.WHITESPACE, false);
        return new TokenStreamComponents(tokenizer, tokenizer);
      }

      @Override
      protected Reader initReader(Reader reader) {
        return new HTMLStripCharFilter(CharReader.get(reader));
      }
    };
    
    int numRounds = RANDOM_MULTIPLIER * 200;
    checkRandomData(random, analyzer, numRounds, 8192);
  }

commonMethod: 
(startLine=39 endLine=52 srcPath=/home/sonia/NewExperiment/luceneFilter/01379/modules/analysis/common/src/test/org/apache/lucene/analysis/charfilter/HTMLStripCharFilterTest.java)
  static private Analyzer newTestAnalyzer() {
    return new Analyzer() {
      @Override
      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
        Tokenizer tokenizer = new MockTokenizer(reader, MockTokenizer.WHITESPACE, false);
        return new TokenStreamComponents(tokenizer, tokenizer);
      }

      @Override
      protected Reader initReader(Reader reader) {
        return new HTMLStripCharFilter(CharReader.get(reader));
      }
    };
  }


, Instance #
frags: 
(startLine=100 endLine=107 srcPath=/home/sonia/NewExperiment/luceneFilter/01392/solr/core/src/java/org/apache/solr/update/SolrIndexConfig.java)
    if(str != null && str.trim().length() >0){
      //legacy handling <mergeScheduler>[classname]</mergeScheduler>
      //remove in Solr2.0
      log.warn("deprecated syntax : <mergeScheduler>[classname]</mergeScheduler>");
      Map<String,String> atrs = new HashMap<String, String>();
      atrs.put("class",str.trim());
      mergeSchedulerInfo = new PluginInfo("mergeScheduler",atrs,null,null);
    } else {

(startLine=111 endLine=118 srcPath=/home/sonia/NewExperiment/luceneFilter/01392/solr/core/src/java/org/apache/solr/update/SolrIndexConfig.java)
    if(str != null && str.trim().length() >0){
      //legacy handling  <mergePolicy>[classname]</mergePolicy>
      //remove in Solr2.0
      log.warn("deprecated syntax : <mergePolicy>[classname]</mergePolicy>");
      Map<String,String> atrs = new HashMap<String, String>();
      atrs.put("class",str.trim());
      mergePolicyInfo = new PluginInfo("mergePolicy",atrs,null,null);
    } else {

commonMethod: 
(startLine=145 endLine=153 srcPath=/home/sonia/NewExperiment/luceneFilter/01393/solr/core/src/java/org/apache/solr/update/SolrIndexConfig.java)
  private void assertWarnOrFail(String reason, boolean assertCondition, boolean failCondition) {
    if(assertCondition) {
      return;
    } else if(failCondition) {
      throw new SolrException(ErrorCode.FORBIDDEN, reason);
    } else {
      log.warn(reason);
    }
  }


, Instance #
frags: 
(startLine=364 endLine=385 srcPath=/home/sonia/NewExperiment/luceneFilter/01420/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java)
  public void doFullImport(SolrWriter writer, RequestParams requestParams) {
    LOG.info("Starting Full Import");
    setStatus(Status.RUNNING_FULL_DUMP);

    setIndexStartTime(new Date());

    try {
      docBuilder = new DocBuilder(this, writer, propWriter, requestParams);
      checkWritablePersistFile(writer);
      docBuilder.execute();
      if (!requestParams.debug)
        cumulativeStatistics.add(docBuilder.importStatistics);
    } catch (Throwable t) {
      SolrException.log(LOG, "Full Import failed", t);
      docBuilder.rollback();
    } finally {
      setStatus(Status.IDLE);
      config.clearCaches();
      DocBuilder.INSTANCE.set(null);
    }

  }

(startLine=396 endLine=416 srcPath=/home/sonia/NewExperiment/luceneFilter/01420/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java)
  public void doDeltaImport(SolrWriter writer, RequestParams requestParams) {
    LOG.info("Starting Delta Import");
    setStatus(Status.RUNNING_DELTA_DUMP);

    try {
      setIndexStartTime(new Date());
      docBuilder = new DocBuilder(this, writer, propWriter, requestParams);
      checkWritablePersistFile(writer);
      docBuilder.execute();
      if (!requestParams.debug)
        cumulativeStatistics.add(docBuilder.importStatistics);
    } catch (Throwable t) {
      LOG.error("Delta Import Failed", t);
      docBuilder.rollback();
    } finally {
      setStatus(Status.IDLE);
      config.clearCaches();
      DocBuilder.INSTANCE.set(null);
    }

  }

commonMethod: 
(startLine=99 endLine=101 srcPath=/home/sonia/NewExperiment/luceneFilter/01421/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/RequestInfo.java)
  public boolean isDebug() {
    return debug;
  }


, Instance #
frags: 
(startLine=916 endLine=934 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // remember the remapping of this ordinal. Note how
            // this requires reading a posting list from the index -
            // but since we do this in lexical order of terms, just
            // like Lucene's merge works, we hope there are few seeks.
            // TODO (Facet): is there a quicker way? E.g., not specifying the
            // next term by name every time?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);
            // and move to the next category in the i'th taxonomy 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

(startLine=946 endLine=960 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // TODO (Facet): again, is there a quicker way?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);

            // and move to the next category 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

commonMethod: 
(startLine=969 endLine=975 srcPath=/home/sonia/NewExperiment/luceneFilter/01441/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
    @Override
    public void addDone() throws IOException {
      if (out!=null) {
        out.close();
        out = null;
      }
    }


, Instance #
frags: 
(startLine=916 endLine=934 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // remember the remapping of this ordinal. Note how
            // this requires reading a posting list from the index -
            // but since we do this in lexical order of terms, just
            // like Lucene's merge works, we hope there are few seeks.
            // TODO (Facet): is there a quicker way? E.g., not specifying the
            // next term by name every time?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);
            // and move to the next category in the i'th taxonomy 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

(startLine=946 endLine=960 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // TODO (Facet): again, is there a quicker way?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);

            // and move to the next category 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

commonMethod: 
(startLine=933 endLine=936 srcPath=/home/sonia/NewExperiment/luceneFilter/01441/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
    @Override
    public void addMapping(int origOrdinal, int newOrdinal) {
      map[origOrdinal] = newOrdinal;
    }


, Instance #
frags: 
(startLine=916 endLine=934 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // remember the remapping of this ordinal. Note how
            // this requires reading a posting list from the index -
            // but since we do this in lexical order of terms, just
            // like Lucene's merge works, we hope there are few seeks.
            // TODO (Facet): is there a quicker way? E.g., not specifying the
            // next term by name every time?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);
            // and move to the next category in the i'th taxonomy 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

(startLine=946 endLine=960 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // TODO (Facet): again, is there a quicker way?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);

            // and move to the next category 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

commonMethod: 
(startLine=958 endLine=962 srcPath=/home/sonia/NewExperiment/luceneFilter/01441/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
    @Override
    public void addMapping(int origOrdinal, int newOrdinal) throws IOException {
      out.writeInt(origOrdinal);
      out.writeInt(newOrdinal);
    }


, Instance #
frags: 
(startLine=916 endLine=934 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // remember the remapping of this ordinal. Note how
            // this requires reading a posting list from the index -
            // but since we do this in lexical order of terms, just
            // like Lucene's merge works, we hope there are few seeks.
            // TODO (Facet): is there a quicker way? E.g., not specifying the
            // next term by name every time?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);
            // and move to the next category in the i'th taxonomy 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

(startLine=946 endLine=960 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // TODO (Facet): again, is there a quicker way?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);

            // and move to the next category 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

commonMethod: 
(startLine=380 endLine=431 srcPath=/home/sonia/NewExperiment/luceneFilter/01441/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
  /**
   * Look up the given category in the cache and/or the on-disk storage,
   * returning the category's ordinal, or a negative number in case the
   * category does not yet exist in the taxonomy.
   */
  protected int findCategory(CategoryPath categoryPath) throws IOException {
    // If we can find the category in our cache, we can return the
    // response directly from it:
    int res = cache.get(categoryPath);
    if (res >= 0) {
      return res;
    }
    // If we know that the cache is complete, i.e., contains every category
    // which exists, we can return -1 immediately. However, if the cache is
    // not complete, we need to check the disk.
    if (cacheIsComplete) {
      return -1;
    }
    cacheMisses++;
    // After a few cache misses, it makes sense to read all the categories
    // from disk and into the cache. The reason not to do this on the first
    // cache miss (or even when opening the writer) is that it will
    // significantly slow down the case when a taxonomy is opened just to
    // add one category. The idea only spending a long time on reading
    // after enough time was spent on cache misses is known as a "online
    // algorithm".
    if (perhapsFillCache()) {
      return cache.get(categoryPath);
    }

    // We need to get an answer from the on-disk index. If a reader
    // is not yet open, do it now:
    if (reader == null) {
      reader = openReader();
    }

    // TODO (Facet): avoid Multi*?
    Bits liveDocs = MultiFields.getLiveDocs(reader);
    DocsEnum docs = MultiFields.getTermDocsEnum(reader, liveDocs, Consts.FULL, 
                                                new BytesRef(categoryPath.toString(delimiter)),
                                                false);
    if (docs == null || docs.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {
      return -1; // category does not exist in taxonomy
    }
    // Note: we do NOT add to the cache the fact that the category
    // does not exist. The reason is that our only use for this
    // method is just before we actually add this category. If
    // in the future this usage changes, we should consider caching
    // the fact that the category is not in the taxonomy.
    addToCache(categoryPath, docs.docID());
    return docs.docID();
  }


, Instance #
frags: 
(startLine=916 endLine=934 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // remember the remapping of this ordinal. Note how
            // this requires reading a posting list from the index -
            // but since we do this in lexical order of terms, just
            // like Lucene's merge works, we hope there are few seeks.
            // TODO (Facet): is there a quicker way? E.g., not specifying the
            // next term by name every time?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);
            // and move to the next category in the i'th taxonomy 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

(startLine=946 endLine=960 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // TODO (Facet): again, is there a quicker way?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);

            // and move to the next category 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

commonMethod: 
(startLine=473 endLine=518 srcPath=/home/sonia/NewExperiment/luceneFilter/01441/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/CategoryPath.java)
  /**
   * Add the given components to the end of the path. The components are given
   * in a single string, separated by a given delimiter character. If the
   * given string is empty, it is assumed to refer to the root (empty)
   * category, and nothing is added to the path (rather than adding a single
   * empty component).
   * <P>
   * Note that when a String object is passed to this method, a reference to
   * it is not saved (rather, its content is copied), which will lead to that
   * String object being gc'ed. To reduce the number of garbage objects, you
   * can pass a mutable CharBuffer instead of an immutable String to this
   * method.
   */
  public void add(CharSequence pathString, char delimiter) {
    int len = pathString.length();
    if (len == 0) {
      return; // assume root category meant, so add nothing.
    }
    short pos = (ncomponents == 0) ? 0 : ends[ncomponents - 1];
    for (int i = 0; i < len; i++) {
      char c = pathString.charAt(i);
      if (c == delimiter) {
        if (ncomponents >= ends.length) {
          short[] newends = new short[(ends.length + 1) * 2];
          System.arraycopy(ends, 0, newends, 0, ends.length);
          ends = newends;
        }
        ends[ncomponents++] = pos;
      } else {
        if (pos >= chars.length) {
          char[] newchars = new char[(chars.length + 1) * 2];
          System.arraycopy(chars, 0, newchars, 0, chars.length);
          chars = newchars;
        }
        chars[pos++] = c;
      }
    }

    // Don't forget to count the last component!
    if (ncomponents >= ends.length) {
      short[] newends = new short[(ends.length + 1) * 2];
      System.arraycopy(ends, 0, newends, 0, ends.length);
      ends = newends;
    }
    ends[ncomponents++] = pos;
  }


, Instance #
frags: 
(startLine=916 endLine=934 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // remember the remapping of this ordinal. Note how
            // this requires reading a posting list from the index -
            // but since we do this in lexical order of terms, just
            // like Lucene's merge works, we hope there are few seeks.
            // TODO (Facet): is there a quicker way? E.g., not specifying the
            // next term by name every time?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);
            // and move to the next category in the i'th taxonomy 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

(startLine=946 endLine=960 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // TODO (Facet): again, is there a quicker way?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);

            // and move to the next category 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

commonMethod: 
(startLine=470 endLine=487 srcPath=/home/sonia/NewExperiment/luceneFilter/01441/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
  @Override
  public synchronized int addCategory(CategoryPath categoryPath) throws IOException {
    ensureOpen();
    // If the category is already in the cache and/or the taxonomy, we
    // should return its existing ordinal:
    int res = findCategory(categoryPath);
    if (res < 0) {
      // This is a new category, and we need to insert it into the index
      // (and the cache). Actually, we might also need to add some of
      // the category's ancestors before we can add the category itself
      // (while keeping the invariant that a parent is always added to
      // the taxonomy before its child). internalAddCategory() does all
      // this recursively:
      res = internalAddCategory(categoryPath, categoryPath.length());
    }
    return res;

  }


, Instance #
frags: 
(startLine=916 endLine=934 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // remember the remapping of this ordinal. Note how
            // this requires reading a posting list from the index -
            // but since we do this in lexical order of terms, just
            // like Lucene's merge works, we hope there are few seeks.
            // TODO (Facet): is there a quicker way? E.g., not specifying the
            // next term by name every time?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);
            // and move to the next category in the i'th taxonomy 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

(startLine=946 endLine=960 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // TODO (Facet): again, is there a quicker way?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);

            // and move to the next category 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

commonMethod: 
(startLine=929 endLine=932 srcPath=/home/sonia/NewExperiment/luceneFilter/01441/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
    @Override
    public void setSize(int taxonomySize) {
      map = new int[taxonomySize];
    }


, Instance #
frags: 
(startLine=916 endLine=934 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // remember the remapping of this ordinal. Note how
            // this requires reading a posting list from the index -
            // but since we do this in lexical order of terms, just
            // like Lucene's merge works, we hope there are few seeks.
            // TODO (Facet): is there a quicker way? E.g., not specifying the
            // next term by name every time?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);
            // and move to the next category in the i'th taxonomy 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

(startLine=946 endLine=960 srcPath=/home/sonia/NewExperiment/luceneFilter/01440/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // TODO (Facet): again, is there a quicker way?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getLiveDocs(otherreaders[i]), otherdocsEnum[i], false);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);

            // and move to the next category 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }

commonMethod: 
(startLine=964 endLine=967 srcPath=/home/sonia/NewExperiment/luceneFilter/01441/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java)
    @Override
    public void setSize(int taxonomySize) throws IOException {
      out.writeInt(taxonomySize);
    }


, Instance #
frags: 
(startLine=757 endLine=793 srcPath=/home/sonia/NewExperiment/luceneFilter/01524/solr/core/src/java/org/apache/solr/core/CoreContainer.java)
  public SolrCore create(CoreDescriptor dcore)  throws ParserConfigurationException, IOException, SAXException {

    // :TODO: would be really nice if this method wrapped any underlying errors and only threw SolrException

    final String name = dcore.getName();
    Exception failure = null;
    try {
      // :nocommit: refactor doCreate completley into this method - only did it this way so patch would be straight forward w/o huge amounts of indenting changes

      SolrCore core = doCreate(dcore);
      coreInitFailures.remove(name);
      return core;

      // :TODO: Java7...
      // http://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.html
    } catch (ParserConfigurationException e1) {
      failure = e1;
      throw e1;
    } catch (IOException e2) {
      failure = e2;
      throw e2;
    } catch (SAXException e3) {
      failure = e3;
      throw e3;
    } catch (RuntimeException e4) {
      failure = e4;
      throw e4;
    } finally {
      if (null != failure) {
        synchronized (coreInitFailures) {
          // remove first so insertion order is updated and newest is last
          coreInitFailures.remove(name);
          coreInitFailures.put(name, failure);
        }
      }
    }
  }

(startLine=969 endLine=1003 srcPath=/home/sonia/NewExperiment/luceneFilter/01524/solr/core/src/java/org/apache/solr/core/CoreContainer.java)
  public void reload(String name) throws ParserConfigurationException, IOException, SAXException {

    // :TODO: would be really nice if this method wrapped any underlying errors and only threw SolrException

    Exception failure = null;
    try {
      // :nocommit: refactor doReload completley into this method - only did it this way so patch would be straight forward w/o huge amounts of indenting changes
      doReload(name);
      coreInitFailures.remove(name);
      return;

      // :TODO: Java7...
      // http://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.html
    } catch (ParserConfigurationException e1) {
      failure = e1;
      throw e1;
    } catch (IOException e2) {
      failure = e2;
      throw e2;
    } catch (SAXException e3) {
      failure = e3;
      throw e3;
    } catch (RuntimeException e4) {
      failure = e4;
      throw e4;
    } finally {
      if (null != failure) {
        synchronized (coreInitFailures) {
          // remove first so insertion order is updated and newest is last
          coreInitFailures.remove(name);
          coreInitFailures.put(name, failure);
        }
      }
    }
  }

commonMethod: 
(startLine=322 endLine=342 srcPath=/home/sonia/NewExperiment/luceneFilter/01525/solr/core/src/java/org/apache/solr/core/CoreContainer.java)
  static Properties getCoreProps(String instanceDir, String file, Properties defaults) {
    if(file == null) file = "conf"+File.separator+ "solrcore.properties";
    File corePropsFile = new File(file);
    if(!corePropsFile.isAbsolute()){
      corePropsFile = new File(instanceDir, file);
    }
    Properties p = defaults;
    if (corePropsFile.exists() && corePropsFile.isFile()) {
      p = new Properties(defaults);
      InputStream is = null;
      try {
        is = new FileInputStream(corePropsFile);
        p.load(is);
      } catch (IOException e) {
        log.warn("Error loading properties ",e);
      } finally{
        IOUtils.closeQuietly(is);        
      }
    }
    return p;
  }


, Instance #
frags: 
(startLine=757 endLine=793 srcPath=/home/sonia/NewExperiment/luceneFilter/01524/solr/core/src/java/org/apache/solr/core/CoreContainer.java)
  public SolrCore create(CoreDescriptor dcore)  throws ParserConfigurationException, IOException, SAXException {

    // :TODO: would be really nice if this method wrapped any underlying errors and only threw SolrException

    final String name = dcore.getName();
    Exception failure = null;
    try {
      // :nocommit: refactor doCreate completley into this method - only did it this way so patch would be straight forward w/o huge amounts of indenting changes

      SolrCore core = doCreate(dcore);
      coreInitFailures.remove(name);
      return core;

      // :TODO: Java7...
      // http://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.html
    } catch (ParserConfigurationException e1) {
      failure = e1;
      throw e1;
    } catch (IOException e2) {
      failure = e2;
      throw e2;
    } catch (SAXException e3) {
      failure = e3;
      throw e3;
    } catch (RuntimeException e4) {
      failure = e4;
      throw e4;
    } finally {
      if (null != failure) {
        synchronized (coreInitFailures) {
          // remove first so insertion order is updated and newest is last
          coreInitFailures.remove(name);
          coreInitFailures.put(name, failure);
        }
      }
    }
  }

(startLine=969 endLine=1003 srcPath=/home/sonia/NewExperiment/luceneFilter/01524/solr/core/src/java/org/apache/solr/core/CoreContainer.java)
  public void reload(String name) throws ParserConfigurationException, IOException, SAXException {

    // :TODO: would be really nice if this method wrapped any underlying errors and only threw SolrException

    Exception failure = null;
    try {
      // :nocommit: refactor doReload completley into this method - only did it this way so patch would be straight forward w/o huge amounts of indenting changes
      doReload(name);
      coreInitFailures.remove(name);
      return;

      // :TODO: Java7...
      // http://docs.oracle.com/javase/7/docs/technotes/guides/language/catch-multiple.html
    } catch (ParserConfigurationException e1) {
      failure = e1;
      throw e1;
    } catch (IOException e2) {
      failure = e2;
      throw e2;
    } catch (SAXException e3) {
      failure = e3;
      throw e3;
    } catch (RuntimeException e4) {
      failure = e4;
      throw e4;
    } finally {
      if (null != failure) {
        synchronized (coreInitFailures) {
          // remove first so insertion order is updated and newest is last
          coreInitFailures.remove(name);
          coreInitFailures.put(name, failure);
        }
      }
    }
  }

commonMethod: 
(startLine=446 endLine=475 srcPath=/home/sonia/NewExperiment/luceneFilter/01525/solr/core/src/java/org/apache/solr/cloud/ZkController.java)
  /**
   * @param collection
   * @return config value
   * @throws KeeperException
   * @throws InterruptedException
   */
  public String readConfigName(String collection) throws KeeperException,
      InterruptedException {

    String configName = null;

    String path = ZkStateReader.COLLECTIONS_ZKNODE + "/" + collection;
    if (log.isInfoEnabled()) {
      log.info("Load collection config from:" + path);
    }
    byte[] data = zkClient.getData(path, null, null, true);
    
    if(data != null) {
      ZkNodeProps props = ZkNodeProps.load(data);
      configName = props.get(CONFIGNAME_PROP);
    }
    
    if (configName != null && !zkClient.exists(CONFIGS_ZKNODE + "/" + configName, true)) {
      log.error("Specified config does not exist in ZooKeeper:" + configName);
      throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,
          "Specified config does not exist in ZooKeeper:" + configName);
    }

    return configName;
  }


, Instance #
frags: 
(startLine=188 endLine=208 srcPath=/home/sonia/NewExperiment/luceneFilter/01584/lucene/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java)
  private Query makeWithin(Rectangle bbox) {
    Query qX = NumericRangeQuery.newDoubleRange(
      fieldNameX,
      precisionStep,
      bbox.getMinX(),
      bbox.getMaxX(),
      true,
      true);
    Query qY = NumericRangeQuery.newDoubleRange(
      fieldNameY,
      precisionStep,
      bbox.getMinY(),
      bbox.getMaxY(),
      true,
      true);

    BooleanQuery bq = new BooleanQuery();
    bq.add(qX,BooleanClause.Occur.MUST);
    bq.add(qY,BooleanClause.Occur.MUST);
    return bq;
  }

(startLine=214 endLine=234 srcPath=/home/sonia/NewExperiment/luceneFilter/01584/lucene/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java)
  Query makeDisjoint(Rectangle bbox) {
    Query qX = NumericRangeQuery.newDoubleRange(
        fieldNameX,
        precisionStep,
        bbox.getMinX(),
        bbox.getMaxX(),
        true,
        true);
    Query qY = NumericRangeQuery.newDoubleRange(
        fieldNameY,
        precisionStep,
        bbox.getMinY(),
        bbox.getMaxY(),
        true,
        true);

    BooleanQuery bq = new BooleanQuery();
    bq.add(qX,BooleanClause.Occur.MUST_NOT);
    bq.add(qY,BooleanClause.Occur.MUST_NOT);
    return bq;
  }

commonMethod: 
(startLine=218 endLine=226 srcPath=/home/sonia/NewExperiment/luceneFilter/01585/lucene/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java)
  private NumericRangeQuery<Double> rangeQuery(String fieldName, Double min, Double max) {
    return NumericRangeQuery.newDoubleRange(
        fieldName,
        precisionStep,
        min,
        max,
        true,
        true);//inclusive
  }


, Instance #
frags: 
(startLine=40 endLine=51 srcPath=/home/sonia/NewExperiment/luceneFilter/01629/lucene/core/src/java/org/apache/lucene/util/packed/Direct8.java)
  Direct8(DataInput in, int valueCount) throws IOException {
    this(valueCount);
    for (int i = 0; i < valueCount; ++i) {
      values[i] = in.readByte();
    }
    final int mod = valueCount % 8;
    if (mod != 0) {
      for (int i = mod; i < 8; ++i) {
        in.readByte();
      }
    }
  }

(startLine=45 endLine=56 srcPath=/home/sonia/NewExperiment/luceneFilter/01629/lucene/core/src/java/org/apache/lucene/util/packed/Packed8ThreeBlocks.java)
  Packed8ThreeBlocks(DataInput in, int valueCount) throws IOException {
    this(valueCount);
    for (int i = 0; i < 3 * valueCount; ++i) {
      blocks[i] = in.readByte();
    }
    final int mod = blocks.length % 8;
    if (mod != 0) {
      for (int i = mod; i < 8; ++i) {
         in.readByte();
      }
    }
  }

commonMethod: 
(startLine=45 endLine=52 srcPath=/home/sonia/NewExperiment/luceneFilter/01630/lucene/core/src/java/org/apache/lucene/store/DataInput.java)
  /** Reads a specified number of bytes into an array at the specified offset.
   * @param b the array to read bytes into
   * @param offset the offset in the array to start storing bytes
   * @param len the number of bytes to read
   * @see DataOutput#writeBytes(byte[],int)
   */
  public abstract void readBytes(byte[] b, int offset, int len)
    throws IOException;


, Instance #
frags: 
(startLine=40 endLine=51 srcPath=/home/sonia/NewExperiment/luceneFilter/01629/lucene/core/src/java/org/apache/lucene/util/packed/Direct8.java)
  Direct8(DataInput in, int valueCount) throws IOException {
    this(valueCount);
    for (int i = 0; i < valueCount; ++i) {
      values[i] = in.readByte();
    }
    final int mod = valueCount % 8;
    if (mod != 0) {
      for (int i = mod; i < 8; ++i) {
        in.readByte();
      }
    }
  }

(startLine=45 endLine=56 srcPath=/home/sonia/NewExperiment/luceneFilter/01629/lucene/core/src/java/org/apache/lucene/util/packed/Packed8ThreeBlocks.java)
  Packed8ThreeBlocks(DataInput in, int valueCount) throws IOException {
    this(valueCount);
    for (int i = 0; i < 3 * valueCount; ++i) {
      blocks[i] = in.readByte();
    }
    final int mod = blocks.length % 8;
    if (mod != 0) {
      for (int i = mod; i < 8; ++i) {
         in.readByte();
      }
    }
  }

commonMethod: 
(startLine=45 endLine=52 srcPath=/home/sonia/NewExperiment/luceneFilter/01630/lucene/core/src/java/org/apache/lucene/store/DataInput.java)
  /** Reads a specified number of bytes into an array at the specified offset.
   * @param b the array to read bytes into
   * @param offset the offset in the array to start storing bytes
   * @param len the number of bytes to read
   * @see DataOutput#writeBytes(byte[],int)
   */
  public abstract void readBytes(byte[] b, int offset, int len)
    throws IOException;


, Instance #
frags: 
(startLine=67 endLine=105 srcPath=/home/sonia/NewExperiment/luceneFilter/01692/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java)
  public void testDefault() throws Exception {
    Directory[][] dirs = getDirs();
    // create and open an index writer
    RandomIndexWriter iw = new RandomIndexWriter(random(), dirs[0][0], newIndexWriterConfig(
        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
    // create and open a taxonomy writer
    TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1], OpenMode.CREATE);

    /**
     * Configure with no custom counting lists
     */
    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(Collections.<CategoryPath, CategoryListParams>emptyMap());

    seedIndex(iw, tw, iParams);

    IndexReader ir = iw.getReader();
    tw.commit();

    // prepare index reader and taxonomy.
    TaxonomyReader tr = new DirectoryTaxonomyReader(dirs[0][1]);

    // prepare searcher to search against
    IndexSearcher searcher = newSearcher(ir);

    FacetsCollector facetsCollector = performSearch(iParams, tr, ir,
        searcher);

    // Obtain facets results and hand-test them
    assertCorrectResults(facetsCollector);

    DocsEnum td = _TestUtil.docs(random(), ir, "$facets", new BytesRef("$fulltree$"), MultiFields.getLiveDocs(ir), null, DocsEnum.FLAG_NONE);
    assertTrue(td.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);

    tr.close();
    ir.close();
    iw.close();
    tw.close();
    IOUtils.close(dirs[0]);
  }

(startLine=108 endLine=144 srcPath=/home/sonia/NewExperiment/luceneFilter/01692/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java)
  public void testCustom() throws Exception {
    Directory[][] dirs = getDirs();
    // create and open an index writer
    RandomIndexWriter iw = new RandomIndexWriter(random(), dirs[0][0], newIndexWriterConfig(
        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
    // create and open a taxonomy writer
    TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1],
        OpenMode.CREATE);

    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(
        Collections.singletonMap(new CategoryPath("Author"),
            new CategoryListParams(new Term("$author", "Authors"))));
    seedIndex(iw, tw, iParams);

    IndexReader ir = iw.getReader();
    tw.commit();

    // prepare index reader and taxonomy.
    TaxonomyReader tr = new DirectoryTaxonomyReader(dirs[0][1]);

    // prepare searcher to search against
    IndexSearcher searcher = newSearcher(ir);

    FacetsCollector facetsCollector = performSearch(iParams, tr, ir, searcher);

    // Obtain facets results and hand-test them
    assertCorrectResults(facetsCollector);

    assertPostingListExists("$facets", "$fulltree$", ir);
    assertPostingListExists("$author", "Authors", ir);

    tr.close();
    ir.close();
    iw.close();
    tw.close();
    IOUtils.close(dirs[0]);
  }

commonMethod: 
(startLine=182 endLine=190 srcPath=/home/sonia/NewExperiment/luceneFilter/01693/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java)
  private void assertOrdinalsExist(String field, IndexReader ir) throws IOException {
    for (AtomicReaderContext context : ir.leaves()) {
      AtomicReader r = context.reader();
      if (r.docValues(field) != null) {
        return; // not all segments must have this DocValues
      }
    }
    fail("no ordinals found for " + field);
  }


, Instance #
frags: 
(startLine=147 endLine=186 srcPath=/home/sonia/NewExperiment/luceneFilter/01692/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java)
  public void testTwoCustomsSameField() throws Exception {
    Directory[][] dirs = getDirs();
    // create and open an index writer
    RandomIndexWriter iw = new RandomIndexWriter(random(), dirs[0][0], newIndexWriterConfig(
        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
    // create and open a taxonomy writer
    TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1],
        OpenMode.CREATE);

    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
    paramsMap.put(new CategoryPath("Band"), new CategoryListParams(new Term("$music", "Bands")));
    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams(new Term("$music", "Composers")));
    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
    seedIndex(iw, tw, iParams);

    IndexReader ir = iw.getReader();
    tw.commit();

    // prepare index reader and taxonomy.
    TaxonomyReader tr = new DirectoryTaxonomyReader(dirs[0][1]);

    // prepare searcher to search against
    IndexSearcher searcher = newSearcher(ir);

    FacetsCollector facetsCollector = performSearch(iParams, tr, ir,
        searcher);

    // Obtain facets results and hand-test them
    assertCorrectResults(facetsCollector);

    assertPostingListExists("$facets", "$fulltree$", ir);
    assertPostingListExists("$music", "Bands", ir);
    assertPostingListExists("$music", "Composers", ir);

    tr.close();
    ir.close();
    iw.close();
    tw.close();
    IOUtils.close(dirs[0]);
  }

(startLine=194 endLine=230 srcPath=/home/sonia/NewExperiment/luceneFilter/01692/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java)
  public void testDifferentFieldsAndText() throws Exception {
    Directory[][] dirs = getDirs();
    // create and open an index writer
    RandomIndexWriter iw = new RandomIndexWriter(random(), dirs[0][0], newIndexWriterConfig(
        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
    // create and open a taxonomy writer
    TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1], OpenMode.CREATE);

    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
    paramsMap.put(new CategoryPath("Band"), new CategoryListParams(new Term("$bands", "Bands")));
    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams(new Term("$composers", "Composers")));
    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
    seedIndex(iw, tw, iParams);

    IndexReader ir = iw.getReader();
    tw.commit();

    // prepare index reader and taxonomy.
    TaxonomyReader tr = new DirectoryTaxonomyReader(dirs[0][1]);

    // prepare searcher to search against
    IndexSearcher searcher = newSearcher(ir);

    FacetsCollector facetsCollector = performSearch(iParams, tr, ir,
        searcher);

    // Obtain facets results and hand-test them
    assertCorrectResults(facetsCollector);
    assertPostingListExists("$facets", "$fulltree$", ir);
    assertPostingListExists("$bands", "Bands", ir);
    assertPostingListExists("$composers", "Composers", ir);
    tr.close();
    ir.close();
    iw.close();
    tw.close();
    IOUtils.close(dirs[0]);
  }

(startLine=233 endLine=272 srcPath=/home/sonia/NewExperiment/luceneFilter/01692/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java)
  public void testSomeSameSomeDifferent() throws Exception {
    Directory[][] dirs = getDirs();
    // create and open an index writer
    RandomIndexWriter iw = new RandomIndexWriter(random(), dirs[0][0], newIndexWriterConfig(
        TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
    // create and open a taxonomy writer
    TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1],
        OpenMode.CREATE);

    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
    paramsMap.put(new CategoryPath("Band"), new CategoryListParams(new Term("$music", "music")));
    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams(new Term("$music", "music")));
    paramsMap.put(new CategoryPath("Author"), new CategoryListParams(new Term("$literature", "Authors")));
    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);

    seedIndex(iw, tw, iParams);

    IndexReader ir = iw.getReader();
    tw.commit();

    // prepare index reader and taxonomy.
    TaxonomyReader tr = new DirectoryTaxonomyReader(dirs[0][1]);

    // prepare searcher to search against
    IndexSearcher searcher = newSearcher(ir);

    FacetsCollector facetsCollector = performSearch(iParams, tr, ir,
        searcher);

    // Obtain facets results and hand-test them
    assertCorrectResults(facetsCollector);
    assertPostingListExists("$music", "music", ir);
    assertPostingListExists("$literature", "Authors", ir);

    tr.close();
    ir.close();
    iw.close();
    tw.close();
    IOUtils.close(dirs[0]);
  }

commonMethod: 
(startLine=182 endLine=190 srcPath=/home/sonia/NewExperiment/luceneFilter/01693/lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java)
  private void assertOrdinalsExist(String field, IndexReader ir) throws IOException {
    for (AtomicReaderContext context : ir.leaves()) {
      AtomicReader r = context.reader();
      if (r.docValues(field) != null) {
        return; // not all segments must have this DocValues
      }
    }
    fail("no ordinals found for " + field);
  }


, Instance #
frags: 
(startLine=409 endLine=459 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      ShortParser parser = (ShortParser) entryKey.custom;
      if (parser == null) {
        return wrapper.getShorts(reader, field, FieldCache.DEFAULT_SHORT_PARSER, setDocsWithField);
      }
      final int maxDoc = reader.maxDoc();
      final short[] retArray = new short[maxDoc];
      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=336 endLine=386 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      ByteParser parser = (ByteParser) entryKey.custom;
      if (parser == null) {
        return wrapper.getBytes(reader, field, FieldCache.DEFAULT_BYTE_PARSER, setDocsWithField);
      }
      final int maxDoc = reader.maxDoc();
      final byte[] retArray = new byte[maxDoc];
      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=503 endLine=568 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      IntParser parser = (IntParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getInts(reader, field, DEFAULT_INT_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getInts(reader, field, NUMERIC_UTILS_INT_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      int[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new int[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=654 endLine=719 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FloatParser parser = (FloatParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getFloats(reader, field, DEFAULT_FLOAT_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getFloats(reader, field, NUMERIC_UTILS_FLOAT_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      float[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new float[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=742 endLine=807 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      long[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new long[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=831 endLine=894 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FieldCache.DoubleParser parser = (FieldCache.DoubleParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getDoubles(reader, field, DEFAULT_DOUBLE_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getDoubles(reader, field, NUMERIC_UTILS_DOUBLE_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      double[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (retArray == null) { // no values
        retArray = new double[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

commonMethod: 
(startLine=336 endLine=354 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
  void setDocsWithField(AtomicReader reader, String field, Bits docsWithField) {
    final int maxDoc = reader.maxDoc();
    final Bits bits;
    if (docsWithField == null) {
      bits = new Bits.MatchNoBits(maxDoc);
    } else if (docsWithField instanceof FixedBitSet) {
      final int numSet = ((FixedBitSet) docsWithField).cardinality();
      if (numSet >= maxDoc) {
        // The cardinality of the BitSet is maxDoc if all documents have a value.
        assert numSet == maxDoc;
        bits = new Bits.MatchAllBits(maxDoc);
      } else {
        bits = docsWithField;
      }
    } else {
      bits = docsWithField;
    }
    caches.get(DocsWithFieldCache.class).put(reader, new CacheKey(field, null), bits);
  }


, Instance #
frags: 
(startLine=409 endLine=459 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      ShortParser parser = (ShortParser) entryKey.custom;
      if (parser == null) {
        return wrapper.getShorts(reader, field, FieldCache.DEFAULT_SHORT_PARSER, setDocsWithField);
      }
      final int maxDoc = reader.maxDoc();
      final short[] retArray = new short[maxDoc];
      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=336 endLine=386 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      ByteParser parser = (ByteParser) entryKey.custom;
      if (parser == null) {
        return wrapper.getBytes(reader, field, FieldCache.DEFAULT_BYTE_PARSER, setDocsWithField);
      }
      final int maxDoc = reader.maxDoc();
      final byte[] retArray = new byte[maxDoc];
      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=503 endLine=568 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      IntParser parser = (IntParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getInts(reader, field, DEFAULT_INT_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getInts(reader, field, NUMERIC_UTILS_INT_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      int[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new int[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=654 endLine=719 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FloatParser parser = (FloatParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getFloats(reader, field, DEFAULT_FLOAT_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getFloats(reader, field, NUMERIC_UTILS_FLOAT_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      float[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new float[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=742 endLine=807 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      long[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new long[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=831 endLine=894 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FieldCache.DoubleParser parser = (FieldCache.DoubleParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getDoubles(reader, field, DEFAULT_DOUBLE_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getDoubles(reader, field, NUMERIC_UTILS_DOUBLE_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      double[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (retArray == null) { // no values
        retArray = new double[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

commonMethod: 
(startLine=287 endLine=328 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
    public void uninvert(AtomicReader reader, String field, boolean setDocsWithField) throws IOException {
      final int maxDoc = reader.maxDoc();
      Terms terms = reader.terms(field);
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            docsWithField = new Bits.MatchAllBits(maxDoc);
            setDocsWithField = false;
          }
        }

        final TermsEnum termsEnum = termsEnum(terms);

        DocsEnum docs = null;
        FixedBitSet docsWithField = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          visitTerm(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            visitDoc(docID);
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                this.docsWithField = docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
    }


, Instance #
frags: 
(startLine=503 endLine=568 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      IntParser parser = (IntParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getInts(reader, field, DEFAULT_INT_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getInts(reader, field, NUMERIC_UTILS_INT_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      int[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new int[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=654 endLine=719 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FloatParser parser = (FloatParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getFloats(reader, field, DEFAULT_FLOAT_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getFloats(reader, field, NUMERIC_UTILS_FLOAT_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      float[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new float[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=742 endLine=807 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      long[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new long[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=831 endLine=894 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FieldCache.DoubleParser parser = (FieldCache.DoubleParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getDoubles(reader, field, DEFAULT_DOUBLE_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getDoubles(reader, field, NUMERIC_UTILS_DOUBLE_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      double[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (retArray == null) { // no values
        retArray = new double[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=336 endLine=386 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      ByteParser parser = (ByteParser) entryKey.custom;
      if (parser == null) {
        return wrapper.getBytes(reader, field, FieldCache.DEFAULT_BYTE_PARSER, setDocsWithField);
      }
      final int maxDoc = reader.maxDoc();
      final byte[] retArray = new byte[maxDoc];
      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=409 endLine=459 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      ShortParser parser = (ShortParser) entryKey.custom;
      if (parser == null) {
        return wrapper.getShorts(reader, field, FieldCache.DEFAULT_SHORT_PARSER, setDocsWithField);
      }
      final int maxDoc = reader.maxDoc();
      final short[] retArray = new short[maxDoc];
      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

commonMethod: 
(startLine=336 endLine=354 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
  void setDocsWithField(AtomicReader reader, String field, Bits docsWithField) {
    final int maxDoc = reader.maxDoc();
    final Bits bits;
    if (docsWithField == null) {
      bits = new Bits.MatchNoBits(maxDoc);
    } else if (docsWithField instanceof FixedBitSet) {
      final int numSet = ((FixedBitSet) docsWithField).cardinality();
      if (numSet >= maxDoc) {
        // The cardinality of the BitSet is maxDoc if all documents have a value.
        assert numSet == maxDoc;
        bits = new Bits.MatchAllBits(maxDoc);
      } else {
        bits = docsWithField;
      }
    } else {
      bits = docsWithField;
    }
    caches.get(DocsWithFieldCache.class).put(reader, new CacheKey(field, null), bits);
  }


, Instance #
frags: 
(startLine=503 endLine=568 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      IntParser parser = (IntParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getInts(reader, field, DEFAULT_INT_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getInts(reader, field, NUMERIC_UTILS_INT_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      int[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new int[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=654 endLine=719 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FloatParser parser = (FloatParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getFloats(reader, field, DEFAULT_FLOAT_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getFloats(reader, field, NUMERIC_UTILS_FLOAT_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      float[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new float[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=742 endLine=807 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FieldCache.LongParser parser = (FieldCache.LongParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getLongs(reader, field, DEFAULT_LONG_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getLongs(reader, field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      long[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

      if (retArray == null) {
        // no values
        retArray = new long[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=831 endLine=894 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      FieldCache.DoubleParser parser = (FieldCache.DoubleParser) entryKey.custom;
      if (parser == null) {
        try {
          return wrapper.getDoubles(reader, field, DEFAULT_DOUBLE_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getDoubles(reader, field, NUMERIC_UTILS_DOUBLE_PARSER, setDocsWithField);
        }
      }
      final int maxDoc = reader.maxDoc();
      double[] retArray = null;

      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (retArray == null) { // no values
        retArray = new double[maxDoc];
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=336 endLine=386 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      ByteParser parser = (ByteParser) entryKey.custom;
      if (parser == null) {
        return wrapper.getBytes(reader, field, FieldCache.DEFAULT_BYTE_PARSER, setDocsWithField);
      }
      final int maxDoc = reader.maxDoc();
      final byte[] retArray = new byte[maxDoc];
      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

(startLine=409 endLine=459 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {
      String field = entryKey.field;
      ShortParser parser = (ShortParser) entryKey.custom;
      if (parser == null) {
        return wrapper.getShorts(reader, field, FieldCache.DEFAULT_SHORT_PARSER, setDocsWithField);
      }
      final int maxDoc = reader.maxDoc();
      final short[] retArray = new short[maxDoc];
      Terms terms = reader.terms(field);
      FixedBitSet docsWithField = null;
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, field, docsWithField);
      }
      return retArray;
    }

commonMethod: 
(startLine=287 endLine=328 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
    public void uninvert(AtomicReader reader, String field, boolean setDocsWithField) throws IOException {
      final int maxDoc = reader.maxDoc();
      Terms terms = reader.terms(field);
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            docsWithField = new Bits.MatchAllBits(maxDoc);
            setDocsWithField = false;
          }
        }

        final TermsEnum termsEnum = termsEnum(terms);

        DocsEnum docs = null;
        FixedBitSet docsWithField = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          visitTerm(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            visitDoc(docID);
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                this.docsWithField = docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
    }


, Instance #
frags: 
(startLine=346 endLine=381 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

(startLine=419 endLine=454 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

(startLine=518 endLine=558 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

(startLine=669 endLine=709 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

(startLine=757 endLine=797 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

(startLine=846 endLine=886 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

commonMethod: 
(startLine=336 endLine=354 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
  void setDocsWithField(AtomicReader reader, String field, Bits docsWithField) {
    final int maxDoc = reader.maxDoc();
    final Bits bits;
    if (docsWithField == null) {
      bits = new Bits.MatchNoBits(maxDoc);
    } else if (docsWithField instanceof FixedBitSet) {
      final int numSet = ((FixedBitSet) docsWithField).cardinality();
      if (numSet >= maxDoc) {
        // The cardinality of the BitSet is maxDoc if all documents have a value.
        assert numSet == maxDoc;
        bits = new Bits.MatchAllBits(maxDoc);
      } else {
        bits = docsWithField;
      }
    } else {
      bits = docsWithField;
    }
    caches.get(DocsWithFieldCache.class).put(reader, new CacheKey(field, null), bits);
  }


, Instance #
frags: 
(startLine=346 endLine=381 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

(startLine=419 endLine=454 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

(startLine=518 endLine=558 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

(startLine=669 endLine=709 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

(startLine=757 endLine=797 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

(startLine=846 endLine=886 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            wrapper.setDocsWithField(reader, field, new Bits.MatchAllBits(maxDoc));
            setDocsWithField = false;
          }
        }
        final TermsEnum termsEnum = parser.termsEnum(terms);
        assert termsEnum != null : "TermsEnum must not be null";
        DocsEnum docs = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }

commonMethod: 
(startLine=287 endLine=328 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
    public void uninvert(AtomicReader reader, String field, boolean setDocsWithField) throws IOException {
      final int maxDoc = reader.maxDoc();
      Terms terms = reader.terms(field);
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            docsWithField = new Bits.MatchAllBits(maxDoc);
            setDocsWithField = false;
          }
        }

        final TermsEnum termsEnum = termsEnum(terms);

        DocsEnum docs = null;
        FixedBitSet docsWithField = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          visitTerm(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            visitDoc(docID);
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                this.docsWithField = docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
    }


, Instance #
frags: 
(startLine=359 endLine=380 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=432 endLine=453 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=531 endLine=557 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=682 endLine=708 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=770 endLine=796 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=859 endLine=885 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

commonMethod: 
(startLine=336 endLine=354 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
  void setDocsWithField(AtomicReader reader, String field, Bits docsWithField) {
    final int maxDoc = reader.maxDoc();
    final Bits bits;
    if (docsWithField == null) {
      bits = new Bits.MatchNoBits(maxDoc);
    } else if (docsWithField instanceof FixedBitSet) {
      final int numSet = ((FixedBitSet) docsWithField).cardinality();
      if (numSet >= maxDoc) {
        // The cardinality of the BitSet is maxDoc if all documents have a value.
        assert numSet == maxDoc;
        bits = new Bits.MatchAllBits(maxDoc);
      } else {
        bits = docsWithField;
      }
    } else {
      bits = docsWithField;
    }
    caches.get(DocsWithFieldCache.class).put(reader, new CacheKey(field, null), bits);
  }


, Instance #
frags: 
(startLine=359 endLine=380 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=432 endLine=453 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=531 endLine=557 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=682 endLine=708 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=770 endLine=796 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=859 endLine=885 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

commonMethod: 
(startLine=302 endLine=305 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCache.java)
    @Override
    public TermsEnum termsEnum(Terms terms) throws IOException {
      return NumericUtils.filterPrefixCodedInts(terms.iterator(null));
    }


, Instance #
frags: 
(startLine=359 endLine=380 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=432 endLine=453 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=531 endLine=557 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=682 endLine=708 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=770 endLine=796 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=859 endLine=885 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

commonMethod: 
(startLine=327 endLine=330 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCache.java)
    @Override
    public TermsEnum termsEnum(Terms terms) throws IOException {
      return NumericUtils.filterPrefixCodedInts(terms.iterator(null));
    }


, Instance #
frags: 
(startLine=359 endLine=380 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=432 endLine=453 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=531 endLine=557 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=682 endLine=708 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=770 endLine=796 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=859 endLine=885 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

commonMethod: 
(startLine=347 endLine=350 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCache.java)
    @Override
    public TermsEnum termsEnum(Terms terms) throws IOException {
      return NumericUtils.filterPrefixCodedLongs(terms.iterator(null));
    }


, Instance #
frags: 
(startLine=359 endLine=380 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=432 endLine=453 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=531 endLine=557 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=682 endLine=708 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=770 endLine=796 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=859 endLine=885 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

commonMethod: 
(startLine=367 endLine=370 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCache.java)
    @Override
    public TermsEnum termsEnum(Terms terms) throws IOException {
      return NumericUtils.filterPrefixCodedLongs(terms.iterator(null));
    }


, Instance #
frags: 
(startLine=359 endLine=380 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=432 endLine=453 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=531 endLine=557 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final int termval = parser.parseInt(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new int[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=682 endLine=708 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final float termval = parser.parseFloat(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new float[maxDoc];
          }
          
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=770 endLine=796 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final long termval = parser.parseLong(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new long[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

(startLine=859 endLine=885 srcPath=/home/sonia/NewExperiment/luceneFilter/01715/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final double termval = parser.parseDouble(term);
          if (retArray == null) {
            // late init so numeric fields don't double allocate
            retArray = new double[maxDoc];
          }

          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            retArray[docID] = termval;
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }

commonMethod: 
(startLine=287 endLine=328 srcPath=/home/sonia/NewExperiment/luceneFilter/01716/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
    public void uninvert(AtomicReader reader, String field, boolean setDocsWithField) throws IOException {
      final int maxDoc = reader.maxDoc();
      Terms terms = reader.terms(field);
      if (terms != null) {
        if (setDocsWithField) {
          final int termsDocCount = terms.getDocCount();
          assert termsDocCount <= maxDoc;
          if (termsDocCount == maxDoc) {
            // Fast case: all docs have this field:
            docsWithField = new Bits.MatchAllBits(maxDoc);
            setDocsWithField = false;
          }
        }

        final TermsEnum termsEnum = termsEnum(terms);

        DocsEnum docs = null;
        FixedBitSet docsWithField = null;
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          visitTerm(term);
          docs = termsEnum.docs(null, docs, DocsEnum.FLAG_NONE);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            visitDoc(docID);
            if (setDocsWithField) {
              if (docsWithField == null) {
                // Lazy init
                this.docsWithField = docsWithField = new FixedBitSet(maxDoc);
              }
              docsWithField.set(docID);
            }
          }
        }
      }
    }


, Instance #
frags: 
(startLine=297 endLine=305 srcPath=/home/sonia/NewExperiment/luceneFilter/01760/lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase.java)
    while ((doc = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
      if (mappedLiveDocs != null) {
        assertTrue("document " + doc + " marked as deleted", mappedLiveDocs.get(doc));
      }
      assertEquals("incorrect value; doc " + doc, sortedValues[doc].intValue(), Integer.parseInt(reader.document(doc).get(ID_FIELD)));
      while (++prev < doc) {
        assertFalse("document " + prev + " not marked as deleted", mappedLiveDocs.get(prev));
      }
    }

(startLine=310 endLine=318 srcPath=/home/sonia/NewExperiment/luceneFilter/01760/lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase.java)
    while ((doc = docs.advance(doc)) != DocIdSetIterator.NO_MORE_DOCS) {
      if (mappedLiveDocs != null) {
        assertTrue("document " + doc + " marked as deleted", mappedLiveDocs.get(doc));
      }
      assertEquals("incorrect value; doc " + doc, sortedValues[doc].intValue(), Integer.parseInt(reader.document(doc).get(ID_FIELD)));
      while (++prev < doc) {
        assertFalse("document " + prev + " not marked as deleted", mappedLiveDocs.get(prev));
      }
    }

commonMethod: 
(startLine=293 endLine=313 srcPath=/home/sonia/NewExperiment/luceneFilter/01761/lucene/misc/src/test/org/apache/lucene/index/sorter/SorterTestBase.java)
  Bits randomLiveDocs(int maxDoc) {
    if (rarely()) {
      if (random().nextBoolean()) {
        return null;
      } else {
        return new Bits.MatchNoBits(maxDoc);
      }
    }
    final FixedBitSet bits = new FixedBitSet(maxDoc);
    final int bitsSet = _TestUtil.nextInt(random(), 1, maxDoc - 1);
    for (int i = 0; i < bitsSet; ++i) {
      while (true) {
        final int index = random().nextInt(maxDoc);
        if (!bits.get(index)) {
          bits.set(index);
          break;
        }
      }
    }
    return bits;
  }


, Instance #
frags: 
(startLine=46 endLine=61 srcPath=/home/sonia/NewExperiment/luceneFilter/01792/lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/DictionaryCompoundWordTokenFilterFactory.java)
  public DictionaryCompoundWordTokenFilterFactory(Map<String, String> args) {
    super(args);
    assureMatchVersion();
    dictFile = args.remove("dictionary");
    if (null == dictFile) {
      throw new IllegalArgumentException("Missing required parameter: dictionary");
    }

    minWordSize = getInt(args, "minWordSize", CompoundWordTokenFilterBase.DEFAULT_MIN_WORD_SIZE);
    minSubwordSize = getInt(args, "minSubwordSize", CompoundWordTokenFilterBase.DEFAULT_MIN_SUBWORD_SIZE);
    maxSubwordSize = getInt(args, "maxSubwordSize", CompoundWordTokenFilterBase.DEFAULT_MAX_SUBWORD_SIZE);
    onlyLongestMatch = getBoolean(args, "onlyLongestMatch", true);
    if (!args.isEmpty()) {
      throw new IllegalArgumentException("Unknown parameters: " + args);
    }
  }

(startLine=71 endLine=88 srcPath=/home/sonia/NewExperiment/luceneFilter/01792/lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/HyphenationCompoundWordTokenFilterFactory.java)
  public HyphenationCompoundWordTokenFilterFactory(Map<String, String> args) {
    super(args);
    assureMatchVersion();
    dictFile = args.remove("dictionary");
    encoding = args.remove("encoding");
    hypFile = args.remove("hyphenator");
    if (null == hypFile) {
      throw new IllegalArgumentException("Missing required parameter: hyphenator");
    }

    minWordSize = getInt(args, "minWordSize", CompoundWordTokenFilterBase.DEFAULT_MIN_WORD_SIZE);
    minSubwordSize = getInt(args, "minSubwordSize", CompoundWordTokenFilterBase.DEFAULT_MIN_SUBWORD_SIZE);
    maxSubwordSize = getInt(args, "maxSubwordSize", CompoundWordTokenFilterBase.DEFAULT_MAX_SUBWORD_SIZE);
    onlyLongestMatch = getBoolean(args, "onlyLongestMatch", false);
    if (!args.isEmpty()) {
      throw new IllegalArgumentException("Unknown parameters: " + args);
    }
  }

commonMethod: 
(startLine=88 endLine=94 srcPath=/home/sonia/NewExperiment/luceneFilter/01793/lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AbstractAnalysisFactory.java)
  public String require(Map<String,String> args, String name) {
    String s = args.remove(name);
    if (s == null) {
      throw new IllegalArgumentException("Configuration Error: missing parameter '" + name + "'");
    }
    return s;
  }


, Instance #
frags: 
(startLine=41 endLine=55 srcPath=/home/sonia/NewExperiment/luceneFilter/01792/lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramFilterFactory.java)
  public EdgeNGramFilterFactory(Map<String, String> args) {
    super(args);
    minGramSize = getInt(args, "minGramSize", EdgeNGramTokenFilter.DEFAULT_MIN_GRAM_SIZE);
    maxGramSize = getInt(args, "maxGramSize", EdgeNGramTokenFilter.DEFAULT_MAX_GRAM_SIZE);

    String sideArg = args.remove("side");
    if (sideArg == null) {
      side = EdgeNGramTokenFilter.Side.FRONT.getLabel();
    } else {
      side = sideArg;
    }
    if (!args.isEmpty()) {
      throw new IllegalArgumentException("Unknown parameters: " + args);
    }
  }

(startLine=41 endLine=55 srcPath=/home/sonia/NewExperiment/luceneFilter/01792/lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenizerFactory.java)
  public EdgeNGramTokenizerFactory(Map<String, String> args) {
    super(args);
    minGramSize = getInt(args, "minGramSize", EdgeNGramTokenizer.DEFAULT_MIN_GRAM_SIZE);
    maxGramSize = getInt(args, "maxGramSize", EdgeNGramTokenizer.DEFAULT_MAX_GRAM_SIZE);

    String sideArg = args.remove("side");
    if (sideArg == null) {
      side = EdgeNGramTokenFilter.Side.FRONT.getLabel();
    } else {
      side = sideArg;
    }
    if (!args.isEmpty()) {
      throw new IllegalArgumentException("Unknown parameters: " + args);
    }
  }

commonMethod: 
(startLine=120 endLine=123 srcPath=/home/sonia/NewExperiment/luceneFilter/01793/lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AbstractAnalysisFactory.java)
  public String get(Map<String,String> args, String name, String defaultVal) {
    String s = args.remove(name);
    return s == null ? defaultVal : s;
  }


, Instance #
frags: 
(startLine=153 endLine=170 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeyShardSplitTest.java)
        public void run() {
          for (int i = 101; i < 201; i++) {
            try {
              indexr("id", i);
              
              // todo - hook in custom hashing
              byte[] bytes = String.valueOf(i).getBytes("UTF-8");
              int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
              for (int i2 = 0; i2 < ranges.size(); i2++) {
                DocRouter.Range range = ranges.get(i2);
                if (range.includes(hash)) docCounts[i2]++;
              }
              Thread.sleep(100);
            } catch (Exception e) {
              log.error("Exception while adding doc", e);
            }
          }
        }

(startLine=126 endLine=144 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
      public void run() {
        for (int i = 101; i < 201; i++) {
          try {
            indexr("id", i);

            // todo - hook in custom hashing
            byte[] bytes = String.valueOf(i).getBytes("UTF-8");
            int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
            for (int i2 = 0; i2 < ranges.size(); i2++) {
              DocRouter.Range range = ranges.get(i2);
              if (range.includes(hash))
                docCounts[i2]++;
            }
            Thread.sleep(100);
          } catch (Exception e) {
            log.error("Exception while adding doc", e);
          }
        }
      }

commonMethod: 
(startLine=181 endLine=197 srcPath=/home/sonia/NewExperiment/luceneFilter/01811/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
  protected void splitShard(String shardId) throws SolrServerException, IOException {
    ModifiableSolrParams params = new ModifiableSolrParams();
    params.set("action", CollectionParams.CollectionAction.SPLITSHARD.toString());
    params.set("collection", "collection1");
    params.set("shard", shardId);
    SolrRequest request = new QueryRequest(params);
    request.setPath("/admin/collections");

    String baseUrl = ((HttpSolrServer) shardToJetty.get(SHARD1).get(0).client.solrClient)
        .getBaseURL();
    baseUrl = baseUrl.substring(0, baseUrl.length() - "collection1".length());

    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);
    baseServer.setConnectionTimeout(15000);
    baseServer.setSoTimeout((int) (CollectionsHandler.DEFAULT_ZK_TIMEOUT * 5));
    baseServer.request(request);
  }


, Instance #
frags: 
(startLine=153 endLine=170 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeyShardSplitTest.java)
        public void run() {
          for (int i = 101; i < 201; i++) {
            try {
              indexr("id", i);
              
              // todo - hook in custom hashing
              byte[] bytes = String.valueOf(i).getBytes("UTF-8");
              int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
              for (int i2 = 0; i2 < ranges.size(); i2++) {
                DocRouter.Range range = ranges.get(i2);
                if (range.includes(hash)) docCounts[i2]++;
              }
              Thread.sleep(100);
            } catch (Exception e) {
              log.error("Exception while adding doc", e);
            }
          }
        }

(startLine=126 endLine=144 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
      public void run() {
        for (int i = 101; i < 201; i++) {
          try {
            indexr("id", i);

            // todo - hook in custom hashing
            byte[] bytes = String.valueOf(i).getBytes("UTF-8");
            int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
            for (int i2 = 0; i2 < ranges.size(); i2++) {
              DocRouter.Range range = ranges.get(i2);
              if (range.includes(hash))
                docCounts[i2]++;
            }
            Thread.sleep(100);
          } catch (Exception e) {
            log.error("Exception while adding doc", e);
          }
        }
      }

commonMethod: 
(startLine=138 endLine=179 srcPath=/home/sonia/NewExperiment/luceneFilter/01811/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
  protected void checkDocCountsAndShardStates(int[] docCounts, int numReplicas) throws SolrServerException, KeeperException, InterruptedException {
    SolrQuery query = new SolrQuery("*:*").setRows(1000).setFields("id", "_version_");
    query.set("distrib", false);

    ZkCoreNodeProps shard1_0 = getLeaderUrlFromZk(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD1_0);
    HttpSolrServer shard1_0Server = new HttpSolrServer(shard1_0.getCoreUrl());
    QueryResponse response = shard1_0Server.query(query);
    long shard10Count = response.getResults().getNumFound();

    ZkCoreNodeProps shard1_1 = getLeaderUrlFromZk(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD1_1);
    HttpSolrServer shard1_1Server = new HttpSolrServer(shard1_1.getCoreUrl());
    QueryResponse response2 = shard1_1Server.query(query);
    long shard11Count = response2.getResults().getNumFound();

    logDebugHelp(docCounts, response, shard10Count, response2, shard11Count);

    assertEquals("Wrong doc count on shard1_0", docCounts[0], shard10Count);
    assertEquals("Wrong doc count on shard1_1", docCounts[1], shard11Count);

    ClusterState clusterState = null;
    Slice slice1_0 = null, slice1_1 = null;
    int i = 0;
    for (i = 0; i < 10; i++) {
      ZkStateReader zkStateReader = cloudClient.getZkStateReader();
      zkStateReader.updateClusterState(true);
      clusterState = zkStateReader.getClusterState();
      slice1_0 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_0");
      slice1_1 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_1");
      if (Slice.ACTIVE.equals(slice1_0.getState()) && Slice.ACTIVE.equals(slice1_1.getState()))
        break;
      Thread.sleep(500);
    }

    log.info("ShardSplitTest waited for {} ms for shard state to be set to active", i * 500);

    assertNotNull("Cluster state does not contain shard1_0", slice1_0);
    assertNotNull("Cluster state does not contain shard1_0", slice1_1);
    assertEquals("shard1_0 is not active", Slice.ACTIVE, slice1_0.getState());
    assertEquals("shard1_1 is not active", Slice.ACTIVE, slice1_1.getState());
    assertEquals("Wrong number of replicas created for shard1_0", numReplicas, slice1_0.getReplicas().size());
    assertEquals("Wrong number of replicas created for shard1_1", numReplicas, slice1_1.getReplicas().size());
  }


, Instance #
frags: 
(startLine=108 endLine=119 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
    for (int i = 0; i < 100; i++) {
      indexr("id", i);

      // todo - hook in custom hashing
      byte[] bytes = String.valueOf(i).getBytes("UTF-8");
      int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
      for (int i2 = 0; i2 < ranges.size(); i2++) {
        DocRouter.Range range = ranges.get(i2);
        if (range.includes(hash))
          docCounts[i2]++;
      }
    }

(startLine=128 endLine=140 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
          try {
            indexr("id", i);

            // todo - hook in custom hashing
            byte[] bytes = String.valueOf(i).getBytes("UTF-8");
            int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
            for (int i2 = 0; i2 < ranges.size(); i2++) {
              DocRouter.Range range = ranges.get(i2);
              if (range.includes(hash))
                docCounts[i2]++;
            }
            Thread.sleep(100);
          } catch (Exception e) {

commonMethod: 
(startLine=212 endLine=243 srcPath=/home/sonia/NewExperiment/luceneFilter/01811/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
  protected void logDebugHelp(int[] docCounts, QueryResponse response, long shard10Count, QueryResponse response2, long shard11Count) {
    for (int i = 0; i < docCounts.length; i++) {
      int docCount = docCounts[i];
      log.info("Expected docCount for shard1_{} = {}", i, docCount);
    }

    log.info("Actual docCount for shard1_0 = {}", shard10Count);
    log.info("Actual docCount for shard1_1 = {}", shard11Count);
    Map<String, String> idVsVersion = new HashMap<String, String>();
    Map<String, SolrDocument> shard10Docs = new HashMap<String, SolrDocument>();
    Map<String, SolrDocument> shard11Docs = new HashMap<String, SolrDocument>();
    for (int i = 0; i < response.getResults().size(); i++) {
      SolrDocument document = response.getResults().get(i);
      idVsVersion.put(document.getFieldValue("id").toString(), document.getFieldValue("_version_").toString());
      SolrDocument old = shard10Docs.put(document.getFieldValue("id").toString(), document);
      if (old != null) {
        log.error("EXTRA: ID: " + document.getFieldValue("id") + " on shard1_0. Old version: " + old.getFieldValue("_version_") + " new version: " + document.getFieldValue("_version_"));
      }
    }
    for (int i = 0; i < response2.getResults().size(); i++) {
      SolrDocument document = response2.getResults().get(i);
      String value = document.getFieldValue("id").toString();
      String version = idVsVersion.get(value);
      if (version != null) {
        log.error("DUPLICATE: ID: " + value + " , shard1_0Version: " + version + " shard1_1Version:" + document.getFieldValue("_version_"));
      }
      SolrDocument old = shard11Docs.put(document.getFieldValue("id").toString(), document);
      if (old != null) {
        log.error("EXTRA: ID: " + document.getFieldValue("id") + " on shard1_1. Old version: " + old.getFieldValue("_version_") + " new version: " + document.getFieldValue("_version_"));
      }
    }
  }


, Instance #
frags: 
(startLine=136 endLine=146 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeyShardSplitTest.java)
      for (int i = 0; i < 100; i++) {
        indexr("id", i);
        
        // todo - hook in custom hashing
        byte[] bytes = String.valueOf(i).getBytes("UTF-8");
        int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
        for (int i2 = 0; i2 < ranges.size(); i2++) {
          DocRouter.Range range = ranges.get(i2);
          if (range.includes(hash)) docCounts[i2]++;
        }
      }

(startLine=155 endLine=166 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeyShardSplitTest.java)
            try {
              indexr("id", i);
              
              // todo - hook in custom hashing
              byte[] bytes = String.valueOf(i).getBytes("UTF-8");
              int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
              for (int i2 = 0; i2 < ranges.size(); i2++) {
                DocRouter.Range range = ranges.get(i2);
                if (range.includes(hash)) docCounts[i2]++;
              }
              Thread.sleep(100);
            } catch (Exception e) {

(startLine=108 endLine=119 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
    for (int i = 0; i < 100; i++) {
      indexr("id", i);

      // todo - hook in custom hashing
      byte[] bytes = String.valueOf(i).getBytes("UTF-8");
      int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
      for (int i2 = 0; i2 < ranges.size(); i2++) {
        DocRouter.Range range = ranges.get(i2);
        if (range.includes(hash))
          docCounts[i2]++;
      }
    }

(startLine=128 endLine=140 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
          try {
            indexr("id", i);

            // todo - hook in custom hashing
            byte[] bytes = String.valueOf(i).getBytes("UTF-8");
            int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
            for (int i2 = 0; i2 < ranges.size(); i2++) {
              DocRouter.Range range = ranges.get(i2);
              if (range.includes(hash))
                docCounts[i2]++;
            }
            Thread.sleep(100);
          } catch (Exception e) {

commonMethod: 
(startLine=181 endLine=197 srcPath=/home/sonia/NewExperiment/luceneFilter/01811/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
  protected void splitShard(String shardId) throws SolrServerException, IOException {
    ModifiableSolrParams params = new ModifiableSolrParams();
    params.set("action", CollectionParams.CollectionAction.SPLITSHARD.toString());
    params.set("collection", "collection1");
    params.set("shard", shardId);
    SolrRequest request = new QueryRequest(params);
    request.setPath("/admin/collections");

    String baseUrl = ((HttpSolrServer) shardToJetty.get(SHARD1).get(0).client.solrClient)
        .getBaseURL();
    baseUrl = baseUrl.substring(0, baseUrl.length() - "collection1".length());

    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);
    baseServer.setConnectionTimeout(15000);
    baseServer.setSoTimeout((int) (CollectionsHandler.DEFAULT_ZK_TIMEOUT * 5));
    baseServer.request(request);
  }


, Instance #
frags: 
(startLine=136 endLine=146 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeyShardSplitTest.java)
      for (int i = 0; i < 100; i++) {
        indexr("id", i);
        
        // todo - hook in custom hashing
        byte[] bytes = String.valueOf(i).getBytes("UTF-8");
        int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
        for (int i2 = 0; i2 < ranges.size(); i2++) {
          DocRouter.Range range = ranges.get(i2);
          if (range.includes(hash)) docCounts[i2]++;
        }
      }

(startLine=155 endLine=166 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeyShardSplitTest.java)
            try {
              indexr("id", i);
              
              // todo - hook in custom hashing
              byte[] bytes = String.valueOf(i).getBytes("UTF-8");
              int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
              for (int i2 = 0; i2 < ranges.size(); i2++) {
                DocRouter.Range range = ranges.get(i2);
                if (range.includes(hash)) docCounts[i2]++;
              }
              Thread.sleep(100);
            } catch (Exception e) {

(startLine=108 endLine=119 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
    for (int i = 0; i < 100; i++) {
      indexr("id", i);

      // todo - hook in custom hashing
      byte[] bytes = String.valueOf(i).getBytes("UTF-8");
      int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
      for (int i2 = 0; i2 < ranges.size(); i2++) {
        DocRouter.Range range = ranges.get(i2);
        if (range.includes(hash))
          docCounts[i2]++;
      }
    }

(startLine=128 endLine=140 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
          try {
            indexr("id", i);

            // todo - hook in custom hashing
            byte[] bytes = String.valueOf(i).getBytes("UTF-8");
            int hash = Hash.murmurhash3_x86_32(bytes, 0, bytes.length, 0);
            for (int i2 = 0; i2 < ranges.size(); i2++) {
              DocRouter.Range range = ranges.get(i2);
              if (range.includes(hash))
                docCounts[i2]++;
            }
            Thread.sleep(100);
          } catch (Exception e) {

commonMethod: 
(startLine=138 endLine=179 srcPath=/home/sonia/NewExperiment/luceneFilter/01811/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
  protected void checkDocCountsAndShardStates(int[] docCounts, int numReplicas) throws SolrServerException, KeeperException, InterruptedException {
    SolrQuery query = new SolrQuery("*:*").setRows(1000).setFields("id", "_version_");
    query.set("distrib", false);

    ZkCoreNodeProps shard1_0 = getLeaderUrlFromZk(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD1_0);
    HttpSolrServer shard1_0Server = new HttpSolrServer(shard1_0.getCoreUrl());
    QueryResponse response = shard1_0Server.query(query);
    long shard10Count = response.getResults().getNumFound();

    ZkCoreNodeProps shard1_1 = getLeaderUrlFromZk(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD1_1);
    HttpSolrServer shard1_1Server = new HttpSolrServer(shard1_1.getCoreUrl());
    QueryResponse response2 = shard1_1Server.query(query);
    long shard11Count = response2.getResults().getNumFound();

    logDebugHelp(docCounts, response, shard10Count, response2, shard11Count);

    assertEquals("Wrong doc count on shard1_0", docCounts[0], shard10Count);
    assertEquals("Wrong doc count on shard1_1", docCounts[1], shard11Count);

    ClusterState clusterState = null;
    Slice slice1_0 = null, slice1_1 = null;
    int i = 0;
    for (i = 0; i < 10; i++) {
      ZkStateReader zkStateReader = cloudClient.getZkStateReader();
      zkStateReader.updateClusterState(true);
      clusterState = zkStateReader.getClusterState();
      slice1_0 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_0");
      slice1_1 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_1");
      if (Slice.ACTIVE.equals(slice1_0.getState()) && Slice.ACTIVE.equals(slice1_1.getState()))
        break;
      Thread.sleep(500);
    }

    log.info("ShardSplitTest waited for {} ms for shard state to be set to active", i * 500);

    assertNotNull("Cluster state does not contain shard1_0", slice1_0);
    assertNotNull("Cluster state does not contain shard1_0", slice1_1);
    assertEquals("shard1_0 is not active", Slice.ACTIVE, slice1_0.getState());
    assertEquals("shard1_1 is not active", Slice.ACTIVE, slice1_1.getState());
    assertEquals("Wrong number of replicas created for shard1_0", numReplicas, slice1_0.getReplicas().size());
    assertEquals("Wrong number of replicas created for shard1_1", numReplicas, slice1_1.getReplicas().size());
  }


, Instance #
frags: 
(startLine=278 endLine=287 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeyShardSplitTest.java)
    for (i = 0; i < 10; i++) {
      ZkStateReader zkStateReader = cloudClient.getZkStateReader();
      zkStateReader.updateClusterState(true);
      clusterState = zkStateReader.getClusterState();
      slice1_0 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_0");
      slice1_1 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_1");
      if (Slice.ACTIVE.equals(slice1_0.getState()) && Slice.ACTIVE.equals(slice1_1.getState()))
        break;
      Thread.sleep(500);
    }

(startLine=224 endLine=233 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
    for (i = 0; i < 10; i++) {
      ZkStateReader zkStateReader = cloudClient.getZkStateReader();
      zkStateReader.updateClusterState(true);
      clusterState = zkStateReader.getClusterState();
      slice1_0 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_0");
      slice1_1 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_1");
      if (Slice.ACTIVE.equals(slice1_0.getState()) && Slice.ACTIVE.equals(slice1_1.getState()))
        break;
      Thread.sleep(500);
    }

commonMethod: 
(startLine=181 endLine=197 srcPath=/home/sonia/NewExperiment/luceneFilter/01811/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
  protected void splitShard(String shardId) throws SolrServerException, IOException {
    ModifiableSolrParams params = new ModifiableSolrParams();
    params.set("action", CollectionParams.CollectionAction.SPLITSHARD.toString());
    params.set("collection", "collection1");
    params.set("shard", shardId);
    SolrRequest request = new QueryRequest(params);
    request.setPath("/admin/collections");

    String baseUrl = ((HttpSolrServer) shardToJetty.get(SHARD1).get(0).client.solrClient)
        .getBaseURL();
    baseUrl = baseUrl.substring(0, baseUrl.length() - "collection1".length());

    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);
    baseServer.setConnectionTimeout(15000);
    baseServer.setSoTimeout((int) (CollectionsHandler.DEFAULT_ZK_TIMEOUT * 5));
    baseServer.request(request);
  }


, Instance #
frags: 
(startLine=278 endLine=287 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ChaosMonkeyShardSplitTest.java)
    for (i = 0; i < 10; i++) {
      ZkStateReader zkStateReader = cloudClient.getZkStateReader();
      zkStateReader.updateClusterState(true);
      clusterState = zkStateReader.getClusterState();
      slice1_0 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_0");
      slice1_1 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_1");
      if (Slice.ACTIVE.equals(slice1_0.getState()) && Slice.ACTIVE.equals(slice1_1.getState()))
        break;
      Thread.sleep(500);
    }

(startLine=224 endLine=233 srcPath=/home/sonia/NewExperiment/luceneFilter/01810/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
    for (i = 0; i < 10; i++) {
      ZkStateReader zkStateReader = cloudClient.getZkStateReader();
      zkStateReader.updateClusterState(true);
      clusterState = zkStateReader.getClusterState();
      slice1_0 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_0");
      slice1_1 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_1");
      if (Slice.ACTIVE.equals(slice1_0.getState()) && Slice.ACTIVE.equals(slice1_1.getState()))
        break;
      Thread.sleep(500);
    }

commonMethod: 
(startLine=138 endLine=179 srcPath=/home/sonia/NewExperiment/luceneFilter/01811/solr/core/src/test/org/apache/solr/cloud/ShardSplitTest.java)
  protected void checkDocCountsAndShardStates(int[] docCounts, int numReplicas) throws SolrServerException, KeeperException, InterruptedException {
    SolrQuery query = new SolrQuery("*:*").setRows(1000).setFields("id", "_version_");
    query.set("distrib", false);

    ZkCoreNodeProps shard1_0 = getLeaderUrlFromZk(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD1_0);
    HttpSolrServer shard1_0Server = new HttpSolrServer(shard1_0.getCoreUrl());
    QueryResponse response = shard1_0Server.query(query);
    long shard10Count = response.getResults().getNumFound();

    ZkCoreNodeProps shard1_1 = getLeaderUrlFromZk(AbstractDistribZkTestBase.DEFAULT_COLLECTION, SHARD1_1);
    HttpSolrServer shard1_1Server = new HttpSolrServer(shard1_1.getCoreUrl());
    QueryResponse response2 = shard1_1Server.query(query);
    long shard11Count = response2.getResults().getNumFound();

    logDebugHelp(docCounts, response, shard10Count, response2, shard11Count);

    assertEquals("Wrong doc count on shard1_0", docCounts[0], shard10Count);
    assertEquals("Wrong doc count on shard1_1", docCounts[1], shard11Count);

    ClusterState clusterState = null;
    Slice slice1_0 = null, slice1_1 = null;
    int i = 0;
    for (i = 0; i < 10; i++) {
      ZkStateReader zkStateReader = cloudClient.getZkStateReader();
      zkStateReader.updateClusterState(true);
      clusterState = zkStateReader.getClusterState();
      slice1_0 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_0");
      slice1_1 = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, "shard1_1");
      if (Slice.ACTIVE.equals(slice1_0.getState()) && Slice.ACTIVE.equals(slice1_1.getState()))
        break;
      Thread.sleep(500);
    }

    log.info("ShardSplitTest waited for {} ms for shard state to be set to active", i * 500);

    assertNotNull("Cluster state does not contain shard1_0", slice1_0);
    assertNotNull("Cluster state does not contain shard1_0", slice1_1);
    assertEquals("shard1_0 is not active", Slice.ACTIVE, slice1_0.getState());
    assertEquals("shard1_1 is not active", Slice.ACTIVE, slice1_1.getState());
    assertEquals("Wrong number of replicas created for shard1_0", numReplicas, slice1_0.getReplicas().size());
    assertEquals("Wrong number of replicas created for shard1_1", numReplicas, slice1_1.getReplicas().size());
  }


, Instance #
frags: 
(startLine=608 endLine=664 srcPath=/home/sonia/NewExperiment/luceneFilter/01858/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {

      final IntParser parser = (IntParser) key.custom;
      if (parser == null) {
        // Confusing: must delegate to wrapper (vs simply
        // setting parser =
        // DEFAULT_INT_PARSER/NUMERIC_UTILS_INT_PARSER) so
        // cache key includes
        // DEFAULT_INT_PARSER/NUMERIC_UTILS_INT_PARSER:
        try {
          return wrapper.getInts(reader, key.field, DEFAULT_INT_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getInts(reader, key.field, NUMERIC_UTILS_INT_PARSER, setDocsWithField);
        }
      }

      final HoldsOneThing<int[]> valuesRef = new HoldsOneThing<int[]>();

      Uninvert u = new Uninvert() {
          private int currentValue;
          private int[] values;

          @Override
          public void visitTerm(BytesRef term) {
            currentValue = parser.parseInt(term);
            if (values == null) {
              // Lazy alloc so for the numeric field case
              // (which will hit a NumberFormatException
              // when we first try the DEFAULT_INT_PARSER),
              // we don't double-alloc:
              values = new int[reader.maxDoc()];
              valuesRef.set(values);
            }
          }

          @Override
          public void visitDoc(int docID) {
            values[docID] = currentValue;
          }
          
          @Override
          protected TermsEnum termsEnum(Terms terms) throws IOException {
            return parser.termsEnum(terms);
          }
        };

      u.uninvert(reader, key.field, setDocsWithField);

      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, key.field, u.docsWithField);
      }
      int[] values = valuesRef.get();
      if (values == null) {
        values = new int[reader.maxDoc()];
      }
      return new IntsFromArray(values);
    }

(startLine=901 endLine=957 srcPath=/home/sonia/NewExperiment/luceneFilter/01858/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {

      final LongParser parser = (LongParser) key.custom;
      if (parser == null) {
        // Confusing: must delegate to wrapper (vs simply
        // setting parser =
        // DEFAULT_LONG_PARSER/NUMERIC_UTILS_LONG_PARSER) so
        // cache key includes
        // DEFAULT_LONG_PARSER/NUMERIC_UTILS_LONG_PARSER:
        try {
          return wrapper.getLongs(reader, key.field, DEFAULT_LONG_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getLongs(reader, key.field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);
        }
      }

      final HoldsOneThing<long[]> valuesRef = new HoldsOneThing<long[]>();

      Uninvert u = new Uninvert() {
          private long currentValue;
          private long[] values;

          @Override
          public void visitTerm(BytesRef term) {
            currentValue = parser.parseLong(term);
            if (values == null) {
              // Lazy alloc so for the numeric field case
              // (which will hit a NumberFormatException
              // when we first try the DEFAULT_INT_PARSER),
              // we don't double-alloc:
              values = new long[reader.maxDoc()];
              valuesRef.set(values);
            }
          }

          @Override
          public void visitDoc(int docID) {
            values[docID] = currentValue;
          }
          
          @Override
          protected TermsEnum termsEnum(Terms terms) throws IOException {
            return parser.termsEnum(terms);
          }
        };

      u.uninvert(reader, key.field, setDocsWithField);

      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, key.field, u.docsWithField);
      }
      long[] values = valuesRef.get();
      if (values == null) {
        values = new long[reader.maxDoc()];
      }
      return new LongsFromArray(values);
    }

commonMethod: 
(startLine=133 endLine=137 srcPath=/home/sonia/NewExperiment/luceneFilter/01859/lucene/core/src/java/org/apache/lucene/util/packed/GrowableWriter.java)
  @Override
  public void fill(int fromIndex, int toIndex, long val) {
    ensureCapacity(val);
    current.fill(fromIndex, toIndex, val);
  }


, Instance #
frags: 
(startLine=608 endLine=664 srcPath=/home/sonia/NewExperiment/luceneFilter/01858/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {

      final IntParser parser = (IntParser) key.custom;
      if (parser == null) {
        // Confusing: must delegate to wrapper (vs simply
        // setting parser =
        // DEFAULT_INT_PARSER/NUMERIC_UTILS_INT_PARSER) so
        // cache key includes
        // DEFAULT_INT_PARSER/NUMERIC_UTILS_INT_PARSER:
        try {
          return wrapper.getInts(reader, key.field, DEFAULT_INT_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getInts(reader, key.field, NUMERIC_UTILS_INT_PARSER, setDocsWithField);
        }
      }

      final HoldsOneThing<int[]> valuesRef = new HoldsOneThing<int[]>();

      Uninvert u = new Uninvert() {
          private int currentValue;
          private int[] values;

          @Override
          public void visitTerm(BytesRef term) {
            currentValue = parser.parseInt(term);
            if (values == null) {
              // Lazy alloc so for the numeric field case
              // (which will hit a NumberFormatException
              // when we first try the DEFAULT_INT_PARSER),
              // we don't double-alloc:
              values = new int[reader.maxDoc()];
              valuesRef.set(values);
            }
          }

          @Override
          public void visitDoc(int docID) {
            values[docID] = currentValue;
          }
          
          @Override
          protected TermsEnum termsEnum(Terms terms) throws IOException {
            return parser.termsEnum(terms);
          }
        };

      u.uninvert(reader, key.field, setDocsWithField);

      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, key.field, u.docsWithField);
      }
      int[] values = valuesRef.get();
      if (values == null) {
        values = new int[reader.maxDoc()];
      }
      return new IntsFromArray(values);
    }

(startLine=901 endLine=957 srcPath=/home/sonia/NewExperiment/luceneFilter/01858/lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java)
        throws IOException {

      final LongParser parser = (LongParser) key.custom;
      if (parser == null) {
        // Confusing: must delegate to wrapper (vs simply
        // setting parser =
        // DEFAULT_LONG_PARSER/NUMERIC_UTILS_LONG_PARSER) so
        // cache key includes
        // DEFAULT_LONG_PARSER/NUMERIC_UTILS_LONG_PARSER:
        try {
          return wrapper.getLongs(reader, key.field, DEFAULT_LONG_PARSER, setDocsWithField);
        } catch (NumberFormatException ne) {
          return wrapper.getLongs(reader, key.field, NUMERIC_UTILS_LONG_PARSER, setDocsWithField);
        }
      }

      final HoldsOneThing<long[]> valuesRef = new HoldsOneThing<long[]>();

      Uninvert u = new Uninvert() {
          private long currentValue;
          private long[] values;

          @Override
          public void visitTerm(BytesRef term) {
            currentValue = parser.parseLong(term);
            if (values == null) {
              // Lazy alloc so for the numeric field case
              // (which will hit a NumberFormatException
              // when we first try the DEFAULT_INT_PARSER),
              // we don't double-alloc:
              values = new long[reader.maxDoc()];
              valuesRef.set(values);
            }
          }

          @Override
          public void visitDoc(int docID) {
            values[docID] = currentValue;
          }
          
          @Override
          protected TermsEnum termsEnum(Terms terms) throws IOException {
            return parser.termsEnum(terms);
          }
        };

      u.uninvert(reader, key.field, setDocsWithField);

      if (setDocsWithField) {
        wrapper.setDocsWithField(reader, key.field, u.docsWithField);
      }
      long[] values = valuesRef.get();
      if (values == null) {
        values = new long[reader.maxDoc()];
      }
      return new LongsFromArray(values);
    }

commonMethod: 
(startLine=133 endLine=137 srcPath=/home/sonia/NewExperiment/luceneFilter/01859/lucene/core/src/java/org/apache/lucene/util/packed/GrowableWriter.java)
  @Override
  public void fill(int fromIndex, int toIndex, long val) {
    ensureCapacity(val);
    current.fill(fromIndex, toIndex, val);
  }


, Instance #
frags: 
(startLine=56 endLine=77 srcPath=/home/sonia/NewExperiment/luceneFilter/01859/solr/core/src/test/org/apache/solr/core/SolrCoreCheckLockOnStartupTest.java)
  public void testSimpleLockErrorOnStartup() throws Exception {

    Directory directory = newFSDirectory(new File(dataDir, "index"), new SimpleFSLockFactory());
    //creates a new IndexWriter without releasing the lock yet
    IndexWriter indexWriter = new IndexWriter(directory, new IndexWriterConfig(Version.LUCENE_40, null));

    try {
      //opening a new core on the same index
      initCore("solrconfig-simplelock.xml", "schema.xml");
      fail("Expected " + LockObtainFailedException.class.getSimpleName());
    } catch (Throwable t) {
      assertTrue(t instanceof RuntimeException);
      assertNotNull(t.getCause());
      assertTrue(t.getCause() instanceof RuntimeException);
      assertNotNull(t.getCause().getCause());
      assertTrue(t.getCause().getCause().toString(), t.getCause().getCause() instanceof LockObtainFailedException);
    } finally {
      indexWriter.close();
      directory.close();
      deleteCore();
    }
  }

(startLine=80 endLine=101 srcPath=/home/sonia/NewExperiment/luceneFilter/01859/solr/core/src/test/org/apache/solr/core/SolrCoreCheckLockOnStartupTest.java)
  public void testNativeLockErrorOnStartup() throws Exception {

    Directory directory = newFSDirectory(new File(dataDir, "index"), new NativeFSLockFactory());
    //creates a new IndexWriter without releasing the lock yet
    IndexWriter indexWriter = new IndexWriter(directory, new IndexWriterConfig(Version.LUCENE_40, null));

    try {
      //opening a new core on the same index
      initCore("solrconfig-nativelock.xml", "schema.xml");
      fail("Expected " + LockObtainFailedException.class.getSimpleName());
    } catch(Throwable t) {
      assertTrue(t instanceof RuntimeException);
      assertNotNull(t.getCause());
      assertTrue(t.getCause() instanceof RuntimeException);
      assertNotNull(t.getCause().getCause());
      assertTrue(t.getCause().getCause() instanceof  LockObtainFailedException);
    } finally {
      indexWriter.close();
      directory.close();
      deleteCore();
    }
  }

commonMethod: 
(startLine=99 endLine=107 srcPath=/home/sonia/NewExperiment/luceneFilter/01860/solr/core/src/test/org/apache/solr/core/SolrCoreCheckLockOnStartupTest.java)
  private boolean checkForCoreInitException(Class<? extends Exception> clazz) {
    for (Map.Entry<String, Exception> entry : h.getCoreContainer().getCoreInitFailures().entrySet()) {
      for (Throwable t = entry.getValue(); t != null; t = t.getCause()) {
        if (clazz.isInstance(t))
          return true;
      }
    }
    return false;
  }


, Instance #
frags: 
(startLine=56 endLine=77 srcPath=/home/sonia/NewExperiment/luceneFilter/01867/solr/core/src/test/org/apache/solr/core/SolrCoreCheckLockOnStartupTest.java)
  public void testSimpleLockErrorOnStartup() throws Exception {

    Directory directory = newFSDirectory(new File(dataDir, "index"), new SimpleFSLockFactory());
    //creates a new IndexWriter without releasing the lock yet
    IndexWriter indexWriter = new IndexWriter(directory, new IndexWriterConfig(Version.LUCENE_40, null));

    try {
      //opening a new core on the same index
      initCore("solrconfig-simplelock.xml", "schema.xml");
      fail("Expected " + LockObtainFailedException.class.getSimpleName());
    } catch (Throwable t) {
      assertTrue(t instanceof RuntimeException);
      assertNotNull(t.getCause());
      assertTrue(t.getCause() instanceof RuntimeException);
      assertNotNull(t.getCause().getCause());
      assertTrue(t.getCause().getCause().toString(), t.getCause().getCause() instanceof LockObtainFailedException);
    } finally {
      indexWriter.close();
      directory.close();
      deleteCore();
    }
  }

(startLine=80 endLine=101 srcPath=/home/sonia/NewExperiment/luceneFilter/01867/solr/core/src/test/org/apache/solr/core/SolrCoreCheckLockOnStartupTest.java)
  public void testNativeLockErrorOnStartup() throws Exception {

    Directory directory = newFSDirectory(new File(dataDir, "index"), new NativeFSLockFactory());
    //creates a new IndexWriter without releasing the lock yet
    IndexWriter indexWriter = new IndexWriter(directory, new IndexWriterConfig(Version.LUCENE_40, null));

    try {
      //opening a new core on the same index
      initCore("solrconfig-nativelock.xml", "schema.xml");
      fail("Expected " + LockObtainFailedException.class.getSimpleName());
    } catch(Throwable t) {
      assertTrue(t instanceof RuntimeException);
      assertNotNull(t.getCause());
      assertTrue(t.getCause() instanceof RuntimeException);
      assertNotNull(t.getCause().getCause());
      assertTrue(t.getCause().getCause() instanceof  LockObtainFailedException);
    } finally {
      indexWriter.close();
      directory.close();
      deleteCore();
    }
  }

commonMethod: 
(startLine=99 endLine=107 srcPath=/home/sonia/NewExperiment/luceneFilter/01868/solr/core/src/test/org/apache/solr/core/SolrCoreCheckLockOnStartupTest.java)
  private boolean checkForCoreInitException(Class<? extends Exception> clazz) {
    for (Map.Entry<String, Exception> entry : h.getCoreContainer().getCoreInitFailures().entrySet()) {
      for (Throwable t = entry.getValue(); t != null; t = t.getCause()) {
        if (clazz.isInstance(t))
          return true;
      }
    }
    return false;
  }


, Instance #
frags: 
(startLine=205 endLine=257 srcPath=/home/sonia/NewExperiment/luceneFilter/01876/solr/test-framework/src/java/org/apache/solr/util/RestTestBase.java)
  public static void assertJQ(String request, double delta, String... tests) throws Exception {
    int queryStartPos = request.indexOf('?');
    String query;
    String path;
    if (-1 == queryStartPos) {
      query = "";
      path = request;
    } else {
      query = request.substring(queryStartPos + 1);
      path = request.substring(0, queryStartPos);
    }
    query = setParam(query, "wt", "json");
    request = path + '?' + setParam(query, "indent", "on");

    String response;
    boolean failed = true;
    try {
      response = restTestHarness.query(request);
      failed = false;
    } finally {
      if (failed) {
        log.error("REQUEST FAILED: " + request);
      }
    }

    for (String test : tests) {
      if (null == test || 0 == test.length()) continue;
      String testJSON = test.replaceAll("(?<!\\\\)\'", "\"");
      testJSON = testJSON.replaceAll("\\\\\'", "'");

      try {
        failed = true;
        String err = JSONTestUtil.match(response, testJSON, delta);
        failed = false;
        if (err != null) {
          log.error("query failed JSON validation. error=" + err +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
          throw new RuntimeException(err);
        }
      } finally {
        if (failed) {
          log.error("JSON query validation threw an exception." +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
        }
      }
    }
  }

(startLine=287 endLine=339 srcPath=/home/sonia/NewExperiment/luceneFilter/01876/solr/test-framework/src/java/org/apache/solr/util/RestTestBase.java)
  public static void assertJPut(String request, String content, double delta, String... tests) throws Exception {
    int queryStartPos = request.indexOf('?');
    String query;
    String path;
    if (-1 == queryStartPos) {
      query = "";
      path = request;
    } else {
      query = request.substring(queryStartPos + 1);
      path = request.substring(0, queryStartPos);
    }
    query = setParam(query, "wt", "json");
    request = path + '?' + setParam(query, "indent", "on");

    String response;
    boolean failed = true;
    try {
      response = restTestHarness.put(request, content);
      failed = false;
    } finally {
      if (failed) {
        log.error("REQUEST FAILED: " + request);
      }
    }

    for (String test : tests) {
      if (null == test || 0 == test.length()) continue;
      String testJSON = test.replaceAll("(?<!\\\\)\'", "\"");
      testJSON = testJSON.replaceAll("\\\\\'", "'");

      try {
        failed = true;
        String err = JSONTestUtil.match(response, testJSON, delta);
        failed = false;
        if (err != null) {
          log.error("query failed JSON validation. error=" + err +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
          throw new RuntimeException(err);
        }
      } finally {
        if (failed) {
          log.error("JSON query validation threw an exception." +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
        }
      }
    }
  }

(startLine=367 endLine=419 srcPath=/home/sonia/NewExperiment/luceneFilter/01876/solr/test-framework/src/java/org/apache/solr/util/RestTestBase.java)
  public static void assertJPost(String request, String content, double delta, String... tests) throws Exception {
    int queryStartPos = request.indexOf('?');
    String query;
    String path;
    if (-1 == queryStartPos) {
      query = "";
      path = request;
    } else {
      query = request.substring(queryStartPos + 1);
      path = request.substring(0, queryStartPos);
    }
    query = setParam(query, "wt", "json");
    request = path + '?' + setParam(query, "indent", "on");

    String response;
    boolean failed = true;
    try {
      response = restTestHarness.post(request, content);
      failed = false;
    } finally {
      if (failed) {
        log.error("REQUEST FAILED: " + request);
      }
    }

    for (String test : tests) {
      if (null == test || 0 == test.length()) continue;
      String testJSON = test.replaceAll("(?<!\\\\)\'", "\"");
      testJSON = testJSON.replaceAll("\\\\\'", "'");

      try {
        failed = true;
        String err = JSONTestUtil.match(response, testJSON, delta);
        failed = false;
        if (err != null) {
          log.error("query failed JSON validation. error=" + err +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
          throw new RuntimeException(err);
        }
      } finally {
        if (failed) {
          log.error("JSON query validation threw an exception." +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
        }
      }
    }
  }

commonMethod: 
(startLine=939 endLine=952 srcPath=/home/sonia/NewExperiment/luceneFilter/01877/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java)
  /** Converts "test JSON" and returns standard JSON.
   *  Currently this only consists of changing unescaped single quotes to double quotes,
   *  and escaped single quotes to single quotes.
   *
   * The primary purpose is to be able to easily embed JSON strings in a JAVA string
   * with the best readability.
   *
   * This transformation is automatically applied to JSON test srings (like assertJQ).
   */
  public static String json(String testJSON) {
    testJSON = nonEscapedSingleQuotePattern.matcher(testJSON).replaceAll("\"");
    testJSON = escapedSingleQuotePattern.matcher(testJSON).replaceAll("'");
    return testJSON;
  }


, Instance #
frags: 
(startLine=230 endLine=256 srcPath=/home/sonia/NewExperiment/luceneFilter/01876/solr/test-framework/src/java/org/apache/solr/util/RestTestBase.java)
    for (String test : tests) {
      if (null == test || 0 == test.length()) continue;
      String testJSON = test.replaceAll("(?<!\\\\)\'", "\"");
      testJSON = testJSON.replaceAll("\\\\\'", "'");

      try {
        failed = true;
        String err = JSONTestUtil.match(response, testJSON, delta);
        failed = false;
        if (err != null) {
          log.error("query failed JSON validation. error=" + err +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
          throw new RuntimeException(err);
        }
      } finally {
        if (failed) {
          log.error("JSON query validation threw an exception." +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
        }
      }
    }

(startLine=312 endLine=338 srcPath=/home/sonia/NewExperiment/luceneFilter/01876/solr/test-framework/src/java/org/apache/solr/util/RestTestBase.java)
    for (String test : tests) {
      if (null == test || 0 == test.length()) continue;
      String testJSON = test.replaceAll("(?<!\\\\)\'", "\"");
      testJSON = testJSON.replaceAll("\\\\\'", "'");

      try {
        failed = true;
        String err = JSONTestUtil.match(response, testJSON, delta);
        failed = false;
        if (err != null) {
          log.error("query failed JSON validation. error=" + err +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
          throw new RuntimeException(err);
        }
      } finally {
        if (failed) {
          log.error("JSON query validation threw an exception." +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
        }
      }
    }

(startLine=392 endLine=418 srcPath=/home/sonia/NewExperiment/luceneFilter/01876/solr/test-framework/src/java/org/apache/solr/util/RestTestBase.java)
    for (String test : tests) {
      if (null == test || 0 == test.length()) continue;
      String testJSON = test.replaceAll("(?<!\\\\)\'", "\"");
      testJSON = testJSON.replaceAll("\\\\\'", "'");

      try {
        failed = true;
        String err = JSONTestUtil.match(response, testJSON, delta);
        failed = false;
        if (err != null) {
          log.error("query failed JSON validation. error=" + err +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
          throw new RuntimeException(err);
        }
      } finally {
        if (failed) {
          log.error("JSON query validation threw an exception." +
              "\n expected =" + testJSON +
              "\n response = " + response +
              "\n request = " + request + "\n"
          );
        }
      }
    }

commonMethod: 
(startLine=939 endLine=952 srcPath=/home/sonia/NewExperiment/luceneFilter/01877/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java)
  /** Converts "test JSON" and returns standard JSON.
   *  Currently this only consists of changing unescaped single quotes to double quotes,
   *  and escaped single quotes to single quotes.
   *
   * The primary purpose is to be able to easily embed JSON strings in a JAVA string
   * with the best readability.
   *
   * This transformation is automatically applied to JSON test srings (like assertJQ).
   */
  public static String json(String testJSON) {
    testJSON = nonEscapedSingleQuotePattern.matcher(testJSON).replaceAll("\"");
    testJSON = escapedSingleQuotePattern.matcher(testJSON).replaceAll("'");
    return testJSON;
  }


, Instance #
frags: 
(startLine=1279 endLine=1300 srcPath=/home/sonia/NewExperiment/luceneFilter/01909/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java)
  public void updateDocuments(Term delTerm, Iterable<? extends IndexDocument> docs, Analyzer analyzer) throws IOException {
    ensureOpen();
    try {
      boolean success = false;
      boolean anySegmentFlushed = false;
      try {
        anySegmentFlushed = docWriter.updateDocuments(docs, analyzer, delTerm);
        success = true;
      } finally {
        if (!success) {
          if (infoStream.isEnabled("IW")) {
            infoStream.message("IW", "hit exception updating document");
          }
        }
      }
      if (anySegmentFlushed) {
        maybeMerge(MergeTrigger.SEGMENT_FLUSH, UNBOUNDED_MAX_MERGE_SEGMENTS);
      }
    } catch (OutOfMemoryError oom) {
      handleOOM(oom, "updateDocuments");
    }
  }

(startLine=1504 endLine=1526 srcPath=/home/sonia/NewExperiment/luceneFilter/01909/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java)
      throws IOException {
    ensureOpen();
    try {
      boolean success = false;
      boolean anySegmentFlushed = false;
      try {
        anySegmentFlushed = docWriter.updateDocument(doc, analyzer, term);
        success = true;
      } finally {
        if (!success) {
          if (infoStream.isEnabled("IW")) {
            infoStream.message("IW", "hit exception updating document");
          }
        }
      }

      if (anySegmentFlushed) {
        maybeMerge(MergeTrigger.SEGMENT_FLUSH, UNBOUNDED_MAX_MERGE_SEGMENTS);
      }
    } catch (OutOfMemoryError oom) {
      handleOOM(oom, "updateDocument");
    }
  }

commonMethod: 
(startLine=4351 endLine=4353 srcPath=/home/sonia/NewExperiment/luceneFilter/01910/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java)
  private boolean processEvents(boolean triggerMerge, boolean forcePurge) throws IOException {
    return processEvents(eventQueue, triggerMerge, forcePurge);
  }


, Instance #
frags: 
(startLine=1279 endLine=1300 srcPath=/home/sonia/NewExperiment/luceneFilter/01909/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java)
  public void updateDocuments(Term delTerm, Iterable<? extends IndexDocument> docs, Analyzer analyzer) throws IOException {
    ensureOpen();
    try {
      boolean success = false;
      boolean anySegmentFlushed = false;
      try {
        anySegmentFlushed = docWriter.updateDocuments(docs, analyzer, delTerm);
        success = true;
      } finally {
        if (!success) {
          if (infoStream.isEnabled("IW")) {
            infoStream.message("IW", "hit exception updating document");
          }
        }
      }
      if (anySegmentFlushed) {
        maybeMerge(MergeTrigger.SEGMENT_FLUSH, UNBOUNDED_MAX_MERGE_SEGMENTS);
      }
    } catch (OutOfMemoryError oom) {
      handleOOM(oom, "updateDocuments");
    }
  }

(startLine=1504 endLine=1526 srcPath=/home/sonia/NewExperiment/luceneFilter/01909/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java)
      throws IOException {
    ensureOpen();
    try {
      boolean success = false;
      boolean anySegmentFlushed = false;
      try {
        anySegmentFlushed = docWriter.updateDocument(doc, analyzer, term);
        success = true;
      } finally {
        if (!success) {
          if (infoStream.isEnabled("IW")) {
            infoStream.message("IW", "hit exception updating document");
          }
        }
      }

      if (anySegmentFlushed) {
        maybeMerge(MergeTrigger.SEGMENT_FLUSH, UNBOUNDED_MAX_MERGE_SEGMENTS);
      }
    } catch (OutOfMemoryError oom) {
      handleOOM(oom, "updateDocument");
    }
  }

commonMethod: 
(startLine=4351 endLine=4353 srcPath=/home/sonia/NewExperiment/luceneFilter/01910/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java)
  private boolean processEvents(boolean triggerMerge, boolean forcePurge) throws IOException {
    return processEvents(eventQueue, triggerMerge, forcePurge);
  }


, Instance #
frags: 
(startLine=157 endLine=167 srcPath=/home/sonia/NewExperiment/luceneFilter/01911/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java)
          if (type == DocValuesType.NUMERIC) {
            List<NumericDocValues> toMerge = new ArrayList<NumericDocValues>();
            for (AtomicReader reader : mergeState.readers) {
              NumericDocValues values = reader.getNumericDocValues(field.name);
              if (values == null) {
                values = NumericDocValues.EMPTY;
              }
              toMerge.add(values);
            }
            consumer.mergeNumericField(field, mergeState, toMerge);
          } else if (type == DocValuesType.BINARY) {

(startLine=167 endLine=177 srcPath=/home/sonia/NewExperiment/luceneFilter/01911/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java)
          } else if (type == DocValuesType.BINARY) {
            List<BinaryDocValues> toMerge = new ArrayList<BinaryDocValues>();
            for (AtomicReader reader : mergeState.readers) {
              BinaryDocValues values = reader.getBinaryDocValues(field.name);
              if (values == null) {
                values = BinaryDocValues.EMPTY;
              }
              toMerge.add(values);
            }
            consumer.mergeBinaryField(field, mergeState, toMerge);
          } else if (type == DocValuesType.SORTED) {

commonMethod: 
(startLine=211 endLine=215 srcPath=/home/sonia/NewExperiment/luceneFilter/01912/lucene/core/src/java/org/apache/lucene/index/AtomicReader.java)
  /** Returns a {@link Bits} at the size of <code>reader.maxDoc()</code>, 
   *  with turned on bits for each docid that does have a value for this field,
   *  or null if no DocValues were indexed for this field. The
   *  returned instance should only be used by a single thread */
  public abstract Bits getDocsWithField(String field) throws IOException;


, Instance #
frags: 
(startLine=157 endLine=167 srcPath=/home/sonia/NewExperiment/luceneFilter/01911/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java)
          if (type == DocValuesType.NUMERIC) {
            List<NumericDocValues> toMerge = new ArrayList<NumericDocValues>();
            for (AtomicReader reader : mergeState.readers) {
              NumericDocValues values = reader.getNumericDocValues(field.name);
              if (values == null) {
                values = NumericDocValues.EMPTY;
              }
              toMerge.add(values);
            }
            consumer.mergeNumericField(field, mergeState, toMerge);
          } else if (type == DocValuesType.BINARY) {

(startLine=167 endLine=177 srcPath=/home/sonia/NewExperiment/luceneFilter/01911/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java)
          } else if (type == DocValuesType.BINARY) {
            List<BinaryDocValues> toMerge = new ArrayList<BinaryDocValues>();
            for (AtomicReader reader : mergeState.readers) {
              BinaryDocValues values = reader.getBinaryDocValues(field.name);
              if (values == null) {
                values = BinaryDocValues.EMPTY;
              }
              toMerge.add(values);
            }
            consumer.mergeBinaryField(field, mergeState, toMerge);
          } else if (type == DocValuesType.SORTED) {

commonMethod: 
(startLine=211 endLine=215 srcPath=/home/sonia/NewExperiment/luceneFilter/01912/lucene/core/src/java/org/apache/lucene/index/AtomicReader.java)
  /** Returns a {@link Bits} at the size of <code>reader.maxDoc()</code>, 
   *  with turned on bits for each docid that does have a value for this field,
   *  or null if no DocValues were indexed for this field. The
   *  returned instance should only be used by a single thread */
  public abstract Bits getDocsWithField(String field) throws IOException;


, Instance #
frags: 
(startLine=229 endLine=250 srcPath=/home/sonia/NewExperiment/luceneFilter/01919/lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41PostingsReader.java)
    if (isFirstTerm) {
      if (termState.docFreq == 1) {
        termState.singletonDocID = in.readVInt();
        termState.docStartFP = 0;
      } else {
        termState.singletonDocID = -1;
        termState.docStartFP = in.readVLong();
      }
      if (fieldHasPositions) {
        termState.posStartFP = in.readVLong();
        if (termState.totalTermFreq > BLOCK_SIZE) {
          termState.lastPosBlockOffset = in.readVLong();
        } else {
          termState.lastPosBlockOffset = -1;
        }
        if ((fieldHasPayloads || fieldHasOffsets) && termState.totalTermFreq >= BLOCK_SIZE) {
          termState.payStartFP = in.readVLong();
        } else {
          termState.payStartFP = -1;
        }
      }
    } else {

(startLine=250 endLine=273 srcPath=/home/sonia/NewExperiment/luceneFilter/01919/lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41PostingsReader.java)
    } else {
      if (termState.docFreq == 1) {
        termState.singletonDocID = in.readVInt();
      } else {
        termState.singletonDocID = -1;
        termState.docStartFP += in.readVLong();
      }
      if (fieldHasPositions) {
        termState.posStartFP += in.readVLong();
        if (termState.totalTermFreq > BLOCK_SIZE) {
          termState.lastPosBlockOffset = in.readVLong();
        } else {
          termState.lastPosBlockOffset = -1;
        }
        if ((fieldHasPayloads || fieldHasOffsets) && termState.totalTermFreq >= BLOCK_SIZE) {
          long delta = in.readVLong();
          if (termState.payStartFP == -1) {
            termState.payStartFP = delta;
          } else {
            termState.payStartFP += delta;
          }
        }
      }
    }

commonMethod: 
(startLine=191 endLine=217 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41PostingsReader.java)
  private void _decodeTerm(DataInput in, FieldInfo fieldInfo, IntBlockTermState termState) throws IOException {
    final boolean fieldHasPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
    final boolean fieldHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
    final boolean fieldHasPayloads = fieldInfo.hasPayloads();
    if (termState.docFreq == 1) {
      termState.singletonDocID = in.readVInt();
    } else {
      termState.singletonDocID = -1;
      termState.docStartFP += in.readVLong();
    }
    if (fieldHasPositions) {
      termState.posStartFP += in.readVLong();
      if (termState.totalTermFreq > BLOCK_SIZE) {
        termState.lastPosBlockOffset = in.readVLong();
      } else {
        termState.lastPosBlockOffset = -1;
      }
      if ((fieldHasPayloads || fieldHasOffsets) && termState.totalTermFreq >= BLOCK_SIZE) {
        termState.payStartFP += in.readVLong();
      }
    }
    if (termState.docFreq > BLOCK_SIZE) {
      termState.skipOffset = in.readVLong();
    } else {
      termState.skipOffset = -1;
    }
  }


, Instance #
frags: 
(startLine=237 endLine=249 srcPath=/home/sonia/NewExperiment/luceneFilter/01919/lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41PostingsReader.java)
      if (fieldHasPositions) {
        termState.posStartFP = in.readVLong();
        if (termState.totalTermFreq > BLOCK_SIZE) {
          termState.lastPosBlockOffset = in.readVLong();
        } else {
          termState.lastPosBlockOffset = -1;
        }
        if ((fieldHasPayloads || fieldHasOffsets) && termState.totalTermFreq >= BLOCK_SIZE) {
          termState.payStartFP = in.readVLong();
        } else {
          termState.payStartFP = -1;
        }
      }

(startLine=257 endLine=272 srcPath=/home/sonia/NewExperiment/luceneFilter/01919/lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41PostingsReader.java)
      if (fieldHasPositions) {
        termState.posStartFP += in.readVLong();
        if (termState.totalTermFreq > BLOCK_SIZE) {
          termState.lastPosBlockOffset = in.readVLong();
        } else {
          termState.lastPosBlockOffset = -1;
        }
        if ((fieldHasPayloads || fieldHasOffsets) && termState.totalTermFreq >= BLOCK_SIZE) {
          long delta = in.readVLong();
          if (termState.payStartFP == -1) {
            termState.payStartFP = delta;
          } else {
            termState.payStartFP += delta;
          }
        }
      }

commonMethod: 
(startLine=191 endLine=217 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/lucene/core/src/java/org/apache/lucene/codecs/lucene41/Lucene41PostingsReader.java)
  private void _decodeTerm(DataInput in, FieldInfo fieldInfo, IntBlockTermState termState) throws IOException {
    final boolean fieldHasPositions = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
    final boolean fieldHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
    final boolean fieldHasPayloads = fieldInfo.hasPayloads();
    if (termState.docFreq == 1) {
      termState.singletonDocID = in.readVInt();
    } else {
      termState.singletonDocID = -1;
      termState.docStartFP += in.readVLong();
    }
    if (fieldHasPositions) {
      termState.posStartFP += in.readVLong();
      if (termState.totalTermFreq > BLOCK_SIZE) {
        termState.lastPosBlockOffset = in.readVLong();
      } else {
        termState.lastPosBlockOffset = -1;
      }
      if ((fieldHasPayloads || fieldHasOffsets) && termState.totalTermFreq >= BLOCK_SIZE) {
        termState.payStartFP += in.readVLong();
      }
    }
    if (termState.docFreq > BLOCK_SIZE) {
      termState.skipOffset = in.readVLong();
    } else {
      termState.skipOffset = -1;
    }
  }


, Instance #
frags: 
(startLine=116 endLine=129 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testIntSort() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "intdv", "-1"));
    assertU(adoc("id", "2", "intdv", "4"));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", "intdv asc"),
        "//result/doc[1]/str[@name='id'][.=1]",
        "//result/doc[2]/str[@name='id'][.=0]",
        "//result/doc[3]/str[@name='id'][.=2]");
    assertQ(req("q", "*:*", "sort", "intdv desc"),
        "//result/doc[1]/str[@name='id'][.=2]",
        "//result/doc[2]/str[@name='id'][.=0]",
        "//result/doc[3]/str[@name='id'][.=1]");
  }

(startLine=189 endLine=202 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testDoubleSort() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "doubledv", "-1.3"));
    assertU(adoc("id", "2", "doubledv", "4.2"));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", "doubledv asc"),
        "//result/doc[1]/str[@name='id'][.=1]",
        "//result/doc[2]/str[@name='id'][.=0]",
        "//result/doc[3]/str[@name='id'][.=2]");
    assertQ(req("q", "*:*", "sort", "doubledv desc"),
        "//result/doc[1]/str[@name='id'][.=2]",
        "//result/doc[2]/str[@name='id'][.=0]",
        "//result/doc[3]/str[@name='id'][.=1]");
  }

(startLine=262 endLine=275 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testLongSort() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "longdv", "-1"));
    assertU(adoc("id", "2", "longdv", "4"));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", "longdv asc"),
        "//result/doc[1]/str[@name='id'][.=1]",
        "//result/doc[2]/str[@name='id'][.=0]",
        "//result/doc[3]/str[@name='id'][.=2]");
    assertQ(req("q", "*:*", "sort", "longdv desc"),
        "//result/doc[1]/str[@name='id'][.=2]",
        "//result/doc[2]/str[@name='id'][.=0]",
        "//result/doc[3]/str[@name='id'][.=1]");
  }

commonMethod: 
(startLine=42 endLine=58 srcPath=/home/sonia/NewExperiment/luceneFilter/01921/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  /** numeric default lucene sort (relative to presumed default value of 0) */
  private void checkSortMissingDefault(final String field,
                                       final String negative,
                                       final String positive) {
      assertU(adoc("id", "0")); // missing
      assertU(adoc("id", "1", field, negative));
      assertU(adoc("id", "2", field, positive));
      assertU(commit());
      assertQ(req("q", "*:*", "sort", field+" asc"),
              "//result/doc[1]/str[@name='id'][.=1]",
              "//result/doc[2]/str[@name='id'][.=0]",
              "//result/doc[3]/str[@name='id'][.=2]");
      assertQ(req("q", "*:*", "sort", field+" desc"),
              "//result/doc[1]/str[@name='id'][.=2]",
              "//result/doc[2]/str[@name='id'][.=0]",
              "//result/doc[3]/str[@name='id'][.=1]");
  }


, Instance #
frags: 
(startLine=148 endLine=161 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testIntSortMissingLast() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "intdv_missinglast", "-1"));
    assertU(adoc("id", "2", "intdv_missinglast", "4"));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", "intdv_missinglast asc"),
        "//result/doc[1]/str[@name='id'][.=1]",
        "//result/doc[2]/str[@name='id'][.=2]",
        "//result/doc[3]/str[@name='id'][.=0]");
    assertQ(req("q", "*:*", "sort", "intdv_missinglast desc"),
        "//result/doc[1]/str[@name='id'][.=2]",
        "//result/doc[2]/str[@name='id'][.=1]",
        "//result/doc[3]/str[@name='id'][.=0]");
  }

(startLine=221 endLine=234 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testDoubleSortMissingLast() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "doubledv_missinglast", "-1.3"));
    assertU(adoc("id", "2", "doubledv_missinglast", "4.2"));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", "doubledv_missinglast asc"),
        "//result/doc[1]/str[@name='id'][.=1]",
        "//result/doc[2]/str[@name='id'][.=2]",
        "//result/doc[3]/str[@name='id'][.=0]");
    assertQ(req("q", "*:*", "sort", "doubledv_missinglast desc"),
        "//result/doc[1]/str[@name='id'][.=2]",
        "//result/doc[2]/str[@name='id'][.=1]",
        "//result/doc[3]/str[@name='id'][.=0]");
  }

(startLine=294 endLine=307 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testLongSortMissingLast() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "longdv_missinglast", "-1"));
    assertU(adoc("id", "2", "longdv_missinglast", "4"));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", "longdv_missinglast asc"),
        "//result/doc[1]/str[@name='id'][.=1]",
        "//result/doc[2]/str[@name='id'][.=2]",
        "//result/doc[3]/str[@name='id'][.=0]");
    assertQ(req("q", "*:*", "sort", "longdv_missinglast desc"),
        "//result/doc[1]/str[@name='id'][.=2]",
        "//result/doc[2]/str[@name='id'][.=1]",
        "//result/doc[3]/str[@name='id'][.=0]");
  }

(startLine=440 endLine=453 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testStringSortMissingLast() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "stringdv_missinglast", "a"));
    assertU(adoc("id", "2", "stringdv_missinglast", "z"));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", "stringdv_missinglast asc"),
        "//result/doc[1]/str[@name='id'][.=1]",
        "//result/doc[2]/str[@name='id'][.=2]",
        "//result/doc[3]/str[@name='id'][.=0]");
    assertQ(req("q", "*:*", "sort", "stringdv_missinglast desc"),
        "//result/doc[1]/str[@name='id'][.=2]",
        "//result/doc[2]/str[@name='id'][.=1]",
        "//result/doc[3]/str[@name='id'][.=0]");
  }

commonMethod: 
(startLine=78 endLine=96 srcPath=/home/sonia/NewExperiment/luceneFilter/01921/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  /** sort missing always last */
  private void checkSortMissingLast(final String field,
                                    final String low,
                                    final String high) {

    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", field, low));
    assertU(adoc("id", "2", field, high));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", field+" asc"),
            "//result/doc[1]/str[@name='id'][.=1]",
            "//result/doc[2]/str[@name='id'][.=2]",
            "//result/doc[3]/str[@name='id'][.=0]");
    assertQ(req("q", "*:*", "sort", field+" desc"),
            "//result/doc[1]/str[@name='id'][.=2]",
            "//result/doc[2]/str[@name='id'][.=1]",
            "//result/doc[3]/str[@name='id'][.=0]");
    
  }


, Instance #
frags: 
(startLine=91 endLine=100 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testFloatMissingFunction() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "floatdv", "-1.3"));
    assertU(adoc("id", "2", "floatdv", "4.2"));
    assertU(commit());
    assertQ(req("q", "*:*", "fl", "e:exists(floatdv)", "sort", "id asc"),
        "//result/doc[1]/bool[@name='e'][.='false']",
        "//result/doc[2]/bool[@name='e'][.='true']",
        "//result/doc[3]/bool[@name='e'][.='true']");
  }

(startLine=164 endLine=173 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testIntMissingFunction() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "intdv", "-1"));
    assertU(adoc("id", "2", "intdv", "4"));
    assertU(commit());
    assertQ(req("q", "*:*", "fl", "e:exists(intdv)", "sort", "id asc"),
        "//result/doc[1]/bool[@name='e'][.='false']",
        "//result/doc[2]/bool[@name='e'][.='true']",
        "//result/doc[3]/bool[@name='e'][.='true']");
  }

(startLine=237 endLine=246 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testDoubleMissingFunction() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "doubledv", "-1.3"));
    assertU(adoc("id", "2", "doubledv", "4.2"));
    assertU(commit());
    assertQ(req("q", "*:*", "fl", "e:exists(doubledv)", "sort", "id asc"),
        "//result/doc[1]/bool[@name='e'][.='false']",
        "//result/doc[2]/bool[@name='e'][.='true']",
        "//result/doc[3]/bool[@name='e'][.='true']");
  }

(startLine=310 endLine=319 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testLongMissingFunction() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "longdv", "-1"));
    assertU(adoc("id", "2", "longdv", "4"));
    assertU(commit());
    assertQ(req("q", "*:*", "fl", "e:exists(longdv)", "sort", "id asc"),
        "//result/doc[1]/bool[@name='e'][.='false']",
        "//result/doc[2]/bool[@name='e'][.='true']",
        "//result/doc[3]/bool[@name='e'][.='true']");
  }

(startLine=456 endLine=465 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testStringMissingFunction() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "stringdv", "a"));
    assertU(adoc("id", "2", "stringdv", "z"));
    assertU(commit());
    assertQ(req("q", "*:*", "fl", "e:exists(stringdv)", "sort", "id asc"),
        "//result/doc[1]/bool[@name='e'][.='false']",
        "//result/doc[2]/bool[@name='e'][.='true']",
        "//result/doc[3]/bool[@name='e'][.='true']");
  }

commonMethod: 
(startLine=98 endLine=110 srcPath=/home/sonia/NewExperiment/luceneFilter/01921/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  /** function query based on missing */
  private void checkSortMissingFunction(final String field,
                                        final String low,
                                        final String high) {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", field, low));
    assertU(adoc("id", "2", field, high));
    assertU(commit());
    assertQ(req("q", "*:*", "fl", "e:exists("+field+")", "sort", "id asc"),
            "//result/doc[1]/bool[@name='e'][.='false']",
            "//result/doc[2]/bool[@name='e'][.='true']",
            "//result/doc[3]/bool[@name='e'][.='true']");
  }


, Instance #
frags: 
(startLine=132 endLine=145 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testIntSortMissingFirst() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "intdv_missingfirst", "-1"));
    assertU(adoc("id", "2", "intdv_missingfirst", "4"));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", "intdv_missingfirst asc"),
        "//result/doc[1]/str[@name='id'][.=0]",
        "//result/doc[2]/str[@name='id'][.=1]",
        "//result/doc[3]/str[@name='id'][.=2]");
    assertQ(req("q", "*:*", "sort", "intdv_missingfirst desc"),
        "//result/doc[1]/str[@name='id'][.=0]",
        "//result/doc[2]/str[@name='id'][.=2]",
        "//result/doc[3]/str[@name='id'][.=1]");
  }

(startLine=205 endLine=218 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testDoubleSortMissingFirst() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "doubledv_missingfirst", "-1.3"));
    assertU(adoc("id", "2", "doubledv_missingfirst", "4.2"));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", "doubledv_missingfirst asc"),
        "//result/doc[1]/str[@name='id'][.=0]",
        "//result/doc[2]/str[@name='id'][.=1]",
        "//result/doc[3]/str[@name='id'][.=2]");
    assertQ(req("q", "*:*", "sort", "doubledv_missingfirst desc"),
        "//result/doc[1]/str[@name='id'][.=0]",
        "//result/doc[2]/str[@name='id'][.=2]",
        "//result/doc[3]/str[@name='id'][.=1]");
  }

(startLine=278 endLine=291 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testLongSortMissingFirst() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "longdv_missingfirst", "-1"));
    assertU(adoc("id", "2", "longdv_missingfirst", "4"));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", "longdv_missingfirst asc"),
        "//result/doc[1]/str[@name='id'][.=0]",
        "//result/doc[2]/str[@name='id'][.=1]",
        "//result/doc[3]/str[@name='id'][.=2]");
    assertQ(req("q", "*:*", "sort", "longdv_missingfirst desc"),
        "//result/doc[1]/str[@name='id'][.=0]",
        "//result/doc[2]/str[@name='id'][.=2]",
        "//result/doc[3]/str[@name='id'][.=1]");
  }

(startLine=424 endLine=437 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testStringSortMissingFirst() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", "stringdv_missingfirst", "a"));
    assertU(adoc("id", "2", "stringdv_missingfirst", "z"));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", "stringdv_missingfirst asc"),
        "//result/doc[1]/str[@name='id'][.=0]",
        "//result/doc[2]/str[@name='id'][.=1]",
        "//result/doc[3]/str[@name='id'][.=2]");
    assertQ(req("q", "*:*", "sort", "stringdv_missingfirst desc"),
        "//result/doc[1]/str[@name='id'][.=0]",
        "//result/doc[2]/str[@name='id'][.=2]",
        "//result/doc[3]/str[@name='id'][.=1]");
  }

commonMethod: 
(startLine=60 endLine=76 srcPath=/home/sonia/NewExperiment/luceneFilter/01921/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  /** sort missing always first */
  private void checkSortMissingFirst(final String field,
                                     final String low,
                                     final String high) {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1", field, low));
    assertU(adoc("id", "2", field, high));
    assertU(commit());
    assertQ(req("q", "*:*", "sort", field+" asc"),
            "//result/doc[1]/str[@name='id'][.=0]",
            "//result/doc[2]/str[@name='id'][.=1]",
            "//result/doc[3]/str[@name='id'][.=2]");
    assertQ(req("q", "*:*", "sort", field+" desc"),
            "//result/doc[1]/str[@name='id'][.=0]",
            "//result/doc[2]/str[@name='id'][.=2]",
            "//result/doc[3]/str[@name='id'][.=1]");
  }


, Instance #
frags: 
(startLine=103 endLine=113 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testFloatMissingFacet() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1")); // missing
    assertU(adoc("id", "2", "floatdv", "-1.3"));
    assertU(adoc("id", "3", "floatdv", "4.2"));
    assertU(commit());
    assertQ(req("q", "*:*", "facet", "true", "facet.field", "floatdv", "facet.mincount", "1", "facet.missing", "true"),
        "//lst[@name='facet_fields']/lst[@name='floatdv']/int[@name='-1.3'][.=1]",
        "//lst[@name='facet_fields']/lst[@name='floatdv']/int[@name='4.2'][.=1]",
        "//lst[@name='facet_fields']/lst[@name='floatdv']/int[.=2]");
  }

(startLine=176 endLine=186 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testIntMissingFacet() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1")); // missing
    assertU(adoc("id", "2", "intdv", "-1"));
    assertU(adoc("id", "3", "intdv", "4"));
    assertU(commit());
    assertQ(req("q", "*:*", "facet", "true", "facet.field", "intdv", "facet.mincount", "1", "facet.missing", "true"),
        "//lst[@name='facet_fields']/lst[@name='intdv']/int[@name='-1'][.=1]",
        "//lst[@name='facet_fields']/lst[@name='intdv']/int[@name='4'][.=1]",
        "//lst[@name='facet_fields']/lst[@name='intdv']/int[.=2]");
  }

(startLine=249 endLine=259 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testDoubleMissingFacet() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1")); // missing
    assertU(adoc("id", "2", "doubledv", "-1.3"));
    assertU(adoc("id", "3", "doubledv", "4.2"));
    assertU(commit());
    assertQ(req("q", "*:*", "facet", "true", "facet.field", "doubledv", "facet.mincount", "1", "facet.missing", "true"),
        "//lst[@name='facet_fields']/lst[@name='doubledv']/int[@name='-1.3'][.=1]",
        "//lst[@name='facet_fields']/lst[@name='doubledv']/int[@name='4.2'][.=1]",
        "//lst[@name='facet_fields']/lst[@name='doubledv']/int[.=2]");
  }

(startLine=322 endLine=332 srcPath=/home/sonia/NewExperiment/luceneFilter/01920/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  public void testLongMissingFacet() throws Exception {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1")); // missing
    assertU(adoc("id", "2", "longdv", "-1"));
    assertU(adoc("id", "3", "longdv", "4"));
    assertU(commit());
    assertQ(req("q", "*:*", "facet", "true", "facet.field", "longdv", "facet.mincount", "1", "facet.missing", "true"),
        "//lst[@name='facet_fields']/lst[@name='longdv']/int[@name='-1'][.=1]",
        "//lst[@name='facet_fields']/lst[@name='longdv']/int[@name='4'][.=1]",
        "//lst[@name='facet_fields']/lst[@name='longdv']/int[.=2]");
  }

commonMethod: 
(startLine=112 endLine=126 srcPath=/home/sonia/NewExperiment/luceneFilter/01921/solr/core/src/test/org/apache/solr/schema/DocValuesMissingTest.java)
  /** missing facet count */
  private void checkSortMissingFacet(final String field,
                                     final String low,
                                     final String high) {
    assertU(adoc("id", "0")); // missing
    assertU(adoc("id", "1")); // missing
    assertU(adoc("id", "2", field, low));
    assertU(adoc("id", "3", field, high));
    assertU(commit());
    assertQ(req("q", "*:*", "facet", "true", "facet.field", field, 
                "facet.mincount", "1", "facet.missing", "true"),
            "//lst[@name='facet_fields']/lst[@name='"+field+"']/int[@name='"+low+"'][.=1]",
            "//lst[@name='facet_fields']/lst[@name='"+field+"']/int[@name='"+high+"'][.=1]",
            "//lst[@name='facet_fields']/lst[@name='"+field+"']/int[.=2]");
  }


, Instance #
frags: 
(startLine=75 endLine=99 srcPath=/home/sonia/NewExperiment/luceneFilter/01945/lucene/core/src/java/org/apache/lucene/util/IOUtils.java)
  public static <E extends Exception> void closeWhileHandlingException(E priorException, Closeable... objects) throws E, IOException {
    Throwable th = null;

    for (Closeable object : objects) {
      try {
        if (object != null) {
          object.close();
        }
      } catch (Throwable t) {
        addSuppressed((priorException == null) ? th : priorException, t);
        if (th == null) {
          th = t;
        }
      }
    }

    if (priorException != null) {
      throw priorException;
    } else if (th != null) {
      if (th instanceof IOException) throw (IOException) th;
      if (th instanceof RuntimeException) throw (RuntimeException) th;
      if (th instanceof Error) throw (Error) th;
      throw new RuntimeException(th);
    }
  }

(startLine=104 endLine=128 srcPath=/home/sonia/NewExperiment/luceneFilter/01945/lucene/core/src/java/org/apache/lucene/util/IOUtils.java)
  public static <E extends Exception> void closeWhileHandlingException(E priorException, Iterable<? extends Closeable> objects) throws E, IOException {
    Throwable th = null;

    for (Closeable object : objects) {
      try {
        if (object != null) {
          object.close();
        }
      } catch (Throwable t) {
        addSuppressed((priorException == null) ? th : priorException, t);
        if (th == null) {
          th = t;
        }
      }
    }

    if (priorException != null) {
      throw priorException;
    } else if (th != null) {
      if (th instanceof IOException) throw (IOException) th;
      if (th instanceof RuntimeException) throw (RuntimeException) th;
      if (th instanceof Error) throw (Error) th;
      throw new RuntimeException(th);
    }
  }

(startLine=140 endLine=162 srcPath=/home/sonia/NewExperiment/luceneFilter/01945/lucene/core/src/java/org/apache/lucene/util/IOUtils.java)
  public static void close(Closeable... objects) throws IOException {
    Throwable th = null;

    for (Closeable object : objects) {
      try {
        if (object != null) {
          object.close();
        }
      } catch (Throwable t) {
        addSuppressed(th, t);
        if (th == null) {
          th = t;
        }
      }
    }

    if (th != null) {
      if (th instanceof IOException) throw (IOException) th;
      if (th instanceof RuntimeException) throw (RuntimeException) th;
      if (th instanceof Error) throw (Error) th;
      throw new RuntimeException(th);
    }
  }

(startLine=168 endLine=190 srcPath=/home/sonia/NewExperiment/luceneFilter/01945/lucene/core/src/java/org/apache/lucene/util/IOUtils.java)
  public static void close(Iterable<? extends Closeable> objects) throws IOException {
    Throwable th = null;

    for (Closeable object : objects) {
      try {
        if (object != null) {
          object.close();
        }
      } catch (Throwable t) {
        addSuppressed(th, t);
        if (th == null) {
          th = t;
        }
      }
    }

    if (th != null) {
      if (th instanceof IOException) throw (IOException) th;
      if (th instanceof RuntimeException) throw (RuntimeException) th;
      if (th instanceof Error) throw (Error) th;
      throw new RuntimeException(th);
    }
  }

commonMethod: 
(startLine=332 endLine=351 srcPath=/home/sonia/NewExperiment/luceneFilter/01946/lucene/core/src/java/org/apache/lucene/util/IOUtils.java)
  /**
   * Simple utilty method that takes a previously caught
   * {@code Throwable} and rethrows either {@code
   * IOException} or an unchecked exception.  If the
   * argument is null then this method does nothing.
   */
  public static void reThrow(Throwable th) throws IOException {
    if (th != null) {
      if (th instanceof IOException) {
        throw (IOException) th;
      }
      if (th instanceof RuntimeException) {
        throw (RuntimeException) th;
      }
      if (th instanceof Error) {
        throw (Error) th;
      }
      throw new RuntimeException(th);
    }
  }


, Instance #
frags: 
(startLine=398 endLine=442 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void sumTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "sum","fieldFacets", "date_dtd");
    Collection<Double> intDate = (ArrayList<Double>)xmlToList(intDateFacet, "double", "int");
    ArrayList<Double> intDateTest = calculateNumberStat(intDateTestStart, "sum");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "sum","fieldFacets", "string_sd");
    Collection<Double> intString = (ArrayList<Double>)xmlToList(intStringFacet, "double", "int");
    ArrayList<Double> intStringTest = calculateNumberStat(intStringTestStart, "sum");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "sum","fieldFacets", "date_dtd");
    Collection<Double> longDate = (ArrayList<Double>)xmlToList(longDateFacet, "double", "long");
    ArrayList<Double> longDateTest = calculateNumberStat(longDateTestStart, "sum");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "sum","fieldFacets", "string_sd");
    Collection<Double> longString = (ArrayList<Double>)xmlToList(longStringFacet, "double", "long");
    ArrayList<Double> longStringTest = calculateNumberStat(longStringTestStart, "sum");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "sum","fieldFacets", "date_dtd");   
    Collection<Double> floatDate = (ArrayList<Double>)xmlToList(floatDateFacet, "double", "float");
    ArrayList<Double> floatDateTest = calculateNumberStat(floatDateTestStart, "sum");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "sum","fieldFacets", "string_sd");    
    Collection<Double> floatString = (ArrayList<Double>)xmlToList(floatStringFacet, "double", "float");
    ArrayList<Double> floatStringTest = calculateNumberStat(floatStringTestStart, "sum");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "sum","fieldFacets", "date_dtd");  
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = calculateNumberStat(doubleDateTestStart, "sum");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "sum","fieldFacets", "string_sd");    
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = calculateNumberStat(doubleStringTestStart, "sum");
    assertEquals(doubleString,doubleStringTest);
  }

(startLine=446 endLine=490 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void meanTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "mean","fieldFacets", "date_dtd");
    Collection<Double> intDate = (ArrayList<Double>)xmlToList(intDateFacet, "double", "int");
    ArrayList<Double> intDateTest = calculateNumberStat(intDateTestStart, "mean");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "mean","fieldFacets", "string_sd");
    Collection<Double> intString = (ArrayList<Double>)xmlToList(intStringFacet, "double", "int");
    ArrayList<Double> intStringTest = calculateNumberStat(intStringTestStart, "mean");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "mean","fieldFacets", "date_dtd");
    Collection<Double> longDate = (ArrayList<Double>)xmlToList(longDateFacet, "double", "long");
    ArrayList<Double> longDateTest = calculateNumberStat(longDateTestStart, "mean");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "mean","fieldFacets", "string_sd");
    Collection<Double> longString = (ArrayList<Double>)xmlToList(longStringFacet, "double", "long");
    ArrayList<Double> longStringTest = calculateNumberStat(longStringTestStart, "mean");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "mean","fieldFacets", "date_dtd");   
    Collection<Double> floatDate = (ArrayList<Double>)xmlToList(floatDateFacet, "double", "float");
    ArrayList<Double> floatDateTest = calculateNumberStat(floatDateTestStart, "mean");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "mean","fieldFacets", "string_sd");    
    Collection<Double> floatString = (ArrayList<Double>)xmlToList(floatStringFacet, "double", "float");
    ArrayList<Double> floatStringTest = calculateNumberStat(floatStringTestStart, "mean");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "mean","fieldFacets", "date_dtd");  
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = calculateNumberStat(doubleDateTestStart, "mean");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "mean","fieldFacets", "string_sd");    
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = calculateNumberStat(doubleStringTestStart, "mean");
    assertEquals(doubleString,doubleStringTest);
  }

(startLine=494 endLine=538 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void sumOfSquaresFacetAscTest() throws Exception {
    //Int Date
    String intDateFacet = getFacetXML(response, "sumOfSquares","fieldFacets", "date_dtd");
    Collection<Double> intDate = (ArrayList<Double>)xmlToList(intDateFacet, "double", "int");
    ArrayList<Double> intDateTest = calculateNumberStat(intDateTestStart, "sumOfSquares");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "sumOfSquares","fieldFacets", "string_sd");
    Collection<Double> intString = (ArrayList<Double>)xmlToList(intStringFacet, "double", "int");
    ArrayList<Double> intStringTest = calculateNumberStat(intStringTestStart, "sumOfSquares");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "sumOfSquares","fieldFacets", "date_dtd");
    Collection<Double> longDate = (ArrayList<Double>)xmlToList(longDateFacet, "double", "long");
    ArrayList<Double> longDateTest = calculateNumberStat(longDateTestStart, "sumOfSquares");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "sumOfSquares","fieldFacets", "string_sd");
    Collection<Double> longString = (ArrayList<Double>)xmlToList(longStringFacet, "double", "long");
    ArrayList<Double> longStringTest = calculateNumberStat(longStringTestStart, "sumOfSquares");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "sumOfSquares","fieldFacets", "date_dtd");   
    Collection<Double> floatDate = (ArrayList<Double>)xmlToList(floatDateFacet, "double", "float");
    ArrayList<Double> floatDateTest = calculateNumberStat(floatDateTestStart, "sumOfSquares");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "sumOfSquares","fieldFacets", "string_sd");    
    Collection<Double> floatString = (ArrayList<Double>)xmlToList(floatStringFacet, "double", "float");
    ArrayList<Double> floatStringTest = calculateNumberStat(floatStringTestStart, "sumOfSquares");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "sumOfSquares","fieldFacets", "date_dtd");  
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = calculateNumberStat(doubleDateTestStart, "sumOfSquares");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "sumOfSquares","fieldFacets", "string_sd");    
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = calculateNumberStat(doubleStringTestStart, "sumOfSquares");
    assertEquals(doubleString,doubleStringTest);
  }

(startLine=590 endLine=634 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void medianFacetAscTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "median","fieldFacets", "date_dtd");
    Collection<Double> intDate = (ArrayList<Double>)xmlToList(intDateFacet, "double", "int");
    ArrayList<Double> intDateTest = calculateNumberStat(intDateTestStart, "median");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "median","fieldFacets", "string_sd");
    Collection<Double> intString = (ArrayList<Double>)xmlToList(intStringFacet, "double", "int");
    ArrayList<Double> intStringTest = calculateNumberStat(intStringTestStart, "median");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "median","fieldFacets", "date_dtd");
    Collection<Double> longDate = (ArrayList<Double>)xmlToList(longDateFacet, "double", "long");
    ArrayList<Double> longDateTest = calculateNumberStat(longDateTestStart, "median");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "median","fieldFacets", "string_sd");
    Collection<Double> longString = (ArrayList<Double>)xmlToList(longStringFacet, "double", "long");
    ArrayList<Double> longStringTest = calculateNumberStat(longStringTestStart, "median");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "median","fieldFacets", "date_dtd");   
    Collection<Double> floatDate = (ArrayList<Double>)xmlToList(floatDateFacet, "double", "float");
    ArrayList<Double> floatDateTest = calculateNumberStat(floatDateTestStart, "median");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "median","fieldFacets", "string_sd");    
    Collection<Double> floatString = (ArrayList<Double>)xmlToList(floatStringFacet, "double", "float");
    ArrayList<Double> floatStringTest = calculateNumberStat(floatStringTestStart, "median");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "median","fieldFacets", "date_dtd");  
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = calculateNumberStat(doubleDateTestStart, "median");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "median","fieldFacets", "string_sd");    
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = calculateNumberStat(doubleStringTestStart, "median");
    assertEquals(doubleString,doubleStringTest);
  }

(startLine=542 endLine=586 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void stddevFacetAscTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "stddev","fieldFacets", "date_dtd");
    ArrayList<Double> intDate = (ArrayList<Double>)xmlToList(intDateFacet, "double", "int");
    ArrayList<Double> intDateTest = calculateNumberStat(intDateTestStart, "stddev");
    assertTrue(checkStddevs(intDate,intDateTest));
    //Int String
    String intStringFacet = getFacetXML(response, "stddev","fieldFacets", "string_sd");
    ArrayList<Double> intString = (ArrayList<Double>)xmlToList(intStringFacet, "double", "int");
    ArrayList<Double> intStringTest = calculateNumberStat(intStringTestStart, "stddev");
    assertTrue(checkStddevs(intString,intStringTest));

    //Long Date
    String longDateFacet = getFacetXML(response, "stddev","fieldFacets", "date_dtd");
    ArrayList<Double> longDate = (ArrayList<Double>)xmlToList(longDateFacet, "double", "long");
    ArrayList<Double> longDateTest = calculateNumberStat(longDateTestStart, "stddev");
    assertTrue(checkStddevs(longDate,longDateTest));
    //Long String
    String longStringFacet = getFacetXML(response, "stddev","fieldFacets", "string_sd");
    ArrayList<Double> longString = (ArrayList<Double>)xmlToList(longStringFacet, "double", "long");
    ArrayList<Double> longStringTest = calculateNumberStat(longStringTestStart, "stddev");
    assertTrue(checkStddevs(longString,longStringTest));

    //Float Date
    String floatDateFacet = getFacetXML(response, "stddev","fieldFacets", "date_dtd");   
    ArrayList<Double> floatDate = (ArrayList<Double>)xmlToList(floatDateFacet, "double", "float");
    ArrayList<Double> floatDateTest = calculateNumberStat(floatDateTestStart, "stddev");
    assertTrue(checkStddevs(floatDate,floatDateTest));
    //Float String
    String floatStringFacet = getFacetXML(response, "stddev","fieldFacets", "string_sd");    
    ArrayList<Double> floatString = (ArrayList<Double>)xmlToList(floatStringFacet, "double", "float");
    ArrayList<Double> floatStringTest = calculateNumberStat(floatStringTestStart, "stddev");
    assertTrue(checkStddevs(floatString,floatStringTest));

    //Double Date
    String doubleDateFacet = getFacetXML(response, "stddev","fieldFacets", "date_dtd");  
    ArrayList<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = calculateNumberStat(doubleDateTestStart, "stddev");
    assertTrue(checkStddevs(doubleDate,doubleDateTest));
    //Double String
    String doubleStringFacet = getFacetXML(response, "stddev","fieldFacets", "string_sd");    
    ArrayList<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = calculateNumberStat(doubleStringTestStart, "stddev");
    assertTrue(checkStddevs(doubleString,doubleStringTest));
  }

commonMethod: 
(startLine=126 endLine=134 srcPath=/home/sonia/NewExperiment/luceneFilter/01996/solr/core/src/test/org/apache/solr/analytics/facet/AbstractAnalyticsFacetTest.java)
  protected ArrayList<Double> getDoubleList(String n1, String n2, String n3, String element, String n4)
      throws XPathExpressionException {
    ArrayList<Double> ret = new ArrayList<Double>();
    NodeList nodes = getNodes(n1, n2, n3, element, n4);
    for (int idx = 0; idx < nodes.getLength(); ++idx) {
      ret.add(Double.parseDouble(nodes.item(idx).getTextContent()));
    }
    return ret;
  }


, Instance #
frags: 
(startLine=638 endLine=704 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void perc20Test() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "perc_20");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "perc_20");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "perc_20");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "perc_20");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "perc_20");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "perc_20");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "perc_20");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "perc_20");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "percentile_20","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "perc_20");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "percentile_20","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "perc_20");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "percentile_20","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "perc_20");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "percentile_20","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "perc_20");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=708 endLine=774 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void perc60Test() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "perc_60");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "perc_60");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "perc_60");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "perc_60");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "perc_60");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "perc_60");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "perc_60");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "perc_60");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "percentile_60","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "perc_60");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "percentile_60","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "perc_60");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "percentile_60","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "perc_60");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "percentile_60","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "perc_60");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=778 endLine=844 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void minTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "min");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "min");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "min");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "min");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "min");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "min");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "min");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "min");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "min","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "min");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "min","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "min");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "min","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "min");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "min","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "min");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=848 endLine=921 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void maxTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "max");
    assertEquals(intDate,intDateTest);
    
    //Int String
    String intStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "max");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "max");
    assertEquals(longDate,longDateTest);
    
    //Long String
    String longStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "max");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "max");
    assertEquals(floatDate,floatDateTest);
    
    //Float String
    String floatStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "max");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "max");
    assertEquals(doubleDate,doubleDateTest);
    
    //Double String
    String doubleStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "max");
    assertEquals(doubleString,doubleStringTest);
    
    //String Int
    String stringIntFacet = getFacetXML(response, "max","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "max");
    assertEquals(stringInt,stringIntTest);
    
    //String Long
    String stringLongFacet = getFacetXML(response, "max","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "max");
    assertEquals(stringLong,stringLongTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "max","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "max");
    assertEquals(dateInt,dateIntTest);
    
    //Date Long
    String dateStringFacet = getFacetXML(response, "max","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "max");
    assertEquals(dateString,dateLongTest);

  }

commonMethod: 
(startLine=88 endLine=96 srcPath=/home/sonia/NewExperiment/luceneFilter/01996/solr/core/src/test/org/apache/solr/analytics/facet/AbstractAnalyticsFacetTest.java)
  protected ArrayList<String> getStringList(String n1, String n2, String n3, String element, String n4)
      throws XPathExpressionException {
    ArrayList<String> ret = new ArrayList<String>();
    NodeList nodes = getNodes(n1, n2, n3, element, n4);
    for (int idx = 0; idx < nodes.getLength(); ++idx) {
      ret.add(nodes.item(idx).getTextContent());
    }
    return ret;
  }


, Instance #
frags: 
(startLine=638 endLine=704 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void perc20Test() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "perc_20");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "perc_20");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "perc_20");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "perc_20");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "perc_20");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "perc_20");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "perc_20");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "perc_20");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "percentile_20","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "perc_20");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "percentile_20","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "perc_20");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "percentile_20","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "perc_20");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "percentile_20","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "perc_20");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=708 endLine=774 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void perc60Test() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "perc_60");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "perc_60");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "perc_60");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "perc_60");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "perc_60");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "perc_60");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "perc_60");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "perc_60");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "percentile_60","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "perc_60");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "percentile_60","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "perc_60");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "percentile_60","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "perc_60");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "percentile_60","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "perc_60");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=778 endLine=844 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void minTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "min");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "min");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "min");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "min");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "min");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "min");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "min");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "min");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "min","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "min");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "min","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "min");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "min","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "min");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "min","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "min");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=848 endLine=921 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void maxTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "max");
    assertEquals(intDate,intDateTest);
    
    //Int String
    String intStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "max");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "max");
    assertEquals(longDate,longDateTest);
    
    //Long String
    String longStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "max");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "max");
    assertEquals(floatDate,floatDateTest);
    
    //Float String
    String floatStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "max");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "max");
    assertEquals(doubleDate,doubleDateTest);
    
    //Double String
    String doubleStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "max");
    assertEquals(doubleString,doubleStringTest);
    
    //String Int
    String stringIntFacet = getFacetXML(response, "max","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "max");
    assertEquals(stringInt,stringIntTest);
    
    //String Long
    String stringLongFacet = getFacetXML(response, "max","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "max");
    assertEquals(stringLong,stringLongTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "max","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "max");
    assertEquals(dateInt,dateIntTest);
    
    //Date Long
    String dateStringFacet = getFacetXML(response, "max","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "max");
    assertEquals(dateString,dateLongTest);

  }

commonMethod: 
(startLine=116 endLine=124 srcPath=/home/sonia/NewExperiment/luceneFilter/01996/solr/core/src/test/org/apache/solr/analytics/facet/AbstractAnalyticsFacetTest.java)
  protected ArrayList<Float> getFloatList(String n1, String n2, String n3, String element, String n4)
      throws XPathExpressionException {
    ArrayList<Float> ret = new ArrayList<Float>();
    NodeList nodes = getNodes(n1, n2, n3, element, n4);
    for (int idx = 0; idx < nodes.getLength(); ++idx) {
      ret.add(Float.parseFloat(nodes.item(idx).getTextContent()));
    }
    return ret;
  }


, Instance #
frags: 
(startLine=638 endLine=704 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void perc20Test() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "perc_20");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "perc_20");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "perc_20");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "perc_20");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "perc_20");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "perc_20");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "perc_20");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "perc_20");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "percentile_20","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "perc_20");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "percentile_20","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "perc_20");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "percentile_20","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "perc_20");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "percentile_20","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "perc_20");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=708 endLine=774 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void perc60Test() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "perc_60");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "perc_60");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "perc_60");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "perc_60");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "perc_60");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "perc_60");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "perc_60");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "perc_60");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "percentile_60","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "perc_60");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "percentile_60","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "perc_60");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "percentile_60","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "perc_60");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "percentile_60","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "perc_60");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=778 endLine=844 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void minTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "min");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "min");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "min");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "min");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "min");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "min");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "min");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "min");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "min","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "min");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "min","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "min");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "min","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "min");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "min","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "min");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=848 endLine=921 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void maxTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "max");
    assertEquals(intDate,intDateTest);
    
    //Int String
    String intStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "max");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "max");
    assertEquals(longDate,longDateTest);
    
    //Long String
    String longStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "max");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "max");
    assertEquals(floatDate,floatDateTest);
    
    //Float String
    String floatStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "max");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "max");
    assertEquals(doubleDate,doubleDateTest);
    
    //Double String
    String doubleStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "max");
    assertEquals(doubleString,doubleStringTest);
    
    //String Int
    String stringIntFacet = getFacetXML(response, "max","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "max");
    assertEquals(stringInt,stringIntTest);
    
    //String Long
    String stringLongFacet = getFacetXML(response, "max","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "max");
    assertEquals(stringLong,stringLongTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "max","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "max");
    assertEquals(dateInt,dateIntTest);
    
    //Date Long
    String dateStringFacet = getFacetXML(response, "max","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "max");
    assertEquals(dateString,dateLongTest);

  }

commonMethod: 
(startLine=107 endLine=115 srcPath=/home/sonia/NewExperiment/luceneFilter/01996/solr/core/src/test/org/apache/solr/analytics/facet/AbstractAnalyticsFacetTest.java)
  protected ArrayList<Long> getLongList(String n1, String n2, String n3, String element, String n4)
      throws XPathExpressionException {
    ArrayList<Long> ret = new ArrayList<Long>();
    NodeList nodes = getNodes(n1, n2, n3, element, n4);
    for (int idx = 0; idx < nodes.getLength(); ++idx) {
      ret.add(Long.parseLong(nodes.item(idx).getTextContent()));
    }
    return ret;
  }


, Instance #
frags: 
(startLine=638 endLine=704 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void perc20Test() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "perc_20");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "perc_20");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "perc_20");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "perc_20");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "perc_20");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "perc_20");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "perc_20");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "perc_20");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "percentile_20","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "perc_20");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "percentile_20","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "perc_20");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "percentile_20","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "perc_20");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "percentile_20","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "perc_20");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=708 endLine=774 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void perc60Test() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "perc_60");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "perc_60");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "perc_60");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "perc_60");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "perc_60");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "perc_60");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "perc_60");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "perc_60");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "percentile_60","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "perc_60");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "percentile_60","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "perc_60");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "percentile_60","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "perc_60");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "percentile_60","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "perc_60");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=778 endLine=844 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void minTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "min");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "min");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "min");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "min");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "min");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "min");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "min");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "min");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "min","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "min");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "min","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "min");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "min","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "min");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "min","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "min");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=848 endLine=921 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void maxTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "max");
    assertEquals(intDate,intDateTest);
    
    //Int String
    String intStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "max");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "max");
    assertEquals(longDate,longDateTest);
    
    //Long String
    String longStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "max");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "max");
    assertEquals(floatDate,floatDateTest);
    
    //Float String
    String floatStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "max");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "max");
    assertEquals(doubleDate,doubleDateTest);
    
    //Double String
    String doubleStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "max");
    assertEquals(doubleString,doubleStringTest);
    
    //String Int
    String stringIntFacet = getFacetXML(response, "max","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "max");
    assertEquals(stringInt,stringIntTest);
    
    //String Long
    String stringLongFacet = getFacetXML(response, "max","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "max");
    assertEquals(stringLong,stringLongTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "max","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "max");
    assertEquals(dateInt,dateIntTest);
    
    //Date Long
    String dateStringFacet = getFacetXML(response, "max","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "max");
    assertEquals(dateString,dateLongTest);

  }

commonMethod: 
(startLine=98 endLine=106 srcPath=/home/sonia/NewExperiment/luceneFilter/01996/solr/core/src/test/org/apache/solr/analytics/facet/AbstractAnalyticsFacetTest.java)
  protected ArrayList<Integer> getIntegerList(String n1, String n2, String n3, String element, String n4)
      throws XPathExpressionException {
    ArrayList<Integer> ret = new ArrayList<Integer>();
    NodeList nodes = getNodes(n1, n2, n3, element, n4);
    for (int idx = 0; idx < nodes.getLength(); ++idx) {
      ret.add(Integer.parseInt(nodes.item(idx).getTextContent()));
    }
    return ret;
  }


, Instance #
frags: 
(startLine=638 endLine=704 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void perc20Test() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "perc_20");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "perc_20");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "perc_20");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "perc_20");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "perc_20");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "perc_20");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "percentile_20n","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "perc_20");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "percentile_20n","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "perc_20");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "percentile_20","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "perc_20");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "percentile_20","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "perc_20");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "percentile_20","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "perc_20");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "percentile_20","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "perc_20");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=708 endLine=774 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void perc60Test() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "perc_60");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "perc_60");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "perc_60");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "perc_60");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "perc_60");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "perc_60");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "percentile_60n","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "perc_60");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "percentile_60n","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "perc_60");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "percentile_60","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "perc_60");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "percentile_60","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "perc_60");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "percentile_60","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "perc_60");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "percentile_60","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "perc_60");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=778 endLine=844 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void minTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "min");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "min");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "min");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "min");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "min");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "min");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "minn","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "min");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "minn","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "min");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "min","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "min");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "min","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "min");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "min","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "min");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "min","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "min");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=848 endLine=921 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void maxTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd"); 
    Collection<Integer> intDate = (ArrayList<Integer>)xmlToList(intDateFacet, "int", "int");
    ArrayList<Integer> intDateTest = (ArrayList<Integer>)calculateStat(intDateTestStart, "max");
    assertEquals(intDate,intDateTest);
    
    //Int String
    String intStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");    
    Collection<Integer> intString = (ArrayList<Integer>)xmlToList(intStringFacet, "int", "int");
    ArrayList<Integer> intStringTest = (ArrayList<Integer>)calculateStat(intStringTestStart, "max");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "max");
    assertEquals(longDate,longDateTest);
    
    //Long String
    String longStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");    
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "max");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Float> floatDate = (ArrayList<Float>)xmlToList(floatDateFacet, "float", "float");
    ArrayList<Float> floatDateTest = (ArrayList<Float>)calculateStat(floatDateTestStart, "max");
    assertEquals(floatDate,floatDateTest);
    
    //Float String
    String floatStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");       
    Collection<Float> floatString = (ArrayList<Float>)xmlToList(floatStringFacet, "float", "float");
    ArrayList<Float> floatStringTest = (ArrayList<Float>)calculateStat(floatStringTestStart, "max");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "maxn","fieldFacets", "date_dtd");    
    Collection<Double> doubleDate = (ArrayList<Double>)xmlToList(doubleDateFacet, "double", "double");
    ArrayList<Double> doubleDateTest = (ArrayList<Double>)calculateStat(doubleDateTestStart, "max");
    assertEquals(doubleDate,doubleDateTest);
    
    //Double String
    String doubleStringFacet = getFacetXML(response, "maxn","fieldFacets", "string_sd");      
    Collection<Double> doubleString = (ArrayList<Double>)xmlToList(doubleStringFacet, "double", "double");
    ArrayList<Double> doubleStringTest = (ArrayList<Double>)calculateStat(doubleStringTestStart, "max");
    assertEquals(doubleString,doubleStringTest);
    
    //String Int
    String stringIntFacet = getFacetXML(response, "max","fieldFacets", "int_id");   
    Collection<String> stringInt = (ArrayList<String>)xmlToList(stringIntFacet, "str", "str");
    ArrayList<String> stringIntTest = (ArrayList<String>)calculateStat(stringIntTestStart, "max");
    assertEquals(stringInt,stringIntTest);
    
    //String Long
    String stringLongFacet = getFacetXML(response, "max","fieldFacets", "long_ld");     
    Collection<String> stringLong = (ArrayList<String>)xmlToList(stringLongFacet, "str", "str");
    ArrayList<String> stringLongTest = (ArrayList<String>)calculateStat(stringLongTestStart, "max");
    assertEquals(stringLong,stringLongTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "max","fieldFacets", "int_id"); 
    Collection<String> dateInt = (ArrayList<String>)xmlToList(dateIntFacet, "date", "date");
    ArrayList<String> dateIntTest = (ArrayList<String>)calculateStat(dateIntTestStart, "max");
    assertEquals(dateInt,dateIntTest);
    
    //Date Long
    String dateStringFacet = getFacetXML(response, "max","fieldFacets", "long_ld");       
    Collection<String> dateString = (ArrayList<String>)xmlToList(dateStringFacet, "date", "date");
    ArrayList<String> dateLongTest = (ArrayList<String>)calculateStat(dateLongTestStart, "max");
    assertEquals(dateString,dateLongTest);

  }

commonMethod: 
(startLine=126 endLine=134 srcPath=/home/sonia/NewExperiment/luceneFilter/01996/solr/core/src/test/org/apache/solr/analytics/facet/AbstractAnalyticsFacetTest.java)
  protected ArrayList<Double> getDoubleList(String n1, String n2, String n3, String element, String n4)
      throws XPathExpressionException {
    ArrayList<Double> ret = new ArrayList<Double>();
    NodeList nodes = getNodes(n1, n2, n3, element, n4);
    for (int idx = 0; idx < nodes.getLength(); ++idx) {
      ret.add(Double.parseDouble(nodes.item(idx).getTextContent()));
    }
    return ret;
  }


, Instance #
frags: 
(startLine=925 endLine=991 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void uniqueTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "uniquen", "fieldFacets", "date_dtd");    
    Collection<Long> intDate = (ArrayList<Long>)xmlToList(intDateFacet, "long", "int");
    ArrayList<Long> intDateTest = (ArrayList<Long>)calculateStat(intDateTestStart, "unique");
    assertEquals(intDate,intDateTest);
    //Int String
    String intStringFacet = getFacetXML(response, "uniquen", "fieldFacets", "string_sd");      
    Collection<Long> intString = (ArrayList<Long>)xmlToList(intStringFacet, "long", "int");
    ArrayList<Long> intStringTest = (ArrayList<Long>)calculateStat(intStringTestStart, "unique");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "uniquen", "fieldFacets", "date_dtd");      
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "unique");
    assertEquals(longDate,longDateTest);
    //Long String
    String longStringFacet = getFacetXML(response, "uniquen", "fieldFacets", "string_sd");   
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "unique");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "uniquen", "fieldFacets", "date_dtd");   
    Collection<Long> floatDate = (ArrayList<Long>)xmlToList(floatDateFacet, "long", "float");
    ArrayList<Long> floatDateTest = (ArrayList<Long>)calculateStat(floatDateTestStart, "unique");
    assertEquals(floatDate,floatDateTest);
    //Float String
    String floatStringFacet = getFacetXML(response, "uniquen", "fieldFacets", "string_sd");   
    Collection<Long> floatString = (ArrayList<Long>)xmlToList(floatStringFacet, "long", "float");
    ArrayList<Long> floatStringTest = (ArrayList<Long>)calculateStat(floatStringTestStart, "unique");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "uniquen", "fieldFacets", "date_dtd");   
    Collection<Long> doubleDate = (ArrayList<Long>)xmlToList(doubleDateFacet, "long", "double");
    ArrayList<Long> doubleDateTest = (ArrayList<Long>)calculateStat(doubleDateTestStart, "unique");
    assertEquals(doubleDate,doubleDateTest);
    //Double String
    String doubleStringFacet = getFacetXML(response, "uniquen", "fieldFacets", "string_sd");   
    Collection<Long> doubleString = (ArrayList<Long>)xmlToList(doubleStringFacet, "long", "double");
    ArrayList<Long> doubleStringTest = (ArrayList<Long>)calculateStat(doubleStringTestStart, "unique");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "unique", "fieldFacets", "int_id");    
    Collection<Long> dateInt = (ArrayList<Long>)xmlToList(dateIntFacet, "long", "date");
    ArrayList<Long> dateIntTest = (ArrayList<Long>)calculateStat(dateIntTestStart, "unique");
    assertEquals(dateInt,dateIntTest);
    //Date Long
    String dateStringFacet = getFacetXML(response, "unique", "fieldFacets", "long_ld");     
    Collection<Long> dateString = (ArrayList<Long>)xmlToList(dateStringFacet, "long", "date");
    ArrayList<Long> dateLongTest = (ArrayList<Long>)calculateStat(dateLongTestStart, "unique");
    assertEquals(dateString,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "unique", "fieldFacets", "int_id");   
    Collection<Long> stringInt = (ArrayList<Long>)xmlToList(stringIntFacet, "long", "str");
    ArrayList<Long> stringIntTest = (ArrayList<Long>)calculateStat(stringIntTestStart, "unique");
    assertEquals(stringInt,stringIntTest);
    //String Long
    String stringLongFacet = getFacetXML(response, "unique", "fieldFacets", "long_ld");    
    Collection<Long> stringLong = (ArrayList<Long>)xmlToList(stringLongFacet, "long", "str");
    ArrayList<Long> stringLongTest = (ArrayList<Long>)calculateStat(stringLongTestStart, "unique");
    assertEquals(stringLong,stringLongTest);
  }

(startLine=995 endLine=1067 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/FieldFacetTest.java)
  public void countTest() throws Exception { 
    //Int Date
    String intDateFacet = getFacetXML(response, "countn", "fieldFacets", "date_dtd");    
    Collection<Long> intDate = (ArrayList<Long>)xmlToList(intDateFacet, "long", "int");
    ArrayList<Long> intDateTest = (ArrayList<Long>)calculateStat(intDateTestStart, "count");
    assertEquals(intDate,intDateTest);
    
    //Int String
    String intStringFacet = getFacetXML(response, "countn", "fieldFacets", "string_sd");      
    Collection<Long> intString = (ArrayList<Long>)xmlToList(intStringFacet, "long", "int");
    ArrayList<Long> intStringTest = (ArrayList<Long>)calculateStat(intStringTestStart, "count");
    assertEquals(intString,intStringTest);

    //Long Date
    String longDateFacet = getFacetXML(response, "countn", "fieldFacets", "date_dtd");      
    Collection<Long> longDate = (ArrayList<Long>)xmlToList(longDateFacet, "long", "long");
    ArrayList<Long> longDateTest = (ArrayList<Long>)calculateStat(longDateTestStart, "count");
    assertEquals(longDate,longDateTest);
    
    //Long String
    String longStringFacet = getFacetXML(response, "countn", "fieldFacets", "string_sd");   
    Collection<Long> longString = (ArrayList<Long>)xmlToList(longStringFacet, "long", "long");
    ArrayList<Long> longStringTest = (ArrayList<Long>)calculateStat(longStringTestStart, "count");
    assertEquals(longString,longStringTest);

    //Float Date
    String floatDateFacet = getFacetXML(response, "countn", "fieldFacets", "date_dtd");   
    Collection<Long> floatDate = (ArrayList<Long>)xmlToList(floatDateFacet, "long", "float");
    ArrayList<Long> floatDateTest = (ArrayList<Long>)calculateStat(floatDateTestStart, "count");
    assertEquals(floatDate,floatDateTest);
    
    //Float String
    String floatStringFacet = getFacetXML(response, "countn", "fieldFacets", "string_sd");   
    Collection<Long> floatString = (ArrayList<Long>)xmlToList(floatStringFacet, "long", "float");
    ArrayList<Long> floatStringTest = (ArrayList<Long>)calculateStat(floatStringTestStart, "count");
    assertEquals(floatString,floatStringTest);

    //Double Date
    String doubleDateFacet = getFacetXML(response, "countn", "fieldFacets", "date_dtd");   
    Collection<Long> doubleDate = (ArrayList<Long>)xmlToList(doubleDateFacet, "long", "double");
    ArrayList<Long> doubleDateTest = (ArrayList<Long>)calculateStat(doubleDateTestStart, "count");
    assertEquals(doubleDate,doubleDateTest);
    
    //Double String
    String doubleStringFacet = getFacetXML(response, "countn", "fieldFacets", "string_sd");   
    Collection<Long> doubleString = (ArrayList<Long>)xmlToList(doubleStringFacet, "long", "double");
    ArrayList<Long> doubleStringTest = (ArrayList<Long>)calculateStat(doubleStringTestStart, "count");
    assertEquals(doubleString,doubleStringTest);

    //Date Int
    String dateIntFacet = getFacetXML(response, "count", "fieldFacets", "int_id");    
    Collection<Long> dateInt = (ArrayList<Long>)xmlToList(dateIntFacet, "long", "date");
    ArrayList<Long> dateIntTest = (ArrayList<Long>)calculateStat(dateIntTestStart, "count");
    assertEquals(dateIntTest,dateInt);
    
    //Date Long
    String dateLongFacet = getFacetXML(response, "count", "fieldFacets", "long_ld");     
    Collection<Long> dateLong = (ArrayList<Long>)xmlToList(dateLongFacet, "long", "date");
    ArrayList<Long> dateLongTest = (ArrayList<Long>)calculateStat(dateLongTestStart, "count");
    assertEquals(dateLong,dateLongTest);

    //String Int
    String stringIntFacet = getFacetXML(response, "count", "fieldFacets", "int_id");   
    Collection<Long> stringInt = (ArrayList<Long>)xmlToList(stringIntFacet, "long", "str");
    ArrayList<Long> stringIntTest = (ArrayList<Long>)calculateStat(stringIntTestStart, "count");
    assertEquals(stringInt,stringIntTest);
    
    //String Long
    String stringLongFacet = getFacetXML(response, "count", "fieldFacets", "long_ld");    
    Collection<Long> stringLong = (ArrayList<Long>)xmlToList(stringLongFacet, "long", "str");
    ArrayList<Long> stringLongTest = (ArrayList<Long>)calculateStat(stringLongTestStart, "count");
    assertEquals(stringLong,stringLongTest);
  }

commonMethod: 
(startLine=107 endLine=115 srcPath=/home/sonia/NewExperiment/luceneFilter/01996/solr/core/src/test/org/apache/solr/analytics/facet/AbstractAnalyticsFacetTest.java)
  protected ArrayList<Long> getLongList(String n1, String n2, String n3, String element, String n4)
      throws XPathExpressionException {
    ArrayList<Long> ret = new ArrayList<Long>();
    NodeList nodes = getNodes(n1, n2, n3, element, n4);
    for (int idx = 0; idx < nodes.getLength(); ++idx) {
      ret.add(Long.parseLong(nodes.item(idx).getTextContent()));
    }
    return ret;
  }


, Instance #
frags: 
(startLine=125 endLine=164 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/RangeFacetTest.java)
  public void rangeTest() throws Exception {
    
    //Int Long
    String intLongRange = getFacetXML(response, "ri", "rangeFacets", "long_ld");
    ArrayList<Double> intLong = (ArrayList<Double>)xmlToList(intLongRange, "long", "count");
    ArrayList<Long> intLongTest = calculateStat(transformLists(intLongTestStart, 5, 30, 5
                                                        , false, true, false, false, false), "count");
    assertEquals(intLong,intLongTest);
    //Int Double
    String intDoubleRange = getFacetXML(response, "ri", "rangeFacets", "double_dd");    
    ArrayList<Double> intDouble = (ArrayList<Double>)xmlToList(intDoubleRange, "double", "mean");
    ArrayList<Double> intDoubleTest = calculateNumberStat(transformLists(intDoubleTestStart, 3, 39, 7
                                                          , false, false, true, false, true), "mean");
    assertEquals(intDouble,intDoubleTest);
    //Int Date
    String intDateRange = getFacetXML(response, "ri", "rangeFacets", "date_dtd");
    ArrayList<Long> intDate = (ArrayList<Long>)xmlToList(intDateRange, "long", "count");
    ArrayList<Long> intDateTest = (ArrayList<Long>)calculateStat(transformLists(intDateTestStart, 7, 44, 7
                                                      , false, true, false, true, true), "count");
    assertEquals(intDate,intDateTest);
    
    //Float Long
    String floatLongRange = getFacetXML(response, "rf", "rangeFacets", "long_ld");
    ArrayList<Double> floatLong = (ArrayList<Double>)xmlToList(floatLongRange, "double", "median");
    ArrayList<Double> floatLongTest = calculateNumberStat(transformLists(floatLongTestStart, 0, 29, 4
                                                          , false, true, true, true, true), "median");
    assertEquals(floatLong,floatLongTest);
    //Float Double
    String floatDoubleRange = getFacetXML(response, "rf", "rangeFacets", "double_dd");    
    ArrayList<Long> floatDouble = (ArrayList<Long>)xmlToList(floatDoubleRange, "long", "count");
    ArrayList<Long> floatDoubleTest = (ArrayList<Long>)calculateStat(transformLists(floatDoubleTestStart, 4, 47, 11
                                                                     , false, false, false, true, false), "count");
    assertEquals(floatDouble,floatDoubleTest);
    //Float Date                      
    String floatDateRange = getFacetXML(response, "rf", "rangeFacets", "date_dtd");
    ArrayList<Double> floatDate = (ArrayList<Double>)xmlToList(floatDateRange, "double", "sumOfSquares");
    ArrayList<Double> floatDateTest = calculateNumberStat(transformLists(floatDateTestStart, 4, 46, 5
                                                          , false, false, true, true, false), "sumOfSquares");
    assertEquals(floatDate,floatDateTest);
  }

(startLine=169 endLine=207 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/RangeFacetTest.java)
  public void hardendRangeTest() throws Exception {
    //Int Long
    String intLongRange = getFacetXML(response, "hi", "rangeFacets", "long_ld");
    ArrayList<Double> intLong = (ArrayList<Double>)xmlToList(intLongRange, "double", "sum");
    ArrayList<Double> intLongTest = calculateNumberStat(transformLists(intLongTestStart, 5, 30, 5
                                                        , true, true, false, false, false), "sum");
    assertEquals(intLong,intLongTest);
    //Int Double
    String intDoubleRange = getFacetXML(response, "hi", "rangeFacets", "double_dd");    
    ArrayList<Double> intDouble = (ArrayList<Double>)xmlToList(intDoubleRange, "double", "mean");
    ArrayList<Double> intDoubleTest = calculateNumberStat(transformLists(intDoubleTestStart, 3, 39, 7
                                                          , true, false, true, false, true), "mean");
    assertEquals(intDouble,intDoubleTest);
    //Int Date
    String intDateRange = getFacetXML(response, "hi", "rangeFacets", "date_dtd");
    ArrayList<Long> intDate = (ArrayList<Long>)xmlToList(intDateRange, "long", "count");
    ArrayList<Long> intDateTest = (ArrayList<Long>)calculateStat(transformLists(intDateTestStart, 7, 44, 7
                                                      , true, true, false, true, true), "count");
    assertEquals(intDate,intDateTest);
    
    //Float Long
    String floatLongRange = getFacetXML(response, "hf", "rangeFacets", "long_ld");
    ArrayList<Double> floatLong = (ArrayList<Double>)xmlToList(floatLongRange, "double", "median");
    ArrayList<Double> floatLongTest = calculateNumberStat(transformLists(floatLongTestStart, 0, 29, 4
                                                          , true, true, true, true, true), "median");
    assertEquals(floatLong,floatLongTest);
    //Float Double
    String floatDoubleRange = getFacetXML(response, "hf", "rangeFacets", "double_dd");    
    ArrayList<Long> floatDouble = (ArrayList<Long>)xmlToList(floatDoubleRange, "long", "count");
    ArrayList<Long> floatDoubleTest = (ArrayList<Long>)calculateStat(transformLists(floatDoubleTestStart, 4, 47, 11
                                                                     , true, false, false, true, false), "count");
    assertEquals(floatDouble,floatDoubleTest);
    //Float Date                      
    String floatDateRange = getFacetXML(response, "hf", "rangeFacets", "date_dtd");
    ArrayList<Double> floatDate = (ArrayList<Double>)xmlToList(floatDateRange, "double", "sumOfSquares");
    ArrayList<Double> floatDateTest = calculateNumberStat(transformLists(floatDateTestStart, 4, 46, 5
                                                          , true, false, true, true, false), "sumOfSquares");
    assertEquals(floatDate,floatDateTest);
  }

(startLine=211 endLine=249 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/RangeFacetTest.java)
  public void multiGapTest() throws Exception {
    //Int Long
    String intLongRange = getFacetXML(response, "mi", "rangeFacets", "long_ld");
    ArrayList<Double> intLong = (ArrayList<Double>)xmlToList(intLongRange, "double", "sum");
    ArrayList<Double> intLongTest = calculateNumberStat(transformLists(intLongTestStart, 5, 30, "4,2,6,3"
                                                        , false, true, false, false, false), "sum");
    assertEquals(intLong,intLongTest);
    //Int Double
    String intDoubleRange = getFacetXML(response, "mi", "rangeFacets", "double_dd");    
    ArrayList<Double> intDouble = (ArrayList<Double>)xmlToList(intDoubleRange, "double", "mean");
    ArrayList<Double> intDoubleTest = calculateNumberStat(transformLists(intDoubleTestStart, 3, 39, "3,1,7"
                                                          , false, false, true, false, true), "mean");
    assertEquals(intDouble,intDoubleTest);
    //Int Date
    String intDateRange = getFacetXML(response, "mi", "rangeFacets", "date_dtd");
    ArrayList<Long> intDate = (ArrayList<Long>)xmlToList(intDateRange, "long", "count");
    ArrayList<Long> intDateTest = (ArrayList<Long>)calculateStat(transformLists(intDateTestStart, 7, 44, "2,7"
                                                      , false, true, false, true, true), "count");
    assertEquals(intDate,intDateTest);
    
    //Float Long
    String floatLongRange = getFacetXML(response, "mf", "rangeFacets", "long_ld");
    ArrayList<Double> floatLong = (ArrayList<Double>)xmlToList(floatLongRange, "double", "median");
    ArrayList<Double> floatLongTest = calculateNumberStat(transformLists(floatLongTestStart, 0, 29, "1,4"
                                                          , false, true, true, true, true), "median");;
    assertEquals(floatLong,floatLongTest);
    //Float Double
    String floatDoubleRange = getFacetXML(response, "mf", "rangeFacets", "double_dd");    
    ArrayList<Long> floatDouble = (ArrayList<Long>)xmlToList(floatDoubleRange, "long", "count");
    ArrayList<Long> floatDoubleTest = (ArrayList<Long>)calculateStat(transformLists(floatDoubleTestStart, 4, 47, "2,3,11"
                                                          , false, false, false, true, false), "count");
    assertEquals(floatDouble,floatDoubleTest);
    //Float Date                      
    String floatDateRange = getFacetXML(response, "mf", "rangeFacets", "date_dtd");
    ArrayList<Double> floatDate = (ArrayList<Double>)xmlToList(floatDateRange, "double", "sumOfSquares");
    ArrayList<Double> floatDateTest = calculateNumberStat(transformLists(floatDateTestStart, 4, 46, "4,5"
                                                          , false, false, true, true, false), "sumOfSquares");
    assertEquals(floatDate,floatDateTest);
  }

commonMethod: 
(startLine=107 endLine=115 srcPath=/home/sonia/NewExperiment/luceneFilter/01996/solr/core/src/test/org/apache/solr/analytics/facet/AbstractAnalyticsFacetTest.java)
  protected ArrayList<Long> getLongList(String n1, String n2, String n3, String element, String n4)
      throws XPathExpressionException {
    ArrayList<Long> ret = new ArrayList<Long>();
    NodeList nodes = getNodes(n1, n2, n3, element, n4);
    for (int idx = 0; idx < nodes.getLength(); ++idx) {
      ret.add(Long.parseLong(nodes.item(idx).getTextContent()));
    }
    return ret;
  }


, Instance #
frags: 
(startLine=125 endLine=164 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/RangeFacetTest.java)
  public void rangeTest() throws Exception {
    
    //Int Long
    String intLongRange = getFacetXML(response, "ri", "rangeFacets", "long_ld");
    ArrayList<Double> intLong = (ArrayList<Double>)xmlToList(intLongRange, "long", "count");
    ArrayList<Long> intLongTest = calculateStat(transformLists(intLongTestStart, 5, 30, 5
                                                        , false, true, false, false, false), "count");
    assertEquals(intLong,intLongTest);
    //Int Double
    String intDoubleRange = getFacetXML(response, "ri", "rangeFacets", "double_dd");    
    ArrayList<Double> intDouble = (ArrayList<Double>)xmlToList(intDoubleRange, "double", "mean");
    ArrayList<Double> intDoubleTest = calculateNumberStat(transformLists(intDoubleTestStart, 3, 39, 7
                                                          , false, false, true, false, true), "mean");
    assertEquals(intDouble,intDoubleTest);
    //Int Date
    String intDateRange = getFacetXML(response, "ri", "rangeFacets", "date_dtd");
    ArrayList<Long> intDate = (ArrayList<Long>)xmlToList(intDateRange, "long", "count");
    ArrayList<Long> intDateTest = (ArrayList<Long>)calculateStat(transformLists(intDateTestStart, 7, 44, 7
                                                      , false, true, false, true, true), "count");
    assertEquals(intDate,intDateTest);
    
    //Float Long
    String floatLongRange = getFacetXML(response, "rf", "rangeFacets", "long_ld");
    ArrayList<Double> floatLong = (ArrayList<Double>)xmlToList(floatLongRange, "double", "median");
    ArrayList<Double> floatLongTest = calculateNumberStat(transformLists(floatLongTestStart, 0, 29, 4
                                                          , false, true, true, true, true), "median");
    assertEquals(floatLong,floatLongTest);
    //Float Double
    String floatDoubleRange = getFacetXML(response, "rf", "rangeFacets", "double_dd");    
    ArrayList<Long> floatDouble = (ArrayList<Long>)xmlToList(floatDoubleRange, "long", "count");
    ArrayList<Long> floatDoubleTest = (ArrayList<Long>)calculateStat(transformLists(floatDoubleTestStart, 4, 47, 11
                                                                     , false, false, false, true, false), "count");
    assertEquals(floatDouble,floatDoubleTest);
    //Float Date                      
    String floatDateRange = getFacetXML(response, "rf", "rangeFacets", "date_dtd");
    ArrayList<Double> floatDate = (ArrayList<Double>)xmlToList(floatDateRange, "double", "sumOfSquares");
    ArrayList<Double> floatDateTest = calculateNumberStat(transformLists(floatDateTestStart, 4, 46, 5
                                                          , false, false, true, true, false), "sumOfSquares");
    assertEquals(floatDate,floatDateTest);
  }

(startLine=169 endLine=207 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/RangeFacetTest.java)
  public void hardendRangeTest() throws Exception {
    //Int Long
    String intLongRange = getFacetXML(response, "hi", "rangeFacets", "long_ld");
    ArrayList<Double> intLong = (ArrayList<Double>)xmlToList(intLongRange, "double", "sum");
    ArrayList<Double> intLongTest = calculateNumberStat(transformLists(intLongTestStart, 5, 30, 5
                                                        , true, true, false, false, false), "sum");
    assertEquals(intLong,intLongTest);
    //Int Double
    String intDoubleRange = getFacetXML(response, "hi", "rangeFacets", "double_dd");    
    ArrayList<Double> intDouble = (ArrayList<Double>)xmlToList(intDoubleRange, "double", "mean");
    ArrayList<Double> intDoubleTest = calculateNumberStat(transformLists(intDoubleTestStart, 3, 39, 7
                                                          , true, false, true, false, true), "mean");
    assertEquals(intDouble,intDoubleTest);
    //Int Date
    String intDateRange = getFacetXML(response, "hi", "rangeFacets", "date_dtd");
    ArrayList<Long> intDate = (ArrayList<Long>)xmlToList(intDateRange, "long", "count");
    ArrayList<Long> intDateTest = (ArrayList<Long>)calculateStat(transformLists(intDateTestStart, 7, 44, 7
                                                      , true, true, false, true, true), "count");
    assertEquals(intDate,intDateTest);
    
    //Float Long
    String floatLongRange = getFacetXML(response, "hf", "rangeFacets", "long_ld");
    ArrayList<Double> floatLong = (ArrayList<Double>)xmlToList(floatLongRange, "double", "median");
    ArrayList<Double> floatLongTest = calculateNumberStat(transformLists(floatLongTestStart, 0, 29, 4
                                                          , true, true, true, true, true), "median");
    assertEquals(floatLong,floatLongTest);
    //Float Double
    String floatDoubleRange = getFacetXML(response, "hf", "rangeFacets", "double_dd");    
    ArrayList<Long> floatDouble = (ArrayList<Long>)xmlToList(floatDoubleRange, "long", "count");
    ArrayList<Long> floatDoubleTest = (ArrayList<Long>)calculateStat(transformLists(floatDoubleTestStart, 4, 47, 11
                                                                     , true, false, false, true, false), "count");
    assertEquals(floatDouble,floatDoubleTest);
    //Float Date                      
    String floatDateRange = getFacetXML(response, "hf", "rangeFacets", "date_dtd");
    ArrayList<Double> floatDate = (ArrayList<Double>)xmlToList(floatDateRange, "double", "sumOfSquares");
    ArrayList<Double> floatDateTest = calculateNumberStat(transformLists(floatDateTestStart, 4, 46, 5
                                                          , true, false, true, true, false), "sumOfSquares");
    assertEquals(floatDate,floatDateTest);
  }

(startLine=211 endLine=249 srcPath=/home/sonia/NewExperiment/luceneFilter/01995/solr/core/src/test/org/apache/solr/analytics/facet/RangeFacetTest.java)
  public void multiGapTest() throws Exception {
    //Int Long
    String intLongRange = getFacetXML(response, "mi", "rangeFacets", "long_ld");
    ArrayList<Double> intLong = (ArrayList<Double>)xmlToList(intLongRange, "double", "sum");
    ArrayList<Double> intLongTest = calculateNumberStat(transformLists(intLongTestStart, 5, 30, "4,2,6,3"
                                                        , false, true, false, false, false), "sum");
    assertEquals(intLong,intLongTest);
    //Int Double
    String intDoubleRange = getFacetXML(response, "mi", "rangeFacets", "double_dd");    
    ArrayList<Double> intDouble = (ArrayList<Double>)xmlToList(intDoubleRange, "double", "mean");
    ArrayList<Double> intDoubleTest = calculateNumberStat(transformLists(intDoubleTestStart, 3, 39, "3,1,7"
                                                          , false, false, true, false, true), "mean");
    assertEquals(intDouble,intDoubleTest);
    //Int Date
    String intDateRange = getFacetXML(response, "mi", "rangeFacets", "date_dtd");
    ArrayList<Long> intDate = (ArrayList<Long>)xmlToList(intDateRange, "long", "count");
    ArrayList<Long> intDateTest = (ArrayList<Long>)calculateStat(transformLists(intDateTestStart, 7, 44, "2,7"
                                                      , false, true, false, true, true), "count");
    assertEquals(intDate,intDateTest);
    
    //Float Long
    String floatLongRange = getFacetXML(response, "mf", "rangeFacets", "long_ld");
    ArrayList<Double> floatLong = (ArrayList<Double>)xmlToList(floatLongRange, "double", "median");
    ArrayList<Double> floatLongTest = calculateNumberStat(transformLists(floatLongTestStart, 0, 29, "1,4"
                                                          , false, true, true, true, true), "median");;
    assertEquals(floatLong,floatLongTest);
    //Float Double
    String floatDoubleRange = getFacetXML(response, "mf", "rangeFacets", "double_dd");    
    ArrayList<Long> floatDouble = (ArrayList<Long>)xmlToList(floatDoubleRange, "long", "count");
    ArrayList<Long> floatDoubleTest = (ArrayList<Long>)calculateStat(transformLists(floatDoubleTestStart, 4, 47, "2,3,11"
                                                          , false, false, false, true, false), "count");
    assertEquals(floatDouble,floatDoubleTest);
    //Float Date                      
    String floatDateRange = getFacetXML(response, "mf", "rangeFacets", "date_dtd");
    ArrayList<Double> floatDate = (ArrayList<Double>)xmlToList(floatDateRange, "double", "sumOfSquares");
    ArrayList<Double> floatDateTest = calculateNumberStat(transformLists(floatDateTestStart, 4, 46, "4,5"
                                                          , false, false, true, true, false), "sumOfSquares");
    assertEquals(floatDate,floatDateTest);
  }

commonMethod: 
(startLine=126 endLine=134 srcPath=/home/sonia/NewExperiment/luceneFilter/01996/solr/core/src/test/org/apache/solr/analytics/facet/AbstractAnalyticsFacetTest.java)
  protected ArrayList<Double> getDoubleList(String n1, String n2, String n3, String element, String n4)
      throws XPathExpressionException {
    ArrayList<Double> ret = new ArrayList<Double>();
    NodeList nodes = getNodes(n1, n2, n3, element, n4);
    for (int idx = 0; idx < nodes.getLength(); ++idx) {
      ret.add(Double.parseDouble(nodes.item(idx).getTextContent()));
    }
    return ret;
  }


]