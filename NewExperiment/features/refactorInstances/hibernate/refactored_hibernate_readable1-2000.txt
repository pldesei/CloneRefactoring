[Instance #
frags: 
(startLine=351 endLine=446 srcPath=/root/NewExperiment/hibernateFilter/00028/cache-jbosscache2/src/test/java/org/hibernate/test/cache/jbc2/entity/AbstractEntityRegionAccessStrategyTestCase.java)
    public void testInsert() throws Exception {
        
        final CountDownLatch readLatch = new CountDownLatch(1);
        final CountDownLatch commitLatch = new CountDownLatch(1);
        final CountDownLatch completionLatch = new CountDownLatch(2);
        
        Thread inserter = new Thread() {          
            
            public void run() {
                
                try {       
                    long txTimestamp = System.currentTimeMillis();
                    BatchModeTransactionManager.getInstance().begin();
                    
                    assertNull("Correct initial value", localAccessStrategy.get(KEY, txTimestamp));
                    
                    localAccessStrategy.insert(KEY, VALUE1, new Integer(1));
                    
                    readLatch.countDown();
                    commitLatch.await();
                    
                    BatchModeTransactionManager.getInstance().commit();
                }
                catch (Exception e) {
                    log.error("node1 caught exception", e);
                    node1Exception = e;
                    rollback();
                }
                catch (AssertionFailedError e) {
                    node1Failure = e;
                    rollback();
                }
                finally {
                    completionLatch.countDown();
                }
            }
        };
        
        Thread reader = new Thread() {          
            
            public void run() {
                
                try {       
                    long txTimestamp = System.currentTimeMillis();
                    BatchModeTransactionManager.getInstance().begin();
                    
                    readLatch.await();
                    Object expected = isUsingOptimisticLocking() ? null : VALUE1;
                    
                    assertEquals("Correct initial value", expected, localAccessStrategy.get(KEY, txTimestamp));
                    
                    BatchModeTransactionManager.getInstance().commit();
                }
                catch (Exception e) {
                    log.error("node1 caught exception", e);
                    node1Exception = e;
                    rollback();
                }
                catch (AssertionFailedError e) {
                    node1Failure = e;
                    rollback();
                }
                finally {
                    commitLatch.countDown();
                    completionLatch.countDown();
                }
            }
        };
        
        inserter.setDaemon(true);
        reader.setDaemon(true);
        inserter.start();
        reader.start();
        
        if (isUsingOptimisticLocking())
            assertTrue("Threads completed", completionLatch.await(1, TimeUnit.SECONDS));
        else {
            // Reader should be blocking for lock
            assertFalse("Threads completed", completionLatch.await(250, TimeUnit.MILLISECONDS));
            commitLatch.countDown();
            assertTrue("Threads completed", completionLatch.await(1, TimeUnit.SECONDS));
        }
        
        if (node1Failure != null)
            throw node1Failure;
        if (node2Failure != null)
            throw node2Failure;
        
        assertEquals("node1 saw no exceptions", null, node1Exception);
        assertEquals("node2 saw no exceptions", null, node2Exception);
        
        long txTimestamp = System.currentTimeMillis();
        assertEquals("Correct node1 value", VALUE1, localAccessStrategy.get(KEY, txTimestamp));
        Object expected = isUsingInvalidation() ? null : VALUE1;
        assertEquals("Correct node2 value", expected, remoteAccessStrategy.get(KEY, txTimestamp));
    }

(startLine=451 endLine=557 srcPath=/root/NewExperiment/hibernateFilter/00028/cache-jbosscache2/src/test/java/org/hibernate/test/cache/jbc2/entity/AbstractEntityRegionAccessStrategyTestCase.java)
    public void testUpdate() throws Exception {
        
        // Set up initial state
        localAccessStrategy.putFromLoad(KEY, VALUE1, System.currentTimeMillis(), new Integer(1));
        remoteAccessStrategy.putFromLoad(KEY, VALUE1, System.currentTimeMillis(), new Integer(1));
        
        // Let the async put propagate
        sleep(250);
        
        final CountDownLatch readLatch = new CountDownLatch(1);
        final CountDownLatch commitLatch = new CountDownLatch(1);
        final CountDownLatch completionLatch = new CountDownLatch(2);
        
        Thread updater = new Thread() {          
            
            public void run() {
                
                try {       
                    long txTimestamp = System.currentTimeMillis();
                    BatchModeTransactionManager.getInstance().begin();
                    
                    assertEquals("Correct initial value", VALUE1, localAccessStrategy.get(KEY, txTimestamp));
                    
                    localAccessStrategy.update(KEY, VALUE2, new Integer(2), new Integer(1));
                    
                    readLatch.countDown();
                    commitLatch.await();
                    
                    BatchModeTransactionManager.getInstance().commit();
                }
                catch (Exception e) {
                    log.error("node1 caught exception", e);
                    node1Exception = e;
                    rollback();
                }
                catch (AssertionFailedError e) {
                    node1Failure = e;
                    rollback();
                }
                finally {
                    completionLatch.countDown();
                }
            }
        };
        
        Thread reader = new Thread() {          
            
            public void run() {                
                try {       
                    long txTimestamp = System.currentTimeMillis();
                    BatchModeTransactionManager.getInstance().begin();
                    
                    readLatch.await();
                    
                    // This will block w/ pessimistic locking and then
                    // read the new value; w/ optimistic it shouldn't
                    // block and will read the old value
                    Object expected = isUsingOptimisticLocking() ? VALUE1 : VALUE2;
                    assertEquals("Correct value", expected, localAccessStrategy.get(KEY, txTimestamp));
                    
                    BatchModeTransactionManager.getInstance().commit();
                }
                catch (Exception e) {
                    log.error("node1 caught exception", e);
                    node1Exception = e;
                    rollback();
                }
                catch (AssertionFailedError e) {
                    node1Failure = e;
                    rollback();
                }
                finally {
                    commitLatch.countDown();
                    completionLatch.countDown();
                }                
            }
        };
        
        updater.setDaemon(true);
        reader.setDaemon(true);
        updater.start();
        reader.start();
        
        if (isUsingOptimisticLocking())
            // Should complete promptly
            assertTrue(completionLatch.await(1, TimeUnit.SECONDS));
        else {        
            // Reader thread should be blocking
            assertFalse(completionLatch.await(250, TimeUnit.MILLISECONDS));
            // Let the writer commit down
            commitLatch.countDown();
            assertTrue(completionLatch.await(1, TimeUnit.SECONDS));
        }
        
        if (node1Failure != null)
            throw node1Failure;
        if (node2Failure != null)
            throw node2Failure;
        
        assertEquals("node1 saw no exceptions", null, node1Exception);
        assertEquals("node2 saw no exceptions", null, node2Exception);
        
        long txTimestamp = System.currentTimeMillis();
        assertEquals("Correct node1 value", VALUE2, localAccessStrategy.get(KEY, txTimestamp));
        Object expected = isUsingInvalidation() ? null : VALUE2;
        assertEquals("Correct node2 value", expected, remoteAccessStrategy.get(KEY, txTimestamp));
    }

commonMethod: 
(startLine=198 endLine=214 srcPath=/root/NewExperiment/hibernateFilter/00029/cache-jbosscache2/src/test/java/org/hibernate/test/cache/jbc2/entity/AbstractEntityRegionAccessStrategyTestCase.java)
    protected void assertThreadsRanCleanly()
    {
        if (node1Failure != null)
            throw node1Failure;
        if (node2Failure != null)
            throw node2Failure;
      
        if (node1Exception != null) {
            log.error("node1 saw an exception", node1Exception);
            assertEquals("node1 saw no exceptions", null, node1Exception);
        }
        
        if (node2Exception != null) {
            log.error("node2 saw an exception", node2Exception);
            assertEquals("node2 saw no exceptions", null, node2Exception);
        }
    }


, Instance #
frags: 
(startLine=363 endLine=406 srcPath=/root/NewExperiment/hibernateFilter/00045/testsuite/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java)
	public void testInsertWithGeneratedVersionAndId() {
		// Make sure the env supports bulk inserts with generated ids...
		EntityPersister persister = sfi().getEntityPersister( IntegerVersioned.class.getName() );
		IdentifierGenerator generator = persister.getIdentifierGenerator();
		if ( !HqlSqlWalker.supportsIdGenWithBulkInsertion( generator ) ) {
			return;
		}

		Session s = openSession();
		Transaction t = s.beginTransaction();

		IntegerVersioned entity = new IntegerVersioned( "int-vers" );
		s.save( entity );
		s.createQuery( "select id, name, version from IntegerVersioned" ).list();
		t.commit();
		s.close();

		Long initialId = entity.getId();
		int initialVersion = entity.getVersion();

		s = openSession();
		t = s.beginTransaction();
		int count = s.createQuery( "insert into IntegerVersioned ( name ) select name from IntegerVersioned" ).executeUpdate();
		t.commit();
		s.close();

		assertEquals( "unexpected insertion count", 1, count );

		s = openSession();
		t = s.beginTransaction();
		IntegerVersioned created = ( IntegerVersioned ) s.createQuery( "from IntegerVersioned where id <> :initialId" )
				.setLong( "initialId", initialId.longValue() )
				.uniqueResult();
		t.commit();
		s.close();

		assertEquals( "version was not seeded", initialVersion, created.getVersion() );

		s = openSession();
		t = s.beginTransaction();
		s.createQuery( "delete IntegerVersioned" ).executeUpdate();
		t.commit();
		s.close();
	}

(startLine=408 endLine=452 srcPath=/root/NewExperiment/hibernateFilter/00045/testsuite/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java)
	public void testInsertWithGeneratedTimestampVersion() {
		// Make sure the env supports bulk inserts with generated ids...
		EntityPersister persister = sfi().getEntityPersister( TimestampVersioned.class.getName() );
		IdentifierGenerator generator = persister.getIdentifierGenerator();
		if ( !HqlSqlWalker.supportsIdGenWithBulkInsertion( generator ) ) {
			return;
		}

		Session s = openSession();
		Transaction t = s.beginTransaction();

		TimestampVersioned entity = new TimestampVersioned( "int-vers" );
		s.save( entity );
		s.createQuery( "select id, name, version from TimestampVersioned" ).list();
		t.commit();
		s.close();

		Long initialId = entity.getId();
		//Date initialVersion = entity.getVersion();

		s = openSession();
		t = s.beginTransaction();
		int count = s.createQuery( "insert into TimestampVersioned ( name ) select name from TimestampVersioned" ).executeUpdate();
		t.commit();
		s.close();

		assertEquals( "unexpected insertion count", 1, count );

		s = openSession();
		t = s.beginTransaction();
		TimestampVersioned created = ( TimestampVersioned ) s.createQuery( "from TimestampVersioned where id <> :initialId" )
				.setLong( "initialId", initialId.longValue() )
				.uniqueResult();
		t.commit();
		s.close();

		assertNotNull( created.getVersion() );
		//assertEquals( "version was not seeded", initialVersion, created.getVersion() );

		s = openSession();
		t = s.beginTransaction();
		s.createQuery( "delete TimestampVersioned" ).executeUpdate();
		t.commit();
		s.close();
	}

commonMethod: 
(startLine=321 endLine=325 srcPath=/root/NewExperiment/hibernateFilter/00046/testsuite/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java)
	protected boolean supportsBulkInsertIdGeneration(Class entityClass) {
		EntityPersister persister = sfi().getEntityPersister( entityClass.getName() );
		IdentifierGenerator generator = persister.getIdentifierGenerator();
		return HqlSqlWalker.supportsIdGenWithBulkInsertion( generator );
	}


, Instance #
frags: 
(startLine=52 endLine=69 srcPath=/root/NewExperiment/hibernateFilter/00233/annotations/src/main/java/org/hibernate/cfg/EJB3DTDEntityResolver.java)
				if ( systemId.endsWith( "orm_1_0.xsd" ) ) {
					log.debug(
							"recognized EJB3 ORM namespace; attempting to resolve on classpath under org/hibernate/ejb"
					);
					String path = "org/hibernate/ejb/" + "orm_1_0.xsd";
					InputStream dtdStream = resolveInHibernateNamespace( path );
					if ( dtdStream == null ) {
						log.debug( "unable to locate [{}] on classpath", systemId );
					}
					else {
						log.debug( "located [{}] in classpath", systemId );
						InputSource source = new InputSource( dtdStream );
						source.setPublicId( publicId );
						source.setSystemId( systemId );
						resolved = false;
						return source;
					}
				}

(startLine=70 endLine=87 srcPath=/root/NewExperiment/hibernateFilter/00233/annotations/src/main/java/org/hibernate/cfg/EJB3DTDEntityResolver.java)
				else if ( systemId.endsWith( "persistence_1_0.xsd" ) ) {
					log.debug(
							"recognized EJB3 ORM namespace; attempting to resolve on classpath under org/hibernate/ejb"
					);
					String path = "org/hibernate/ejb/" + "persistence_1_0.xsd";
					InputStream dtdStream = resolveInHibernateNamespace( path );
					if ( dtdStream == null ) {
						log.debug( "unable to locate [{}] on classpath", systemId );
					}
					else {
						log.debug( "located [{}] in classpath", systemId );
						InputSource source = new InputSource( dtdStream );
						source.setPublicId( publicId );
						source.setSystemId( systemId );
						resolved = true;
						return source;
					}
				}

commonMethod: 
(startLine=89 endLine=102 srcPath=/root/NewExperiment/hibernateFilter/00234/annotations/src/main/java/org/hibernate/cfg/EJB3DTDEntityResolver.java)
	private InputSource buildInputSource(String publicId, String systemId, InputStream dtdStream, boolean resolved) {
		if ( dtdStream == null ) {
			log.trace( "unable to locate [{}] on classpath", systemId );
			return null;
		}
		else {
			log.trace( "located [{}] in classpath", systemId );
			InputSource source = new InputSource( dtdStream );
			source.setPublicId( publicId );
			source.setSystemId( systemId );
			this.resolved = resolved;
			return source;
		}
	}


, Instance #
frags: 
(startLine=52 endLine=69 srcPath=/root/NewExperiment/hibernateFilter/00233/annotations/src/main/java/org/hibernate/cfg/EJB3DTDEntityResolver.java)
				if ( systemId.endsWith( "orm_1_0.xsd" ) ) {
					log.debug(
							"recognized EJB3 ORM namespace; attempting to resolve on classpath under org/hibernate/ejb"
					);
					String path = "org/hibernate/ejb/" + "orm_1_0.xsd";
					InputStream dtdStream = resolveInHibernateNamespace( path );
					if ( dtdStream == null ) {
						log.debug( "unable to locate [{}] on classpath", systemId );
					}
					else {
						log.debug( "located [{}] in classpath", systemId );
						InputSource source = new InputSource( dtdStream );
						source.setPublicId( publicId );
						source.setSystemId( systemId );
						resolved = false;
						return source;
					}
				}

(startLine=70 endLine=87 srcPath=/root/NewExperiment/hibernateFilter/00233/annotations/src/main/java/org/hibernate/cfg/EJB3DTDEntityResolver.java)
				else if ( systemId.endsWith( "persistence_1_0.xsd" ) ) {
					log.debug(
							"recognized EJB3 ORM namespace; attempting to resolve on classpath under org/hibernate/ejb"
					);
					String path = "org/hibernate/ejb/" + "persistence_1_0.xsd";
					InputStream dtdStream = resolveInHibernateNamespace( path );
					if ( dtdStream == null ) {
						log.debug( "unable to locate [{}] on classpath", systemId );
					}
					else {
						log.debug( "located [{}] in classpath", systemId );
						InputSource source = new InputSource( dtdStream );
						source.setPublicId( publicId );
						source.setSystemId( systemId );
						resolved = true;
						return source;
					}
				}

commonMethod: 
(startLine=104 endLine=111 srcPath=/root/NewExperiment/hibernateFilter/00234/annotations/src/main/java/org/hibernate/cfg/EJB3DTDEntityResolver.java)
	private InputStream getStreamFromClasspath(String fileName) {
		log.trace(
							"recognized JPA ORM namespace; attempting to resolve on classpath under org/hibernate/ejb"
		);
		String path = "org/hibernate/ejb/" + fileName;
		InputStream dtdStream = resolveInHibernateNamespace( path );
		return dtdStream;
	}


, Instance #
frags: 
(startLine=80 endLine=100 srcPath=/root/NewExperiment/hibernateFilter/00299/core/src/main/java/org/hibernate/proxy/pojo/cglib/SerializableProxy.java)
	private Object readResolve() {
		try {
			return CGLIBLazyInitializer.getProxy(
				entityName,
				persistentClass,
				interfaces,
				getIdentifierMethodName==null ?
					null :
					getIdentifierMethodClass.getDeclaredMethod(getIdentifierMethodName, null),
				setIdentifierMethodName==null ?
					null :
					setIdentifierMethodClass.getDeclaredMethod(setIdentifierMethodName, setIdentifierMethodParams),
					componentIdType,
				id,
				null
			);
		}
		catch (NoSuchMethodException nsme) {
			throw new HibernateException("could not create proxy for entity: " + entityName, nsme);
		}
	}

(startLine=80 endLine=100 srcPath=/root/NewExperiment/hibernateFilter/00299/core/src/main/java/org/hibernate/proxy/pojo/javassist/SerializableProxy.java)
	private Object readResolve() {
		try {
			return JavassistLazyInitializer.getProxy(
				entityName,
				persistentClass,
				interfaces,
				getIdentifierMethodName==null ?
					null :
					getIdentifierMethodClass.getDeclaredMethod(getIdentifierMethodName, null),
				setIdentifierMethodName==null ?
					null :
					setIdentifierMethodClass.getDeclaredMethod(setIdentifierMethodName, setIdentifierMethodParams),
					componentIdType,
				id,
				null
			);
		}
		catch (NoSuchMethodException nsme) {
			throw new HibernateException("could not create proxy for entity: " + entityName, nsme);
		}
	}

commonMethod: 
(startLine=55 endLine=57 srcPath=/root/NewExperiment/hibernateFilter/00300/core/src/main/java/org/hibernate/proxy/AbstractSerializableProxy.java)
	protected Serializable getId() {
		return id;
	}


, Instance #
frags: 
(startLine=80 endLine=100 srcPath=/root/NewExperiment/hibernateFilter/00299/core/src/main/java/org/hibernate/proxy/pojo/cglib/SerializableProxy.java)
	private Object readResolve() {
		try {
			return CGLIBLazyInitializer.getProxy(
				entityName,
				persistentClass,
				interfaces,
				getIdentifierMethodName==null ?
					null :
					getIdentifierMethodClass.getDeclaredMethod(getIdentifierMethodName, null),
				setIdentifierMethodName==null ?
					null :
					setIdentifierMethodClass.getDeclaredMethod(setIdentifierMethodName, setIdentifierMethodParams),
					componentIdType,
				id,
				null
			);
		}
		catch (NoSuchMethodException nsme) {
			throw new HibernateException("could not create proxy for entity: " + entityName, nsme);
		}
	}

(startLine=80 endLine=100 srcPath=/root/NewExperiment/hibernateFilter/00299/core/src/main/java/org/hibernate/proxy/pojo/javassist/SerializableProxy.java)
	private Object readResolve() {
		try {
			return JavassistLazyInitializer.getProxy(
				entityName,
				persistentClass,
				interfaces,
				getIdentifierMethodName==null ?
					null :
					getIdentifierMethodClass.getDeclaredMethod(getIdentifierMethodName, null),
				setIdentifierMethodName==null ?
					null :
					setIdentifierMethodClass.getDeclaredMethod(setIdentifierMethodName, setIdentifierMethodParams),
					componentIdType,
				id,
				null
			);
		}
		catch (NoSuchMethodException nsme) {
			throw new HibernateException("could not create proxy for entity: " + entityName, nsme);
		}
	}

commonMethod: 
(startLine=59 endLine=71 srcPath=/root/NewExperiment/hibernateFilter/00300/core/src/main/java/org/hibernate/proxy/AbstractSerializableProxy.java)
	/**
	 * Set the read-only/modifiable setting from this object in an AbstractLazyInitializer.
	 *
	 * This method should only be called during deserialization, before associating the
	 * AbstractLazyInitializer with a session.
	 *
	 * @param li, the read-only/modifiable setting to use when
	 * associated with a session; null indicates that the default should be used.
	 * @throws IllegalStateException if isReadOnlySettingAvailable() == true
	 */
	protected void setReadOnlyBeforeAttachedToSession(AbstractLazyInitializer li) {
		li.setReadOnlyBeforeAttachedToSession( readOnly );
	}


, Instance #
frags: 
(startLine=80 endLine=100 srcPath=/root/NewExperiment/hibernateFilter/00299/core/src/main/java/org/hibernate/proxy/pojo/cglib/SerializableProxy.java)
	private Object readResolve() {
		try {
			return CGLIBLazyInitializer.getProxy(
				entityName,
				persistentClass,
				interfaces,
				getIdentifierMethodName==null ?
					null :
					getIdentifierMethodClass.getDeclaredMethod(getIdentifierMethodName, null),
				setIdentifierMethodName==null ?
					null :
					setIdentifierMethodClass.getDeclaredMethod(setIdentifierMethodName, setIdentifierMethodParams),
					componentIdType,
				id,
				null
			);
		}
		catch (NoSuchMethodException nsme) {
			throw new HibernateException("could not create proxy for entity: " + entityName, nsme);
		}
	}

(startLine=80 endLine=100 srcPath=/root/NewExperiment/hibernateFilter/00299/core/src/main/java/org/hibernate/proxy/pojo/javassist/SerializableProxy.java)
	private Object readResolve() {
		try {
			return JavassistLazyInitializer.getProxy(
				entityName,
				persistentClass,
				interfaces,
				getIdentifierMethodName==null ?
					null :
					getIdentifierMethodClass.getDeclaredMethod(getIdentifierMethodName, null),
				setIdentifierMethodName==null ?
					null :
					setIdentifierMethodClass.getDeclaredMethod(setIdentifierMethodName, setIdentifierMethodParams),
					componentIdType,
				id,
				null
			);
		}
		catch (NoSuchMethodException nsme) {
			throw new HibernateException("could not create proxy for entity: " + entityName, nsme);
		}
	}

commonMethod: 
(startLine=51 endLine=53 srcPath=/root/NewExperiment/hibernateFilter/00300/core/src/main/java/org/hibernate/proxy/AbstractSerializableProxy.java)
	protected String getEntityName() {
		return entityName;
	}


, Instance #
frags: 
(startLine=104 endLine=127 srcPath=/root/NewExperiment/hibernateFilter/00308/core/src/main/java/org/hibernate/id/SequenceGenerator.java)
		try {

			PreparedStatement st = session.getBatcher().prepareSelectStatement(sql);
			try {
				ResultSet rs = st.executeQuery();
				try {
					rs.next();
					Serializable result = IdentifierGeneratorHelper.get(
							rs, identifierType
						);
					if ( log.isDebugEnabled() ) {
						log.debug("Sequence identifier generated: " + result);
					}
					return result;
				}
				finally {
					rs.close();
				}
			}
			finally {
				session.getBatcher().closeStatement(st);
			}
			
		}

(startLine=96 endLine=121 srcPath=/root/NewExperiment/hibernateFilter/00308/core/src/main/java/org/hibernate/id/enhanced/SequenceStructure.java)
				try {
					PreparedStatement st = session.getBatcher().prepareSelectStatement( sql );
					try {
						ResultSet rs = st.executeQuery();
						try {
							rs.next();
							long result = rs.getLong( 1 );
							if ( log.isDebugEnabled() ) {
								log.debug("Sequence identifier generated: " + result);
							}
							return result;
						}
						finally {
							try {
								rs.close();
							}
							catch( Throwable ignore ) {
								// intentionally empty
							}
						}
					}
					finally {
						session.getBatcher().closeStatement( st );
					}

				}

commonMethod: 
(startLine=165 endLine=182 srcPath=/root/NewExperiment/hibernateFilter/00309/core/src/main/java/org/hibernate/id/IdentifierGeneratorHelper.java)
	public static IntegralDataTypeHolder getIntegralDataTypeHolder(Class integralType) {
		if ( integralType == Long.class
				|| integralType == Integer.class
				|| integralType == Short.class ) {
			return new BasicHolder( integralType );
		}
		else if ( integralType == BigInteger.class ) {
			return new BigIntegerHolder();
		}
		else if ( integralType == BigDecimal.class ) {
			return new BigDecimalHolder();
		}
		else {
			throw new IdentifierGenerationException(
					"Unknown integral data type for ids : " + integralType.getName()
			);
		}
	}


, Instance #
frags: 
(startLine=102 endLine=137 srcPath=/root/NewExperiment/hibernateFilter/00308/core/src/main/java/org/hibernate/id/SequenceGenerator.java)
	throws HibernateException {
		
		try {

			PreparedStatement st = session.getBatcher().prepareSelectStatement(sql);
			try {
				ResultSet rs = st.executeQuery();
				try {
					rs.next();
					Serializable result = IdentifierGeneratorHelper.get(
							rs, identifierType
						);
					if ( log.isDebugEnabled() ) {
						log.debug("Sequence identifier generated: " + result);
					}
					return result;
				}
				finally {
					rs.close();
				}
			}
			finally {
				session.getBatcher().closeStatement(st);
			}
			
		}
		catch (SQLException sqle) {
			throw JDBCExceptionHelper.convert(
					session.getFactory().getSQLExceptionConverter(),
					sqle,
					"could not get next sequence value",
					sql
				);
		}

	}

(startLine=92 endLine=132 srcPath=/root/NewExperiment/hibernateFilter/00308/core/src/main/java/org/hibernate/id/enhanced/SequenceStructure.java)
	public AccessCallback buildCallback(final SessionImplementor session) {
		return new AccessCallback() {
			public long getNextValue() {
				accessCounter++;
				try {
					PreparedStatement st = session.getBatcher().prepareSelectStatement( sql );
					try {
						ResultSet rs = st.executeQuery();
						try {
							rs.next();
							long result = rs.getLong( 1 );
							if ( log.isDebugEnabled() ) {
								log.debug("Sequence identifier generated: " + result);
							}
							return result;
						}
						finally {
							try {
								rs.close();
							}
							catch( Throwable ignore ) {
								// intentionally empty
							}
						}
					}
					finally {
						session.getBatcher().closeStatement( st );
					}

				}
				catch ( SQLException sqle) {
					throw JDBCExceptionHelper.convert(
							session.getFactory().getSQLExceptionConverter(),
							sqle,
							"could not get next sequence value",
							sql
					);
				}
			}
		};
	}

commonMethod: 
(startLine=46 endLine=57 srcPath=/root/NewExperiment/hibernateFilter/00309/core/src/main/java/org/hibernate/id/IntegralDataTypeHolder.java)
	/**
	 * Initialize the internal value from the given result set, using the specified default value
	 * if we could not get a value from the result set (aka result was null).
	 *
	 * @param resultSet The JDBC result set
	 * @param defaultValue The default value to use if we did not get a result set value.
	 *
	 * @return <tt>this</tt>, for method chaining
	 *
	 * @throws SQLException Any exception from accessing the result set
	 */
	public IntegralDataTypeHolder initialize(ResultSet resultSet, long defaultValue) throws SQLException;


, Instance #
frags: 
(startLine=102 endLine=137 srcPath=/root/NewExperiment/hibernateFilter/00308/core/src/main/java/org/hibernate/id/SequenceGenerator.java)
	throws HibernateException {
		
		try {

			PreparedStatement st = session.getBatcher().prepareSelectStatement(sql);
			try {
				ResultSet rs = st.executeQuery();
				try {
					rs.next();
					Serializable result = IdentifierGeneratorHelper.get(
							rs, identifierType
						);
					if ( log.isDebugEnabled() ) {
						log.debug("Sequence identifier generated: " + result);
					}
					return result;
				}
				finally {
					rs.close();
				}
			}
			finally {
				session.getBatcher().closeStatement(st);
			}
			
		}
		catch (SQLException sqle) {
			throw JDBCExceptionHelper.convert(
					session.getFactory().getSQLExceptionConverter(),
					sqle,
					"could not get next sequence value",
					sql
				);
		}

	}

(startLine=92 endLine=132 srcPath=/root/NewExperiment/hibernateFilter/00308/core/src/main/java/org/hibernate/id/enhanced/SequenceStructure.java)
	public AccessCallback buildCallback(final SessionImplementor session) {
		return new AccessCallback() {
			public long getNextValue() {
				accessCounter++;
				try {
					PreparedStatement st = session.getBatcher().prepareSelectStatement( sql );
					try {
						ResultSet rs = st.executeQuery();
						try {
							rs.next();
							long result = rs.getLong( 1 );
							if ( log.isDebugEnabled() ) {
								log.debug("Sequence identifier generated: " + result);
							}
							return result;
						}
						finally {
							try {
								rs.close();
							}
							catch( Throwable ignore ) {
								// intentionally empty
							}
						}
					}
					finally {
						session.getBatcher().closeStatement( st );
					}

				}
				catch ( SQLException sqle) {
					throw JDBCExceptionHelper.convert(
							session.getFactory().getSQLExceptionConverter(),
							sqle,
							"could not get next sequence value",
							sql
					);
				}
			}
		};
	}

commonMethod: 
(startLine=165 endLine=182 srcPath=/root/NewExperiment/hibernateFilter/00309/core/src/main/java/org/hibernate/id/IdentifierGeneratorHelper.java)
	public static IntegralDataTypeHolder getIntegralDataTypeHolder(Class integralType) {
		if ( integralType == Long.class
				|| integralType == Integer.class
				|| integralType == Short.class ) {
			return new BasicHolder( integralType );
		}
		else if ( integralType == BigInteger.class ) {
			return new BigIntegerHolder();
		}
		else if ( integralType == BigDecimal.class ) {
			return new BigDecimalHolder();
		}
		else {
			throw new IdentifierGenerationException(
					"Unknown integral data type for ids : " + integralType.getName()
			);
		}
	}


, Instance #
frags: 
(startLine=26 endLine=52 srcPath=/root/NewExperiment/hibernateFilter/00315/entitymanager/src/test/java/org/hibernate/ejb/test/ops/PersistTest.java)
	public void testCreateTree() {

		clearCounts();

		Session s = openSession();
		Transaction tx = s.beginTransaction();
		Node root = new Node( "root" );
		Node child = new Node( "child" );
		root.addChild( child );
		s.persist( root );
		tx.commit();
		s.close();

		assertInsertCount( 2 );
		assertUpdateCount( 0 );

		s = openSession();
		tx = s.beginTransaction();
		root = (Node) s.get( Node.class, "root" );
		Node child2 = new Node( "child2" );
		root.addChild( child2 );
		tx.commit();
		s.close();

		assertInsertCount( 3 );
		assertUpdateCount( 0 );
	}

(startLine=54 endLine=80 srcPath=/root/NewExperiment/hibernateFilter/00315/entitymanager/src/test/java/org/hibernate/ejb/test/ops/PersistTest.java)
	public void testCreateTreeWithGeneratedId() {

		clearCounts();

		Session s = openSession();
		Transaction tx = s.beginTransaction();
		NumberedNode root = new NumberedNode( "root" );
		NumberedNode child = new NumberedNode( "child" );
		root.addChild( child );
		s.persist( root );
		tx.commit();
		s.close();

		assertInsertCount( 2 );
		assertUpdateCount( 0 );

		s = openSession();
		tx = s.beginTransaction();
		root = (NumberedNode) s.get( NumberedNode.class, new Long( root.getId() ) );
		NumberedNode child2 = new NumberedNode( "child2" );
		root.addChild( child2 );
		tx.commit();
		s.close();

		assertInsertCount( 3 );
		assertUpdateCount( 0 );
	}

commonMethod: 
(startLine=124 endLine=129 srcPath=/root/NewExperiment/hibernateFilter/00316/entitymanager/src/test/java/org/hibernate/ejb/test/TestCase.java)
	protected EntityManager getOrCreateEntityManager() {
		if ( em == null || !em.isOpen() ) {
			em = factory.createEntityManager();
		}
		return em;
	}


, Instance #
frags: 
(startLine=82 endLine=119 srcPath=/root/NewExperiment/hibernateFilter/00315/entitymanager/src/test/java/org/hibernate/ejb/test/ops/PersistTest.java)
	public void testCreateException() {
		Session s = openSession();
		Transaction tx = s.beginTransaction();
		Node dupe = new Node( "dupe" );
		s.persist( dupe );
		s.persist( dupe );
		tx.commit();
		s.close();

		s = openSession();
		tx = s.beginTransaction();
		s.persist( dupe );
		try {
			tx.commit();
			fail( "Cannot persist() twice the same entity" );
		}
		catch (ConstraintViolationException cve) {
			//verify that an exception is thrown!
		}
		tx.rollback();
		s.close();

		Node nondupe = new Node( "nondupe" );
		nondupe.addChild( dupe );

		s = openSession();
		tx = s.beginTransaction();
		s.persist( nondupe );
		try {
			tx.commit();
			assertFalse( true );
		}
		catch (ConstraintViolationException cve) {
			//verify that an exception is thrown!
		}
		tx.rollback();
		s.close();
	}

(startLine=121 endLine=156 srcPath=/root/NewExperiment/hibernateFilter/00315/entitymanager/src/test/java/org/hibernate/ejb/test/ops/PersistTest.java)
	public void testCreateExceptionWithGeneratedId() {
		Session s = openSession();
		Transaction tx = s.beginTransaction();
		NumberedNode dupe = new NumberedNode( "dupe" );
		s.persist( dupe );
		s.persist( dupe );
		tx.commit();
		s.close();

		s = openSession();
		tx = s.beginTransaction();
		try {
			s.persist( dupe );
			fail();
		}
		catch (PersistentObjectException poe) {
			//verify that an exception is thrown!
		}
		tx.rollback();
		s.close();

		NumberedNode nondupe = new NumberedNode( "nondupe" );
		nondupe.addChild( dupe );

		s = openSession();
		tx = s.beginTransaction();
		try {
			s.persist( nondupe );
			fail();
		}
		catch (PersistentObjectException poe) {
			//verify that an exception is thrown!
		}
		tx.rollback();
		s.close();
	}

commonMethod: 
(startLine=124 endLine=129 srcPath=/root/NewExperiment/hibernateFilter/00316/entitymanager/src/test/java/org/hibernate/ejb/test/TestCase.java)
	protected EntityManager getOrCreateEntityManager() {
		if ( em == null || !em.isOpen() ) {
			em = factory.createEntityManager();
		}
		return em;
	}


, Instance #
frags: 
(startLine=172 endLine=207 srcPath=/root/NewExperiment/hibernateFilter/00318/testsuite/src/test/java/org/hibernate/test/readonly/ReadOnlyTest.java)
	public void testReadOnlyRefresh() {

		Session s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		Transaction t = s.beginTransaction();
		DataPoint dp = new DataPoint();
		dp.setDescription( "original" );
		dp.setX( new BigDecimal(0.1d).setScale(19, BigDecimal.ROUND_DOWN) );
		dp.setY( new BigDecimal( Math.cos( dp.getX().doubleValue() ) ).setScale(19, BigDecimal.ROUND_DOWN) );
		s.save(dp);
		t.commit();
		s.close();

		s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		t = s.beginTransaction();
		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
		s.setReadOnly( dp, true );
		assertEquals( "original", dp.getDescription() );
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		s.refresh( dp );
		assertEquals( "original", dp.getDescription() );
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		t.commit();

		s.clear();
		t = s.beginTransaction();
		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
		assertEquals( "original", dp.getDescription() );
		s.delete( dp );
		t.commit();
		s.close();

	}

(startLine=209 endLine=246 srcPath=/root/NewExperiment/hibernateFilter/00318/testsuite/src/test/java/org/hibernate/test/readonly/ReadOnlyTest.java)
	public void testReadOnlyRefreshDetached() {

		Session s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		Transaction t = s.beginTransaction();
		DataPoint dp = new DataPoint();
		dp.setDescription( "original" );
		dp.setX( new BigDecimal(0.1d).setScale(19, BigDecimal.ROUND_DOWN) );
		dp.setY( new BigDecimal( Math.cos( dp.getX().doubleValue() ) ).setScale(19, BigDecimal.ROUND_DOWN) );
		s.save(dp);
		t.commit();
		s.close();

		s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		t = s.beginTransaction();
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		s.refresh( dp );
		assertEquals( "original", dp.getDescription() );
		assertFalse( s.isReadOnly( dp ) );
		s.setReadOnly( dp, true );
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		s.evict( dp );
		s.refresh( dp );
		assertEquals( "original", dp.getDescription() );
		assertFalse( s.isReadOnly( dp ) );
		t.commit();

		s.clear();
		t = s.beginTransaction();
		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
		assertEquals( "original", dp.getDescription() );
		s.delete( dp );
		t.commit();
		s.close();
	}

commonMethod: 
(startLine=65 endLine=68 srcPath=/root/NewExperiment/hibernateFilter/00319/testsuite/src/test/java/org/hibernate/test/readonly/AbstractReadOnlyTest.java)
	protected void assertInsertCount(int expected) {
		int inserts = ( int ) getSessions().getStatistics().getEntityInsertCount();
		assertEquals( "unexpected insert count", expected, inserts );
	}


, Instance #
frags: 
(startLine=172 endLine=207 srcPath=/root/NewExperiment/hibernateFilter/00318/testsuite/src/test/java/org/hibernate/test/readonly/ReadOnlyTest.java)
	public void testReadOnlyRefresh() {

		Session s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		Transaction t = s.beginTransaction();
		DataPoint dp = new DataPoint();
		dp.setDescription( "original" );
		dp.setX( new BigDecimal(0.1d).setScale(19, BigDecimal.ROUND_DOWN) );
		dp.setY( new BigDecimal( Math.cos( dp.getX().doubleValue() ) ).setScale(19, BigDecimal.ROUND_DOWN) );
		s.save(dp);
		t.commit();
		s.close();

		s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		t = s.beginTransaction();
		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
		s.setReadOnly( dp, true );
		assertEquals( "original", dp.getDescription() );
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		s.refresh( dp );
		assertEquals( "original", dp.getDescription() );
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		t.commit();

		s.clear();
		t = s.beginTransaction();
		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
		assertEquals( "original", dp.getDescription() );
		s.delete( dp );
		t.commit();
		s.close();

	}

(startLine=209 endLine=246 srcPath=/root/NewExperiment/hibernateFilter/00318/testsuite/src/test/java/org/hibernate/test/readonly/ReadOnlyTest.java)
	public void testReadOnlyRefreshDetached() {

		Session s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		Transaction t = s.beginTransaction();
		DataPoint dp = new DataPoint();
		dp.setDescription( "original" );
		dp.setX( new BigDecimal(0.1d).setScale(19, BigDecimal.ROUND_DOWN) );
		dp.setY( new BigDecimal( Math.cos( dp.getX().doubleValue() ) ).setScale(19, BigDecimal.ROUND_DOWN) );
		s.save(dp);
		t.commit();
		s.close();

		s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		t = s.beginTransaction();
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		s.refresh( dp );
		assertEquals( "original", dp.getDescription() );
		assertFalse( s.isReadOnly( dp ) );
		s.setReadOnly( dp, true );
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		s.evict( dp );
		s.refresh( dp );
		assertEquals( "original", dp.getDescription() );
		assertFalse( s.isReadOnly( dp ) );
		t.commit();

		s.clear();
		t = s.beginTransaction();
		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
		assertEquals( "original", dp.getDescription() );
		s.delete( dp );
		t.commit();
		s.close();
	}

commonMethod: 
(startLine=75 endLine=78 srcPath=/root/NewExperiment/hibernateFilter/00319/testsuite/src/test/java/org/hibernate/test/readonly/AbstractReadOnlyTest.java)
	protected void assertDeleteCount(int expected) {
		int deletes = ( int ) getSessions().getStatistics().getEntityDeleteCount();
		assertEquals( "unexpected delete counts", expected, deletes );
	}


, Instance #
frags: 
(startLine=172 endLine=207 srcPath=/root/NewExperiment/hibernateFilter/00318/testsuite/src/test/java/org/hibernate/test/readonly/ReadOnlyTest.java)
	public void testReadOnlyRefresh() {

		Session s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		Transaction t = s.beginTransaction();
		DataPoint dp = new DataPoint();
		dp.setDescription( "original" );
		dp.setX( new BigDecimal(0.1d).setScale(19, BigDecimal.ROUND_DOWN) );
		dp.setY( new BigDecimal( Math.cos( dp.getX().doubleValue() ) ).setScale(19, BigDecimal.ROUND_DOWN) );
		s.save(dp);
		t.commit();
		s.close();

		s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		t = s.beginTransaction();
		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
		s.setReadOnly( dp, true );
		assertEquals( "original", dp.getDescription() );
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		s.refresh( dp );
		assertEquals( "original", dp.getDescription() );
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		t.commit();

		s.clear();
		t = s.beginTransaction();
		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
		assertEquals( "original", dp.getDescription() );
		s.delete( dp );
		t.commit();
		s.close();

	}

(startLine=209 endLine=246 srcPath=/root/NewExperiment/hibernateFilter/00318/testsuite/src/test/java/org/hibernate/test/readonly/ReadOnlyTest.java)
	public void testReadOnlyRefreshDetached() {

		Session s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		Transaction t = s.beginTransaction();
		DataPoint dp = new DataPoint();
		dp.setDescription( "original" );
		dp.setX( new BigDecimal(0.1d).setScale(19, BigDecimal.ROUND_DOWN) );
		dp.setY( new BigDecimal( Math.cos( dp.getX().doubleValue() ) ).setScale(19, BigDecimal.ROUND_DOWN) );
		s.save(dp);
		t.commit();
		s.close();

		s = openSession();
		s.setCacheMode(CacheMode.IGNORE);
		t = s.beginTransaction();
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		s.refresh( dp );
		assertEquals( "original", dp.getDescription() );
		assertFalse( s.isReadOnly( dp ) );
		s.setReadOnly( dp, true );
		dp.setDescription( "changed" );
		assertEquals( "changed", dp.getDescription() );
		s.evict( dp );
		s.refresh( dp );
		assertEquals( "original", dp.getDescription() );
		assertFalse( s.isReadOnly( dp ) );
		t.commit();

		s.clear();
		t = s.beginTransaction();
		dp = ( DataPoint ) s.get( DataPoint.class, dp.getId() );
		assertEquals( "original", dp.getDescription() );
		s.delete( dp );
		t.commit();
		s.close();
	}

commonMethod: 
(startLine=70 endLine=73 srcPath=/root/NewExperiment/hibernateFilter/00319/testsuite/src/test/java/org/hibernate/test/readonly/AbstractReadOnlyTest.java)
	protected void assertUpdateCount(int expected) {
		int updates = ( int ) getSessions().getStatistics().getEntityUpdateCount();
		assertEquals( "unexpected update counts", expected, updates );
	}


, Instance #
frags: 
(startLine=86 endLine=137 srcPath=/root/NewExperiment/hibernateFilter/00328/core/src/main/java/org/hibernate/dialect/lock/PessimisticWriteSelectLockingStrategy.java)
      int timeout, SessionImplementor session) throws StaleObjectStateException, JDBCException {
		String sql = this.sql;
		if ( timeout == LockOptions.NO_WAIT ) {
			sql = generateLockString( LockOptions.NO_WAIT );
		}
		else if ( timeout > 0) {
			sql = generateLockString( timeout );
		}

		SessionFactoryImplementor factory = session.getFactory();
		try {
			PreparedStatement st = session.getBatcher().prepareSelectStatement( sql );
			try {
				lockable.getIdentifierType().nullSafeSet( st, id, 1, session );
				if ( lockable.isVersioned() ) {
					lockable.getVersionType().nullSafeSet(
							st,
							version,
							lockable.getIdentifierType().getColumnSpan( factory ) + 1,
							session
					);
				}

				ResultSet rs = st.executeQuery();
				try {
					if ( !rs.next() ) {
						if ( factory.getStatistics().isStatisticsEnabled() ) {
							factory.getStatisticsImplementor()
									.optimisticFailure( lockable.getEntityName() );
						}
						throw new StaleObjectStateException( lockable.getEntityName(), id );
					}
				}
				finally {
					rs.close();
				}
			}
			finally {
				session.getBatcher().closeStatement( st );
			}

		}
		catch ( SQLException sqle ) {
			JDBCException e = JDBCExceptionHelper.convert(
					session.getFactory().getSQLExceptionConverter(),
					sqle,
					"could not lock: " + MessageHelper.infoString( lockable, id, session.getFactory() ),
					sql
				);
			throw new PessimisticLockException("could not obtain pessimistic lock", e, object);
		}
	}

(startLine=86 endLine=137 srcPath=/root/NewExperiment/hibernateFilter/00328/core/src/main/java/org/hibernate/dialect/lock/PessimisticReadSelectLockingStrategy.java)
      int timeout, SessionImplementor session) throws StaleObjectStateException, JDBCException {
		String sql = this.sql;
		if ( timeout == LockOptions.NO_WAIT ) {
			sql = generateLockString( LockOptions.NO_WAIT );
		}
		else if ( timeout > 0) {
			sql = generateLockString( timeout );
		}

		SessionFactoryImplementor factory = session.getFactory();
		try {
			PreparedStatement st = session.getBatcher().prepareSelectStatement( sql );
			try {
				lockable.getIdentifierType().nullSafeSet( st, id, 1, session );
				if ( lockable.isVersioned() ) {
					lockable.getVersionType().nullSafeSet(
							st,
							version,
							lockable.getIdentifierType().getColumnSpan( factory ) + 1,
							session
					);
				}

				ResultSet rs = st.executeQuery();
				try {
					if ( !rs.next() ) {
						if ( factory.getStatistics().isStatisticsEnabled() ) {
							factory.getStatisticsImplementor()
									.optimisticFailure( lockable.getEntityName() );
						}
						throw new StaleObjectStateException( lockable.getEntityName(), id );
					}
				}
				finally {
					rs.close();
				}
			}
			finally {
				session.getBatcher().closeStatement( st );
			}

		}
		catch ( SQLException sqle ) {
			JDBCException e = JDBCExceptionHelper.convert(
					session.getFactory().getSQLExceptionConverter(),
					sqle,
					"could not lock: " + MessageHelper.infoString( lockable, id, session.getFactory() ),
					sql
				);
			throw new PessimisticLockException("could not obtain pessimistic lock", e, object);
		}
	}

commonMethod: 
(startLine=57 endLine=63 srcPath=/root/NewExperiment/hibernateFilter/00329/core/src/main/java/org/hibernate/dialect/lock/AbstractSelectLockingStrategy.java)
	protected String determineSql(int timeout) {
		return timeout == LockOptions.WAIT_FOREVER
				? waitForeverSql
				: timeout == LockOptions.NO_WAIT
						? getNoWaitSql()
						: generateLockString( timeout );
	}


, Instance #
frags: 
(startLine=69 endLine=90 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java)
	public synchronized Serializable generate(SessionImplementor session, Object obj) {
		// maxLo < 1 indicates a hilo generator with no hilo :?
		if ( maxLo < 1 ) {
			//keep the behavior consistent even for boundary usages
			IntegralDataTypeHolder value = null;
			while ( value == null || value.lt( 0 ) ) {
				value = super.generateHolder( session );
			}
			return value.makeValue();
		}

		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = generateHolder( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

		return value.makeValueThenIncrement();
	}

(startLine=204 endLine=224 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java)
		throws HibernateException {
		// maxLo < 1 indicates a hilo generator with no hilo :?
		if ( maxLo < 1 ) {
			//keep the behavior consistent even for boundary usages
			IntegralDataTypeHolder value = null;
			while ( value == null || value.lt( 1 ) ) {
				value = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			}
			return value.makeValue();
		}

		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}
		return value.makeValueThenIncrement();
	}

commonMethod: 
(startLine=130 endLine=143 srcPath=/root/NewExperiment/hibernateFilter/00349/core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java)
		/**
		 * {@inheritDoc}
		 */
		public Serializable generate(AccessCallback callback) {
			if ( lastSourceValue == null ) {
				do {
					lastSourceValue = callback.getNextValue();
				} while ( lastSourceValue.lt( 1 ) );
			}
			else {
				lastSourceValue = callback.getNextValue();
			}
			return lastSourceValue.makeValue();
		}


, Instance #
frags: 
(startLine=69 endLine=90 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java)
	public synchronized Serializable generate(SessionImplementor session, Object obj) {
		// maxLo < 1 indicates a hilo generator with no hilo :?
		if ( maxLo < 1 ) {
			//keep the behavior consistent even for boundary usages
			IntegralDataTypeHolder value = null;
			while ( value == null || value.lt( 0 ) ) {
				value = super.generateHolder( session );
			}
			return value.makeValue();
		}

		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = generateHolder( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

		return value.makeValueThenIncrement();
	}

(startLine=204 endLine=224 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java)
		throws HibernateException {
		// maxLo < 1 indicates a hilo generator with no hilo :?
		if ( maxLo < 1 ) {
			//keep the behavior consistent even for boundary usages
			IntegralDataTypeHolder value = null;
			while ( value == null || value.lt( 1 ) ) {
				value = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			}
			return value.makeValue();
		}

		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}
		return value.makeValueThenIncrement();
	}

commonMethod: 
(startLine=208 endLine=229 srcPath=/root/NewExperiment/hibernateFilter/00349/core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java)
		/**
		 * {@inheritDoc}
		 */
		public synchronized Serializable generate(AccessCallback callback) {
			if ( lastSourceValue == null ) {
				// first call, so initialize ourselves.  we need to read the database
				// value and set up the 'bucket' boundaries
				lastSourceValue = callback.getNextValue();
				while ( lastSourceValue.lt( 1 ) ) {
					lastSourceValue = callback.getNextValue();
				}
				// upperLimit defines the upper end of the bucket values
				upperLimit = lastSourceValue.copy().multiplyBy( incrementSize ).increment();
				// initialize value to the low end of the bucket
				value = upperLimit.copy().subtract( incrementSize );
			}
			else if ( ! upperLimit.gt( value ) ) {
				lastSourceValue = callback.getNextValue();
				upperLimit = lastSourceValue.copy().multiplyBy( incrementSize ).increment();
			}
			return value.makeValueThenIncrement();
		}


, Instance #
frags: 
(startLine=69 endLine=90 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java)
	public synchronized Serializable generate(SessionImplementor session, Object obj) {
		// maxLo < 1 indicates a hilo generator with no hilo :?
		if ( maxLo < 1 ) {
			//keep the behavior consistent even for boundary usages
			IntegralDataTypeHolder value = null;
			while ( value == null || value.lt( 0 ) ) {
				value = super.generateHolder( session );
			}
			return value.makeValue();
		}

		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = generateHolder( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

		return value.makeValueThenIncrement();
	}

(startLine=204 endLine=224 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java)
		throws HibernateException {
		// maxLo < 1 indicates a hilo generator with no hilo :?
		if ( maxLo < 1 ) {
			//keep the behavior consistent even for boundary usages
			IntegralDataTypeHolder value = null;
			while ( value == null || value.lt( 1 ) ) {
				value = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			}
			return value.makeValue();
		}

		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}
		return value.makeValueThenIncrement();
	}

commonMethod: 
(startLine=291 endLine=302 srcPath=/root/NewExperiment/hibernateFilter/00349/core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java)
		/**
		 * {@inheritDoc}
		 */
		public synchronized Serializable generate(AccessCallback callback) {
			if ( lo > maxLo ) {
				lastSourceValue = callback.getNextValue();
				lo = lastSourceValue.eq( 0 ) ? 1 : 0;
				hi = lastSourceValue.copy().multiplyBy( maxLo+1 );
			}
			value = hi.copy().add( lo++ );
			return value.makeValue();
		}


, Instance #
frags: 
(startLine=69 endLine=90 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java)
	public synchronized Serializable generate(SessionImplementor session, Object obj) {
		// maxLo < 1 indicates a hilo generator with no hilo :?
		if ( maxLo < 1 ) {
			//keep the behavior consistent even for boundary usages
			IntegralDataTypeHolder value = null;
			while ( value == null || value.lt( 0 ) ) {
				value = super.generateHolder( session );
			}
			return value.makeValue();
		}

		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = generateHolder( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

		return value.makeValueThenIncrement();
	}

(startLine=204 endLine=224 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java)
		throws HibernateException {
		// maxLo < 1 indicates a hilo generator with no hilo :?
		if ( maxLo < 1 ) {
			//keep the behavior consistent even for boundary usages
			IntegralDataTypeHolder value = null;
			while ( value == null || value.lt( 1 ) ) {
				value = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			}
			return value.makeValue();
		}

		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}
		return value.makeValueThenIncrement();
	}

commonMethod: 
(startLine=352 endLine=372 srcPath=/root/NewExperiment/hibernateFilter/00349/core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java)
		/**
		 * {@inheritDoc}
		 */
		public synchronized Serializable generate(AccessCallback callback) {
			if ( hiValue == null ) {
				value = callback.getNextValue();
				if ( value.lt( 1 ) ) {
					// unfortunately not really safe to normalize this
					// to 1 as an initial value like we do the others
					// because we would not be able to control this if
					// we are using a sequence...
					log.info( "pooled optimizer source reported [" + value + "] as the initial value; use of 1 or greater highly recommended" );
				}
				hiValue = callback.getNextValue();
			}
			else if ( ! hiValue.gt( value ) ) {
				hiValue = callback.getNextValue();
				value = hiValue.copy().subtract( incrementSize );
			}
			return value.makeValueThenIncrement();
		}


, Instance #
frags: 
(startLine=80 endLine=87 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java)
		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = generateHolder( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

(startLine=215 endLine=222 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java)
		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

commonMethod: 
(startLine=130 endLine=143 srcPath=/root/NewExperiment/hibernateFilter/00349/core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java)
		/**
		 * {@inheritDoc}
		 */
		public Serializable generate(AccessCallback callback) {
			if ( lastSourceValue == null ) {
				do {
					lastSourceValue = callback.getNextValue();
				} while ( lastSourceValue.lt( 1 ) );
			}
			else {
				lastSourceValue = callback.getNextValue();
			}
			return lastSourceValue.makeValue();
		}


, Instance #
frags: 
(startLine=80 endLine=87 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java)
		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = generateHolder( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

(startLine=215 endLine=222 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java)
		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

commonMethod: 
(startLine=208 endLine=229 srcPath=/root/NewExperiment/hibernateFilter/00349/core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java)
		/**
		 * {@inheritDoc}
		 */
		public synchronized Serializable generate(AccessCallback callback) {
			if ( lastSourceValue == null ) {
				// first call, so initialize ourselves.  we need to read the database
				// value and set up the 'bucket' boundaries
				lastSourceValue = callback.getNextValue();
				while ( lastSourceValue.lt( 1 ) ) {
					lastSourceValue = callback.getNextValue();
				}
				// upperLimit defines the upper end of the bucket values
				upperLimit = lastSourceValue.copy().multiplyBy( incrementSize ).increment();
				// initialize value to the low end of the bucket
				value = upperLimit.copy().subtract( incrementSize );
			}
			else if ( ! upperLimit.gt( value ) ) {
				lastSourceValue = callback.getNextValue();
				upperLimit = lastSourceValue.copy().multiplyBy( incrementSize ).increment();
			}
			return value.makeValueThenIncrement();
		}


, Instance #
frags: 
(startLine=80 endLine=87 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java)
		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = generateHolder( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

(startLine=215 endLine=222 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java)
		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

commonMethod: 
(startLine=291 endLine=302 srcPath=/root/NewExperiment/hibernateFilter/00349/core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java)
		/**
		 * {@inheritDoc}
		 */
		public synchronized Serializable generate(AccessCallback callback) {
			if ( lo > maxLo ) {
				lastSourceValue = callback.getNextValue();
				lo = lastSourceValue.eq( 0 ) ? 1 : 0;
				hi = lastSourceValue.copy().multiplyBy( maxLo+1 );
			}
			value = hi.copy().add( lo++ );
			return value.makeValue();
		}


, Instance #
frags: 
(startLine=80 endLine=87 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/SequenceHiLoGenerator.java)
		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = generateHolder( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

(startLine=215 endLine=222 srcPath=/root/NewExperiment/hibernateFilter/00348/core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java)
		if ( lo > maxLo ) {
			IntegralDataTypeHolder hiVal = (IntegralDataTypeHolder) doWorkInNewTransaction( session );
			lo = ( hiVal.eq( 0 ) ) ? 1 : 0;
			value = hiVal.copy().multiplyBy( maxLo+1 ).add( lo );
			if ( log.isDebugEnabled() ) {
				log.debug("new hi value: " + hiVal);
			}
		}

commonMethod: 
(startLine=352 endLine=372 srcPath=/root/NewExperiment/hibernateFilter/00349/core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java)
		/**
		 * {@inheritDoc}
		 */
		public synchronized Serializable generate(AccessCallback callback) {
			if ( hiValue == null ) {
				value = callback.getNextValue();
				if ( value.lt( 1 ) ) {
					// unfortunately not really safe to normalize this
					// to 1 as an initial value like we do the others
					// because we would not be able to control this if
					// we are using a sequence...
					log.info( "pooled optimizer source reported [" + value + "] as the initial value; use of 1 or greater highly recommended" );
				}
				hiValue = callback.getNextValue();
			}
			else if ( ! hiValue.gt( value ) ) {
				hiValue = callback.getNextValue();
				value = hiValue.copy().subtract( incrementSize );
			}
			return value.makeValueThenIncrement();
		}


, Instance #
frags: 
(startLine=21 endLine=53 srcPath=/root/NewExperiment/hibernateFilter/00376/entitymanager/src/test/java/org/hibernate/ejb/test/ops/MergeTest.java)
	public void testMergeTree() {

		clearCounts();

		Session s = openSession();
		Transaction tx = s.beginTransaction();
		Node root = new Node( "root" );
		Node child = new Node( "child" );
		root.addChild( child );
		s.persist( root );
		tx.commit();
		s.close();

		assertInsertCount( 2 );
		clearCounts();

		root.setDescription( "The root node" );
		child.setDescription( "The child node" );

		Node secondChild = new Node( "second child" );

		root.addChild( secondChild );

		s = openSession();
		tx = s.beginTransaction();
		s.merge( root );
		tx.commit();
		s.close();

		assertInsertCount( 1 );
		assertUpdateCount( 2 );

	}

(startLine=55 endLine=87 srcPath=/root/NewExperiment/hibernateFilter/00376/entitymanager/src/test/java/org/hibernate/ejb/test/ops/MergeTest.java)
	public void testMergeTreeWithGeneratedId() {

		clearCounts();

		Session s = openSession();
		Transaction tx = s.beginTransaction();
		NumberedNode root = new NumberedNode( "root" );
		NumberedNode child = new NumberedNode( "child" );
		root.addChild( child );
		s.persist( root );
		tx.commit();
		s.close();

		assertInsertCount( 2 );
		clearCounts();

		root.setDescription( "The root node" );
		child.setDescription( "The child node" );

		NumberedNode secondChild = new NumberedNode( "second child" );

		root.addChild( secondChild );

		s = openSession();
		tx = s.beginTransaction();
		s.merge( root );
		tx.commit();
		s.close();

		assertInsertCount( 1 );
		assertUpdateCount( 2 );

	}

commonMethod: 
(startLine=123 endLine=128 srcPath=/root/NewExperiment/hibernateFilter/00377/entitymanager/src/test/java/org/hibernate/ejb/test/TestCase.java)
	protected EntityManager getOrCreateEntityManager() {
		if ( em == null || !em.isOpen() ) {
			em = factory.createEntityManager();
		}
		return em;
	}


, Instance #
frags: 
(startLine=21 endLine=53 srcPath=/root/NewExperiment/hibernateFilter/00376/entitymanager/src/test/java/org/hibernate/ejb/test/ops/MergeTest.java)
	public void testMergeTree() {

		clearCounts();

		Session s = openSession();
		Transaction tx = s.beginTransaction();
		Node root = new Node( "root" );
		Node child = new Node( "child" );
		root.addChild( child );
		s.persist( root );
		tx.commit();
		s.close();

		assertInsertCount( 2 );
		clearCounts();

		root.setDescription( "The root node" );
		child.setDescription( "The child node" );

		Node secondChild = new Node( "second child" );

		root.addChild( secondChild );

		s = openSession();
		tx = s.beginTransaction();
		s.merge( root );
		tx.commit();
		s.close();

		assertInsertCount( 1 );
		assertUpdateCount( 2 );

	}

(startLine=55 endLine=87 srcPath=/root/NewExperiment/hibernateFilter/00376/entitymanager/src/test/java/org/hibernate/ejb/test/ops/MergeTest.java)
	public void testMergeTreeWithGeneratedId() {

		clearCounts();

		Session s = openSession();
		Transaction tx = s.beginTransaction();
		NumberedNode root = new NumberedNode( "root" );
		NumberedNode child = new NumberedNode( "child" );
		root.addChild( child );
		s.persist( root );
		tx.commit();
		s.close();

		assertInsertCount( 2 );
		clearCounts();

		root.setDescription( "The root node" );
		child.setDescription( "The child node" );

		NumberedNode secondChild = new NumberedNode( "second child" );

		root.addChild( secondChild );

		s = openSession();
		tx = s.beginTransaction();
		s.merge( root );
		tx.commit();
		s.close();

		assertInsertCount( 1 );
		assertUpdateCount( 2 );

	}

commonMethod: 
(startLine=123 endLine=128 srcPath=/root/NewExperiment/hibernateFilter/00377/entitymanager/src/test/java/org/hibernate/ejb/test/TestCase.java)
	protected EntityManager getOrCreateEntityManager() {
		if ( em == null || !em.isOpen() ) {
			em = factory.createEntityManager();
		}
		return em;
	}


, Instance #
frags: 
(startLine=124 endLine=148 srcPath=/root/NewExperiment/hibernateFilter/00463/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/entityNames/oneToManyNotAudited/ReadEntityWithAuditedCollectionTest.java)
    public void testObtainCollectionWithEntityNameAndNotAuditedModeWithNewSession() {
    	// force new session and AR
    	super.newSessionFactory();
    	
    	Car car1_1 = getAuditReader().find(Car.class, id_car1, 2);
    	Car car2 = getAuditReader().find(Car.class, id_car2, 2);

    	for (Person owner : car1_1.getOwners()) {
    		owner.getName();
    		owner.getAge();
		}
    	for (Person owner : car2.getOwners()) {
    		owner.getName();
    		owner.getAge();
		}
    	
    	if(getAuditReader().isEntityNameNotAudited("Personaje")) {
    		person1_1 = (Person)getSession().get("Personaje", id_pers1); 
    	} else {
    		assert(false);
    	}
    	person1_1.getName();
    	person1_1.getAge();
    	
    }

(startLine=121 endLine=140 srcPath=/root/NewExperiment/hibernateFilter/00463/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/entityNames/oneToManyAudited/ReadEntityWithAuditedCollectionTest.java)
    public void testObtainAuditedCollectionWithEntityNameWithNewSession() {
    	// force a new session and AR
    	super.newSessionFactory();
    	
    	Car car1_1 = getAuditReader().find(Car.class, id_car1, 2);
    	Car car2 = getAuditReader().find(Car.class, id_car2, 2);
    	Person person1_1 = getAuditReader().find(Person.class,"Personaje", id_pers1, 1);

    	for (Person owner : car1_1.getOwners()) {
    		owner.getName(); 
    		owner.getAge();
		}
    	for (Person owner : car2.getOwners()) {
    		owner.getName(); 
    		owner.getAge();
		}    	
    	
    	person1_1.getName();
    	person1_1.getAge();
    }

commonMethod: 
(startLine=79 endLine=85 srcPath=/root/NewExperiment/hibernateFilter/00464/hibernate-envers/src/test/java/org/hibernate/envers/test/AbstractOneSessionTest.java)
	/**
	 * Creates a new session and auditReader.
	 */
	public void forceNewSession() {
	      session = getSessionFactory().openSession();
	      auditReader = AuditReaderFactory.get(session);
	}	


, Instance #
frags: 
(startLine=142 endLine=158 srcPath=/root/NewExperiment/hibernateFilter/00465/hibernate-core/src/main/java/org/hibernate/cfg/PropertyContainer.java)
		for ( XProperty property : fieldAccessMap.values() ) {
			Access access = property.getAnnotation( Access.class );
			if ( access == null ) {
				continue;
			}

			// see "2.3.2 Explicit Access Type" of JPA 2 spec
			// the access type for this property is explicitly set to AccessType.FIELD, hence we have to
			// use field access for this property even if the default access type for the class is AccessType.PROPERTY
			AccessType accessType = AccessType.getAccessStrategy( access.value() );
			if ( accessType == AccessType.FIELD ) {
				propertyAccessMap.put( property.getName(), property );
			}
			else {   // AccessType.PROPERTY
				log.warn( "Placing @Access(AccessType.PROPERTY) on a field does not have any effect." );
			}
		}

(startLine=160 endLine=177 srcPath=/root/NewExperiment/hibernateFilter/00465/hibernate-core/src/main/java/org/hibernate/cfg/PropertyContainer.java)
		for ( XProperty property : propertyAccessMap.values() ) {
			Access access = property.getAnnotation( Access.class );
			if ( access == null ) {
				continue;
			}

			AccessType accessType = AccessType.getAccessStrategy( access.value() );

			// see "2.3.2 Explicit Access Type" of JPA 2 spec
			// the access type for this property is explicitly set to AccessType.PROPERTY, hence we have to
			// return use method access even if the default class access type is AccessType.FIELD
			if ( accessType == AccessType.PROPERTY ) {
				fieldAccessMap.put( property.getName(), property );
			}
			else { // AccessType.FIELD
				log.warn( "Placing @Access(AccessType.FIELD) on a property does not have any effect." );
			}
		}

commonMethod: 
(startLine=288 endLine=290 srcPath=/root/NewExperiment/hibernateFilter/00466/hibernate-core/src/main/java/org/hibernate/cfg/PropertyContainer.java)
        @LogMessage( level = WARN )
        @Message( value = "Placing @Access(AccessType.%s) on a field does not have any effect." )
        void annotationHasNoEffect( AccessType type );


, Instance #
frags: 
(startLine=195 endLine=233 srcPath=/root/NewExperiment/hibernateFilter/00482/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java)
		if ( getFactory().getDialect().dropTemporaryTableAfterUse() ) {
			IsolatedWork work = new IsolatedWork() {
				public void doWork(Connection connection) throws HibernateException {
					final String command = session.getFactory().getDialect().getDropTemporaryTableString()
							+ ' ' + persister.getTemporaryIdTableName();
					try {
						Statement statement = connection.createStatement();
						try {
							statement = connection.createStatement();
							statement.executeUpdate( command );
						}
						finally {
							try {
								statement.close();
							}
							catch( Throwable ignore ) {
								// ignore
							}
						}
					}
					catch( Exception e ) {
                        LOG.unableToDropTemporaryIdTable(e.getMessage());
					}
				}
			};

			if ( shouldIsolateTemporaryTableDDL() ) {
				if ( getFactory().getSettings().isDataDefinitionInTransactionSupported() ) {
					Isolater.doIsolatedWork( work, session );
				}
				else {
					Isolater.doNonTransactedWork( work, session );
				}
			}
			else {
				work.doWork( session.getJDBCContext().getConnectionManager().getConnection() );
				session.getJDBCContext().getConnectionManager().afterStatement();
			}
		}

(startLine=139 endLine=176 srcPath=/root/NewExperiment/hibernateFilter/00482/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java)
	protected void createTemporaryTableIfNecessary(final Queryable persister, final SessionImplementor session) {
		// Don't really know all the codes required to adequately decipher returned jdbc exceptions here.
		// simply allow the failure to be eaten and the subsequent insert-selects/deletes should fail
		IsolatedWork work = new IsolatedWork() {
			public void doWork(Connection connection) throws HibernateException {
				try {
					Statement statement = connection.createStatement();
					try {
						statement.executeUpdate( persister.getTemporaryIdTableDDL() );
						JDBCExceptionReporter.handleAndClearWarnings( statement, CREATION_WARNING_HANDLER );
					}
					finally {
						try {
							statement.close();
						}
						catch( Throwable ignore ) {
							// ignore
						}
					}
				}
				catch( Exception e ) {
                    LOG.debugf("Unable to create temporary id table [%s]", e.getMessage());
				}
			}
		};
		if ( shouldIsolateTemporaryTableDDL() ) {
			if ( getFactory().getSettings().isDataDefinitionInTransactionSupported() ) {
				Isolater.doIsolatedWork( work, session );
			}
			else {
				Isolater.doNonTransactedWork( work, session );
			}
		}
		else {
			work.doWork( session.getJDBCContext().getConnectionManager().getConnection() );
			session.getJDBCContext().getConnectionManager().afterStatement();
		}
	}

commonMethod: 
(startLine=147 endLine=171 srcPath=/root/NewExperiment/hibernateFilter/00483/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java)
		@Override
		public void execute(Connection connection) {
			try {
				Statement statement = connection.createStatement();
				try {
					statement.executeUpdate( persister.getTemporaryIdTableDDL() );
					persister.getFactory()
							.getServiceRegistry()
							.getService( JdbcServices.class )
							.getSqlExceptionHelper()
							.handleAndClearWarnings( statement, CREATION_WARNING_HANDLER );
				}
				finally {
					try {
						statement.close();
					}
					catch( Throwable ignore ) {
						// ignore
					}
				}
			}
			catch( Exception e ) {
				LOG.debug( "unable to create temporary id table [" + e.getMessage() + "]" );
			}
		}


, Instance #
frags: 
(startLine=195 endLine=233 srcPath=/root/NewExperiment/hibernateFilter/00482/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java)
		if ( getFactory().getDialect().dropTemporaryTableAfterUse() ) {
			IsolatedWork work = new IsolatedWork() {
				public void doWork(Connection connection) throws HibernateException {
					final String command = session.getFactory().getDialect().getDropTemporaryTableString()
							+ ' ' + persister.getTemporaryIdTableName();
					try {
						Statement statement = connection.createStatement();
						try {
							statement = connection.createStatement();
							statement.executeUpdate( command );
						}
						finally {
							try {
								statement.close();
							}
							catch( Throwable ignore ) {
								// ignore
							}
						}
					}
					catch( Exception e ) {
                        LOG.unableToDropTemporaryIdTable(e.getMessage());
					}
				}
			};

			if ( shouldIsolateTemporaryTableDDL() ) {
				if ( getFactory().getSettings().isDataDefinitionInTransactionSupported() ) {
					Isolater.doIsolatedWork( work, session );
				}
				else {
					Isolater.doNonTransactedWork( work, session );
				}
			}
			else {
				work.doWork( session.getJDBCContext().getConnectionManager().getConnection() );
				session.getJDBCContext().getConnectionManager().afterStatement();
			}
		}

(startLine=139 endLine=176 srcPath=/root/NewExperiment/hibernateFilter/00482/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java)
	protected void createTemporaryTableIfNecessary(final Queryable persister, final SessionImplementor session) {
		// Don't really know all the codes required to adequately decipher returned jdbc exceptions here.
		// simply allow the failure to be eaten and the subsequent insert-selects/deletes should fail
		IsolatedWork work = new IsolatedWork() {
			public void doWork(Connection connection) throws HibernateException {
				try {
					Statement statement = connection.createStatement();
					try {
						statement.executeUpdate( persister.getTemporaryIdTableDDL() );
						JDBCExceptionReporter.handleAndClearWarnings( statement, CREATION_WARNING_HANDLER );
					}
					finally {
						try {
							statement.close();
						}
						catch( Throwable ignore ) {
							// ignore
						}
					}
				}
				catch( Exception e ) {
                    LOG.debugf("Unable to create temporary id table [%s]", e.getMessage());
				}
			}
		};
		if ( shouldIsolateTemporaryTableDDL() ) {
			if ( getFactory().getSettings().isDataDefinitionInTransactionSupported() ) {
				Isolater.doIsolatedWork( work, session );
			}
			else {
				Isolater.doNonTransactedWork( work, session );
			}
		}
		else {
			work.doWork( session.getJDBCContext().getConnectionManager().getConnection() );
			session.getJDBCContext().getConnectionManager().afterStatement();
		}
	}

commonMethod: 
(startLine=221 endLine=243 srcPath=/root/NewExperiment/hibernateFilter/00483/hibernate-core/src/main/java/org/hibernate/hql/ast/exec/AbstractStatementExecutor.java)
		@Override
		public void execute(Connection connection) {
			final String command = session.getFactory().getDialect().getDropTemporaryTableString()
					+ ' ' + persister.getTemporaryIdTableName();
			try {
				Statement statement = connection.createStatement();
				try {
					statement = connection.createStatement();
					statement.executeUpdate( command );
				}
				finally {
					try {
						statement.close();
					}
					catch( Throwable ignore ) {
						// ignore
					}
				}
			}
			catch( Exception e ) {
				LOG.warn( "unable to drop temporary id table after use [" + e.getMessage() + "]" );
			}
		}


, Instance #
frags: 
(startLine=723 endLine=735 srcPath=/root/NewExperiment/hibernateFilter/00556/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java)
	private Object readResolve() throws ObjectStreamException {
        LOG.trace("Resolving serialized SessionFactory");
		// look for the instance by uuid
		Object result = SessionFactoryObjectFactory.getInstance(uuid);
		if (result==null) {
			// in case we were deserialized in a different JVM, look for an instance with the same name
			// (alternatively we could do an actual JNDI lookup here....)
			result = SessionFactoryObjectFactory.getNamedInstance(name);
            if (result == null) throw new InvalidObjectException("Could not find a SessionFactory named: " + name);
            LOG.debugf("Resolved SessionFactory by name");
        } else LOG.debugf("Resolved SessionFactory by UID");
		return result;
	}

(startLine=104 endLine=115 srcPath=/root/NewExperiment/hibernateFilter/00556/hibernate-core/src/main/java/org/hibernate/jmx/SessionFactoryStub.java)
	private Object readResolve() throws ObjectStreamException {
		// look for the instance by uuid
		Object result = SessionFactoryObjectFactory.getInstance(uuid);
		if (result==null) {
            // in case we were deserialized in a different JVM, look for an instance with the same name
			// (alternatively we could do an actual JNDI lookup here....)
			result = SessionFactoryObjectFactory.getNamedInstance(name);
            if (result == null) throw new InvalidObjectException("Could not find a stub SessionFactory named: " + name);
            LOG.debugf("Resolved stub SessionFactory by name");
        } else LOG.debugf("Resolved stub SessionFactory by uid");
		return result;
	}

commonMethod: 
(startLine=116 endLine=120 srcPath=/root/NewExperiment/hibernateFilter/00557/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryRegistry.java)
	public SessionFactory getNamedSessionFactory(String name) {
        LOG.debugf( "Lookup: name=%s", name );
		final String uuid = nameUuidXref.get( name );
		return getSessionFactory( uuid );
	}


, Instance #
frags: 
(startLine=723 endLine=735 srcPath=/root/NewExperiment/hibernateFilter/00556/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java)
	private Object readResolve() throws ObjectStreamException {
        LOG.trace("Resolving serialized SessionFactory");
		// look for the instance by uuid
		Object result = SessionFactoryObjectFactory.getInstance(uuid);
		if (result==null) {
			// in case we were deserialized in a different JVM, look for an instance with the same name
			// (alternatively we could do an actual JNDI lookup here....)
			result = SessionFactoryObjectFactory.getNamedInstance(name);
            if (result == null) throw new InvalidObjectException("Could not find a SessionFactory named: " + name);
            LOG.debugf("Resolved SessionFactory by name");
        } else LOG.debugf("Resolved SessionFactory by UID");
		return result;
	}

(startLine=104 endLine=115 srcPath=/root/NewExperiment/hibernateFilter/00556/hibernate-core/src/main/java/org/hibernate/jmx/SessionFactoryStub.java)
	private Object readResolve() throws ObjectStreamException {
		// look for the instance by uuid
		Object result = SessionFactoryObjectFactory.getInstance(uuid);
		if (result==null) {
            // in case we were deserialized in a different JVM, look for an instance with the same name
			// (alternatively we could do an actual JNDI lookup here....)
			result = SessionFactoryObjectFactory.getNamedInstance(name);
            if (result == null) throw new InvalidObjectException("Could not find a stub SessionFactory named: " + name);
            LOG.debugf("Resolved stub SessionFactory by name");
        } else LOG.debugf("Resolved stub SessionFactory by uid");
		return result;
	}

commonMethod: 
(startLine=122 endLine=130 srcPath=/root/NewExperiment/hibernateFilter/00557/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryRegistry.java)
	public SessionFactory getSessionFactory(String uuid) {
        LOG.debugf( "Lookup: uid=%s", uuid );
		final SessionFactory sessionFactory = sessionFactoryMap.get( uuid );
		if ( sessionFactory == null ) {
			LOG.debugf( "Not found: %s", uuid );
            LOG.debugf( sessionFactoryMap.toString() );
		}
		return sessionFactory;
	}


, Instance #
frags: 
(startLine=78 endLine=92 srcPath=/root/NewExperiment/hibernateFilter/00562/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/domain/HbmSimpleAttributeDomainState.java)
										 XMLVersion version) {

		super( defaults, attribute, entityMetaAttributes, version );
		this.isLazy = false;

		// for version properties marked as being generated, make sure they are "always"
		// generated; aka, "insert" is invalid; this is dis-allowed by the DTD,
		// but just to make sure.
		this.propertyGeneration = PropertyGeneration.parse(  version.getGenerated().value()  );
		if ( propertyGeneration == PropertyGeneration.INSERT ) {
			throw new MappingException( "'generated' attribute cannot be 'insert' for versioning property" );
		}
		this.isInsertable = MappingHelper.getBooleanValue( version.isInsert(), true );
		this.isUpdateable = true;
	}

(startLine=97 endLine=111 srcPath=/root/NewExperiment/hibernateFilter/00562/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/domain/HbmSimpleAttributeDomainState.java)
										 XMLTimestamp timestamp) {

		super( defaults, attribute, entityMetaAttributes, timestamp );
		this.isLazy = false;

		// for version properties marked as being generated, make sure they are "always"
		// generated; aka, "insert" is invalid; this is dis-allowed by the DTD,
		// but just to make sure.
		this.propertyGeneration = PropertyGeneration.parse(  timestamp.getGenerated().value()  );
		if ( propertyGeneration == PropertyGeneration.INSERT ) {
			throw new MappingException( "'generated' attribute cannot be 'insert' for versioning property" );
		}
		this.isInsertable = true; //TODO: is this right????
		this.isUpdateable = true;
	}

commonMethod: 
(startLine=124 endLine=130 srcPath=/root/NewExperiment/hibernateFilter/00563/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmHelper.java)
	public static String getPropertyAccessorName(Element element, boolean isEmbedded, String defaultAccess) {
		return DomHelper.extractAttributeValue(
				element,
				"access",
				isEmbedded ? "embedded" : defaultAccess
		);
	}


, Instance #
frags: 
(startLine=160 endLine=169 srcPath=/root/NewExperiment/hibernateFilter/00701/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityClass.java)
            for (AnnotationInstance callbackClasses : context.getIndex().getAnnotations(PseudoJpaDotNames.DEFAULT_ENTITY_LISTENERS)) {
                for (Type callbackClass : callbackClasses.value().asClassArray()) {
                    String callbackClassName = callbackClass.name().toString();
                    try {
                        processDefaultJpaCallbacks(callbackClassName, context.getClassInfo(callbackClassName), context);
                    } catch (PersistenceException error) {
                        throw new PersistenceException(error.getMessage() + "default entity listener " + callbackClassName);
                    }
                }
            }

(startLine=172 endLine=181 srcPath=/root/NewExperiment/hibernateFilter/00701/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityClass.java)
        for (AnnotationInstance callbackClasses : classInfo.annotations().get(JPADotNames.ENTITY_LISTENERS)) {
            for (Type callbackClass : callbackClasses.value().asClassArray()) {
                String callbackClassName = callbackClass.name().toString();
                try {
                    processJpaCallbacks(callbackClassName, context.getClassInfo(callbackClassName), true, context);
                } catch (PersistenceException error) {
                    throw new PersistenceException(error.getMessage() + "entity listener " + callbackClassName);
                }
            }
        }

commonMethod: 
(startLine=765 endLine=812 srcPath=/root/NewExperiment/hibernateFilter/00702/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityClass.java)
	private List<JpaCallbackClass> determineEntityListeners() {
		List<JpaCallbackClass> callbackClassList = new ArrayList<JpaCallbackClass>();

		// Bind default JPA entity listener callbacks (unless excluded), using superclasses first (unless excluded)
		if ( JandexHelper.getSingleAnnotation( getClassInfo(), JPADotNames.EXCLUDE_DEFAULT_LISTENERS ) == null ) {
			List<AnnotationInstance> defaultEntityListenerAnnotations = getLocalBindingContext().getIndex()
					.getAnnotations( PseudoJpaDotNames.DEFAULT_ENTITY_LISTENERS );
			for ( AnnotationInstance annotation : defaultEntityListenerAnnotations ) {
				for ( Type callbackClass : annotation.value().asClassArray() ) {
					String callbackClassName = callbackClass.name().toString();
					try {
						processDefaultJpaCallbacks( callbackClassName, callbackClassList );
					}
					catch ( PersistenceException error ) {
						throw new PersistenceException( error.getMessage() + "default entity listener " + callbackClassName );
					}
				}
			}
		}

		// Bind JPA entity listener callbacks, using superclasses first (unless excluded)
		List<AnnotationInstance> annotationList = getClassInfo().annotations().get( JPADotNames.ENTITY_LISTENERS );
		if ( annotationList != null ) {
			for ( AnnotationInstance annotation : annotationList ) {
				for ( Type callbackClass : annotation.value().asClassArray() ) {
					String callbackClassName = callbackClass.name().toString();
					try {
						processJpaCallbacks( callbackClassName, true, callbackClassList );
					}
					catch ( PersistenceException error ) {
						throw new PersistenceException( error.getMessage() + "entity listener " + callbackClassName );
					}
				}
			}
		}

		// Bind JPA entity.mapped superclass callbacks, using superclasses first (unless excluded)
		try {
			processJpaCallbacks( getName(), false, callbackClassList );
		}
		catch ( PersistenceException error ) {
			throw new PersistenceException(
					error.getMessage() + "entity/mapped superclass " + getClassInfo().name().toString()
			);
		}

		return callbackClassList;
	}


, Instance #
frags: 
(startLine=76 endLine=114 srcPath=/root/NewExperiment/hibernateFilter/00742/hibernate-core/src/matrix/java/org/hibernate/test/locking/LockModeTest.java)
	public void testLoading() {
		// open a session, begin a transaction and lock row
		Session s1 = sessionFactory().openSession();
		s1.beginTransaction();
		try {
			A it = (A) s1.get( A.class, 1, LockMode.PESSIMISTIC_WRITE );
			// make sure we got it
			assertNotNull( it );

			// that initial transaction is still active and so the lock should still be held.
			// Lets open another session/transaction and verify
			Session s2 = sessionFactory().openSession();
			s2.beginTransaction();
			try {
				s2.get( A.class, 1, LockMode.PESSIMISTIC_WRITE );
				fail( "Pessimistic lock was not obtained/held" );
			}
			catch ( Exception e ) {
				// grr, exception can be any number of types based on database
				// 		see HHH-6887
				if ( LockAcquisitionException.class.isInstance( e )
						|| GenericJDBCException.class.isInstance( e )
						|| PessimisticLockException.class.isInstance( e ) ) {
					// "ok"
				}
				else {
					fail( "Unexpected error type testing pessimistic locking : " + e.getClass().getName() );
				}
			}
			finally {
				s2.getTransaction().commit();
				s2.close();
			}
		}
		finally {
			s1.getTransaction().commit();
			s1.close();
		}
	}

(startLine=118 endLine=161 srcPath=/root/NewExperiment/hibernateFilter/00742/hibernate-core/src/matrix/java/org/hibernate/test/locking/LockModeTest.java)
	public void testLegacyCriteria() {
		// open a session, begin a transaction and lock row
		Session s1 = sessionFactory().openSession();
		s1.beginTransaction();
		try {
			A it = (A) s1.createCriteria( A.class )
					.setLockMode( LockMode.PESSIMISTIC_WRITE )
					.uniqueResult();
			// make sure we got it
			assertNotNull( it );

			// that initial transaction is still active and so the lock should still be held.
			// Lets open another session/transaction and verify
			Session s2 = sessionFactory().openSession();
			s2.beginTransaction();
			try {
				s2.createCriteria( A.class )
						.setLockMode( LockMode.PESSIMISTIC_WRITE )
						.uniqueResult();

				fail( "Pessimistic lock was not obtained/held" );
			}
			catch ( Exception e ) {
				// grr, exception can be any number of types based on database
				// 		see HHH-6887
				if ( LockAcquisitionException.class.isInstance( e )
						|| GenericJDBCException.class.isInstance( e )
						|| PessimisticLockException.class.isInstance( e ) ) {
					// "ok"
				}
				else {
					fail( "Unexpected error type testing pessimistic locking : " + e.getClass().getName() );
				}
			}
			finally {
				s2.getTransaction().commit();
				s2.close();
			}
		}
		finally {
			s1.getTransaction().commit();
			s1.close();
		}
	}

(startLine=165 endLine=208 srcPath=/root/NewExperiment/hibernateFilter/00742/hibernate-core/src/matrix/java/org/hibernate/test/locking/LockModeTest.java)
	public void testLegacyCriteriaAliasSpecific() {
		// open a session, begin a transaction and lock row
		Session s1 = sessionFactory().openSession();
		s1.beginTransaction();
		try {
			A it = (A) s1.createCriteria( A.class )
					.setLockMode( "this", LockMode.PESSIMISTIC_WRITE )
					.uniqueResult();
			// make sure we got it
			assertNotNull( it );

			// that initial transaction is still active and so the lock should still be held.
			// Lets open another session/transaction and verify
			Session s2 = sessionFactory().openSession();
			s2.beginTransaction();
			try {
				s2.createCriteria( A.class )
						.setLockMode( "this", LockMode.PESSIMISTIC_WRITE )
						.uniqueResult();

				fail( "Pessimistic lock was not obtained/held" );
			}
			catch ( Exception e ) {
				// grr, exception can be any number of types based on database
				// 		see HHH-6887
				if ( LockAcquisitionException.class.isInstance( e )
						|| GenericJDBCException.class.isInstance( e )
						|| PessimisticLockException.class.isInstance( e ) ) {
					// "ok"
				}
				else {
					fail( "Unexpected error type testing pessimistic locking : " + e.getClass().getName() );
				}
			}
			finally {
				s2.getTransaction().commit();
				s2.close();
			}
		}
		finally {
			s1.getTransaction().commit();
			s1.close();
		}
	}

(startLine=212 endLine=255 srcPath=/root/NewExperiment/hibernateFilter/00742/hibernate-core/src/matrix/java/org/hibernate/test/locking/LockModeTest.java)
	public void testQuery() {
		// open a session, begin a transaction and lock row
		Session s1 = sessionFactory().openSession();
		s1.beginTransaction();
		try {
			A it = (A) s1.createQuery( "from A a" )
					.setLockMode( "a", LockMode.PESSIMISTIC_WRITE )
					.uniqueResult();
			// make sure we got it
			assertNotNull( it );

			// that initial transaction is still active and so the lock should still be held.
			// Lets open another session/transaction and verify
			Session s2 = sessionFactory().openSession();
			s2.beginTransaction();
			try {
				s2.createQuery( "from A a" )
						.setLockMode( "a", LockMode.PESSIMISTIC_WRITE )
						.uniqueResult();

				fail( "Pessimistic lock was not obtained/held" );
			}
			catch ( Exception e ) {
				// grr, exception can be any number of types based on database
				// 		see HHH-6887
				if ( LockAcquisitionException.class.isInstance( e )
						|| GenericJDBCException.class.isInstance( e )
						|| PessimisticLockException.class.isInstance( e ) ) {
					// "ok"
				}
				else {
					fail( "Unexpected error type testing pessimistic locking : " + e.getClass().getName() );
				}
			}
			finally {
				s2.getTransaction().commit();
				s2.close();
			}
		}
		finally {
			s1.getTransaction().commit();
			s1.close();
		}
	}

commonMethod: 
(startLine=179 endLine=204 srcPath=/root/NewExperiment/hibernateFilter/00743/hibernate-core/src/matrix/java/org/hibernate/test/locking/LockModeTest.java)
	private void nowAttemptToUpdateRow() {
		Session s = sessionFactory().openSession();
		s.beginTransaction();
		try {
			A it2 = (A) s.get( A.class, 1 );
			it2.setValue( "changed" );
			s.flush();
			fail( "Pessimistic lock not obtained/held" );
		}
		catch ( Exception e ) {
			// grr, exception can be any number of types based on database
			// 		see HHH-6887
			if ( LockAcquisitionException.class.isInstance( e )
					|| GenericJDBCException.class.isInstance( e )
					|| PessimisticLockException.class.isInstance( e ) ) {
				// "ok"
			}
			else {
				fail( "Unexpected error type testing pessimistic locking : " + e.getClass().getName() );
			}
		}
		finally {
			s.getTransaction().rollback();
			s.close();
		}
	}


, Instance #
frags: 
(startLine=87 endLine=107 srcPath=/root/NewExperiment/hibernateFilter/00754/hibernate-envers/src/main/java/org/hibernate/envers/event/BaseEnversEventListener.java)
					if (newValue != null) {
						// relDesc.getToEntityName() doesn't always return the entity name of the value - in case
						// of subclasses, this will be root class, no the actual class. So it can't be used here.
						String toEntityName;
						Serializable id;

						if (newValue instanceof HibernateProxy ) {
							HibernateProxy hibernateProxy = (HibernateProxy) newValue;
							toEntityName = session.bestGuessEntityName(newValue);
							id = hibernateProxy.getHibernateLazyInitializer().getIdentifier();
							// We've got to initialize the object from the proxy to later read its state.
							newValue = Tools.getTargetFromProxy(session.getFactory(), hibernateProxy);
						} else {
							toEntityName =  session.guessEntityName(newValue);

							IdMapper idMapper = enversConfiguration.getEntCfg().get(toEntityName).getIdMapper();
							 id = (Serializable) idMapper.mapToIdFromEntity(newValue);
						}

						auditProcess.addWorkUnit(new CollectionChangeWorkUnit(session, toEntityName, enversConfiguration, id, newValue));
					}

(startLine=109 endLine=127 srcPath=/root/NewExperiment/hibernateFilter/00754/hibernate-envers/src/main/java/org/hibernate/envers/event/BaseEnversEventListener.java)
					if (oldValue != null) {
						String toEntityName;
						Serializable id;

						if(oldValue instanceof HibernateProxy) {
							HibernateProxy hibernateProxy = (HibernateProxy) oldValue;
							toEntityName = session.bestGuessEntityName(oldValue);
							id = hibernateProxy.getHibernateLazyInitializer().getIdentifier();
							// We've got to initialize the object as we'll read it's state anyway.
							oldValue = Tools.getTargetFromProxy(session.getFactory(), hibernateProxy);
						} else {
							toEntityName =  session.guessEntityName(oldValue);

							IdMapper idMapper = enversConfiguration.getEntCfg().get(toEntityName).getIdMapper();
							id = (Serializable) idMapper.mapToIdFromEntity(oldValue);
						}

						auditProcess.addWorkUnit(new CollectionChangeWorkUnit(session, toEntityName, enversConfiguration, id, oldValue));
					}

commonMethod: 
(startLine=101 endLine=127 srcPath=/root/NewExperiment/hibernateFilter/00755/hibernate-envers/src/main/java/org/hibernate/envers/event/BaseEnversEventListener.java)
	private void addCollectionChangeWorkUnit(AuditProcess auditProcess, SessionImplementor session,
											 String fromEntityName, RelationDescription relDesc, Object value) {
		// relDesc.getToEntityName() doesn't always return the entity name of the value - in case
		// of subclasses, this will be root class, no the actual class. So it can't be used here.
		String toEntityName;
		Serializable id;

		if (value instanceof HibernateProxy) {
		    HibernateProxy hibernateProxy = (HibernateProxy) value;
		    toEntityName = session.bestGuessEntityName(value);
		    id = hibernateProxy.getHibernateLazyInitializer().getIdentifier();
            // We've got to initialize the object from the proxy to later read its state.
            value = Tools.getTargetFromProxy(session.getFactory(), hibernateProxy);
		} else {
	        toEntityName =  session.guessEntityName(value);

            IdMapper idMapper = enversConfiguration.getEntCfg().get(toEntityName).getIdMapper();
            id = (Serializable) idMapper.mapToIdFromEntity(value);
		}

		Set<String> toPropertyNames = enversConfiguration.getEntCfg()
				.getToPropertyNames(fromEntityName, relDesc.getFromPropertyName(), toEntityName);
		String toPropertyName = toPropertyNames.iterator().next();

		auditProcess.addWorkUnit(new CollectionChangeWorkUnit(session, toEntityName,
				toPropertyName, enversConfiguration, id, value));
	}


, Instance #
frags: 
(startLine=65 endLine=123 srcPath=/root/NewExperiment/hibernateFilter/00781/hibernate-core/src/matrix/java/org/hibernate/test/annotations/naturalid/NaturalIdTest.java)
	public void testNaturalIdCached() {
		saveSomeCitizens();
		
		Session s = openSession();
		Transaction tx = s.beginTransaction();
		State france = ( State ) s.load( State.class, 2 );
		Criteria criteria = s.createCriteria( Citizen.class );
		criteria.add( Restrictions.naturalId().set( "ssn", "1234" ).set( "state", france ) );
		criteria.setCacheable( true );
		
		s.getSessionFactory().getCache().evictNaturalIdRegions();

		Statistics stats = sessionFactory().getStatistics();
		stats.setStatisticsEnabled( true );
		stats.clear();
		assertEquals(
				"Cache hits should be empty", 0, stats
						.getNaturalIdCacheHitCount()
		);

		// first query
		List results = criteria.list();
		assertEquals( 1, results.size() );
		assertEquals(
				"Cache hits should be empty", 0, stats
						.getNaturalIdCacheHitCount()
		);
		assertEquals(
				"First query should be a miss", 1, stats
						.getNaturalIdCacheMissCount()
		);
		assertEquals(
				"Query result should be added to cache", 1, stats
						.getNaturalIdCachePutCount()
		);
		assertEquals(
				"Query execution count should be one", 1, stats
						.getNaturalIdQueryExecutionCount()
		);

		// query a second time - result should be cached in session
		criteria.list();
		assertEquals(
				"Cache hits should be empty", 0, stats
						.getNaturalIdCacheHitCount()
		);
		assertEquals(
				"Second query should not be a miss", 1, stats
						.getNaturalIdCacheMissCount()
		);
		assertEquals(
				"Query execution count should be one", 1, stats
						.getNaturalIdQueryExecutionCount()
		);

		// cleanup
		tx.rollback();
		s.close();
	}

(startLine=220 endLine=275 srcPath=/root/NewExperiment/hibernateFilter/00781/hibernate-core/src/matrix/java/org/hibernate/test/annotations/naturalid/NaturalIdTest.java)
	public void testNaturalIdUncached() {
		saveSomeCitizens();

		Session s = openSession();
		Transaction tx = s.beginTransaction();
		State france = ( State ) s.load( State.class, 2 );
		Criteria criteria = s.createCriteria( Citizen.class );
		criteria.add(
				Restrictions.naturalId().set( "ssn", "1234" ).set(
						"state",
						france
				)
		);
		criteria.setCacheable( false );
		
		s.getSessionFactory().getCache().evictNaturalIdRegions();

		Statistics stats = sessionFactory().getStatistics();
		stats.setStatisticsEnabled( true );
		stats.clear();
		assertEquals(
				"Cache hits should be empty", 0, stats
						.getNaturalIdCacheHitCount()
		);

		// first query
		List results = criteria.list();
		assertEquals( 1, results.size() );
		assertEquals(
				"Cache hits should be empty", 0, stats
						.getNaturalIdCacheHitCount()
		);
		assertEquals(
				"Query execution count should be one", 1, stats
						.getNaturalIdQueryExecutionCount()
		);

		// query a second time - result should be cached in session
		criteria.list();
		assertEquals(
				"Cache hits should be empty", 0, stats
						.getNaturalIdCacheHitCount()
		);
		assertEquals(
				"Second query should not be a miss", 1, stats
						.getNaturalIdCacheMissCount()
		);
		assertEquals(
				"Query execution count should be one", 1, stats
						.getNaturalIdQueryExecutionCount()
		);

		// cleanup
		tx.rollback();
		s.close();
	}

commonMethod: 
(startLine=336 endLine=341 srcPath=/root/NewExperiment/hibernateFilter/00782/hibernate-core/src/matrix/java/org/hibernate/test/annotations/naturalid/NaturalIdTest.java)
	private State getState(Session s, String name) {
		Criteria criteria = s.createCriteria( State.class );
		criteria.add( Restrictions.eq( "name", name ) );
		criteria.setCacheable( true );
		return (State) criteria.list().get( 0 );
	}


, Instance #
frags: 
(startLine=70 endLine=94 srcPath=/root/NewExperiment/hibernateFilter/00836/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/ejb3configuration/InterceptorTest.java)
    public void testConfiguredInterceptor() {
        EntityManagerFactory emf = constructConfiguration().setProperty(
                AvailableSettings.INTERCEPTOR,
                ExceptionInterceptor.class.getName()
        ).createEntityManagerFactory();
        EntityManager em = emf.createEntityManager();
        Item i = new Item();
        i.setName( "Laptop" );
        try {
            em.getTransaction().begin();
            em.persist( i );
            em.getTransaction().commit();
            fail( "No interceptor" );
        }
        catch ( IllegalStateException e ) {
            assertEquals( ExceptionInterceptor.EXCEPTION_MESSAGE, e.getMessage() );
        }
        finally {
            if ( em.getTransaction() != null && em.getTransaction().isActive() ) {
                em.getTransaction().rollback();
            }
            em.close();
            emf.close();
        }
    }

(startLine=97 endLine=121 srcPath=/root/NewExperiment/hibernateFilter/00836/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/ejb3configuration/InterceptorTest.java)
    public void testConfiguredSessionInterceptor() {
        EntityManagerFactory emf = constructConfiguration().setProperty(
                AvailableSettings.SESSION_INTERCEPTOR,
                LocalExceptionInterceptor.class.getName()
        ).setProperty( "aaaaaaaaaaaaaaaaaaaaa", "bbbbbbbbbbbbbbbbbbbb" ).createEntityManagerFactory();
        EntityManager em = emf.createEntityManager();
        Item i = new Item();
        i.setName( "Laptop" );
        try {
            em.getTransaction().begin();
            em.persist( i );
            em.getTransaction().commit();
            fail( "No interceptor" );
        }
        catch ( IllegalStateException e ) {
            assertEquals( LocalExceptionInterceptor.LOCAL_EXCEPTION_MESSAGE, e.getMessage() );
        }
        finally {
            if ( em.getTransaction() != null && em.getTransaction().isActive() ) {
                em.getTransaction().rollback();
            }
            em.close();
            emf.close();
        }
    }

(startLine=124 endLine=148 srcPath=/root/NewExperiment/hibernateFilter/00836/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/ejb3configuration/InterceptorTest.java)
    public void testEmptyCreateEntityManagerFactoryAndPropertyUse() {
        EntityManagerFactory emf = constructConfiguration().setProperty(
                AvailableSettings.INTERCEPTOR,
                ExceptionInterceptor.class.getName()
        ).createEntityManagerFactory();
        EntityManager em = emf.createEntityManager();
        Item i = new Item();
        i.setName( "Laptop" );
        try {
            em.getTransaction().begin();
            em.persist( i );
            em.getTransaction().commit();
            fail( "No interceptor" );
        }
        catch ( IllegalStateException e ) {
            assertEquals( ExceptionInterceptor.EXCEPTION_MESSAGE, e.getMessage() );
        }
        finally {
            if ( em.getTransaction() != null && em.getTransaction().isActive() ) {
                em.getTransaction().rollback();
            }
            em.close();
            emf.close();
        }
    }

commonMethod: 
(startLine=158 endLine=165 srcPath=/root/NewExperiment/hibernateFilter/00837/hibernate-entitymanager/src/test/java/org/hibernate/ejb/test/ejb3configuration/InterceptorTest.java)
    protected Map basicSettings() {
		return SettingsGenerator.generateSettings(
				Environment.HBM2DDL_AUTO, "create-drop",
				Environment.USE_NEW_ID_GENERATOR_MAPPINGS, "true",
				Environment.DIALECT, Dialect.getDialect().getClass().getName(),
				AvailableSettings.LOADED_CLASSES, Arrays.asList( getAnnotatedClasses() )
		);
    }


, Instance #
frags: 
(startLine=213 endLine=223 srcPath=/root/NewExperiment/hibernateFilter/00922/hibernate-core/src/main/java/org/hibernate/id/TableGenerator.java)
	public String[] sqlDropStrings(Dialect dialect) {
		StringBuilder sqlDropString = new StringBuilder( "drop table " );
		if ( dialect.supportsIfExistsBeforeTableName() ) {
			sqlDropString.append( "if exists " );
		}
		sqlDropString.append( tableName ).append( dialect.getCascadeConstraintsString() );
		if ( dialect.supportsIfExistsAfterTableName() ) {
			sqlDropString.append( " if exists" );
		}
		return new String[] { sqlDropString.toString() };
	}

(startLine=136 endLine=146 srcPath=/root/NewExperiment/hibernateFilter/00922/hibernate-core/src/main/java/org/hibernate/id/MultipleHiLoPerTableGenerator.java)
	public String[] sqlDropStrings(Dialect dialect) throws HibernateException {
		StringBuilder sqlDropString = new StringBuilder( "drop table " );
		if ( dialect.supportsIfExistsBeforeTableName() ) {
			sqlDropString.append( "if exists " );
		}
		sqlDropString.append( tableName ).append( dialect.getCascadeConstraintsString() );
		if ( dialect.supportsIfExistsAfterTableName() ) {
			sqlDropString.append( " if exists" );
		}
		return new String[] { sqlDropString.toString() };
	}

(startLine=573 endLine=583 srcPath=/root/NewExperiment/hibernateFilter/00922/hibernate-core/src/main/java/org/hibernate/id/enhanced/TableGenerator.java)
	public String[] sqlDropStrings(Dialect dialect) throws HibernateException {
		StringBuilder sqlDropString = new StringBuilder().append( "drop table " );
		if ( dialect.supportsIfExistsBeforeTableName() ) {
			sqlDropString.append( "if exists " );
		}
		sqlDropString.append( tableName ).append( dialect.getCascadeConstraintsString() );
		if ( dialect.supportsIfExistsAfterTableName() ) {
			sqlDropString.append( " if exists" );
		}
		return new String[] { sqlDropString.toString() };
	}

(startLine=189 endLine=199 srcPath=/root/NewExperiment/hibernateFilter/00922/hibernate-core/src/main/java/org/hibernate/id/enhanced/TableStructure.java)
	public String[] sqlDropStrings(Dialect dialect) throws HibernateException {
		StringBuilder sqlDropString = new StringBuilder().append( "drop table " );
		if ( dialect.supportsIfExistsBeforeTableName() ) {
			sqlDropString.append( "if exists " );
		}
		sqlDropString.append( tableName ).append( dialect.getCascadeConstraintsString() );
		if ( dialect.supportsIfExistsAfterTableName() ) {
			sqlDropString.append( " if exists" );
		}
		return new String[] { sqlDropString.toString() };
	}

commonMethod: 
(startLine=2015 endLine=2025 srcPath=/root/NewExperiment/hibernateFilter/00923/hibernate-core/src/main/java/org/hibernate/dialect/Dialect.java)
	public String getDropTableString( String tableName ) {
		StringBuilder buf = new StringBuilder( "drop table " );
		if ( supportsIfExistsBeforeTableName() ) {
			buf.append( "if exists " );
		}
		buf.append( tableName ).append( getCascadeConstraintsString() );
		if ( supportsIfExistsAfterTableName() ) {
			buf.append( " if exists" );
		}
		return buf.toString();
	}


, Instance #
frags: 
(startLine=270 endLine=281 srcPath=/root/NewExperiment/hibernateFilter/00922/hibernate-core/src/main/java/org/hibernate/metamodel/relational/Table.java)
	public String[] sqlDropStrings(Dialect dialect) {
		StringBuilder buf = new StringBuilder( "drop table " );
		if ( dialect.supportsIfExistsBeforeTableName() ) {
			buf.append( "if exists " );
		}
		buf.append( getQualifiedName( dialect ) )
				.append( dialect.getCascadeConstraintsString() );
		if ( dialect.supportsIfExistsAfterTableName() ) {
			buf.append( " if exists" );
		}
		return new String[] { buf.toString() };
	}

(startLine=573 endLine=584 srcPath=/root/NewExperiment/hibernateFilter/00922/hibernate-core/src/main/java/org/hibernate/mapping/Table.java)
	public String sqlDropString(Dialect dialect, String defaultCatalog, String defaultSchema) {
		StringBuilder buf = new StringBuilder( "drop table " );
		if ( dialect.supportsIfExistsBeforeTableName() ) {
			buf.append( "if exists " );
		}
		buf.append( getQualifiedName( dialect, defaultCatalog, defaultSchema ) )
				.append( dialect.getCascadeConstraintsString() );
		if ( dialect.supportsIfExistsAfterTableName() ) {
			buf.append( " if exists" );
		}
		return buf.toString();
	}

commonMethod: 
(startLine=2015 endLine=2025 srcPath=/root/NewExperiment/hibernateFilter/00923/hibernate-core/src/main/java/org/hibernate/dialect/Dialect.java)
	public String getDropTableString( String tableName ) {
		StringBuilder buf = new StringBuilder( "drop table " );
		if ( supportsIfExistsBeforeTableName() ) {
			buf.append( "if exists " );
		}
		buf.append( tableName ).append( getCascadeConstraintsString() );
		if ( supportsIfExistsAfterTableName() ) {
			buf.append( " if exists" );
		}
		return buf.toString();
	}


, Instance #
frags: 
(startLine=50 endLine=96 srcPath=/root/NewExperiment/hibernateFilter/00977/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/query/OneAuditEntityQueryGenerator.java)
										boolean revisionTypeInId) {
		super( verEntCfg, referencingIdData, revisionTypeInId );

        /*
         * The query that we need to create:
         *   SELECT e FROM versionsReferencedEntity e
         *   WHERE
         * (only entities referenced by the association; id_ref_ing = id of the referencing entity)
         *     e.id_ref_ing = :id_ref_ing AND
         * (selecting e entities at revision :revision)
         *   --> for DefaultAuditStrategy:
         *     e.revision = (SELECT max(e2.revision) FROM versionsReferencedEntity e2
         *       WHERE e2.revision <= :revision AND e2.id = e.id) 
         *     
         *   --> for ValidityAuditStrategy:
         *     e.revision <= :revision and (e.endRevision > :revision or e.endRevision is null)
         *     
         *     AND
         * (only non-deleted entities)
         *     e.revision_type != DEL
         */
        String revisionPropertyPath = verEntCfg.getRevisionNumberPath();
        String originalIdPropertyName = verEntCfg.getOriginalIdPropName();

        String versionsReferencedEntityName = verEntCfg.getAuditEntityName(referencedEntityName);

        // SELECT e FROM versionsEntity e
        QueryBuilder qb = new QueryBuilder(versionsReferencedEntityName, REFERENCED_ENTITY_ALIAS);
        qb.addProjection(null, REFERENCED_ENTITY_ALIAS, false, false);
        // WHERE
        Parameters rootParameters = qb.getRootParameters();
        // e.id_ref_ed = :id_ref_ed
        referencingIdData.getPrefixedMapper().addNamedIdEqualsToQuery(rootParameters, null, true);

        // (selecting e entities at revision :revision)
        // --> based on auditStrategy (see above)
        auditStrategy.addEntityAtRevisionRestriction(globalCfg, qb, revisionPropertyPath,
        		verEntCfg.getRevisionEndFieldName(), true, referencedIdData, 
				revisionPropertyPath, originalIdPropertyName, REFERENCED_ENTITY_ALIAS, REFERENCED_ENTITY_ALIAS_DEF_AUD_STR);

        // e.revision_type != DEL
        rootParameters.addWhereWithNamedParam(getRevisionTypePath(), false, "!=", DEL_REVISION_TYPE_PARAMETER);

        StringBuilder sb = new StringBuilder();
        qb.build(sb, Collections.<String, Object>emptyMap());
        queryString = sb.toString();
    }

(startLine=51 endLine=105 srcPath=/root/NewExperiment/hibernateFilter/00977/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/query/TwoEntityOneAuditedQueryGenerator.java)
                                   MiddleComponentData... componentDatas) {
		super( verEntCfg, referencingIdData, revisionTypeInId );

        /*
         * The query that we need to create:
         *   SELECT new list(ee, e) FROM referencedEntity e, middleEntity ee
         *   WHERE
         * (entities referenced by the middle table; id_ref_ed = id of the referenced entity)
         *     ee.id_ref_ed = e.id_ref_ed AND
         * (only entities referenced by the association; id_ref_ing = id of the referencing entity)
         *     ee.id_ref_ing = :id_ref_ing AND
         *     
         * (the association at revision :revision)
         *   --> for DefaultAuditStrategy:
         *     ee.revision = (SELECT max(ee2.revision) FROM middleEntity ee2
         *       WHERE ee2.revision <= :revision AND ee2.originalId.* = ee.originalId.*)
         *       
         *   --> for ValidityAuditStrategy:
         *     ee.revision <= :revision and (ee.endRevision > :revision or ee.endRevision is null)
         *
         *     AND
         *     
         * (only non-deleted entities and associations)
         *     ee.revision_type != DEL
         */
        String revisionPropertyPath = verEntCfg.getRevisionNumberPath();
        String originalIdPropertyName = verEntCfg.getOriginalIdPropName();

        String eeOriginalIdPropertyPath = MIDDLE_ENTITY_ALIAS + "." + originalIdPropertyName;

        // SELECT new list(ee) FROM middleEntity ee
        QueryBuilder qb = new QueryBuilder(versionsMiddleEntityName, MIDDLE_ENTITY_ALIAS);
        qb.addFrom(referencedIdData.getEntityName(), REFERENCED_ENTITY_ALIAS);
        qb.addProjection("new list", MIDDLE_ENTITY_ALIAS + ", " + REFERENCED_ENTITY_ALIAS, false, false);
        // WHERE
        Parameters rootParameters = qb.getRootParameters();
        // ee.id_ref_ed = e.id_ref_ed
        referencedIdData.getPrefixedMapper().addIdsEqualToQuery(rootParameters, eeOriginalIdPropertyPath,
                referencedIdData.getOriginalMapper(), REFERENCED_ENTITY_ALIAS);
        // ee.originalId.id_ref_ing = :id_ref_ing
        referencingIdData.getPrefixedMapper().addNamedIdEqualsToQuery(rootParameters, originalIdPropertyName, true);

        // (with ee association at revision :revision)
        // --> based on auditStrategy (see above)
        auditStrategy.addAssociationAtRevisionRestriction(qb, revisionPropertyPath,
        		verEntCfg.getRevisionEndFieldName(), true,referencingIdData, versionsMiddleEntityName,
        		eeOriginalIdPropertyPath, revisionPropertyPath, originalIdPropertyName, MIDDLE_ENTITY_ALIAS, componentDatas);

        // ee.revision_type != DEL
        rootParameters.addWhereWithNamedParam(getRevisionTypePath(), "!=", DEL_REVISION_TYPE_PARAMETER);

        StringBuilder sb = new StringBuilder();
        qb.build(sb, Collections.<String, Object>emptyMap());
        queryString = sb.toString();
    }

commonMethod: 
(startLine=108 endLine=123 srcPath=/root/NewExperiment/hibernateFilter/00978/hibernate-envers/src/main/java/org/hibernate/envers/internal/tools/query/Parameters.java)
    /**
     * Adds sub-parameters with a new connective. That is, the parameters will be grouped in parentheses in the
     * generated query, e.g.: ... and (exp1 or exp2) and ..., assuming the old connective is "and", and the
     * new connective is "or".
     * @param newConnective New connective of the parameters.
     * @return Sub-parameters with the given connective.
     */
    public Parameters addSubParameters(String newConnective) {
        if (connective.equals(newConnective)) {
            return this;
        } else {
            Parameters newParams = new Parameters(alias, newConnective, queryParamCounter);
            subParameters.add(newParams);
            return newParams;
        }
    }


, Instance #
frags: 
(startLine=50 endLine=97 srcPath=/root/NewExperiment/hibernateFilter/00977/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/query/OneEntityQueryGenerator.java)
                                   MiddleComponentData... componentDatas) {
		super( verEntCfg, referencingIdData, revisionTypeInId );

        /*
         * The query that we need to create:
         *   SELECT ee FROM middleEntity ee WHERE
         * (only entities referenced by the association; id_ref_ing = id of the referencing entity)
         *     ee.originalId.id_ref_ing = :id_ref_ing AND
         *     
         * (the association at revision :revision)
         *   --> for DefaultAuditStrategy:
         *     ee.revision = (SELECT max(ee2.revision) FROM middleEntity ee2
         *       WHERE ee2.revision <= :revision AND ee2.originalId.* = ee.originalId.*)
         *       
         *   --> for ValidityAuditStrategy:
         *     ee.revision <= :revision and (ee.endRevision > :revision or ee.endRevision is null)
         * 
         *     AND
         *     
         * (only non-deleted entities and associations)
         *     ee.revision_type != DEL
         */
        String revisionPropertyPath = verEntCfg.getRevisionNumberPath();
        String originalIdPropertyName = verEntCfg.getOriginalIdPropName();

        // SELECT ee FROM middleEntity ee
        QueryBuilder qb = new QueryBuilder(versionsMiddleEntityName, MIDDLE_ENTITY_ALIAS);
        qb.addProjection(null, MIDDLE_ENTITY_ALIAS, false, false);
        // WHERE
        Parameters rootParameters = qb.getRootParameters();
        // ee.originalId.id_ref_ing = :id_ref_ing
        referencingIdData.getPrefixedMapper().addNamedIdEqualsToQuery(rootParameters, originalIdPropertyName, true);
        
        String eeOriginalIdPropertyPath = MIDDLE_ENTITY_ALIAS + "." + originalIdPropertyName;

        // (with ee association at revision :revision)
        // --> based on auditStrategy (see above)
        auditStrategy.addAssociationAtRevisionRestriction(qb, revisionPropertyPath,
         		verEntCfg.getRevisionEndFieldName(), true, referencingIdData, versionsMiddleEntityName,
         		eeOriginalIdPropertyPath, revisionPropertyPath, originalIdPropertyName, MIDDLE_ENTITY_ALIAS, componentDatas);
         
        // ee.revision_type != DEL
        rootParameters.addWhereWithNamedParam(getRevisionTypePath(), "!=", DEL_REVISION_TYPE_PARAMETER);

        StringBuilder sb = new StringBuilder();
        qb.build(sb, Collections.<String, Object>emptyMap());
        queryString = sb.toString();
    }

(startLine=50 endLine=96 srcPath=/root/NewExperiment/hibernateFilter/00977/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/query/OneAuditEntityQueryGenerator.java)
										boolean revisionTypeInId) {
		super( verEntCfg, referencingIdData, revisionTypeInId );

        /*
         * The query that we need to create:
         *   SELECT e FROM versionsReferencedEntity e
         *   WHERE
         * (only entities referenced by the association; id_ref_ing = id of the referencing entity)
         *     e.id_ref_ing = :id_ref_ing AND
         * (selecting e entities at revision :revision)
         *   --> for DefaultAuditStrategy:
         *     e.revision = (SELECT max(e2.revision) FROM versionsReferencedEntity e2
         *       WHERE e2.revision <= :revision AND e2.id = e.id) 
         *     
         *   --> for ValidityAuditStrategy:
         *     e.revision <= :revision and (e.endRevision > :revision or e.endRevision is null)
         *     
         *     AND
         * (only non-deleted entities)
         *     e.revision_type != DEL
         */
        String revisionPropertyPath = verEntCfg.getRevisionNumberPath();
        String originalIdPropertyName = verEntCfg.getOriginalIdPropName();

        String versionsReferencedEntityName = verEntCfg.getAuditEntityName(referencedEntityName);

        // SELECT e FROM versionsEntity e
        QueryBuilder qb = new QueryBuilder(versionsReferencedEntityName, REFERENCED_ENTITY_ALIAS);
        qb.addProjection(null, REFERENCED_ENTITY_ALIAS, false, false);
        // WHERE
        Parameters rootParameters = qb.getRootParameters();
        // e.id_ref_ed = :id_ref_ed
        referencingIdData.getPrefixedMapper().addNamedIdEqualsToQuery(rootParameters, null, true);

        // (selecting e entities at revision :revision)
        // --> based on auditStrategy (see above)
        auditStrategy.addEntityAtRevisionRestriction(globalCfg, qb, revisionPropertyPath,
        		verEntCfg.getRevisionEndFieldName(), true, referencedIdData, 
				revisionPropertyPath, originalIdPropertyName, REFERENCED_ENTITY_ALIAS, REFERENCED_ENTITY_ALIAS_DEF_AUD_STR);

        // e.revision_type != DEL
        rootParameters.addWhereWithNamedParam(getRevisionTypePath(), false, "!=", DEL_REVISION_TYPE_PARAMETER);

        StringBuilder sb = new StringBuilder();
        qb.build(sb, Collections.<String, Object>emptyMap());
        queryString = sb.toString();
    }

(startLine=51 endLine=105 srcPath=/root/NewExperiment/hibernateFilter/00977/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/query/TwoEntityOneAuditedQueryGenerator.java)
                                   MiddleComponentData... componentDatas) {
		super( verEntCfg, referencingIdData, revisionTypeInId );

        /*
         * The query that we need to create:
         *   SELECT new list(ee, e) FROM referencedEntity e, middleEntity ee
         *   WHERE
         * (entities referenced by the middle table; id_ref_ed = id of the referenced entity)
         *     ee.id_ref_ed = e.id_ref_ed AND
         * (only entities referenced by the association; id_ref_ing = id of the referencing entity)
         *     ee.id_ref_ing = :id_ref_ing AND
         *     
         * (the association at revision :revision)
         *   --> for DefaultAuditStrategy:
         *     ee.revision = (SELECT max(ee2.revision) FROM middleEntity ee2
         *       WHERE ee2.revision <= :revision AND ee2.originalId.* = ee.originalId.*)
         *       
         *   --> for ValidityAuditStrategy:
         *     ee.revision <= :revision and (ee.endRevision > :revision or ee.endRevision is null)
         *
         *     AND
         *     
         * (only non-deleted entities and associations)
         *     ee.revision_type != DEL
         */
        String revisionPropertyPath = verEntCfg.getRevisionNumberPath();
        String originalIdPropertyName = verEntCfg.getOriginalIdPropName();

        String eeOriginalIdPropertyPath = MIDDLE_ENTITY_ALIAS + "." + originalIdPropertyName;

        // SELECT new list(ee) FROM middleEntity ee
        QueryBuilder qb = new QueryBuilder(versionsMiddleEntityName, MIDDLE_ENTITY_ALIAS);
        qb.addFrom(referencedIdData.getEntityName(), REFERENCED_ENTITY_ALIAS);
        qb.addProjection("new list", MIDDLE_ENTITY_ALIAS + ", " + REFERENCED_ENTITY_ALIAS, false, false);
        // WHERE
        Parameters rootParameters = qb.getRootParameters();
        // ee.id_ref_ed = e.id_ref_ed
        referencedIdData.getPrefixedMapper().addIdsEqualToQuery(rootParameters, eeOriginalIdPropertyPath,
                referencedIdData.getOriginalMapper(), REFERENCED_ENTITY_ALIAS);
        // ee.originalId.id_ref_ing = :id_ref_ing
        referencingIdData.getPrefixedMapper().addNamedIdEqualsToQuery(rootParameters, originalIdPropertyName, true);

        // (with ee association at revision :revision)
        // --> based on auditStrategy (see above)
        auditStrategy.addAssociationAtRevisionRestriction(qb, revisionPropertyPath,
        		verEntCfg.getRevisionEndFieldName(), true,referencingIdData, versionsMiddleEntityName,
        		eeOriginalIdPropertyPath, revisionPropertyPath, originalIdPropertyName, MIDDLE_ENTITY_ALIAS, componentDatas);

        // ee.revision_type != DEL
        rootParameters.addWhereWithNamedParam(getRevisionTypePath(), "!=", DEL_REVISION_TYPE_PARAMETER);

        StringBuilder sb = new StringBuilder();
        qb.build(sb, Collections.<String, Object>emptyMap());
        queryString = sb.toString();
    }

commonMethod: 
(startLine=85 endLine=87 srcPath=/root/NewExperiment/hibernateFilter/00978/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/query/AbstractRelationQueryGenerator.java)
	protected String queryToString(QueryBuilder query) {
		return queryToString( query, Collections.<String, Object>emptyMap() );
	}


, Instance #
frags: 
(startLine=76 endLine=83 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/main/java/org/hibernate/loader/entity/plan/LegacyBatchingEntityLoaderBuilder.java)
				LoadQueryInfluencers loadQueryInfluencers) {
			super( persister );
			this.batchSizes = ArrayHelper.getBatchSizes( maxBatchSize );
			this.loaders = new EntityLoader[ batchSizes.length ];
			for ( int i = 0; i < batchSizes.length; i++ ) {
				this.loaders[i] = new EntityLoader( persister, batchSizes[i], lockMode, factory, loadQueryInfluencers);
			}
		}

(startLine=90 endLine=97 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/main/java/org/hibernate/loader/entity/plan/LegacyBatchingEntityLoaderBuilder.java)
				LoadQueryInfluencers loadQueryInfluencers) {
			super( persister );
			this.batchSizes = ArrayHelper.getBatchSizes( maxBatchSize );
			this.loaders = new EntityLoader[ batchSizes.length ];
			for ( int i = 0; i < batchSizes.length; i++ ) {
				this.loaders[i] = new EntityLoader( persister, batchSizes[i], lockOptions, factory, loadQueryInfluencers);
			}
		}

commonMethod: 
(startLine=94 endLine=96 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/main/java/org/hibernate/loader/entity/plan/EntityLoader.java)
		public EntityLoader byPrimaryKey() {
			return byUniqueKey( persister.getIdentifierColumnNames(), persister.getIdentifierType() );
		}


, Instance #
frags: 
(startLine=76 endLine=83 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/main/java/org/hibernate/loader/entity/plan/LegacyBatchingEntityLoaderBuilder.java)
				LoadQueryInfluencers loadQueryInfluencers) {
			super( persister );
			this.batchSizes = ArrayHelper.getBatchSizes( maxBatchSize );
			this.loaders = new EntityLoader[ batchSizes.length ];
			for ( int i = 0; i < batchSizes.length; i++ ) {
				this.loaders[i] = new EntityLoader( persister, batchSizes[i], lockMode, factory, loadQueryInfluencers);
			}
		}

(startLine=90 endLine=97 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/main/java/org/hibernate/loader/entity/plan/LegacyBatchingEntityLoaderBuilder.java)
				LoadQueryInfluencers loadQueryInfluencers) {
			super( persister );
			this.batchSizes = ArrayHelper.getBatchSizes( maxBatchSize );
			this.loaders = new EntityLoader[ batchSizes.length ];
			for ( int i = 0; i < batchSizes.length; i++ ) {
				this.loaders[i] = new EntityLoader( persister, batchSizes[i], lockOptions, factory, loadQueryInfluencers);
			}
		}

commonMethod: 
(startLine=59 endLine=61 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/main/java/org/hibernate/loader/entity/plan/EntityLoader.java)
	public static Builder forEntity(OuterJoinLoadable persister) {
		return new Builder( persister );
	}


, Instance #
frags: 
(startLine=81 endLine=214 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManySetResultSetProcessorTest.java)
	public void testEntityWithSet() throws Exception {
		final EntityPersister entityPersister = sessionFactory().getEntityPersister( Poster.class.getName() );

		// create some test data
		Session session = openSession();
		session.beginTransaction();
		Poster poster = new Poster();
		poster.pid = 0;
		poster.name = "John Doe";
		Message message1 = new Message();
		message1.mid = 1;
		message1.msgTxt = "Howdy!";
		message1.poster = poster;
		poster.messages.add( message1 );
		Message message2 = new Message();
		message2.mid = 2;
		message2.msgTxt = "Bye!";
		message2.poster = poster;
		poster.messages.add( message2 );
		session.save( poster );
		session.getTransaction().commit();
		session.close();

		session = openSession();
		session.beginTransaction();
		Poster posterGotten = (Poster) session.get( Poster.class, poster.pid );
		assertEquals( 0, posterGotten.pid.intValue() );
		assertEquals( poster.name, posterGotten.name );
		assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
		assertEquals( 2, posterGotten.messages.size() );
		for ( Message message : posterGotten.messages ) {
			if ( message.mid == 1 ) {
				assertEquals( message1.msgTxt, message.msgTxt );
			}
			else if ( message.mid == 2 ) {
				assertEquals( message2.msgTxt, message.msgTxt );
			}
			else {
				fail( "unexpected message id." );
			}
			assertSame( posterGotten, message.poster );
		}
		session.getTransaction().commit();
		session.close();

		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			for ( Message message : workPoster.messages ) {
				if ( message.mid == 1 ) {
					assertEquals( message1.msgTxt, message.msgTxt );
				}
				else if ( message.mid == 2 ) {
					assertEquals( message2.msgTxt, message.msgTxt );
				}
				else {
					fail( "unexpected message id." );
				}
				assertSame( workPoster, message.poster );
			}
			workSession.getTransaction().commit();
			workSession.close();
		}

		// clean up test data
		session = openSession();
		session.beginTransaction();
		session.delete( poster );
		session.getTransaction().commit();
		session.close();
	}

(startLine=78 endLine=195 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManyListResultSetProcessorTest.java)
	public void testEntityWithList() throws Exception {
		final EntityPersister entityPersister = sessionFactory().getEntityPersister( Poster.class.getName() );

		// create some test data
		Session session = openSession();
		session.beginTransaction();
		Poster poster = new Poster();
		poster.pid = 0;
		poster.name = "John Doe";
		Message message1 = new Message();
		message1.mid = 1;
		message1.msgTxt = "Howdy!";
		message1.poster = poster;
		poster.messages.add( message1 );
		Message message2 = new Message();
		message2.mid = 2;
		message2.msgTxt = "Bye!";
		message2.poster = poster;
		poster.messages.add( message2 );
		session.save( poster );
		session.getTransaction().commit();
		session.close();

		session = openSession();
		session.beginTransaction();
		Poster posterGotten = (Poster) session.get( Poster.class, poster.pid );
		assertEquals( 0, posterGotten.pid.intValue() );
		assertEquals( poster.name, posterGotten.name );
		assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
		assertEquals( 2, posterGotten.messages.size() );
		assertEquals( message1.msgTxt, posterGotten.messages.get( 0 ).msgTxt );
		assertEquals( message2.msgTxt, posterGotten.messages.get( 1 ).msgTxt );
		assertSame( posterGotten, posterGotten.messages.get( 0 ).poster );
		assertSame( posterGotten, posterGotten.messages.get( 1 ).poster );
		session.getTransaction().commit();
		session.close();

		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertEquals( message1.msgTxt, workPoster.messages.get( 0 ).msgTxt );
			assertEquals( message2.msgTxt, workPoster.messages.get( 1 ).msgTxt );
			assertSame( workPoster, workPoster.messages.get( 0 ).poster );
			assertSame( workPoster, workPoster.messages.get( 1 ).poster );
			workSession.getTransaction().commit();
			workSession.close();
		}

		// clean up test data
		session = openSession();
		session.beginTransaction();
		session.delete( poster );
		session.getTransaction().commit();
		session.close();
	}

commonMethod: 
(startLine=50 endLine=56 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/Helper.java)
	public LoadPlan buildLoadPlan(SessionFactoryImplementor sf, EntityPersister entityPersister) {
		final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
				sf,
				LoadQueryInfluencers.NONE
		);
		return LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
	}


, Instance #
frags: 
(startLine=126 endLine=206 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManySetResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			for ( Message message : workPoster.messages ) {
				if ( message.mid == 1 ) {
					assertEquals( message1.msgTxt, message.msgTxt );
				}
				else if ( message.mid == 2 ) {
					assertEquals( message2.msgTxt, message.msgTxt );
				}
				else {
					fail( "unexpected message id." );
				}
				assertSame( workPoster, message.poster );
			}
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=115 endLine=187 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManyListResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertEquals( message1.msgTxt, workPoster.messages.get( 0 ).msgTxt );
			assertEquals( message2.msgTxt, workPoster.messages.get( 1 ).msgTxt );
			assertSame( workPoster, workPoster.messages.get( 0 ).poster );
			assertSame( workPoster, workPoster.messages.get( 1 ).poster );
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=190 endLine=247 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EncapsulatedCompositeAttributeResultSetProcessorTest.java)
	private List<?> getResults(EntityPersister entityPersister ) {
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			workSession.getTransaction().commit();
			workSession.close();
			return results;
		}

(startLine=165 endLine=225 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/NonEncapsulatedCompositeIdResultSetProcessorTest.java)
	private List getResults(final EntityPersister entityPersister, final Callback callback) {
		final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
				sessionFactory(),
				LoadQueryInfluencers.NONE
		);
		final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
		final LoadQueryAliasResolutionContext aliasResolutionContext =
				new LoadQueryAliasResolutionContextImpl(
						sessionFactory(),
						0,
						Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
				);
		final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
				LoadQueryInfluencers.NONE,
				plan
		);
		final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

		final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
		final List results = new ArrayList();

		final Session workSession = openSession();
		workSession.beginTransaction();
		workSession.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						System.out.println( "SQL : " + sql );
						PreparedStatement ps = connection.prepareStatement( sql );
						callback.bind( ps );
						ResultSet resultSet = ps.executeQuery();
						//callback.beforeExtractResults( workSession );
						results.addAll(
								resultSetProcessor.extractResults(
										NoOpLoadPlanAdvisor.INSTANCE,
										resultSet,
										(SessionImplementor) workSession,
										callback.getQueryParameters(),
										new NamedParameterContext() {
											@Override
											public int[] getNamedParameterLocations(String name) {
												return new int[0];
											}
										},
										aliasResolutionContext,
										true,
										false,
										null,
										null
								)
						);
						resultSet.close();
						ps.close();
					}
				}
		);
		workSession.getTransaction().commit();
		workSession.close();

		return results;
	}

(startLine=82 endLine=145 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/SimpleResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			SimpleEntity workEntity = ExtraAssertions.assertTyping( SimpleEntity.class, result );
			assertEquals( 1, workEntity.id.intValue() );
			assertEquals( "the only", workEntity.name );
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=93 endLine=160 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyCollectionResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertSame( result1, results.get( 1 ) );
			assertNotNull( result1 );

			Person workPerson = ExtraAssertions.assertTyping( Person.class, result1 );
			assertEquals( 1, workPerson.id.intValue() );
			assertEquals( person.name, workPerson.name );
			assertTrue( Hibernate.isInitialized( workPerson.nickNames ) );
			assertEquals( 2, workPerson.nickNames.size() );
			assertEquals( person.nickNames, workPerson.nickNames );
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=195 endLine=254 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EncapsulatedCompositeIdResultSetProcessorTest.java)
	private List getResults(final EntityPersister entityPersister, final Callback callback) {
		final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
				sessionFactory(),
				LoadQueryInfluencers.NONE
		);
		final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
		final LoadQueryAliasResolutionContext aliasResolutionContext =
				new LoadQueryAliasResolutionContextImpl(
						sessionFactory(),
						0,
						Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
				);
		final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
				LoadQueryInfluencers.NONE,
				plan
		);
		final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

		final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
		final List results = new ArrayList();

		final Session workSession = openSession();
		workSession.beginTransaction();
		workSession.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						PreparedStatement ps = connection.prepareStatement( sql );
						callback.bind( ps );
						ResultSet resultSet = ps.executeQuery();
						//callback.beforeExtractResults( workSession );
						results.addAll(
								resultSetProcessor.extractResults(
										NoOpLoadPlanAdvisor.INSTANCE,
										resultSet,
										(SessionImplementor) workSession,
										callback.getQueryParameters(),
										new NamedParameterContext() {
											@Override
											public int[] getNamedParameterLocations(String name) {
												return new int[0];
											}
										},
										aliasResolutionContext,
										true,
										false,
										null,
										null
								)
						);
						resultSet.close();
						ps.close();
					}
				}
		);
		workSession.getTransaction().commit();
		workSession.close();

		return results;
	}

(startLine=92 endLine=161 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			Message workMessage = ExtraAssertions.assertTyping( Message.class, result );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=190 endLine=264 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			ReportedMessage workReportedMessage = ExtraAssertions.assertTyping( ReportedMessage.class, result );
			assertEquals( 0, workReportedMessage.id.intValue() );
			assertEquals( "inappropriate", workReportedMessage.reason );
			Message workMessage = workReportedMessage.message;
			assertNotNull( workMessage );
			assertTrue( Hibernate.isInitialized( workMessage ) );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

commonMethod: 
(startLine=50 endLine=56 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/Helper.java)
	public LoadPlan buildLoadPlan(SessionFactoryImplementor sf, EntityPersister entityPersister) {
		final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
				sf,
				LoadQueryInfluencers.NONE
		);
		return LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
	}


, Instance #
frags: 
(startLine=190 endLine=247 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EncapsulatedCompositeAttributeResultSetProcessorTest.java)
	private List<?> getResults(EntityPersister entityPersister ) {
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			workSession.getTransaction().commit();
			workSession.close();
			return results;
		}

(startLine=165 endLine=225 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/NonEncapsulatedCompositeIdResultSetProcessorTest.java)
	private List getResults(final EntityPersister entityPersister, final Callback callback) {
		final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
				sessionFactory(),
				LoadQueryInfluencers.NONE
		);
		final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
		final LoadQueryAliasResolutionContext aliasResolutionContext =
				new LoadQueryAliasResolutionContextImpl(
						sessionFactory(),
						0,
						Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
				);
		final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
				LoadQueryInfluencers.NONE,
				plan
		);
		final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

		final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
		final List results = new ArrayList();

		final Session workSession = openSession();
		workSession.beginTransaction();
		workSession.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						System.out.println( "SQL : " + sql );
						PreparedStatement ps = connection.prepareStatement( sql );
						callback.bind( ps );
						ResultSet resultSet = ps.executeQuery();
						//callback.beforeExtractResults( workSession );
						results.addAll(
								resultSetProcessor.extractResults(
										NoOpLoadPlanAdvisor.INSTANCE,
										resultSet,
										(SessionImplementor) workSession,
										callback.getQueryParameters(),
										new NamedParameterContext() {
											@Override
											public int[] getNamedParameterLocations(String name) {
												return new int[0];
											}
										},
										aliasResolutionContext,
										true,
										false,
										null,
										null
								)
						);
						resultSet.close();
						ps.close();
					}
				}
		);
		workSession.getTransaction().commit();
		workSession.close();

		return results;
	}

(startLine=195 endLine=254 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EncapsulatedCompositeIdResultSetProcessorTest.java)
	private List getResults(final EntityPersister entityPersister, final Callback callback) {
		final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
				sessionFactory(),
				LoadQueryInfluencers.NONE
		);
		final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
		final LoadQueryAliasResolutionContext aliasResolutionContext =
				new LoadQueryAliasResolutionContextImpl(
						sessionFactory(),
						0,
						Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
				);
		final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
				LoadQueryInfluencers.NONE,
				plan
		);
		final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

		final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
		final List results = new ArrayList();

		final Session workSession = openSession();
		workSession.beginTransaction();
		workSession.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						PreparedStatement ps = connection.prepareStatement( sql );
						callback.bind( ps );
						ResultSet resultSet = ps.executeQuery();
						//callback.beforeExtractResults( workSession );
						results.addAll(
								resultSetProcessor.extractResults(
										NoOpLoadPlanAdvisor.INSTANCE,
										resultSet,
										(SessionImplementor) workSession,
										callback.getQueryParameters(),
										new NamedParameterContext() {
											@Override
											public int[] getNamedParameterLocations(String name) {
												return new int[0];
											}
										},
										aliasResolutionContext,
										true,
										false,
										null,
										null
								)
						);
						resultSet.close();
						ps.close();
					}
				}
		);
		workSession.getTransaction().commit();
		workSession.close();

		return results;
	}

(startLine=126 endLine=206 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManySetResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			for ( Message message : workPoster.messages ) {
				if ( message.mid == 1 ) {
					assertEquals( message1.msgTxt, message.msgTxt );
				}
				else if ( message.mid == 2 ) {
					assertEquals( message2.msgTxt, message.msgTxt );
				}
				else {
					fail( "unexpected message id." );
				}
				assertSame( workPoster, message.poster );
			}
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=82 endLine=145 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/SimpleResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			SimpleEntity workEntity = ExtraAssertions.assertTyping( SimpleEntity.class, result );
			assertEquals( 1, workEntity.id.intValue() );
			assertEquals( "the only", workEntity.name );
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=93 endLine=160 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyCollectionResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertSame( result1, results.get( 1 ) );
			assertNotNull( result1 );

			Person workPerson = ExtraAssertions.assertTyping( Person.class, result1 );
			assertEquals( 1, workPerson.id.intValue() );
			assertEquals( person.name, workPerson.name );
			assertTrue( Hibernate.isInitialized( workPerson.nickNames ) );
			assertEquals( 2, workPerson.nickNames.size() );
			assertEquals( person.nickNames, workPerson.nickNames );
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=115 endLine=187 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManyListResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertEquals( message1.msgTxt, workPoster.messages.get( 0 ).msgTxt );
			assertEquals( message2.msgTxt, workPoster.messages.get( 1 ).msgTxt );
			assertSame( workPoster, workPoster.messages.get( 0 ).poster );
			assertSame( workPoster, workPoster.messages.get( 1 ).poster );
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=92 endLine=161 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			Message workMessage = ExtraAssertions.assertTyping( Message.class, result );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=190 endLine=264 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			ReportedMessage workReportedMessage = ExtraAssertions.assertTyping( ReportedMessage.class, result );
			assertEquals( 0, workReportedMessage.id.intValue() );
			assertEquals( "inappropriate", workReportedMessage.reason );
			Message workMessage = workReportedMessage.message;
			assertNotNull( workMessage );
			assertTrue( Hibernate.isInitialized( workMessage ) );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

commonMethod: 
(startLine=50 endLine=56 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/Helper.java)
	public LoadPlan buildLoadPlan(SessionFactoryImplementor sf, EntityPersister entityPersister) {
		final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
				sf,
				LoadQueryInfluencers.NONE
		);
		return LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
	}


, Instance #
frags: 
(startLine=77 endLine=170 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
	public void testManyToOneEntityProcessing() throws Exception {
		final EntityPersister entityPersister = sessionFactory().getEntityPersister( Message.class.getName() );

		// create some test data
		Session session = openSession();
		session.beginTransaction();
		Message message = new Message( 1, "the message" );
		Poster poster = new Poster( 2, "the poster" );
		session.save( message );
		session.save( poster );
		message.poster = poster;
		poster.messages.add( message );
		session.getTransaction().commit();
		session.close();

		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			Message workMessage = ExtraAssertions.assertTyping( Message.class, result );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

		// clean up test data
		session = openSession();
		session.beginTransaction();
		session.createQuery( "delete Message" ).executeUpdate();
		session.createQuery( "delete Poster" ).executeUpdate();
		session.getTransaction().commit();
		session.close();
	}

(startLine=173 endLine=274 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
	public void testNestedManyToOneEntityProcessing() throws Exception {
		final EntityPersister entityPersister = sessionFactory().getEntityPersister( ReportedMessage.class.getName() );

		// create some test data
		Session session = openSession();
		session.beginTransaction();
		Message message = new Message( 1, "the message" );
		Poster poster = new Poster( 2, "the poster" );
		session.save( message );
		session.save( poster );
		message.poster = poster;
		poster.messages.add( message );
		ReportedMessage reportedMessage = new ReportedMessage( 0, "inappropriate", message );
		session.save( reportedMessage );
		session.getTransaction().commit();
		session.close();

		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			ReportedMessage workReportedMessage = ExtraAssertions.assertTyping( ReportedMessage.class, result );
			assertEquals( 0, workReportedMessage.id.intValue() );
			assertEquals( "inappropriate", workReportedMessage.reason );
			Message workMessage = workReportedMessage.message;
			assertNotNull( workMessage );
			assertTrue( Hibernate.isInitialized( workMessage ) );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

		// clean up test data
		session = openSession();
		session.beginTransaction();
		session.createQuery( "delete ReportedMessage" ).executeUpdate();
		session.createQuery( "delete Message" ).executeUpdate();
		session.createQuery( "delete Poster" ).executeUpdate();
		session.getTransaction().commit();
		session.close();
	}

commonMethod: 
(startLine=50 endLine=56 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/Helper.java)
	public LoadPlan buildLoadPlan(SessionFactoryImplementor sf, EntityPersister entityPersister) {
		final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
				sf,
				LoadQueryInfluencers.NONE
		);
		return LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
	}


, Instance #
frags: 
(startLine=82 endLine=145 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/SimpleResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			SimpleEntity workEntity = ExtraAssertions.assertTyping( SimpleEntity.class, result );
			assertEquals( 1, workEntity.id.intValue() );
			assertEquals( "the only", workEntity.name );
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=93 endLine=160 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyCollectionResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertSame( result1, results.get( 1 ) );
			assertNotNull( result1 );

			Person workPerson = ExtraAssertions.assertTyping( Person.class, result1 );
			assertEquals( 1, workPerson.id.intValue() );
			assertEquals( person.name, workPerson.name );
			assertTrue( Hibernate.isInitialized( workPerson.nickNames ) );
			assertEquals( 2, workPerson.nickNames.size() );
			assertEquals( person.nickNames, workPerson.nickNames );
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=92 endLine=161 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			Message workMessage = ExtraAssertions.assertTyping( Message.class, result );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=190 endLine=264 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			ReportedMessage workReportedMessage = ExtraAssertions.assertTyping( ReportedMessage.class, result );
			assertEquals( 0, workReportedMessage.id.intValue() );
			assertEquals( "inappropriate", workReportedMessage.reason );
			Message workMessage = workReportedMessage.message;
			assertNotNull( workMessage );
			assertTrue( Hibernate.isInitialized( workMessage ) );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=190 endLine=247 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EncapsulatedCompositeAttributeResultSetProcessorTest.java)
	private List<?> getResults(EntityPersister entityPersister ) {
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			workSession.getTransaction().commit();
			workSession.close();
			return results;
		}

(startLine=126 endLine=206 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManySetResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			for ( Message message : workPoster.messages ) {
				if ( message.mid == 1 ) {
					assertEquals( message1.msgTxt, message.msgTxt );
				}
				else if ( message.mid == 2 ) {
					assertEquals( message2.msgTxt, message.msgTxt );
				}
				else {
					fail( "unexpected message id." );
				}
				assertSame( workPoster, message.poster );
			}
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=165 endLine=225 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/NonEncapsulatedCompositeIdResultSetProcessorTest.java)
	private List getResults(final EntityPersister entityPersister, final Callback callback) {
		final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
				sessionFactory(),
				LoadQueryInfluencers.NONE
		);
		final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
		final LoadQueryAliasResolutionContext aliasResolutionContext =
				new LoadQueryAliasResolutionContextImpl(
						sessionFactory(),
						0,
						Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
				);
		final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
				LoadQueryInfluencers.NONE,
				plan
		);
		final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

		final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
		final List results = new ArrayList();

		final Session workSession = openSession();
		workSession.beginTransaction();
		workSession.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						System.out.println( "SQL : " + sql );
						PreparedStatement ps = connection.prepareStatement( sql );
						callback.bind( ps );
						ResultSet resultSet = ps.executeQuery();
						//callback.beforeExtractResults( workSession );
						results.addAll(
								resultSetProcessor.extractResults(
										NoOpLoadPlanAdvisor.INSTANCE,
										resultSet,
										(SessionImplementor) workSession,
										callback.getQueryParameters(),
										new NamedParameterContext() {
											@Override
											public int[] getNamedParameterLocations(String name) {
												return new int[0];
											}
										},
										aliasResolutionContext,
										true,
										false,
										null,
										null
								)
						);
						resultSet.close();
						ps.close();
					}
				}
		);
		workSession.getTransaction().commit();
		workSession.close();

		return results;
	}

(startLine=115 endLine=187 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManyListResultSetProcessorTest.java)
		{
			final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
					sessionFactory(),
					LoadQueryInfluencers.NONE
			);
			final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
			final LoadQueryAliasResolutionContext aliasResolutionContext =
					new LoadQueryAliasResolutionContextImpl(
							sessionFactory(),
							0,
							Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
					);
			final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
					LoadQueryInfluencers.NONE,
					plan
			);
			final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertEquals( message1.msgTxt, workPoster.messages.get( 0 ).msgTxt );
			assertEquals( message2.msgTxt, workPoster.messages.get( 1 ).msgTxt );
			assertSame( workPoster, workPoster.messages.get( 0 ).poster );
			assertSame( workPoster, workPoster.messages.get( 1 ).poster );
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=195 endLine=254 srcPath=/root/NewExperiment/hibernateFilter/01093/hibernate-core/src/test/java/org/hibernate/loader/EncapsulatedCompositeIdResultSetProcessorTest.java)
	private List getResults(final EntityPersister entityPersister, final Callback callback) {
		final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
				sessionFactory(),
				LoadQueryInfluencers.NONE
		);
		final LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
		final LoadQueryAliasResolutionContext aliasResolutionContext =
				new LoadQueryAliasResolutionContextImpl(
						sessionFactory(),
						0,
						Collections.singletonMap( plan.getReturns().get( 0 ), new String[] { "abc" } )
				);
		final EntityLoadQueryBuilderImpl queryBuilder = new EntityLoadQueryBuilderImpl(
				LoadQueryInfluencers.NONE,
				plan
		);
		final String sql = queryBuilder.generateSql( 1, sessionFactory(), aliasResolutionContext );

		final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan );
		final List results = new ArrayList();

		final Session workSession = openSession();
		workSession.beginTransaction();
		workSession.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						PreparedStatement ps = connection.prepareStatement( sql );
						callback.bind( ps );
						ResultSet resultSet = ps.executeQuery();
						//callback.beforeExtractResults( workSession );
						results.addAll(
								resultSetProcessor.extractResults(
										NoOpLoadPlanAdvisor.INSTANCE,
										resultSet,
										(SessionImplementor) workSession,
										callback.getQueryParameters(),
										new NamedParameterContext() {
											@Override
											public int[] getNamedParameterLocations(String name) {
												return new int[0];
											}
										},
										aliasResolutionContext,
										true,
										false,
										null,
										null
								)
						);
						resultSet.close();
						ps.close();
					}
				}
		);
		workSession.getTransaction().commit();
		workSession.close();

		return results;
	}

commonMethod: 
(startLine=50 endLine=56 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/Helper.java)
	public LoadPlan buildLoadPlan(SessionFactoryImplementor sf, EntityPersister entityPersister) {
		final SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
				sf,
				LoadQueryInfluencers.NONE
		);
		return LoadPlanBuilder.buildRootEntityLoadPlan( strategy, entityPersister );
	}


, Instance #
frags: 
(startLine=255 endLine=309 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EncapsulatedCompositeAttributeResultSetProcessorTest.java)
	private List<?> getResults(EntityPersister entityPersister ) {
		final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );

		// ultimately, using a LoadPlan requires that it be interpreted into 2 pieces of information:
		//		1) The query to execute
		//		2) The ResultSetProcessor to use.
		//
		// Those 2 pieces of information share some common context:
		//		1) alias resolution context
		//

		final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory() );

		final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

		final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
		final List results = new ArrayList();

		final Session workSession = openSession();
		workSession.beginTransaction();
		workSession.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						PreparedStatement ps = connection.prepareStatement( sql );
						ps.setInt( 1, 1 );
						ResultSet resultSet = ps.executeQuery();
						results.addAll(
								resultSetProcessor.extractResults(
										NoOpLoadPlanAdvisor.INSTANCE,
										resultSet,
										(SessionImplementor) workSession,
										new QueryParameters(),
										new NamedParameterContext() {
											@Override
											public int[] getNamedParameterLocations(String name) {
												return new int[0];
											}
										},
										aliasResolutionContext,
										true,
										false,
										null,
										null
								)
						);
						resultSet.close();
						ps.close();
					}
				}
		);
		workSession.getTransaction().commit();
		workSession.close();
		return results;
	}

(startLine=160 endLine=208 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/NonEncapsulatedCompositeIdResultSetProcessorTest.java)
	private List getResults(final EntityPersister entityPersister, final Callback callback) {
		final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
		final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

		final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

		final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
		final List results = new ArrayList();

		final Session workSession = openSession();
		workSession.beginTransaction();
		workSession.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						System.out.println( "SQL : " + sql );
						PreparedStatement ps = connection.prepareStatement( sql );
						callback.bind( ps );
						ResultSet resultSet = ps.executeQuery();
						//callback.beforeExtractResults( workSession );
						results.addAll(
								resultSetProcessor.extractResults(
										NoOpLoadPlanAdvisor.INSTANCE,
										resultSet,
										(SessionImplementor) workSession,
										callback.getQueryParameters(),
										new NamedParameterContext() {
											@Override
											public int[] getNamedParameterLocations(String name) {
												return new int[0];
											}
										},
										aliasResolutionContext,
										true,
										false,
										null,
										null
								)
						);
						resultSet.close();
						ps.close();
					}
				}
		);
		workSession.getTransaction().commit();
		workSession.close();

		return results;
	}

(startLine=188 endLine=236 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EncapsulatedCompositeIdResultSetProcessorTest.java)
	private List getResults(final EntityPersister entityPersister, final Callback callback) {
		final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
		final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

		final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

		final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );

		final List results = new ArrayList();

		final Session workSession = openSession();
		workSession.beginTransaction();
		workSession.doWork(
				new Work() {
					@Override
					public void execute(Connection connection) throws SQLException {
						PreparedStatement ps = connection.prepareStatement( sql );
						callback.bind( ps );
						ResultSet resultSet = ps.executeQuery();
						//callback.beforeExtractResults( workSession );
						results.addAll(
								resultSetProcessor.extractResults(
										NoOpLoadPlanAdvisor.INSTANCE,
										resultSet,
										(SessionImplementor) workSession,
										callback.getQueryParameters(),
										new NamedParameterContext() {
											@Override
											public int[] getNamedParameterLocations(String name) {
												return new int[0];
											}
										},
										aliasResolutionContext,
										true,
										false,
										null,
										null
								)
						);
						resultSet.close();
						ps.close();
					}
				}
		);
		workSession.getTransaction().commit();
		workSession.close();

		return results;
	}

commonMethod: 
(startLine=59 endLine=66 srcPath=/root/NewExperiment/hibernateFilter/01095/hibernate-core/src/test/java/org/hibernate/loader/Helper.java)
	public EntityLoadQueryDetails buildLoadQueryDetails(LoadPlan loadPlan, SessionFactoryImplementor sf) {
		return EntityLoadQueryDetails.makeForBatching(
				loadPlan,
				null,
				this,
				sf
		);
	}


, Instance #
frags: 
(startLine=105 endLine=130 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyCollectionResultSetProcessorTest.java)
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}

(startLine=125 endLine=150 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManyListResultSetProcessorTest.java)
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}

(startLine=203 endLine=229 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EncapsulatedCompositeIdResultSetProcessorTest.java)
					public void execute(Connection connection) throws SQLException {
						PreparedStatement ps = connection.prepareStatement( sql );
						callback.bind( ps );
						ResultSet resultSet = ps.executeQuery();
						//callback.beforeExtractResults( workSession );
						results.addAll(
								resultSetProcessor.extractResults(
										NoOpLoadPlanAdvisor.INSTANCE,
										resultSet,
										(SessionImplementor) workSession,
										callback.getQueryParameters(),
										new NamedParameterContext() {
											@Override
											public int[] getNamedParameterLocations(String name) {
												return new int[0];
											}
										},
										aliasResolutionContext,
										true,
										false,
										null,
										null
								)
						);
						resultSet.close();
						ps.close();
					}

(startLine=102 endLine=127 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}

(startLine=188 endLine=213 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}

commonMethod: 
(startLine=59 endLine=66 srcPath=/root/NewExperiment/hibernateFilter/01095/hibernate-core/src/test/java/org/hibernate/loader/Helper.java)
	public EntityLoadQueryDetails buildLoadQueryDetails(LoadPlan loadPlan, SessionFactoryImplementor sf) {
		return EntityLoadQueryDetails.makeForBatching(
				loadPlan,
				null,
				this,
				sf
		);
	}


, Instance #
frags: 
(startLine=77 endLine=198 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManySetResultSetProcessorTest.java)
	public void testEntityWithSet() throws Exception {
		final EntityPersister entityPersister = sessionFactory().getEntityPersister( Poster.class.getName() );

		// create some test data
		Session session = openSession();
		session.beginTransaction();
		Poster poster = new Poster();
		poster.pid = 0;
		poster.name = "John Doe";
		Message message1 = new Message();
		message1.mid = 1;
		message1.msgTxt = "Howdy!";
		message1.poster = poster;
		poster.messages.add( message1 );
		Message message2 = new Message();
		message2.mid = 2;
		message2.msgTxt = "Bye!";
		message2.poster = poster;
		poster.messages.add( message2 );
		session.save( poster );
		session.getTransaction().commit();
		session.close();

		session = openSession();
		session.beginTransaction();
		Poster posterGotten = (Poster) session.get( Poster.class, poster.pid );
		assertEquals( 0, posterGotten.pid.intValue() );
		assertEquals( poster.name, posterGotten.name );
		assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
		assertEquals( 2, posterGotten.messages.size() );
		for ( Message message : posterGotten.messages ) {
			if ( message.mid == 1 ) {
				assertEquals( message1.msgTxt, message.msgTxt );
			}
			else if ( message.mid == 2 ) {
				assertEquals( message2.msgTxt, message.msgTxt );
			}
			else {
				fail( "unexpected message id." );
			}
			assertSame( posterGotten, message.poster );
		}
		session.getTransaction().commit();
		session.close();

		{
			final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
			final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

			final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			for ( Message message : workPoster.messages ) {
				if ( message.mid == 1 ) {
					assertEquals( message1.msgTxt, message.msgTxt );
				}
				else if ( message.mid == 2 ) {
					assertEquals( message2.msgTxt, message.msgTxt );
				}
				else {
					fail( "unexpected message id." );
				}
				assertSame( workPoster, message.poster );
			}
			workSession.getTransaction().commit();
			workSession.close();
		}

		// clean up test data
		session = openSession();
		session.beginTransaction();
		session.delete( poster );
		session.getTransaction().commit();
		session.close();
	}

(startLine=74 endLine=179 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManyListResultSetProcessorTest.java)
	public void testEntityWithList() throws Exception {
		final EntityPersister entityPersister = sessionFactory().getEntityPersister( Poster.class.getName() );

		// create some test data
		Session session = openSession();
		session.beginTransaction();
		Poster poster = new Poster();
		poster.pid = 0;
		poster.name = "John Doe";
		Message message1 = new Message();
		message1.mid = 1;
		message1.msgTxt = "Howdy!";
		message1.poster = poster;
		poster.messages.add( message1 );
		Message message2 = new Message();
		message2.mid = 2;
		message2.msgTxt = "Bye!";
		message2.poster = poster;
		poster.messages.add( message2 );
		session.save( poster );
		session.getTransaction().commit();
		session.close();

		session = openSession();
		session.beginTransaction();
		Poster posterGotten = (Poster) session.get( Poster.class, poster.pid );
		assertEquals( 0, posterGotten.pid.intValue() );
		assertEquals( poster.name, posterGotten.name );
		assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
		assertEquals( 2, posterGotten.messages.size() );
		assertEquals( message1.msgTxt, posterGotten.messages.get( 0 ).msgTxt );
		assertEquals( message2.msgTxt, posterGotten.messages.get( 1 ).msgTxt );
		assertSame( posterGotten, posterGotten.messages.get( 0 ).poster );
		assertSame( posterGotten, posterGotten.messages.get( 1 ).poster );
		session.getTransaction().commit();
		session.close();

		{
			final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
			final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

			final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertEquals( message1.msgTxt, workPoster.messages.get( 0 ).msgTxt );
			assertEquals( message2.msgTxt, workPoster.messages.get( 1 ).msgTxt );
			assertSame( workPoster, workPoster.messages.get( 0 ).poster );
			assertSame( workPoster, workPoster.messages.get( 1 ).poster );
			workSession.getTransaction().commit();
			workSession.close();
		}

		// clean up test data
		session = openSession();
		session.beginTransaction();
		session.delete( poster );
		session.getTransaction().commit();
		session.close();
	}

commonMethod: 
(startLine=59 endLine=66 srcPath=/root/NewExperiment/hibernateFilter/01095/hibernate-core/src/test/java/org/hibernate/loader/Helper.java)
	public EntityLoadQueryDetails buildLoadQueryDetails(LoadPlan loadPlan, SessionFactoryImplementor sf) {
		return EntityLoadQueryDetails.makeForBatching(
				loadPlan,
				null,
				this,
				sf
		);
	}


, Instance #
frags: 
(startLine=122 endLine=190 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManySetResultSetProcessorTest.java)
		{
			final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
			final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

			final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			for ( Message message : workPoster.messages ) {
				if ( message.mid == 1 ) {
					assertEquals( message1.msgTxt, message.msgTxt );
				}
				else if ( message.mid == 2 ) {
					assertEquals( message2.msgTxt, message.msgTxt );
				}
				else {
					fail( "unexpected message id." );
				}
				assertSame( workPoster, message.poster );
			}
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=111 endLine=171 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyOneToManyListResultSetProcessorTest.java)
		{
			final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
			final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

			final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertNotNull( result1 );
			assertSame( result1, results.get( 1 ) );

			Poster workPoster = ExtraAssertions.assertTyping( Poster.class, result1 );
			assertEquals( 0, workPoster.pid.intValue() );
			assertEquals( poster.name, workPoster.name );
			assertTrue( Hibernate.isInitialized( workPoster.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertTrue( Hibernate.isInitialized( posterGotten.messages ) );
			assertEquals( 2, workPoster.messages.size() );
			assertEquals( message1.msgTxt, workPoster.messages.get( 0 ).msgTxt );
			assertEquals( message2.msgTxt, workPoster.messages.get( 1 ).msgTxt );
			assertSame( workPoster, workPoster.messages.get( 0 ).poster );
			assertSame( workPoster, workPoster.messages.get( 1 ).poster );
			workSession.getTransaction().commit();
			workSession.close();
		}

commonMethod: 
(startLine=59 endLine=66 srcPath=/root/NewExperiment/hibernateFilter/01095/hibernate-core/src/test/java/org/hibernate/loader/Helper.java)
	public EntityLoadQueryDetails buildLoadQueryDetails(LoadPlan loadPlan, SessionFactoryImplementor sf) {
		return EntityLoadQueryDetails.makeForBatching(
				loadPlan,
				null,
				this,
				sf
		);
	}


, Instance #
frags: 
(startLine=73 endLine=154 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
	public void testManyToOneEntityProcessing() throws Exception {
		final EntityPersister entityPersister = sessionFactory().getEntityPersister( Message.class.getName() );

		// create some test data
		Session session = openSession();
		session.beginTransaction();
		Message message = new Message( 1, "the message" );
		Poster poster = new Poster( 2, "the poster" );
		session.save( message );
		session.save( poster );
		message.poster = poster;
		poster.messages.add( message );
		session.getTransaction().commit();
		session.close();

		{
			final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
			final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

			final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			Message workMessage = ExtraAssertions.assertTyping( Message.class, result );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

		// clean up test data
		session = openSession();
		session.beginTransaction();
		session.createQuery( "delete Message" ).executeUpdate();
		session.createQuery( "delete Poster" ).executeUpdate();
		session.getTransaction().commit();
		session.close();
	}

(startLine=157 endLine=246 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
	public void testNestedManyToOneEntityProcessing() throws Exception {
		final EntityPersister entityPersister = sessionFactory().getEntityPersister( ReportedMessage.class.getName() );

		// create some test data
		Session session = openSession();
		session.beginTransaction();
		Message message = new Message( 1, "the message" );
		Poster poster = new Poster( 2, "the poster" );
		session.save( message );
		session.save( poster );
		message.poster = poster;
		poster.messages.add( message );
		ReportedMessage reportedMessage = new ReportedMessage( 0, "inappropriate", message );
		session.save( reportedMessage );
		session.getTransaction().commit();
		session.close();

		{
			final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
			final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

			final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			ReportedMessage workReportedMessage = ExtraAssertions.assertTyping( ReportedMessage.class, result );
			assertEquals( 0, workReportedMessage.id.intValue() );
			assertEquals( "inappropriate", workReportedMessage.reason );
			Message workMessage = workReportedMessage.message;
			assertNotNull( workMessage );
			assertTrue( Hibernate.isInitialized( workMessage ) );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

		// clean up test data
		session = openSession();
		session.beginTransaction();
		session.createQuery( "delete ReportedMessage" ).executeUpdate();
		session.createQuery( "delete Message" ).executeUpdate();
		session.createQuery( "delete Poster" ).executeUpdate();
		session.getTransaction().commit();
		session.close();
	}

commonMethod: 
(startLine=59 endLine=66 srcPath=/root/NewExperiment/hibernateFilter/01095/hibernate-core/src/test/java/org/hibernate/loader/Helper.java)
	public EntityLoadQueryDetails buildLoadQueryDetails(LoadPlan loadPlan, SessionFactoryImplementor sf) {
		return EntityLoadQueryDetails.makeForBatching(
				loadPlan,
				null,
				this,
				sf
		);
	}


, Instance #
frags: 
(startLine=91 endLine=146 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityWithNonLazyCollectionResultSetProcessorTest.java)
		{
			final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
			final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

			final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 2, results.size() );
			Object result1 = results.get( 0 );
			assertSame( result1, results.get( 1 ) );
			assertNotNull( result1 );

			Person workPerson = ExtraAssertions.assertTyping( Person.class, result1 );
			assertEquals( 1, workPerson.id.intValue() );
			assertEquals( person.name, workPerson.name );
			assertTrue( Hibernate.isInitialized( workPerson.nickNames ) );
			assertEquals( 2, workPerson.nickNames.size() );
			assertEquals( person.nickNames, workPerson.nickNames );
			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=88 endLine=145 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
		{
			final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
			final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

			final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			Message workMessage = ExtraAssertions.assertTyping( Message.class, result );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=174 endLine=236 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/EntityAssociationResultSetProcessorTest.java)
		{
			final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
			final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

			final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 0 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			ReportedMessage workReportedMessage = ExtraAssertions.assertTyping( ReportedMessage.class, result );
			assertEquals( 0, workReportedMessage.id.intValue() );
			assertEquals( "inappropriate", workReportedMessage.reason );
			Message workMessage = workReportedMessage.message;
			assertNotNull( workMessage );
			assertTrue( Hibernate.isInitialized( workMessage ) );
			assertEquals( 1, workMessage.mid.intValue() );
			assertEquals( "the message", workMessage.msgTxt );
			assertTrue( Hibernate.isInitialized( workMessage.poster ) );
			Poster workPoster = workMessage.poster;
			assertEquals( 2, workPoster.pid.intValue() );
			assertEquals( "the poster", workPoster.name );
			assertFalse( Hibernate.isInitialized( workPoster.messages ) );

			workSession.getTransaction().commit();
			workSession.close();
		}

(startLine=76 endLine=128 srcPath=/root/NewExperiment/hibernateFilter/01094/hibernate-core/src/test/java/org/hibernate/loader/SimpleResultSetProcessorTest.java)
		{
			final LoadPlan plan = Helper.INSTANCE.buildLoadPlan( sessionFactory(), entityPersister );
			final AliasResolutionContext aliasResolutionContext = new AliasResolutionContextImpl( sessionFactory(), 0 );

			final String sql = Helper.INSTANCE.generateSql( sessionFactory(), plan, aliasResolutionContext );

			final ResultSetProcessorImpl resultSetProcessor = new ResultSetProcessorImpl( plan, true );
			final List results = new ArrayList();

			final Session workSession = openSession();
			workSession.beginTransaction();
			workSession.doWork(
					new Work() {
						@Override
						public void execute(Connection connection) throws SQLException {
							( (SessionImplementor) workSession ).getFactory().getJdbcServices().getSqlStatementLogger().logStatement( sql );
							PreparedStatement ps = connection.prepareStatement( sql );
							ps.setInt( 1, 1 );
							ResultSet resultSet = ps.executeQuery();
							results.addAll(
									resultSetProcessor.extractResults(
											NoOpLoadPlanAdvisor.INSTANCE,
											resultSet,
											(SessionImplementor) workSession,
											new QueryParameters(),
											new NamedParameterContext() {
												@Override
												public int[] getNamedParameterLocations(String name) {
													return new int[0];
												}
											},
											aliasResolutionContext,
											true,
											false,
											null,
											null
									)
							);
							resultSet.close();
							ps.close();
						}
					}
			);
			assertEquals( 1, results.size() );
			Object result = results.get( 0 );
			assertNotNull( result );

			SimpleEntity workEntity = ExtraAssertions.assertTyping( SimpleEntity.class, result );
			assertEquals( 1, workEntity.id.intValue() );
			assertEquals( "the only", workEntity.name );
			workSession.getTransaction().commit();
			workSession.close();
		}

commonMethod: 
(startLine=59 endLine=66 srcPath=/root/NewExperiment/hibernateFilter/01095/hibernate-core/src/test/java/org/hibernate/loader/Helper.java)
	public EntityLoadQueryDetails buildLoadQueryDetails(LoadPlan loadPlan, SessionFactoryImplementor sf) {
		return EntityLoadQueryDetails.makeForBatching(
				loadPlan,
				null,
				this,
				sf
		);
	}


, Instance #
frags: 
(startLine=76 endLine=103 srcPath=/root/NewExperiment/hibernateFilter/01118/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/spaces/EntityQuerySpaceImpl.java)
	public JoinImpl addCompositeJoin(CompositionDefinition compositionDefinition, String querySpaceUid) {
		final boolean required = canJoinsBeRequired() && !compositionDefinition.isNullable();

		final CompositeQuerySpaceImpl rhs = new CompositeQuerySpaceImpl(
				new CompositePropertyMapping(
						compositionDefinition.getType(),
						(PropertyMapping) this.getEntityPersister(),
						compositionDefinition.getName()
				),
				querySpaceUid,
				getQuerySpaces(),
				required,
				sessionFactory()
		);
		getQuerySpaces().registerQuerySpace( rhs );

		final JoinImpl join = new JoinImpl(
				this,
				compositionDefinition.getName(),
				rhs,
				( (PropertyMapping) persister ).toColumns( compositionDefinition.getName() ),
				compositionDefinition.getType(),
				required
		);
		internalGetJoins().add( join );

		return join;
	}

(startLine=76 endLine=104 srcPath=/root/NewExperiment/hibernateFilter/01118/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/spaces/CompositeQuerySpaceImpl.java)
	public JoinImpl addCompositeJoin(CompositionDefinition compositionDefinition, String querySpaceUid) {
		final String propertyPath = compositionDefinition.getName();
		final boolean required = canJoinsBeRequired() && !compositionDefinition.isNullable();

		final CompositeQuerySpaceImpl rhs = new CompositeQuerySpaceImpl(
				new CompositePropertyMapping(
						compositionDefinition.getType(),
						compositeSubPropertyMapping,
						compositionDefinition.getName()
				),
				querySpaceUid,
				getQuerySpaces(),
				required,
				sessionFactory()
		);
		getQuerySpaces().registerQuerySpace( rhs );

		final JoinImpl join = new JoinImpl(
				this,
				propertyPath,
				rhs,
				getPropertyMapping().toColumns( compositionDefinition.getName() ),
				compositionDefinition.getType(),
				required
		);
		internalGetJoins().add( join );

		return join;
	}

commonMethod: 
(startLine=85 endLine=99 srcPath=/root/NewExperiment/hibernateFilter/01119/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/spaces/JoinHelper.java)
	public JoinDefinedByMetadata createCompositeJoin(
			QuerySpace leftHandSide,
			String lhsPropertyName,
			CompositeQuerySpace rightHandSide,
			boolean rightHandSideRequired,
			CompositeType joinedPropertyType) {
		return new JoinImpl(
				leftHandSide,
				lhsPropertyName,
				rightHandSide,
				null,
				joinedPropertyType,
				rightHandSideRequired
		);
	}


, Instance #
frags: 
(startLine=331 endLine=344 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=346 endLine=359 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=361 endLine=374 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=408 endLine=421 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=423 endLine=436 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

commonMethod: 
(startLine=496 endLine=504 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseBasic(Basic basic) {
		XmlMetaSingleAttribute attribute;
		ElementKind elementKind = getElementKind( basic.getAccess() );
		String type = getType( basic.getName(), null, elementKind );
		if ( type != null ) {
			attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
			members.add( attribute );
		}
	}


, Instance #
frags: 
(startLine=331 endLine=344 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=346 endLine=359 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=361 endLine=374 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=408 endLine=421 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=423 endLine=436 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

commonMethod: 
(startLine=486 endLine=494 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseManyToOne(ManyToOne manyToOne) {
		XmlMetaSingleAttribute attribute;
		ElementKind elementKind = getElementKind( manyToOne.getAccess() );
		String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
		if ( type != null ) {
			attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
			members.add( attribute );
		}
	}


, Instance #
frags: 
(startLine=408 endLine=421 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=423 endLine=436 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

commonMethod: 
(startLine=186 endLine=207 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private String[] getCollectionTypes(String propertyName, String explicitTargetEntity, String explicitMapKeyClass, ElementKind expectedElementKind) {
		String types[] = new String[3];
		for ( Element elem : element.getEnclosedElements() ) {
			if ( expectedElementKind.equals( elem.getKind() ) ) {
				continue;
			}

			if ( !elem.getSimpleName().toString().equals( propertyName ) ) {
				continue;
			}

			DeclaredType type = ( ( DeclaredType ) elem.asType() );
			determineTargetType( type, propertyName, explicitTargetEntity, types );
			determineCollectionType( type, types );
			if ( types[1].equals( "javax.persistence.metamodel.MapAttribute" ) ) {
				determineMapType( type, explicitMapKeyClass, types );
			}
			return types;

		}
		return null;
	}


, Instance #
frags: 
(startLine=331 endLine=344 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=346 endLine=359 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=361 endLine=374 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=408 endLine=421 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=423 endLine=436 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

commonMethod: 
(startLine=476 endLine=484 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseOneToOne(OneToOne oneToOne) {
		XmlMetaSingleAttribute attribute;
		ElementKind elementKind = getElementKind( oneToOne.getAccess() );
		String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
		if ( type != null ) {
			attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
			members.add( attribute );
		}
	}


, Instance #
frags: 
(startLine=438 endLine=451 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=331 endLine=344 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=346 endLine=359 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=361 endLine=374 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=408 endLine=421 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=423 endLine=436 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

commonMethod: 
(startLine=496 endLine=504 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseBasic(Basic basic) {
		XmlMetaSingleAttribute attribute;
		ElementKind elementKind = getElementKind( basic.getAccess() );
		String type = getType( basic.getName(), null, elementKind );
		if ( type != null ) {
			attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
			members.add( attribute );
		}
	}


, Instance #
frags: 
(startLine=438 endLine=451 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=331 endLine=344 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=346 endLine=359 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=361 endLine=374 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=408 endLine=421 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=423 endLine=436 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

commonMethod: 
(startLine=486 endLine=494 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseManyToOne(ManyToOne manyToOne) {
		XmlMetaSingleAttribute attribute;
		ElementKind elementKind = getElementKind( manyToOne.getAccess() );
		String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
		if ( type != null ) {
			attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
			members.add( attribute );
		}
	}


, Instance #
frags: 
(startLine=438 endLine=451 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=408 endLine=421 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=423 endLine=436 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

commonMethod: 
(startLine=186 endLine=207 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private String[] getCollectionTypes(String propertyName, String explicitTargetEntity, String explicitMapKeyClass, ElementKind expectedElementKind) {
		String types[] = new String[3];
		for ( Element elem : element.getEnclosedElements() ) {
			if ( expectedElementKind.equals( elem.getKind() ) ) {
				continue;
			}

			if ( !elem.getSimpleName().toString().equals( propertyName ) ) {
				continue;
			}

			DeclaredType type = ( ( DeclaredType ) elem.asType() );
			determineTargetType( type, propertyName, explicitTargetEntity, types );
			determineCollectionType( type, types );
			if ( types[1].equals( "javax.persistence.metamodel.MapAttribute" ) ) {
				determineMapType( type, explicitMapKeyClass, types );
			}
			return types;

		}
		return null;
	}


, Instance #
frags: 
(startLine=438 endLine=451 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=331 endLine=344 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=346 endLine=359 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=361 endLine=374 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=408 endLine=421 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

(startLine=423 endLine=436 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

commonMethod: 
(startLine=476 endLine=484 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseOneToOne(OneToOne oneToOne) {
		XmlMetaSingleAttribute attribute;
		ElementKind elementKind = getElementKind( oneToOne.getAccess() );
		String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
		if ( type != null ) {
			attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
			members.add( attribute );
		}
	}


, Instance #
frags: 
(startLine=291 endLine=375 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseAttributes(Attributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Id id : attributes.getId() ) {
			ElementKind elementKind = getElementKind( id.getAccess() );
			String type = getType( id.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, id.getName(), type );
				members.add( attribute );
			}
		}

		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

(startLine=377 endLine=452 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseEmbeddableAttributes(EmbeddableAttributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

commonMethod: 
(startLine=496 endLine=504 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseBasic(Basic basic) {
		XmlMetaSingleAttribute attribute;
		ElementKind elementKind = getElementKind( basic.getAccess() );
		String type = getType( basic.getName(), null, elementKind );
		if ( type != null ) {
			attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
			members.add( attribute );
		}
	}


, Instance #
frags: 
(startLine=291 endLine=375 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseAttributes(Attributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Id id : attributes.getId() ) {
			ElementKind elementKind = getElementKind( id.getAccess() );
			String type = getType( id.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, id.getName(), type );
				members.add( attribute );
			}
		}

		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

(startLine=377 endLine=452 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseEmbeddableAttributes(EmbeddableAttributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

commonMethod: 
(startLine=486 endLine=494 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseManyToOne(ManyToOne manyToOne) {
		XmlMetaSingleAttribute attribute;
		ElementKind elementKind = getElementKind( manyToOne.getAccess() );
		String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
		if ( type != null ) {
			attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
			members.add( attribute );
		}
	}


, Instance #
frags: 
(startLine=291 endLine=375 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseAttributes(Attributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Id id : attributes.getId() ) {
			ElementKind elementKind = getElementKind( id.getAccess() );
			String type = getType( id.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, id.getName(), type );
				members.add( attribute );
			}
		}

		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

(startLine=377 endLine=452 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseEmbeddableAttributes(EmbeddableAttributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

commonMethod: 
(startLine=388 endLine=416 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private boolean parseElementCollection(ElementCollection collection) {
		String[] types;
		XmlMetaCollection metaCollection;
		ElementKind elementKind = getElementKind( collection.getAccess() );
		MapKeyClass mapKeyClass = collection.getMapKeyClass();
		String explicitMapKey = null;
		if ( mapKeyClass != null ) {
			explicitMapKey = mapKeyClass.getClazz();
		}
		try {
			types = getCollectionTypes(
					collection.getName(), collection.getTargetClass(), explicitMapKey, elementKind
			);
		}
		catch ( MetaModelGenerationException e ) {
			logMetaModelException( collection.getName(), e );
			return true;
		}
		if ( types != null ) {
			if ( types[2] == null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
			}
			else {
				metaCollection = new XmlMetaMap( this, collection.getName(), types[0], types[1], types[2] );
			}
			members.add( metaCollection );
		}
		return false;
	}


, Instance #
frags: 
(startLine=291 endLine=375 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseAttributes(Attributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Id id : attributes.getId() ) {
			ElementKind elementKind = getElementKind( id.getAccess() );
			String type = getType( id.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, id.getName(), type );
				members.add( attribute );
			}
		}

		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

(startLine=377 endLine=452 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseEmbeddableAttributes(EmbeddableAttributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

commonMethod: 
(startLine=476 endLine=484 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseOneToOne(OneToOne oneToOne) {
		XmlMetaSingleAttribute attribute;
		ElementKind elementKind = getElementKind( oneToOne.getAccess() );
		String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
		if ( type != null ) {
			attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
			members.add( attribute );
		}
	}


, Instance #
frags: 
(startLine=291 endLine=375 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseAttributes(Attributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Id id : attributes.getId() ) {
			ElementKind elementKind = getElementKind( id.getAccess() );
			String type = getType( id.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, id.getName(), type );
				members.add( attribute );
			}
		}

		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

(startLine=377 endLine=452 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseEmbeddableAttributes(EmbeddableAttributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

commonMethod: 
(startLine=418 endLine=444 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private boolean parseOneToMany(OneToMany oneToMany) {
		String[] types;
		XmlMetaCollection metaCollection;
		ElementKind elementKind = getElementKind( oneToMany.getAccess() );
		MapKeyClass mapKeyClass = oneToMany.getMapKeyClass();
		String explicitMapKey = null;
		if ( mapKeyClass != null ) {
			explicitMapKey = mapKeyClass.getClazz();
		}
		try {
			types = getCollectionTypes( oneToMany.getName(), oneToMany.getTargetEntity(), explicitMapKey, elementKind );
		}
		catch ( MetaModelGenerationException e ) {
			logMetaModelException( oneToMany.getName(), e );
			return true;
		}
		if ( types != null ) {
			if ( types[2] == null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
			}
			else {
				metaCollection = new XmlMetaMap( this, oneToMany.getName(), types[0], types[1], types[2] );
			}
			members.add( metaCollection );
		}
		return false;
	}


, Instance #
frags: 
(startLine=291 endLine=375 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseAttributes(Attributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Id id : attributes.getId() ) {
			ElementKind elementKind = getElementKind( id.getAccess() );
			String type = getType( id.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, id.getName(), type );
				members.add( attribute );
			}
		}

		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

(startLine=377 endLine=452 srcPath=/root/NewExperiment/hibernateFilter/01137/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private void parseEmbeddableAttributes(EmbeddableAttributes attributes) {
		XmlMetaSingleAttribute attribute;
		for ( Basic basic : attributes.getBasic() ) {
			ElementKind elementKind = getElementKind( basic.getAccess() );
			String type = getType( basic.getName(), null, elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, basic.getName(), type );
				members.add( attribute );
			}
		}

		for ( ManyToOne manyToOne : attributes.getManyToOne() ) {
			ElementKind elementKind = getElementKind( manyToOne.getAccess() );
			String type = getType( manyToOne.getName(), manyToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, manyToOne.getName(), type );
				members.add( attribute );
			}
		}

		for ( OneToOne oneToOne : attributes.getOneToOne() ) {
			ElementKind elementKind = getElementKind( oneToOne.getAccess() );
			String type = getType( oneToOne.getName(), oneToOne.getTargetEntity(), elementKind );
			if ( type != null ) {
				attribute = new XmlMetaSingleAttribute( this, oneToOne.getName(), type );
				members.add( attribute );
			}
		}

		XmlMetaCollection metaCollection;
		String[] types;
		for ( ManyToMany manyToMany : attributes.getManyToMany() ) {
			ElementKind elementKind = getElementKind( manyToMany.getAccess() );
			try {
				types = getCollectionType( manyToMany.getName(), manyToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( manyToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( OneToMany oneToMany : attributes.getOneToMany() ) {
			ElementKind elementKind = getElementKind( oneToMany.getAccess() );
			try {
				types = getCollectionType( oneToMany.getName(), oneToMany.getTargetEntity(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( oneToMany.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}

		for ( ElementCollection collection : attributes.getElementCollection() ) {
			ElementKind elementKind = getElementKind( collection.getAccess() );
			try {
				types = getCollectionType( collection.getName(), collection.getTargetClass(), elementKind );
			}
			catch ( MetaModelGenerationException e ) {
				logMetaModelException( collection.getName(), e );
				break;
			}
			if ( types != null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
				members.add( metaCollection );
			}
		}
	}

commonMethod: 
(startLine=446 endLine=474 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private boolean parseManyToMany(ManyToMany manyToMany) {
		String[] types;
		XmlMetaCollection metaCollection;
		ElementKind elementKind = getElementKind( manyToMany.getAccess() );
		MapKeyClass mapKeyClass = manyToMany.getMapKeyClass();
		String explicitMapKey = null;
		if ( mapKeyClass != null ) {
			explicitMapKey = mapKeyClass.getClazz();
		}
		try {
			types = getCollectionTypes(
					manyToMany.getName(), manyToMany.getTargetEntity(), explicitMapKey, elementKind
			);
		}
		catch ( MetaModelGenerationException e ) {
			logMetaModelException( manyToMany.getName(), e );
			return true;
		}
		if ( types != null ) {
			if ( types[2] == null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
			}
			else {
				metaCollection = new XmlMetaMap( this, manyToMany.getName(), types[0], types[1], types[2] );
			}
			members.add( metaCollection );
		}
		return false;
	}


, Instance #
frags: 
(startLine=388 endLine=416 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private boolean parseElementCollection(ElementCollection collection) {
		String[] types;
		XmlMetaCollection metaCollection;
		ElementKind elementKind = getElementKind( collection.getAccess() );
		MapKeyClass mapKeyClass = collection.getMapKeyClass();
		String explicitMapKey = null;
		if ( mapKeyClass != null ) {
			explicitMapKey = mapKeyClass.getClazz();
		}
		try {
			types = getCollectionTypes(
					collection.getName(), collection.getTargetClass(), explicitMapKey, elementKind
			);
		}
		catch ( MetaModelGenerationException e ) {
			logMetaModelException( collection.getName(), e );
			return true;
		}
		if ( types != null ) {
			if ( types[2] == null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
			}
			else {
				metaCollection = new XmlMetaMap( this, collection.getName(), types[0], types[1], types[2] );
			}
			members.add( metaCollection );
		}
		return false;
	}

(startLine=418 endLine=444 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private boolean parseOneToMany(OneToMany oneToMany) {
		String[] types;
		XmlMetaCollection metaCollection;
		ElementKind elementKind = getElementKind( oneToMany.getAccess() );
		MapKeyClass mapKeyClass = oneToMany.getMapKeyClass();
		String explicitMapKey = null;
		if ( mapKeyClass != null ) {
			explicitMapKey = mapKeyClass.getClazz();
		}
		try {
			types = getCollectionTypes( oneToMany.getName(), oneToMany.getTargetEntity(), explicitMapKey, elementKind );
		}
		catch ( MetaModelGenerationException e ) {
			logMetaModelException( oneToMany.getName(), e );
			return true;
		}
		if ( types != null ) {
			if ( types[2] == null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
			}
			else {
				metaCollection = new XmlMetaMap( this, oneToMany.getName(), types[0], types[1], types[2] );
			}
			members.add( metaCollection );
		}
		return false;
	}

(startLine=446 endLine=474 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private boolean parseManyToMany(ManyToMany manyToMany) {
		String[] types;
		XmlMetaCollection metaCollection;
		ElementKind elementKind = getElementKind( manyToMany.getAccess() );
		MapKeyClass mapKeyClass = manyToMany.getMapKeyClass();
		String explicitMapKey = null;
		if ( mapKeyClass != null ) {
			explicitMapKey = mapKeyClass.getClazz();
		}
		try {
			types = getCollectionTypes(
					manyToMany.getName(), manyToMany.getTargetEntity(), explicitMapKey, elementKind
			);
		}
		catch ( MetaModelGenerationException e ) {
			logMetaModelException( manyToMany.getName(), e );
			return true;
		}
		if ( types != null ) {
			if ( types[2] == null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
			}
			else {
				metaCollection = new XmlMetaMap( this, manyToMany.getName(), types[0], types[1], types[2] );
			}
			members.add( metaCollection );
		}
		return false;
	}

commonMethod: 
(startLine=434 endLine=440 srcPath=/root/NewExperiment/hibernateFilter/01139/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private String determineExplicitMapKeyClass(MapKeyClass mapKeyClass) {
		String explicitMapKey = null;
		if ( mapKeyClass != null ) {
			explicitMapKey = StringUtil.determineFullyQualifiedClassName( defaultPackageName, mapKeyClass.getClazz() );
		}
		return explicitMapKey;
	}


, Instance #
frags: 
(startLine=388 endLine=416 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private boolean parseElementCollection(ElementCollection collection) {
		String[] types;
		XmlMetaCollection metaCollection;
		ElementKind elementKind = getElementKind( collection.getAccess() );
		MapKeyClass mapKeyClass = collection.getMapKeyClass();
		String explicitMapKey = null;
		if ( mapKeyClass != null ) {
			explicitMapKey = mapKeyClass.getClazz();
		}
		try {
			types = getCollectionTypes(
					collection.getName(), collection.getTargetClass(), explicitMapKey, elementKind
			);
		}
		catch ( MetaModelGenerationException e ) {
			logMetaModelException( collection.getName(), e );
			return true;
		}
		if ( types != null ) {
			if ( types[2] == null ) {
				metaCollection = new XmlMetaCollection( this, collection.getName(), types[0], types[1] );
			}
			else {
				metaCollection = new XmlMetaMap( this, collection.getName(), types[0], types[1], types[2] );
			}
			members.add( metaCollection );
		}
		return false;
	}

(startLine=418 endLine=444 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private boolean parseOneToMany(OneToMany oneToMany) {
		String[] types;
		XmlMetaCollection metaCollection;
		ElementKind elementKind = getElementKind( oneToMany.getAccess() );
		MapKeyClass mapKeyClass = oneToMany.getMapKeyClass();
		String explicitMapKey = null;
		if ( mapKeyClass != null ) {
			explicitMapKey = mapKeyClass.getClazz();
		}
		try {
			types = getCollectionTypes( oneToMany.getName(), oneToMany.getTargetEntity(), explicitMapKey, elementKind );
		}
		catch ( MetaModelGenerationException e ) {
			logMetaModelException( oneToMany.getName(), e );
			return true;
		}
		if ( types != null ) {
			if ( types[2] == null ) {
				metaCollection = new XmlMetaCollection( this, oneToMany.getName(), types[0], types[1] );
			}
			else {
				metaCollection = new XmlMetaMap( this, oneToMany.getName(), types[0], types[1], types[2] );
			}
			members.add( metaCollection );
		}
		return false;
	}

(startLine=446 endLine=474 srcPath=/root/NewExperiment/hibernateFilter/01138/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private boolean parseManyToMany(ManyToMany manyToMany) {
		String[] types;
		XmlMetaCollection metaCollection;
		ElementKind elementKind = getElementKind( manyToMany.getAccess() );
		MapKeyClass mapKeyClass = manyToMany.getMapKeyClass();
		String explicitMapKey = null;
		if ( mapKeyClass != null ) {
			explicitMapKey = mapKeyClass.getClazz();
		}
		try {
			types = getCollectionTypes(
					manyToMany.getName(), manyToMany.getTargetEntity(), explicitMapKey, elementKind
			);
		}
		catch ( MetaModelGenerationException e ) {
			logMetaModelException( manyToMany.getName(), e );
			return true;
		}
		if ( types != null ) {
			if ( types[2] == null ) {
				metaCollection = new XmlMetaCollection( this, manyToMany.getName(), types[0], types[1] );
			}
			else {
				metaCollection = new XmlMetaMap( this, manyToMany.getName(), types[0], types[1], types[2] );
			}
			members.add( metaCollection );
		}
		return false;
	}

commonMethod: 
(startLine=424 endLine=432 srcPath=/root/NewExperiment/hibernateFilter/01139/tooling/metamodel-generator/src/main/java/org/hibernate/jpamodelgen/xml/XmlMetaEntity.java)
	private String determineExplicitTargetEntity(String targetClass) {
		String explicitTargetClass = targetClass;
		if ( explicitTargetClass != null ) {
			explicitTargetClass = StringUtil.determineFullyQualifiedClassName(
					defaultPackageName, targetClass
			);
		}
		return explicitTargetClass;
	}


, Instance #
frags: 
(startLine=89 endLine=105 srcPath=/root/NewExperiment/hibernateFilter/01163/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/spaces/QuerySpacesImpl.java)
	public ExpandingEntityQuerySpace makeEntityQuerySpace(String uid, EntityPersister entityPersister) {
		if ( querySpaceByUid.containsKey( uid ) ) {
			throw new IllegalStateException( "Encountered duplicate QuerySpace uid : " + uid );
		}

		final EntityQuerySpaceImpl space = new EntityQuerySpaceImpl(
				entityPersister,
				uid,
				this,
				true,
				sessionFactory
		);
		registerQuerySpace( space );
		roots.add( space );

		return space;
	}

(startLine=108 endLine=124 srcPath=/root/NewExperiment/hibernateFilter/01163/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/spaces/QuerySpacesImpl.java)
	public CollectionQuerySpace makeCollectionQuerySpace(String uid, CollectionPersister collectionPersister) {
		if ( querySpaceByUid.containsKey( uid ) ) {
			throw new IllegalStateException( "Encountered duplicate QuerySpace uid : " + uid );
		}

		final CollectionQuerySpaceImpl space = new CollectionQuerySpaceImpl(
				collectionPersister,
				uid,
				this,
				true,
				sessionFactory
		);
		registerQuerySpace( space );
		roots.add( space );

		return space;
	}

commonMethod: 
(startLine=163 endLine=167 srcPath=/root/NewExperiment/hibernateFilter/01164/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/spaces/QuerySpacesImpl.java)
	private void checkQuerySpaceDoesNotExist(String uid) {
		if ( querySpaceByUid.containsKey( uid ) ) {
			throw new IllegalStateException( "Encountered duplicate QuerySpace uid : " + uid );
		}
	}


, Instance #
frags: 
(startLine=68 endLine=93 srcPath=/root/NewExperiment/hibernateFilter/01163/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/spaces/CollectionQuerySpaceImpl.java)
	public JoinDefinedByMetadata addIndexEntityJoin(final EntityPersister indexPersister) {
		final boolean required = canJoinsBeRequired();
		final String entityQuerySpaceUid = getQuerySpaces().generateImplicitUid();
		final EntityQuerySpaceImpl entityQuerySpace = new EntityQuerySpaceImpl(
				indexPersister,
				entityQuerySpaceUid,
				getQuerySpaces(),
				required,
				sessionFactory()
		);
		getQuerySpaces().registerQuerySpace( entityQuerySpace );

		final JoinDefinedByMetadata join = JoinHelper.INSTANCE.createEntityJoin(
				this,
				// collection persister maps its index (through its PropertyMapping contract) as non-prefixed
				CollectionPropertyNames.COLLECTION_INDICES,
				entityQuerySpace,
				canJoinsBeRequired(),
				(EntityType) persister.getIndexType(),
				sessionFactory()
		);

		internalGetJoins().add( join );

		return join;
	}

(startLine=122 endLine=145 srcPath=/root/NewExperiment/hibernateFilter/01163/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/spaces/CollectionQuerySpaceImpl.java)
	public JoinDefinedByMetadata addElementEntityJoin(final EntityPersister elementPersister) {
		final String entityQuerySpaceUid = getQuerySpaces().generateImplicitUid();
		final EntityQuerySpaceImpl entityQuerySpace = new EntityQuerySpaceImpl(
				elementPersister,
				entityQuerySpaceUid,
				getQuerySpaces(),
				canJoinsBeRequired(),
				sessionFactory()
		);
		getQuerySpaces().registerQuerySpace( entityQuerySpace );

		final JoinDefinedByMetadata join = JoinHelper.INSTANCE.createEntityJoin(
				this,
				// collection persister maps its elements (through its PropertyMapping contract) as non-prefixed
				CollectionPropertyNames.COLLECTION_ELEMENTS,
				entityQuerySpace,
				canJoinsBeRequired(),
				(EntityType) persister.getElementType(),
				sessionFactory()
		);
		internalGetJoins().add( join );

		return join;
	}

commonMethod: 
(startLine=88 endLine=90 srcPath=/root/NewExperiment/hibernateFilter/01164/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/spaces/AbstractQuerySpace.java)
	protected ExpandingQuerySpaces getExpandingQuerySpaces() {
		return querySpaces;
	}


, Instance #
frags: 
(startLine=59 endLine=84 srcPath=/root/NewExperiment/hibernateFilter/01164/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/returns/AbstractCollectionReference.java)
	private CollectionFetchableIndex buildIndexGraph(ExpandingCollectionQuerySpace collectionQuerySpace) {
		final CollectionPersister persister = collectionQuerySpace.getCollectionPersister();
		if ( persister.hasIndex() ) {
			final Type type = persister.getIndexType();
			if ( type.isAssociationType() ) {
				if ( type.isEntityType() ) {
					final EntityPersister indexPersister = persister.getFactory().getEntityPersister(
							( (EntityType) type ).getAssociatedEntityName()
					);

					final ExpandingEntityQuerySpace entityQuerySpace = collectionQuerySpace.addIndexEntityQuerySpace(
							indexPersister
					);
					return new CollectionFetchableIndexEntityGraph( this, entityQuerySpace );
				}
			}
			else if ( type.isComponentType() ) {
				final ExpandingCompositeQuerySpace compositeQuerySpace = collectionQuerySpace.addIndexCompositeQuerySpace(
						(CompositeType) type
				);
				return new CollectionFetchableIndexCompositeGraph( this, compositeQuerySpace );
			}
		}

		return null;
	}

(startLine=87 endLine=110 srcPath=/root/NewExperiment/hibernateFilter/01164/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/returns/AbstractCollectionReference.java)
			ExpandingCollectionQuerySpace collectionQuerySpace) {
		final CollectionPersister persister = collectionQuerySpace.getCollectionPersister();
		final Type type = persister.getElementType();
		if ( type.isAssociationType() ) {
			if ( type.isEntityType() ) {
				final EntityPersister elementPersister = persister.getFactory().getEntityPersister(
						( (EntityType) type ).getAssociatedEntityName()
				);

				final ExpandingEntityQuerySpace entityQuerySpace = collectionQuerySpace.addElementEntityQuerySpace(
						elementPersister
				);
				return new CollectionFetchableElementEntityGraph( this, entityQuerySpace );
			}
		}
		else if ( type.isComponentType() ) {
			final ExpandingCompositeQuerySpace compositeQuerySpace = collectionQuerySpace.addElementCompositeQuerySpace(
					(CompositeType) type
			);
			return new CollectionFetchableElementCompositeGraph( this, compositeQuerySpace );
		}

		return null;
	}

commonMethod: 
(startLine=88 endLine=116 srcPath=/root/NewExperiment/hibernateFilter/01165/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/spaces/QuerySpaceHelper.java)
	public ExpandingEntityQuerySpace makeEntityQuerySpace(
			ExpandingQuerySpace lhsQuerySpace,
			EntityPersister fetchedPersister,
			String attributeName,
			EntityType attributeType,
			String querySpaceUid,
			boolean required,
			boolean shouldIncludeJoin) {

		final ExpandingEntityQuerySpace rhs = lhsQuerySpace.getExpandingQuerySpaces().makeEntityQuerySpace(
				querySpaceUid,
				fetchedPersister,
				required
		);

		if ( shouldIncludeJoin ) {
			final JoinDefinedByMetadata join = JoinHelper.INSTANCE.createEntityJoin(
					lhsQuerySpace,
					attributeName,
					rhs,
					required,
					attributeType,
					fetchedPersister.getFactory()
			);
			lhsQuerySpace.addJoin( join );
		}

		return rhs;
	}


, Instance #
frags: 
(startLine=59 endLine=84 srcPath=/root/NewExperiment/hibernateFilter/01164/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/returns/AbstractCollectionReference.java)
	private CollectionFetchableIndex buildIndexGraph(ExpandingCollectionQuerySpace collectionQuerySpace) {
		final CollectionPersister persister = collectionQuerySpace.getCollectionPersister();
		if ( persister.hasIndex() ) {
			final Type type = persister.getIndexType();
			if ( type.isAssociationType() ) {
				if ( type.isEntityType() ) {
					final EntityPersister indexPersister = persister.getFactory().getEntityPersister(
							( (EntityType) type ).getAssociatedEntityName()
					);

					final ExpandingEntityQuerySpace entityQuerySpace = collectionQuerySpace.addIndexEntityQuerySpace(
							indexPersister
					);
					return new CollectionFetchableIndexEntityGraph( this, entityQuerySpace );
				}
			}
			else if ( type.isComponentType() ) {
				final ExpandingCompositeQuerySpace compositeQuerySpace = collectionQuerySpace.addIndexCompositeQuerySpace(
						(CompositeType) type
				);
				return new CollectionFetchableIndexCompositeGraph( this, compositeQuerySpace );
			}
		}

		return null;
	}

(startLine=87 endLine=110 srcPath=/root/NewExperiment/hibernateFilter/01164/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/returns/AbstractCollectionReference.java)
			ExpandingCollectionQuerySpace collectionQuerySpace) {
		final CollectionPersister persister = collectionQuerySpace.getCollectionPersister();
		final Type type = persister.getElementType();
		if ( type.isAssociationType() ) {
			if ( type.isEntityType() ) {
				final EntityPersister elementPersister = persister.getFactory().getEntityPersister(
						( (EntityType) type ).getAssociatedEntityName()
				);

				final ExpandingEntityQuerySpace entityQuerySpace = collectionQuerySpace.addElementEntityQuerySpace(
						elementPersister
				);
				return new CollectionFetchableElementEntityGraph( this, entityQuerySpace );
			}
		}
		else if ( type.isComponentType() ) {
			final ExpandingCompositeQuerySpace compositeQuerySpace = collectionQuerySpace.addElementCompositeQuerySpace(
					(CompositeType) type
			);
			return new CollectionFetchableElementCompositeGraph( this, compositeQuerySpace );
		}

		return null;
	}

commonMethod: 
(startLine=140 endLine=167 srcPath=/root/NewExperiment/hibernateFilter/01165/hibernate-core/src/main/java/org/hibernate/loader/plan2/build/internal/spaces/QuerySpaceHelper.java)
	public ExpandingCompositeQuerySpace makeCompositeQuerySpace(
			ExpandingQuerySpace lhsQuerySpace,
			CompositePropertyMapping compositePropertyMapping,
			String attributeName,
			CompositeType attributeType,
			String querySpaceUid,
			boolean required,
			boolean shouldIncludeJoin) {

		final ExpandingCompositeQuerySpace rhs = lhsQuerySpace.getExpandingQuerySpaces().makeCompositeQuerySpace(
				querySpaceUid,
				compositePropertyMapping,
				required
		);

		if ( shouldIncludeJoin ) {
			final JoinDefinedByMetadata join = JoinHelper.INSTANCE.createCompositeJoin(
					lhsQuerySpace,
					attributeName,
					rhs,
					required,
					attributeType
			);
			lhsQuerySpace.addJoin( join );
		}

		return rhs;
	}


, Instance #
frags: 
(startLine=130 endLine=144 srcPath=/root/NewExperiment/hibernateFilter/01168/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultInitializeCollectionEventListener.java)
		try {
			source.getEventListenerManager().cacheGetStart();
			ce = persister.getCacheAccessStrategy().get(ck, source.getTimestamp());

			if ( factory.getStatistics().isStatisticsEnabled() ) {
				if (ce == null) {
					factory.getStatisticsImplementor()
							.secondLevelCacheMiss( persister.getCacheAccessStrategy().getRegion().getName() );
				}
				else {
					factory.getStatisticsImplementor()
							.secondLevelCacheHit( persister.getCacheAccessStrategy().getRegion().getName() );
				}
			}
		}

(startLine=551 endLine=567 srcPath=/root/NewExperiment/hibernateFilter/01168/hibernate-core/src/main/java/org/hibernate/event/internal/DefaultLoadEventListener.java)
		try {
			source.getEventListenerManager().cacheGetStart();
			ce = persister.getCacheAccessStrategy().get( ck, source.getTimestamp() );

			if ( factory.getStatistics().isStatisticsEnabled() ) {
				if ( ce == null ) {
					factory.getStatisticsImplementor().secondLevelCacheMiss(
							persister.getCacheAccessStrategy().getRegion().getName()
					);
				}
				else {
					factory.getStatisticsImplementor().secondLevelCacheHit(
							persister.getCacheAccessStrategy().getRegion().getName()
					);
				}
			}
		}

commonMethod: 
(startLine=61 endLine=66 srcPath=/root/NewExperiment/hibernateFilter/01169/hibernate-core/src/main/java/org/hibernate/engine/internal/CacheHelper.java)
	public static Serializable fromSharedCache(
			SessionImplementor session,
			CacheKey cacheKey,
			RegionAccessStrategy cacheAccessStrategy) {
		return fromSharedCache( session, (Object) cacheKey, cacheAccessStrategy );
	}


, Instance #
frags: 
(startLine=186 endLine=201 srcPath=/root/NewExperiment/hibernateFilter/01201/hibernate-core/src/main/java/org/hibernate/type/ComponentType.java)
			throws HibernateException {
		if ( x == y ) {
			return true;
		}
		if ( x == null || y == null ) {
			return false;
		}
		Object[] xvalues = getPropertyValues( x, entityMode );
		Object[] yvalues = getPropertyValues( y, entityMode );
		for ( int i = 0; i < propertySpan; i++ ) {
			if ( !propertyTypes[i].isEqual( xvalues[i], yvalues[i] ) ) {
				return false;
			}
		}
		return true;
	}

(startLine=205 endLine=220 srcPath=/root/NewExperiment/hibernateFilter/01201/hibernate-core/src/main/java/org/hibernate/type/ComponentType.java)
			throws HibernateException {
		if ( x == y ) {
			return true;
		}
		if ( x == null || y == null ) {
			return false;
		}
		Object[] xvalues = getPropertyValues( x, entityMode );
		Object[] yvalues = getPropertyValues( y, entityMode );
		for ( int i = 0; i < propertySpan; i++ ) {
			if ( !propertyTypes[i].isEqual( xvalues[i], yvalues[i], factory ) ) {
				return false;
			}
		}
		return true;
	}

(startLine=272 endLine=287 srcPath=/root/NewExperiment/hibernateFilter/01201/hibernate-core/src/main/java/org/hibernate/type/ComponentType.java)
			throws HibernateException {
		if ( x == y ) {
			return false;
		}
		if ( x == null || y == null ) {
			return true;
		}
		Object[] xvalues = getPropertyValues( x, entityMode );
		Object[] yvalues = getPropertyValues( y, entityMode );
		for ( int i = 0; i < xvalues.length; i++ ) {
			if ( propertyTypes[i].isDirty( xvalues[i], yvalues[i], session ) ) {
				return true;
			}
		}
		return false;
	}

commonMethod: 
(startLine=405 endLine=416 srcPath=/root/NewExperiment/hibernateFilter/01202/hibernate-core/src/main/java/org/hibernate/type/ComponentType.java)
	public Object getPropertyValue(Object component, int i)
			throws HibernateException {
		if ( component instanceof Object[] ) {
			// A few calls to hashCode pass the property values already in an
			// Object[] (ex: QueryKey hash codes for cached queries).
			// It's easiest to just check for the condition here prior to
			// trying reflection.
			return (( Object[] ) component)[i];
		} else {
			return componentTuplizer.getPropertyValue( component, i );
		}
	}


, Instance #
frags: 
(startLine=243 endLine=254 srcPath=/root/NewExperiment/hibernateFilter/01201/hibernate-core/src/main/java/org/hibernate/type/ComponentType.java)
    public int getHashCode(Object x) {
		int result = 17;
		Object[] values = getPropertyValues( x, entityMode );
		for ( int i = 0; i < propertySpan; i++ ) {
			Object y = values[i];
			result *= 37;
			if ( y != null ) {
				result += propertyTypes[i].getHashCode( y );
			}
		}
		return result;
	}

(startLine=257 endLine=268 srcPath=/root/NewExperiment/hibernateFilter/01201/hibernate-core/src/main/java/org/hibernate/type/ComponentType.java)
    public int getHashCode(Object x, SessionFactoryImplementor factory) {
		int result = 17;
		Object[] values = getPropertyValues( x, entityMode );
		for ( int i = 0; i < propertySpan; i++ ) {
			Object y = values[i];
			result *= 37;
			if ( y != null ) {
				result += propertyTypes[i].getHashCode( y, factory );
			}
		}
		return result;
	}

commonMethod: 
(startLine=405 endLine=416 srcPath=/root/NewExperiment/hibernateFilter/01202/hibernate-core/src/main/java/org/hibernate/type/ComponentType.java)
	public Object getPropertyValue(Object component, int i)
			throws HibernateException {
		if ( component instanceof Object[] ) {
			// A few calls to hashCode pass the property values already in an
			// Object[] (ex: QueryKey hash codes for cached queries).
			// It's easiest to just check for the condition here prior to
			// trying reflection.
			return (( Object[] ) component)[i];
		} else {
			return componentTuplizer.getPropertyValue( component, i );
		}
	}


, Instance #
frags: 
(startLine=317 endLine=327 srcPath=/root/NewExperiment/hibernateFilter/01229/hibernate-entitymanager/src/main/java/org/hibernate/jpa/spi/BaseQueryImpl.java)
			else if ( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE.equals( hintName ) ) {
				final CacheRetrieveMode retrieveMode = (CacheRetrieveMode) value;

				CacheStoreMode storeMode = hints != null
						? (CacheStoreMode) hints.get( AvailableSettings.SHARED_CACHE_STORE_MODE )
						: null;
				if ( storeMode == null ) {
					storeMode = (CacheStoreMode) entityManager.getProperties().get( AvailableSettings.SHARED_CACHE_STORE_MODE );
				}
				applied = applyCacheModeHint( CacheModeHelper.interpretCacheMode( storeMode, retrieveMode ) );
			}

(startLine=328 endLine=340 srcPath=/root/NewExperiment/hibernateFilter/01229/hibernate-entitymanager/src/main/java/org/hibernate/jpa/spi/BaseQueryImpl.java)
			else if ( AvailableSettings.SHARED_CACHE_STORE_MODE.equals( hintName ) ) {
				final CacheStoreMode storeMode = (CacheStoreMode) value;

				CacheRetrieveMode retrieveMode = hints != null
						? (CacheRetrieveMode) hints.get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE )
						: null;
				if ( retrieveMode == null ) {
					retrieveMode = (CacheRetrieveMode) entityManager.getProperties().get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE );
				}
				applied = applyCacheModeHint(
						CacheModeHelper.interpretCacheMode( storeMode, retrieveMode )
				);
			}

commonMethod: 
(startLine=400 endLine=408 srcPath=/root/NewExperiment/hibernateFilter/01230/hibernate-entitymanager/src/main/java/org/hibernate/jpa/spi/BaseQueryImpl.java)
	private <T extends Enum<T>> T getHint(String key, Class<T> hintClass) {
		Object hint = hints != null ? hints.get( key ) : null;

		if ( hint == null ) {
			hint = entityManager.getProperties().get( key );
		}

		return hint != null ? Enum.valueOf( hintClass, hint.toString() ) : null;
	}


, Instance #
frags: 
(startLine=101 endLine=121 srcPath=/root/NewExperiment/hibernateFilter/01239/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/packaging/JarVisitorTest.java)
	public void testInputStreamZippedJar() throws Exception {
		File defaultPar = buildDefaultPar();
		addPackageToClasspath( defaultPar );

		ArchiveDescriptor archiveDescriptor = new JarInputStreamBasedArchiveDescriptor(
				StandardArchiveDescriptorFactory.INSTANCE,
				defaultPar.toURL(),
				""
		);

		AbstractScannerImpl.ResultCollector resultCollector = new AbstractScannerImpl.ResultCollector( new StandardScanOptions() );
		archiveDescriptor.visitArchive(
				new AbstractScannerImpl.ArchiveContextImpl(
						new PersistenceUnitDescriptorAdapter(),
						true,
						resultCollector
				)
		);

		validateResults( resultCollector, org.hibernate.jpa.test.pack.defaultpar.ApplicationServer.class, Version.class );
	}

(startLine=214 endLine=233 srcPath=/root/NewExperiment/hibernateFilter/01239/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/packaging/JarVisitorTest.java)
	public void testZippedJar() throws Exception {
		File defaultPar = buildDefaultPar();
		addPackageToClasspath( defaultPar );

		JarFileBasedArchiveDescriptor archiveDescriptor = new JarFileBasedArchiveDescriptor(
				StandardArchiveDescriptorFactory.INSTANCE,
				defaultPar.toURL(),
				""
		);
		AbstractScannerImpl.ResultCollector resultCollector = new AbstractScannerImpl.ResultCollector( new StandardScanOptions() );
		archiveDescriptor.visitArchive(
				new AbstractScannerImpl.ArchiveContextImpl(
						new PersistenceUnitDescriptorAdapter(),
						true,
						resultCollector
				)
		);

		validateResults( resultCollector, org.hibernate.jpa.test.pack.defaultpar.ApplicationServer.class, Version.class );
	}

commonMethod: 
(startLine=97 endLine=111 srcPath=/root/NewExperiment/hibernateFilter/01240/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/packaging/JarVisitorTest.java)
	private ScanResult standardScan(URL url) {
		ScanEnvironment env = new ScanEnvironmentImpl( url );
		return new StandardScanner().scan(
				env,
				new StandardScanOptions(),
				new ScanParameters() {
//					private final JandexInitManager jandexInitManager = new JandexInitManager();
					@Override
					public JandexInitializer getJandexInitializer() {
//						return jandexInitManager;
						return null;
					}
				}
		);
	}


, Instance #
frags: 
(startLine=186 endLine=203 srcPath=/root/NewExperiment/hibernateFilter/01258/hibernate-core/src/main/java/org/hibernate/loader/plan/exec/internal/AbstractLoadPlanBasedLoader.java)
			SessionImplementor session) throws SQLException {

		// Processing query filters.
		queryParameters.processFilters( sqlStatement, session );

		// Applying LIMIT clause.
		final LimitHandler limitHandler = getLimitHandler(
				queryParameters.getFilteredSQL(),
				queryParameters.getRowSelection()
		);
		String sql = limitHandler.getProcessedSql();

		// Adding locks and comments.
		sql = preprocessSQL( sql, queryParameters, getFactory().getDialect(), afterLoadActions );

		final PreparedStatement st = prepareQueryStatement( sql, queryParameters, limitHandler, scroll, session );
		return new SqlStatementWrapper( st, getResultSet( st, queryParameters.getRowSelection(), limitHandler, queryParameters.hasAutoDiscoverScalarTypes(), session ) );
	}

(startLine=1847 endLine=1864 srcPath=/root/NewExperiment/hibernateFilter/01258/hibernate-core/src/main/java/org/hibernate/loader/Loader.java)
			SessionImplementor session) throws SQLException {

		// Processing query filters.
		queryParameters.processFilters( sqlStatement, session );

		// Applying LIMIT clause.
		final LimitHandler limitHandler = getLimitHandler(
				queryParameters.getFilteredSQL(),
				queryParameters.getRowSelection()
		);
		String sql = limitHandler.getProcessedSql();

		// Adding locks and comments.
		sql = preprocessSQL( sql, queryParameters, getFactory().getDialect(), afterLoadActions );

		final PreparedStatement st = prepareQueryStatement( sql, queryParameters, limitHandler, scroll, session );
		return new SqlStatementWrapper( st, getResultSet( st, queryParameters.getRowSelection(), limitHandler, queryParameters.hasAutoDiscoverScalarTypes(), session ) );
	}

commonMethod: 
(startLine=54 endLine=62 srcPath=/root/NewExperiment/hibernateFilter/01259/hibernate-core/src/main/java/org/hibernate/dialect/pagination/LimitHandler.java)
	/**
	 * Return processed SQL query.
	 *
     * @param sql       the SQL query to process.
     * @param selection the selection criteria for rows.
     *
	 * @return Query statement with LIMIT clause applied.
	 */
	String processSql(String sql, RowSelection selection);


, Instance #
frags: 
(startLine=115 endLine=132 srcPath=/root/NewExperiment/hibernateFilter/01308/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
	public ResultSet extract(CallableStatement callableStatement) {
		// IMPL NOTE : SQL logged by caller
		try {
			final ResultSet rs;
			try {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().startStatementExecution();
				rs = dialect.getResultSet( callableStatement );
			}
			finally {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().endStatementExecution();
			}
			postExtract( rs, callableStatement );
			return rs;
		}
		catch (SQLException e) {
			throw sqlExceptionHelper.convert( e, "could not extract ResultSet" );
		}
	}

(startLine=135 endLine=152 srcPath=/root/NewExperiment/hibernateFilter/01308/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
	public ResultSet extract(Statement statement, String sql) {
		sqlStatementLogger.logStatement( sql );
		try {
			final ResultSet rs;
			try {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().startStatementExecution();
				rs = statement.executeQuery( sql );
			}
			finally {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().endStatementExecution();
			}
			postExtract( rs, statement );
			return rs;
		}
		catch (SQLException e) {
			throw sqlExceptionHelper.convert( e, "could not extract ResultSet" );
		}
	}

commonMethod: 
(startLine=101 endLine=103 srcPath=/root/NewExperiment/hibernateFilter/01309/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
	private void jdbcExecuteStatementStart() {
		jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcExecuteStatementStart();
	}


, Instance #
frags: 
(startLine=115 endLine=132 srcPath=/root/NewExperiment/hibernateFilter/01308/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
	public ResultSet extract(CallableStatement callableStatement) {
		// IMPL NOTE : SQL logged by caller
		try {
			final ResultSet rs;
			try {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().startStatementExecution();
				rs = dialect.getResultSet( callableStatement );
			}
			finally {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().endStatementExecution();
			}
			postExtract( rs, callableStatement );
			return rs;
		}
		catch (SQLException e) {
			throw sqlExceptionHelper.convert( e, "could not extract ResultSet" );
		}
	}

(startLine=135 endLine=152 srcPath=/root/NewExperiment/hibernateFilter/01308/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
	public ResultSet extract(Statement statement, String sql) {
		sqlStatementLogger.logStatement( sql );
		try {
			final ResultSet rs;
			try {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().startStatementExecution();
				rs = statement.executeQuery( sql );
			}
			finally {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().endStatementExecution();
			}
			postExtract( rs, statement );
			return rs;
		}
		catch (SQLException e) {
			throw sqlExceptionHelper.convert( e, "could not extract ResultSet" );
		}
	}

commonMethod: 
(startLine=97 endLine=99 srcPath=/root/NewExperiment/hibernateFilter/01309/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
	private void jdbcExecuteStatementEnd() {
		jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcExecuteStatementEnd();
	}


, Instance #
frags: 
(startLine=157 endLine=173 srcPath=/root/NewExperiment/hibernateFilter/01308/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
		try {
			final ResultSet rs;
			try {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().startStatementExecution();
				if ( !statement.execute() ) {
					while ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {
						// do nothing until we hit the resultset
					}
				}
				rs = statement.getResultSet();
			}
			finally {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().endStatementExecution();
			}
			postExtract( rs, statement );
			return rs;
		}

(startLine=182 endLine=198 srcPath=/root/NewExperiment/hibernateFilter/01308/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
		try {
			final ResultSet rs;
			try {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().startStatementExecution();
				if ( !statement.execute( sql ) ) {
					while ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {
						// do nothing until we hit the resultset
					}
				}
				rs = statement.getResultSet();
			}
			finally {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().endStatementExecution();
			}
			postExtract( rs, statement );
			return rs;
		}

commonMethod: 
(startLine=101 endLine=103 srcPath=/root/NewExperiment/hibernateFilter/01309/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
	private void jdbcExecuteStatementStart() {
		jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcExecuteStatementStart();
	}


, Instance #
frags: 
(startLine=157 endLine=173 srcPath=/root/NewExperiment/hibernateFilter/01308/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
		try {
			final ResultSet rs;
			try {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().startStatementExecution();
				if ( !statement.execute() ) {
					while ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {
						// do nothing until we hit the resultset
					}
				}
				rs = statement.getResultSet();
			}
			finally {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().endStatementExecution();
			}
			postExtract( rs, statement );
			return rs;
		}

(startLine=182 endLine=198 srcPath=/root/NewExperiment/hibernateFilter/01308/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
		try {
			final ResultSet rs;
			try {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().startStatementExecution();
				if ( !statement.execute( sql ) ) {
					while ( !statement.getMoreResults() && statement.getUpdateCount() != -1 ) {
						// do nothing until we hit the resultset
					}
				}
				rs = statement.getResultSet();
			}
			finally {
				jdbcCoordinator.getTransactionCoordinator().getTransactionContext().endStatementExecution();
			}
			postExtract( rs, statement );
			return rs;
		}

commonMethod: 
(startLine=97 endLine=99 srcPath=/root/NewExperiment/hibernateFilter/01309/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/ResultSetReturnImpl.java)
	private void jdbcExecuteStatementEnd() {
		jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver().jdbcExecuteStatementEnd();
	}


, Instance #
frags: 
(startLine=291 endLine=308 srcPath=/root/NewExperiment/hibernateFilter/01409/hibernate-core/src/main/java/org/hibernate/persister/entity/JoinedSubclassEntityPersister.java)
		while ( titer.hasNext() ) {
			Table tab = (Table) titer.next();
			isConcretes.add( persistentClass.isClassOrSuperclassTable( tab ) );
			isDeferreds.add( Boolean.FALSE );
			isLazies.add( Boolean.FALSE );
			String tabname = tab.getQualifiedName(
					factory.getDialect(),
					factory.getSettings().getDefaultCatalogName(),
					factory.getSettings().getDefaultSchemaName()
			);
			subtables.add( tabname );
			String[] key = new String[idColumnSpan];
			Iterator citer = tab.getPrimaryKey().getColumnIterator();
			for ( int k = 0; k < idColumnSpan; k++ ) {
				key[k] = ( (Column) citer.next() ).getQuotedName( factory.getDialect() );
			}
			keyColumns.add( key );
		}

(startLine=312 endLine=333 srcPath=/root/NewExperiment/hibernateFilter/01409/hibernate-core/src/main/java/org/hibernate/persister/entity/JoinedSubclassEntityPersister.java)
		while ( joinIter.hasNext() ) {
			Join join = (Join) joinIter.next();

			Table tab = join.getTable();

			isConcretes.add( persistentClass.isClassOrSuperclassTable( tab ) );
			isDeferreds.add( join.isSequentialSelect() );
			isLazies.add( join.isLazy() );

			String tabname = tab.getQualifiedName(
					factory.getDialect(),
					factory.getSettings().getDefaultCatalogName(),
					factory.getSettings().getDefaultSchemaName()
			);
			subtables.add( tabname );
			String[] key = new String[idColumnSpan];
			Iterator citer = tab.getPrimaryKey().getColumnIterator();
			for ( int k = 0; k < idColumnSpan; k++ ) {
				key[k] = ( (Column) citer.next() ).getQuotedName( factory.getDialect() );
			}
			keyColumns.add( key );
		}

commonMethod: 
(startLine=5117 endLine=5126 srcPath=/root/NewExperiment/hibernateFilter/01410/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java)
	protected String determineTableName(Table table, JdbcEnvironment jdbcEnvironment) {
		if ( table.getSubselect() != null ) {
			return "( " + table.getSubselect() + " )";
		}

		return jdbcEnvironment.getQualifiedObjectNameFormatter().format(
				table.getQualifiedTableName(),
				jdbcEnvironment.getDialect()
		);
	}


, Instance #
frags: 
(startLine=348 endLine=391 srcPath=/root/NewExperiment/hibernateFilter/01415/hibernate-core/src/main/java/org/hibernate/cfg/CollectionPropertyHolder.java)
	public AttributeConverterDefinition resolveElementAttributeConverterDefinition(XClass elementXClass) {
		AttributeConversionInfo info = locateAttributeConversionInfo( "element" );
		if ( info != null ) {
			if ( info.isConversionDisabled() ) {
				return null;
			}
			else {
				try {
					return makeAttributeConverterDefinition( info );
				}
				catch (Exception e) {
					throw new IllegalStateException(
							String.format( "Unable to instantiate AttributeConverter [%s", info.getConverterClass().getName() ),
							e
					);
				}
			}
		}

		log.debugf(
				"Attempting to locate auto-apply AttributeConverter for collection element [%s]",
				collection.getRole()
		);

		final Class elementClass = determineElementClass( elementXClass );
		if ( elementClass != null ) {
			for ( AttributeConverterDefinition attributeConverterDefinition : getContext().getMetadataCollector().getAttributeConverters() ) {
				if ( ! attributeConverterDefinition.isAutoApply() ) {
					continue;
				}
				log.debugf(
						"Checking auto-apply AttributeConverter [%s] type [%s] for match [%s]",
						attributeConverterDefinition.toString(),
						attributeConverterDefinition.getEntityAttributeType().getSimpleName(),
						elementClass.getSimpleName()
				);
				if ( areTypeMatch( attributeConverterDefinition.getEntityAttributeType(), elementClass ) ) {
					return attributeConverterDefinition;
				}
			}
		}

		return null;
	}

(startLine=422 endLine=465 srcPath=/root/NewExperiment/hibernateFilter/01415/hibernate-core/src/main/java/org/hibernate/cfg/CollectionPropertyHolder.java)
	public AttributeConverterDefinition keyElementAttributeConverterDefinition(XClass keyXClass) {
		AttributeConversionInfo info = locateAttributeConversionInfo( "key" );
		if ( info != null ) {
			if ( info.isConversionDisabled() ) {
				return null;
			}
			else {
				try {
					return makeAttributeConverterDefinition( info );
				}
				catch (Exception e) {
					throw new IllegalStateException(
							String.format( "Unable to instantiate AttributeConverter [%s", info.getConverterClass().getName() ),
							e
					);
				}
			}
		}

		log.debugf(
				"Attempting to locate auto-apply AttributeConverter for collection key [%s]",
				collection.getRole()
		);

		final Class elementClass = determineKeyClass( keyXClass );
		if ( elementClass != null ) {
			for ( AttributeConverterDefinition attributeConverterDefinition : getContext().getMetadataCollector().getAttributeConverters() ) {
				if ( ! attributeConverterDefinition.isAutoApply() ) {
					continue;
				}
				log.debugf(
						"Checking auto-apply AttributeConverter [%s] type [%s] for match [%s]",
						attributeConverterDefinition.toString(),
						attributeConverterDefinition.getEntityAttributeType().getSimpleName(),
						elementClass.getSimpleName()
				);
				if ( areTypeMatch( attributeConverterDefinition.getEntityAttributeType(), elementClass ) ) {
					return attributeConverterDefinition;
				}
			}
		}

		return null;
	}

(startLine=71 endLine=109 srcPath=/root/NewExperiment/hibernateFilter/01415/hibernate-core/src/main/java/org/hibernate/cfg/AbstractPropertyHolder.java)
	public AttributeConverterDefinition resolveAttributeConverterDefinition(XProperty property) {
		AttributeConversionInfo info = locateAttributeConversionInfo( property );
		if ( info != null ) {
			if ( info.isConversionDisabled() ) {
				return null;
			}
			else {
				try {
					return makeAttributeConverterDefinition( info );
				}
				catch (Exception e) {
					throw new IllegalStateException(
							String.format( "Unable to instantiate AttributeConverter [%s", info.getConverterClass().getName() ),
							e
					);
				}
			}
		}

		log.debugf( "Attempting to locate auto-apply AttributeConverter for property [%s:%s]", path, property.getName() );

		final Class propertyType = context.getBuildingOptions().getReflectionManager().toClass( property.getType() );
		for ( AttributeConverterDefinition attributeConverterDefinition : context.getMetadataCollector().getAttributeConverters() ) {
			if ( ! attributeConverterDefinition.isAutoApply() ) {
				continue;
			}
			log.debugf(
					"Checking auto-apply AttributeConverter [%s] type [%s] for match [%s]",
					attributeConverterDefinition.toString(),
					attributeConverterDefinition.getEntityAttributeType().getSimpleName(),
					propertyType.getSimpleName()
			);
			if ( areTypeMatch( attributeConverterDefinition.getEntityAttributeType(), propertyType ) ) {
				return attributeConverterDefinition;
			}
		}

		return null;
	}

commonMethod: 
(startLine=99 endLine=107 srcPath=/root/NewExperiment/hibernateFilter/01416/hibernate-core/src/main/java/org/hibernate/cfg/AbstractPropertyHolder.java)
	protected AttributeConverterDescriptor makeAttributeConverterDescriptor(AttributeConversionInfo conversion) {
		try {
			AttributeConverterDefinition definition = new AttributeConverterDefinition( conversion.getConverterClass().newInstance(), false );
			return AttributeConverterDescriptorImpl.create( definition, context.getMetadataCollector().getClassmateContext() );
		}
		catch (Exception e) {
			throw new AnnotationException( "Unable to create AttributeConverter instance", e );
		}
	}


, Instance #
frags: 
(startLine=373 endLine=388 srcPath=/root/NewExperiment/hibernateFilter/01415/hibernate-core/src/main/java/org/hibernate/cfg/CollectionPropertyHolder.java)
		if ( elementClass != null ) {
			for ( AttributeConverterDefinition attributeConverterDefinition : getContext().getMetadataCollector().getAttributeConverters() ) {
				if ( ! attributeConverterDefinition.isAutoApply() ) {
					continue;
				}
				log.debugf(
						"Checking auto-apply AttributeConverter [%s] type [%s] for match [%s]",
						attributeConverterDefinition.toString(),
						attributeConverterDefinition.getEntityAttributeType().getSimpleName(),
						elementClass.getSimpleName()
				);
				if ( areTypeMatch( attributeConverterDefinition.getEntityAttributeType(), elementClass ) ) {
					return attributeConverterDefinition;
				}
			}
		}

(startLine=447 endLine=462 srcPath=/root/NewExperiment/hibernateFilter/01415/hibernate-core/src/main/java/org/hibernate/cfg/CollectionPropertyHolder.java)
		if ( elementClass != null ) {
			for ( AttributeConverterDefinition attributeConverterDefinition : getContext().getMetadataCollector().getAttributeConverters() ) {
				if ( ! attributeConverterDefinition.isAutoApply() ) {
					continue;
				}
				log.debugf(
						"Checking auto-apply AttributeConverter [%s] type [%s] for match [%s]",
						attributeConverterDefinition.toString(),
						attributeConverterDefinition.getEntityAttributeType().getSimpleName(),
						elementClass.getSimpleName()
				);
				if ( areTypeMatch( attributeConverterDefinition.getEntityAttributeType(), elementClass ) ) {
					return attributeConverterDefinition;
				}
			}
		}

(startLine=93 endLine=106 srcPath=/root/NewExperiment/hibernateFilter/01415/hibernate-core/src/main/java/org/hibernate/cfg/AbstractPropertyHolder.java)
		for ( AttributeConverterDefinition attributeConverterDefinition : context.getMetadataCollector().getAttributeConverters() ) {
			if ( ! attributeConverterDefinition.isAutoApply() ) {
				continue;
			}
			log.debugf(
					"Checking auto-apply AttributeConverter [%s] type [%s] for match [%s]",
					attributeConverterDefinition.toString(),
					attributeConverterDefinition.getEntityAttributeType().getSimpleName(),
					propertyType.getSimpleName()
			);
			if ( areTypeMatch( attributeConverterDefinition.getEntityAttributeType(), propertyType ) ) {
				return attributeConverterDefinition;
			}
		}

commonMethod: 
(startLine=99 endLine=107 srcPath=/root/NewExperiment/hibernateFilter/01416/hibernate-core/src/main/java/org/hibernate/cfg/AbstractPropertyHolder.java)
	protected AttributeConverterDescriptor makeAttributeConverterDescriptor(AttributeConversionInfo conversion) {
		try {
			AttributeConverterDefinition definition = new AttributeConverterDefinition( conversion.getConverterClass().newInstance(), false );
			return AttributeConverterDescriptorImpl.create( definition, context.getMetadataCollector().getClassmateContext() );
		}
		catch (Exception e) {
			throw new AnnotationException( "Unable to create AttributeConverter instance", e );
		}
	}


, Instance #
frags: 
(startLine=348 endLine=377 srcPath=/root/NewExperiment/hibernateFilter/01451/hibernate-core/src/main/java/org/hibernate/cfg/CollectionPropertyHolder.java)
	public AttributeConverterDescriptor resolveElementAttributeConverterDescriptor(XProperty collectionXProperty, XClass elementXClass) {
		AttributeConversionInfo info = locateAttributeConversionInfo( "element" );
		if ( info != null ) {
			if ( info.isConversionDisabled() ) {
				return null;
			}
			else {
				try {
					return makeAttributeConverterDescriptor( info );
				}
				catch (Exception e) {
					throw new IllegalStateException(
							String.format( "Unable to instantiate AttributeConverter [%s", info.getConverterClass().getName() ),
							e
					);
				}
			}
		}

		log.debugf(
				"Attempting to locate auto-apply AttributeConverter for collection element [%s]",
				collection.getRole()
		);

		// todo : do we need to pass along `XClass elementXClass`?

		return getContext().getMetadataCollector()
				.getAttributeConverterAutoApplyHandler()
				.findAutoApplyConverterForCollectionElement( collectionXProperty, getContext() );
	}

(startLine=408 endLine=437 srcPath=/root/NewExperiment/hibernateFilter/01451/hibernate-core/src/main/java/org/hibernate/cfg/CollectionPropertyHolder.java)
	public AttributeConverterDescriptor mapKeyAttributeConverterDescriptor(XProperty mapXProperty, XClass keyXClass) {
		AttributeConversionInfo info = locateAttributeConversionInfo( "key" );
		if ( info != null ) {
			if ( info.isConversionDisabled() ) {
				return null;
			}
			else {
				try {
					return makeAttributeConverterDescriptor( info );
				}
				catch (Exception e) {
					throw new IllegalStateException(
							String.format( "Unable to instantiate AttributeConverter [%s", info.getConverterClass().getName() ),
							e
					);
				}
			}
		}

		log.debugf(
				"Attempting to locate auto-apply AttributeConverter for collection key [%s]",
				collection.getRole()
		);

		// todo : do we need to pass along `XClass keyXClass`?

		return getContext().getMetadataCollector()
				.getAttributeConverterAutoApplyHandler()
				.findAutoApplyConverterForMapKey( mapXProperty, getContext() );
	}

(startLine=73 endLine=97 srcPath=/root/NewExperiment/hibernateFilter/01451/hibernate-core/src/main/java/org/hibernate/cfg/AbstractPropertyHolder.java)
	public AttributeConverterDescriptor resolveAttributeConverterDescriptor(XProperty property) {
		AttributeConversionInfo info = locateAttributeConversionInfo( property );
		if ( info != null ) {
			if ( info.isConversionDisabled() ) {
				return null;
			}
			else {
				try {
					return makeAttributeConverterDescriptor( info );
				}
				catch (Exception e) {
					throw new IllegalStateException(
							String.format( "Unable to instantiate AttributeConverter [%s", info.getConverterClass().getName() ),
							e
					);
				}
			}
		}

		log.debugf( "Attempting to locate auto-apply AttributeConverter for property [%s:%s]", path, property.getName() );

		return context.getMetadataCollector()
				.getAttributeConverterAutoApplyHandler()
				.findAutoApplyConverterForAttribute( property, context );
	}

commonMethod: 
(startLine=96 endLine=115 srcPath=/root/NewExperiment/hibernateFilter/01452/hibernate-core/src/main/java/org/hibernate/cfg/AbstractPropertyHolder.java)
	protected IllegalStateException buildExceptionFromInstantiationError(AttributeConversionInfo info, Exception e) {
		if ( void.class.equals( info.getConverterClass() ) ) {
			// the user forgot to set @Convert.converter
			// we already know it's not a @Convert.disableConversion
			return new IllegalStateException(
					"Unable to instantiate AttributeConverter: you left @Convert.converter to its default value void.",
					e
			);

		}
		else {
			return new IllegalStateException(
					String.format(
							"Unable to instantiate AttributeConverter [%s]",
							info.getConverterClass().getName()
					),
					e
			);
		}
	}


, Instance #
frags: 
(startLine=69 endLine=95 srcPath=/root/NewExperiment/hibernateFilter/01490/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/SchemaCreatorImpl.java)
	public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces) {
		final ArrayList<String> commands = new ArrayList<String>();
		doCreation(
				metadata,
				createNamespaces,
				new Target() {
					@Override
					public boolean acceptsImportScriptActions() {
						return true;
					}

					@Override
					public void prepare() {
					}

					@Override
					public void accept(String action) {
						commands.add( action );
					}

					@Override
					public void release() {
					}
				}
		);
		return commands;
	}

(startLine=62 endLine=90 srcPath=/root/NewExperiment/hibernateFilter/01490/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/SchemaDropperImpl.java)
			Dialect dialect) {
		final ArrayList<String> commands = new ArrayList<String>();
		doDrop(
				metadata,
				dropNamespaces,
				dialect,
				new Target() {

					@Override
					public boolean acceptsImportScriptActions() {
						return true;
					}

					@Override
					public void prepare() {
					}

					@Override
					public void accept(String action) {
						commands.add( action );
					}

					@Override
					public void release() {
					}
				}
		);
		return commands;
	}

commonMethod: 
(startLine=162 endLine=229 srcPath=/root/NewExperiment/hibernateFilter/01491/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/HibernateSchemaManagementTool.java)
	public JdbcContext resolveJdbcContext(Map configurationValues) {
		final JdbcContextBuilder jdbcContextBuilder = new JdbcContextBuilder( serviceRegistry );

		// see if a specific connection has been provided
		final Connection providedConnection = (Connection) configurationValues.get( HBM2DDL_CONNECTION );
		if ( providedConnection != null ) {
			jdbcContextBuilder.jdbcConnectionAccess = new JdbcConnectionAccessProvidedConnectionImpl( providedConnection );
		}

		// see if a specific Dialect override has been provided...
		final String explicitDbName = (String) configurationValues.get( AvailableSettings.HBM2DDL_DB_NAME );
		if ( StringHelper.isNotEmpty( explicitDbName ) ) {
			final String explicitDbMajor = (String) configurationValues.get( AvailableSettings.HBM2DDL_DB_MAJOR_VERSION );
			final String explicitDbMinor = (String) configurationValues.get( AvailableSettings.HBM2DDL_DB_MINOR_VERSION );

			final Dialect indicatedDialect = serviceRegistry.getService( DialectResolver.class ).resolveDialect(
					new DialectResolutionInfo() {
						@Override
						public String getDatabaseName() {
							return explicitDbName;
						}

						@Override
						public int getDatabaseMajorVersion() {
							return StringHelper.isEmpty( explicitDbMajor )
									? NO_VERSION
									: Integer.parseInt( explicitDbMajor );
						}

						@Override
						public int getDatabaseMinorVersion() {
							return StringHelper.isEmpty( explicitDbMinor )
									? NO_VERSION
									: Integer.parseInt( explicitDbMinor );
						}

						@Override
						public String getDriverName() {
							return null;
						}

						@Override
						public int getDriverMajorVersion() {
							return NO_VERSION;
						}

						@Override
						public int getDriverMinorVersion() {
							return NO_VERSION;
						}
					}
			);

			if ( indicatedDialect == null ) {
				log.debugf(
						"Unable to resolve indicated Dialect resolution info (%s, %s, %s)",
						explicitDbName,
						explicitDbMajor,
						explicitDbMinor
				);
			}
			else {
				jdbcContextBuilder.dialect = indicatedDialect;
			}
		}

		return jdbcContextBuilder.buildJdbcContext();
	}


, Instance #
frags: 
(startLine=69 endLine=95 srcPath=/root/NewExperiment/hibernateFilter/01490/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/SchemaCreatorImpl.java)
	public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces) {
		final ArrayList<String> commands = new ArrayList<String>();
		doCreation(
				metadata,
				createNamespaces,
				new Target() {
					@Override
					public boolean acceptsImportScriptActions() {
						return true;
					}

					@Override
					public void prepare() {
					}

					@Override
					public void accept(String action) {
						commands.add( action );
					}

					@Override
					public void release() {
					}
				}
		);
		return commands;
	}

(startLine=62 endLine=90 srcPath=/root/NewExperiment/hibernateFilter/01490/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/SchemaDropperImpl.java)
			Dialect dialect) {
		final ArrayList<String> commands = new ArrayList<String>();
		doDrop(
				metadata,
				dropNamespaces,
				dialect,
				new Target() {

					@Override
					public boolean acceptsImportScriptActions() {
						return true;
					}

					@Override
					public void prepare() {
					}

					@Override
					public void accept(String action) {
						commands.add( action );
					}

					@Override
					public void release() {
					}
				}
		);
		return commands;
	}

commonMethod: 
(startLine=94 endLine=130 srcPath=/root/NewExperiment/hibernateFilter/01491/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/HibernateSchemaManagementTool.java)
	GenerationTarget[] buildGenerationTargets(
			TargetDescriptor targetDescriptor,
			JdbcContext jdbcContext,
			Map options,
			boolean needsAutoCommit) {
		final String scriptDelimiter = ConfigurationHelper.getString( HBM2DDL_DELIMITER, options );

		final GenerationTarget[] targets = new GenerationTarget[ targetDescriptor.getTargetTypes().size() ];

		int index = 0;

		if ( targetDescriptor.getTargetTypes().contains( TargetType.STDOUT ) ) {
			targets[index] = new GenerationTargetToStdout( scriptDelimiter );
			index++;
		}

		if ( targetDescriptor.getTargetTypes().contains( TargetType.SCRIPT ) ) {
			if ( targetDescriptor.getScriptTargetOutput() == null ) {
				throw new SchemaManagementException( "Writing to script was requested, but no script file was specified" );
			}
			targets[index] = new GenerationTargetToScript( targetDescriptor.getScriptTargetOutput(), scriptDelimiter );
			index++;
		}

		if ( targetDescriptor.getTargetTypes().contains( TargetType.DATABASE ) ) {
			targets[index] = new GenerationTargetToDatabase(
					new JdbcConnectionContextNonSharedImpl(
							jdbcContext.getJdbcConnectionAccess(),
							jdbcContext.getSqlStatementLogger(),
							needsAutoCommit
					)
			);

		}

		return targets;
	}


, Instance #
frags: 
(startLine=69 endLine=95 srcPath=/root/NewExperiment/hibernateFilter/01490/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/SchemaCreatorImpl.java)
	public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces) {
		final ArrayList<String> commands = new ArrayList<String>();
		doCreation(
				metadata,
				createNamespaces,
				new Target() {
					@Override
					public boolean acceptsImportScriptActions() {
						return true;
					}

					@Override
					public void prepare() {
					}

					@Override
					public void accept(String action) {
						commands.add( action );
					}

					@Override
					public void release() {
					}
				}
		);
		return commands;
	}

(startLine=62 endLine=90 srcPath=/root/NewExperiment/hibernateFilter/01490/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/SchemaDropperImpl.java)
			Dialect dialect) {
		final ArrayList<String> commands = new ArrayList<String>();
		doDrop(
				metadata,
				dropNamespaces,
				dialect,
				new Target() {

					@Override
					public boolean acceptsImportScriptActions() {
						return true;
					}

					@Override
					public void prepare() {
					}

					@Override
					public void accept(String action) {
						commands.add( action );
					}

					@Override
					public void release() {
					}
				}
		);
		return commands;
	}

commonMethod: 
(startLine=162 endLine=229 srcPath=/root/NewExperiment/hibernateFilter/01491/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/HibernateSchemaManagementTool.java)
	public JdbcContext resolveJdbcContext(Map configurationValues) {
		final JdbcContextBuilder jdbcContextBuilder = new JdbcContextBuilder( serviceRegistry );

		// see if a specific connection has been provided
		final Connection providedConnection = (Connection) configurationValues.get( HBM2DDL_CONNECTION );
		if ( providedConnection != null ) {
			jdbcContextBuilder.jdbcConnectionAccess = new JdbcConnectionAccessProvidedConnectionImpl( providedConnection );
		}

		// see if a specific Dialect override has been provided...
		final String explicitDbName = (String) configurationValues.get( AvailableSettings.HBM2DDL_DB_NAME );
		if ( StringHelper.isNotEmpty( explicitDbName ) ) {
			final String explicitDbMajor = (String) configurationValues.get( AvailableSettings.HBM2DDL_DB_MAJOR_VERSION );
			final String explicitDbMinor = (String) configurationValues.get( AvailableSettings.HBM2DDL_DB_MINOR_VERSION );

			final Dialect indicatedDialect = serviceRegistry.getService( DialectResolver.class ).resolveDialect(
					new DialectResolutionInfo() {
						@Override
						public String getDatabaseName() {
							return explicitDbName;
						}

						@Override
						public int getDatabaseMajorVersion() {
							return StringHelper.isEmpty( explicitDbMajor )
									? NO_VERSION
									: Integer.parseInt( explicitDbMajor );
						}

						@Override
						public int getDatabaseMinorVersion() {
							return StringHelper.isEmpty( explicitDbMinor )
									? NO_VERSION
									: Integer.parseInt( explicitDbMinor );
						}

						@Override
						public String getDriverName() {
							return null;
						}

						@Override
						public int getDriverMajorVersion() {
							return NO_VERSION;
						}

						@Override
						public int getDriverMinorVersion() {
							return NO_VERSION;
						}
					}
			);

			if ( indicatedDialect == null ) {
				log.debugf(
						"Unable to resolve indicated Dialect resolution info (%s, %s, %s)",
						explicitDbName,
						explicitDbMajor,
						explicitDbMinor
				);
			}
			else {
				jdbcContextBuilder.dialect = indicatedDialect;
			}
		}

		return jdbcContextBuilder.buildJdbcContext();
	}


, Instance #
frags: 
(startLine=69 endLine=95 srcPath=/root/NewExperiment/hibernateFilter/01490/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/SchemaCreatorImpl.java)
	public List<String> generateCreationCommands(Metadata metadata, boolean createNamespaces) {
		final ArrayList<String> commands = new ArrayList<String>();
		doCreation(
				metadata,
				createNamespaces,
				new Target() {
					@Override
					public boolean acceptsImportScriptActions() {
						return true;
					}

					@Override
					public void prepare() {
					}

					@Override
					public void accept(String action) {
						commands.add( action );
					}

					@Override
					public void release() {
					}
				}
		);
		return commands;
	}

(startLine=62 endLine=90 srcPath=/root/NewExperiment/hibernateFilter/01490/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/SchemaDropperImpl.java)
			Dialect dialect) {
		final ArrayList<String> commands = new ArrayList<String>();
		doDrop(
				metadata,
				dropNamespaces,
				dialect,
				new Target() {

					@Override
					public boolean acceptsImportScriptActions() {
						return true;
					}

					@Override
					public void prepare() {
					}

					@Override
					public void accept(String action) {
						commands.add( action );
					}

					@Override
					public void release() {
					}
				}
		);
		return commands;
	}

commonMethod: 
(startLine=94 endLine=130 srcPath=/root/NewExperiment/hibernateFilter/01491/hibernate-core/src/main/java/org/hibernate/tool/schema/internal/HibernateSchemaManagementTool.java)
	GenerationTarget[] buildGenerationTargets(
			TargetDescriptor targetDescriptor,
			JdbcContext jdbcContext,
			Map options,
			boolean needsAutoCommit) {
		final String scriptDelimiter = ConfigurationHelper.getString( HBM2DDL_DELIMITER, options );

		final GenerationTarget[] targets = new GenerationTarget[ targetDescriptor.getTargetTypes().size() ];

		int index = 0;

		if ( targetDescriptor.getTargetTypes().contains( TargetType.STDOUT ) ) {
			targets[index] = new GenerationTargetToStdout( scriptDelimiter );
			index++;
		}

		if ( targetDescriptor.getTargetTypes().contains( TargetType.SCRIPT ) ) {
			if ( targetDescriptor.getScriptTargetOutput() == null ) {
				throw new SchemaManagementException( "Writing to script was requested, but no script file was specified" );
			}
			targets[index] = new GenerationTargetToScript( targetDescriptor.getScriptTargetOutput(), scriptDelimiter );
			index++;
		}

		if ( targetDescriptor.getTargetTypes().contains( TargetType.DATABASE ) ) {
			targets[index] = new GenerationTargetToDatabase(
					new JdbcConnectionContextNonSharedImpl(
							jdbcContext.getJdbcConnectionAccess(),
							jdbcContext.getSqlStatementLogger(),
							needsAutoCommit
					)
			);

		}

		return targets;
	}


, Instance #
frags: 
(startLine=59 endLine=116 srcPath=/root/NewExperiment/hibernateFilter/01514/hibernate-core/src/test/java/org/hibernate/test/optlock/OptimisticLockTest.java)
	private void testUpdateOptimisticLockFailure(String entityName) {
		Session mainSession = openSession();
		mainSession.beginTransaction();
		Document doc = new Document();
		doc.setTitle( "Hibernate in Action" );
		doc.setAuthor( "Bauer et al" );
		doc.setSummary( "Very boring book about persistence" );
		doc.setText( "blah blah yada yada yada" );
		doc.setPubDate( new PublicationDate( 2004 ) );
		mainSession.save( entityName, doc );
		mainSession.getTransaction().commit();
		mainSession.close();

		mainSession = openSession();
		mainSession.beginTransaction();
		doc = ( Document ) mainSession.get( entityName, doc.getId() );

		Session otherSession = sessionFactory().openSession();
		otherSession.beginTransaction();
		Document otherDoc = ( Document ) otherSession.get( entityName, doc.getId() );
		otherDoc.setSummary( "A modern classic" );
		otherSession.getTransaction().commit();
		otherSession.close();

		try {
			doc.setSummary( "A machiavellian achievement of epic proportions" );
			mainSession.flush();
			fail( "expecting opt lock failure" );
		}
		catch ( StaleObjectStateException expected ) {
			// expected result...
		}
		catch( StaleStateException expected ) {
			// expected result (if using versioned batching)...
		}
		catch( JDBCException e ) {
			// SQLServer will report this condition via a SQLException
			// when using its SNAPSHOT transaction isolation...
			if ( ! ( getDialect() instanceof SQLServerDialect && e.getErrorCode() == 3960 ) ) {
				throw e;
			}
			else {
				// it seems to "lose track" of the transaction as well...
				mainSession.getTransaction().rollback();
				mainSession.beginTransaction();
			}
		}
		mainSession.clear();
		mainSession.getTransaction().commit();
		mainSession.close();

		mainSession = openSession();
		mainSession.beginTransaction();
		doc = ( Document ) mainSession.load( entityName, doc.getId() );
		mainSession.delete( entityName, doc );
		mainSession.getTransaction().commit();
		mainSession.close();
	}

(startLine=118 endLine=181 srcPath=/root/NewExperiment/hibernateFilter/01514/hibernate-core/src/test/java/org/hibernate/test/optlock/OptimisticLockTest.java)
	private void testDeleteOptimisticLockFailure(String entityName) {
		Session mainSession = openSession();
		mainSession.beginTransaction();
		Document doc = new Document();
		doc.setTitle( "Hibernate in Action" );
		doc.setAuthor( "Bauer et al" );
		doc.setSummary( "Very boring book about persistence" );
		doc.setText( "blah blah yada yada yada" );
		doc.setPubDate( new PublicationDate( 2004 ) );
		mainSession.save( entityName, doc );
		mainSession.flush();
		doc.setSummary( "A modern classic" );
		mainSession.flush();
		doc.getPubDate().setMonth( Integer.valueOf( 3 ) );
		mainSession.flush();
		mainSession.getTransaction().commit();
		mainSession.close();

		mainSession = openSession();
		mainSession.beginTransaction();
		doc = ( Document ) mainSession.get( entityName, doc.getId() );

		Session otherSession = openSession();
		otherSession.beginTransaction();
		Document otherDoc = ( Document ) otherSession.get( entityName, doc.getId() );
		otherDoc.setSummary( "my other summary" );
		otherSession.flush();
		otherSession.getTransaction().commit();
		otherSession.close();

		try {
			mainSession.delete( doc );
			mainSession.flush();
			fail( "expecting opt lock failure" );
		}
		catch ( StaleObjectStateException e ) {
			// expected
		}
		catch( StaleStateException expected ) {
			// expected result (if using versioned batching)...
		}
		catch( JDBCException e ) {
			// SQLServer will report this condition via a SQLException
			// when using its SNAPSHOT transaction isolation...
			if ( ! ( getDialect() instanceof SQLServerDialect && e.getErrorCode() == 3960 ) ) {
				throw e;
			}
			else {
				// it seems to "lose track" of the transaction as well...
				mainSession.getTransaction().rollback();
				mainSession.beginTransaction();
			}
		}
		mainSession.clear();
		mainSession.getTransaction().commit();
		mainSession.close();

		mainSession = openSession();
		mainSession.beginTransaction();
		doc = ( Document ) mainSession.load( entityName, doc.getId() );
		mainSession.delete( entityName, doc );
		mainSession.getTransaction().commit();
		mainSession.close();
	}

commonMethod: 
(startLine=161 endLine=179 srcPath=/root/NewExperiment/hibernateFilter/01515/hibernate-core/src/test/java/org/hibernate/test/optlock/OptimisticLockTest.java)
	private void checkException(Session mainSession, PersistenceException e) {
		final Throwable cause = e.getCause();
		if ( cause instanceof JDBCException ) {
			// SQLServer will report this condition via a SQLException
			// when using its SNAPSHOT transaction isolation...

			if ( !(getDialect() instanceof SQLServerDialect && ((JDBCException) cause).getErrorCode() == 3960) ) {
				throw e;
			}
			else {
				// it seems to "lose track" of the transaction as well...
				mainSession.getTransaction().rollback();
				mainSession.beginTransaction();
			}
		}
		else if ( !(cause instanceof StaleObjectStateException) && !(cause instanceof StaleStateException) ) {
			fail( "expectd StaleObjectStateException or StaleStateException exception but is" + cause );
		}
	}


, Instance #
frags: 
(startLine=24 endLine=53 srcPath=/root/NewExperiment/hibernateFilter/01526/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/TransactionRollbackBehaviour.java)
	public void testAuditRecordsRollback() {
		// Given
		EntityManager em = getEntityManager();
		em.getTransaction().begin();
		IntTestEntity iteToRollback = new IntTestEntity( 30 );
		em.persist( iteToRollback );
		Integer rollbackedIteId = iteToRollback.getId();
		em.getTransaction().rollback();

		// When
		em.getTransaction().begin();
		IntTestEntity ite2 = new IntTestEntity( 50 );
		em.persist( ite2 );
		Integer ite2Id = ite2.getId();
		em.getTransaction().commit();

		// Then
		List<Number> revisionsForSavedClass = getAuditReader().getRevisions( IntTestEntity.class, ite2Id );
		Assert.assertEquals( "There should be one revision for inserted entity.", 1, revisionsForSavedClass.size() );

		List<Number> revisionsForRolledbackClass = getAuditReader().getRevisions(
				IntTestEntity.class,
				rollbackedIteId
		);
		Assert.assertEquals(
				"There should be no revision for rolled back transaction.",
				0,
				revisionsForRolledbackClass.size()
		);
	}

(startLine=57 endLine=88 srcPath=/root/NewExperiment/hibernateFilter/01526/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/TransactionRollbackBehaviour.java)
	public void testFlushedAuditRecordsRollback() {
		// Given
		EntityManager em = getEntityManager();
		em.getTransaction().begin();
		IntTestEntity iteToRollback = new IntTestEntity( 30 );
		em.persist( iteToRollback );
		em.flush();
		Integer rollbackedIteId = iteToRollback.getId();
		em.getTransaction().rollback();

		// When
		em.getTransaction().begin();
		IntTestEntity ite2 = new IntTestEntity( 50 );
		em.persist( ite2 );
		em.flush();
		Integer ite2Id = ite2.getId();
		em.getTransaction().commit();

		// Then
		List<Number> revisionsForSavedClass = getAuditReader().getRevisions( IntTestEntity.class, ite2Id );
		Assert.assertEquals( "There should be one revision for inserted entity.", 1, revisionsForSavedClass.size() );

		List<Number> revisionsForRolledbackClass = getAuditReader().getRevisions(
				IntTestEntity.class,
				rollbackedIteId
		);
		Assert.assertEquals(
				"There should be no revision for rolled back transaction.",
				0,
				revisionsForRolledbackClass.size()
		);
	}

commonMethod: 
(startLine=46 endLine=88 srcPath=/root/NewExperiment/hibernateFilter/01527/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/TransactionRollbackBehaviour.java)
	private void testAuditRecordsRollbackBehavior(boolean flush, Boolean autoClear) {
		EntityManager entityManager = getEntityManager();
		try {
			if ( autoClear != null ) {
				entityManager.unwrap( SessionImpl.class ).setAutoClear( autoClear );
			}

			// persist and rollback
			entityManager.getTransaction().begin();
			IntTestEntity rollbackEntity = new IntTestEntity( 30 );
			entityManager.persist( rollbackEntity );
			if ( flush ) {
				entityManager.flush();
			}
			Integer rollbackId = rollbackEntity.getId();
			entityManager.getTransaction().rollback();

			// persist and commit
			entityManager.getTransaction().begin();
			IntTestEntity commitEntity = new IntTestEntity( 50 );
			entityManager.persist( commitEntity );
			if ( flush ) {
				entityManager.flush();
			}
			Integer commitId = commitEntity.getId();
			entityManager.getTransaction().commit();

			List<Number> revisionsForSavedClass = getAuditReader().getRevisions(
					IntTestEntity.class,
					commitId
			);
			assertEquals( "There should be one revision for inserted entity.", 1, revisionsForSavedClass.size() );

			List<Number> revisionsForRolledbackClass = getAuditReader().getRevisions(
					IntTestEntity.class,
					rollbackId
			);
			assertEquals( "There should be no revision for rolled back entity.", 0, revisionsForRolledbackClass.size() );
		}
		finally {
			entityManager.close();
		}
	}


, Instance #
frags: 
(startLine=40 endLine=56 srcPath=/root/NewExperiment/hibernateFilter/01549/hibernate-jcache/src/main/java/org/hibernate/cache/jcache/access/ReadWriteEntityRegionAccessStrategy.java)
	public boolean afterInsert(SharedSessionContractImplementor session, Object key, Object value, Object version) throws CacheException {
		return region.invoke(
				key, new EntryProcessor<Object, Object, Boolean>() {
					@Override
					public Boolean process(MutableEntry<Object, Object> entry, Object... args)
							throws EntryProcessorException {
						if ( !entry.exists() ) {
							entry.setValue( new Item( args[0], args[1], (Long) args[2] ) );
							return true;
						}
						else {
							return false;
						}
					}
				}, value, version, region.nextTimestamp()
		);
	}

(startLine=39 endLine=55 srcPath=/root/NewExperiment/hibernateFilter/01549/hibernate-jcache/src/main/java/org/hibernate/cache/jcache/access/ReadWriteNaturalIdRegionAccessStrategy.java)
	public boolean afterInsert(SharedSessionContractImplementor session, Object key, Object value) throws CacheException {
		return region.invoke(
				key, new EntryProcessor<Object, Object, Boolean>() {
					@Override
					public Boolean process(MutableEntry<Object, Object> entry, Object... args)
							throws EntryProcessorException {
						if ( !entry.exists() ) {
							entry.setValue( new Item( args[0], null, (Long) args[1] ) );
							return true;
						}
						else {
							return false;
						}
					}
				}, value, region.nextTimestamp()
		);
	}

commonMethod: 
(startLine=71 endLine=73 srcPath=/root/NewExperiment/hibernateFilter/01550/hibernate-jcache/src/main/java/org/hibernate/cache/jcache/JCacheTransactionalDataRegion.java)
	public boolean putIfAbsent(Object key, Object value) {
		return cache.putIfAbsent( key, value );
	}


, Instance #
frags: 
(startLine=66 endLine=94 srcPath=/root/NewExperiment/hibernateFilter/01549/hibernate-jcache/src/main/java/org/hibernate/cache/jcache/access/ReadWriteEntityRegionAccessStrategy.java)
			throws CacheException {
		return region.invoke(
				key, new EntryProcessor<Object, Object, Boolean>() {
					@Override
					public Boolean process(MutableEntry<Object, Object> entry, Object... args)
							throws EntryProcessorException {
						final Lockable item = (Lockable) entry.getValue();

						if ( item != null && item.isUnlockable( (SoftLock) args[3] ) ) {
							final Lock lockItem = (Lock) item;
							if ( lockItem.wasLockedConcurrently() ) {
								lockItem.unlock( (Long) args[1] );
								entry.setValue( lockItem );
								return false;
							}
							else {
								entry.setValue( new Item( args[0], args[1], (Long) args[4] ) );
								return true;
							}
						}
						else {
							entry.setValue( null );
							return false;
						}

					}
				}, value, currentVersion, previousVersion, lock, region.nextTimestamp()
		);
	}

(startLine=65 endLine=93 srcPath=/root/NewExperiment/hibernateFilter/01549/hibernate-jcache/src/main/java/org/hibernate/cache/jcache/access/ReadWriteNaturalIdRegionAccessStrategy.java)
			throws CacheException {
		return region.invoke(
				key, new EntryProcessor<Object, Object, Boolean>() {
					@Override
					public Boolean process(MutableEntry<Object, Object> entry, Object... args)
							throws EntryProcessorException {
						final Lockable item = (Lockable) entry.getValue();

						if ( item != null && item.isUnlockable( (SoftLock) args[1] ) ) {
							final Lock lockItem = (Lock) item;
							if ( lockItem.wasLockedConcurrently() ) {
								lockItem.unlock( region.nextTimestamp() );
								entry.setValue( lockItem );
								return false;
							}
							else {
								entry.setValue( new Item( args[0], null, (Long) args[2] ) );
								return true;
							}
						}
						else {
							entry.setValue( null );
							return false;
						}

					}
				}, value, lock, region.nextTimestamp()
		);
	}

commonMethod: 
(startLine=59 endLine=61 srcPath=/root/NewExperiment/hibernateFilter/01550/hibernate-jcache/src/main/java/org/hibernate/cache/jcache/JCacheTransactionalDataRegion.java)
	public Object get(Object key) {
		return cache.get( key );
	}


, Instance #
frags: 
(startLine=66 endLine=94 srcPath=/root/NewExperiment/hibernateFilter/01549/hibernate-jcache/src/main/java/org/hibernate/cache/jcache/access/ReadWriteEntityRegionAccessStrategy.java)
			throws CacheException {
		return region.invoke(
				key, new EntryProcessor<Object, Object, Boolean>() {
					@Override
					public Boolean process(MutableEntry<Object, Object> entry, Object... args)
							throws EntryProcessorException {
						final Lockable item = (Lockable) entry.getValue();

						if ( item != null && item.isUnlockable( (SoftLock) args[3] ) ) {
							final Lock lockItem = (Lock) item;
							if ( lockItem.wasLockedConcurrently() ) {
								lockItem.unlock( (Long) args[1] );
								entry.setValue( lockItem );
								return false;
							}
							else {
								entry.setValue( new Item( args[0], args[1], (Long) args[4] ) );
								return true;
							}
						}
						else {
							entry.setValue( null );
							return false;
						}

					}
				}, value, currentVersion, previousVersion, lock, region.nextTimestamp()
		);
	}

(startLine=65 endLine=93 srcPath=/root/NewExperiment/hibernateFilter/01549/hibernate-jcache/src/main/java/org/hibernate/cache/jcache/access/ReadWriteNaturalIdRegionAccessStrategy.java)
			throws CacheException {
		return region.invoke(
				key, new EntryProcessor<Object, Object, Boolean>() {
					@Override
					public Boolean process(MutableEntry<Object, Object> entry, Object... args)
							throws EntryProcessorException {
						final Lockable item = (Lockable) entry.getValue();

						if ( item != null && item.isUnlockable( (SoftLock) args[1] ) ) {
							final Lock lockItem = (Lock) item;
							if ( lockItem.wasLockedConcurrently() ) {
								lockItem.unlock( region.nextTimestamp() );
								entry.setValue( lockItem );
								return false;
							}
							else {
								entry.setValue( new Item( args[0], null, (Long) args[2] ) );
								return true;
							}
						}
						else {
							entry.setValue( null );
							return false;
						}

					}
				}, value, lock, region.nextTimestamp()
		);
	}

commonMethod: 
(startLine=75 endLine=77 srcPath=/root/NewExperiment/hibernateFilter/01550/hibernate-jcache/src/main/java/org/hibernate/cache/jcache/JCacheTransactionalDataRegion.java)
	public boolean replace(Object key, Object expected, Object value) {
		return cache.replace( key, expected, value );
	}


, Instance #
frags: 
(startLine=275 endLine=292 srcPath=/root/NewExperiment/hibernateFilter/01556/hibernate-core/src/main/java/org/hibernate/dialect/PostgreSQL81Dialect.java)
	public String getForUpdateString(String aliases, LockOptions lockOptions) {
		/*
		 * Parent's implementation for (aliases, lockOptions) ignores aliases.
		 */
		if ( "".equals( aliases ) ) {
			LockMode lockMode = lockOptions.getLockMode();
			final Iterator<Map.Entry<String, LockMode>> itr = lockOptions.getAliasLockIterator();
			while ( itr.hasNext() ) {
				// seek the highest lock mode
				final Map.Entry<String, LockMode> entry = itr.next();
				final LockMode lm = entry.getValue();
				if ( lm.greaterThan( lockMode ) ) {
					aliases = entry.getKey();
				}
			}
		}
		return getForUpdateString( aliases );
	}

(startLine=476 endLine=494 srcPath=/root/NewExperiment/hibernateFilter/01556/hibernate-core/src/main/java/org/hibernate/dialect/AbstractHANADialect.java)
	public String getForUpdateString(final String aliases, final LockOptions lockOptions) {
		LockMode lockMode = lockOptions.getLockMode();
		final Iterator<Map.Entry<String, LockMode>> itr = lockOptions.getAliasLockIterator();
		while ( itr.hasNext() ) {
			// seek the highest lock mode
			final Map.Entry<String, LockMode> entry = itr.next();
			final LockMode lm = entry.getValue();
			if ( lm.greaterThan( lockMode ) ) {
				lockMode = lm;
			}
		}

		// not sure why this is sometimes empty
		if ( aliases == null || "".equals( aliases ) ) {
			return getForUpdateString( lockMode );
		}

		return getForUpdateString( lockMode ) + " of " + aliases;
	}

commonMethod: 
(startLine=226 endLine=238 srcPath=/root/NewExperiment/hibernateFilter/01557/hibernate-core/src/main/java/org/hibernate/LockOptions.java)
	/**
	 * Retrieve the current timeout setting.
	 * <p/>
	 * The timeout is the amount of time, in milliseconds, we should instruct the database
	 * to wait for any requested pessimistic lock acquisition.
	 * <p/>
	 * {@link #NO_WAIT}, {@link #WAIT_FOREVER} or {@link #SKIP_LOCKED} represent 3 "magic" values.
	 *
	 * @return timeout in milliseconds, {@link #NO_WAIT}, {@link #WAIT_FOREVER} or {@link #SKIP_LOCKED}
	 */
	public int getTimeOut() {
		return timeout;
	}


, Instance #
frags: 
(startLine=470 endLine=488 srcPath=/root/NewExperiment/hibernateFilter/01668/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/access/PutFromLoadValidatorUnitTest.java)
		public Void call() throws Exception {
			try {
				long txTimestamp = System.currentTimeMillis(); // this should be acquired before UserTransaction.begin()
				SharedSessionContractImplementor session = mock (SharedSessionContractImplementor.class);
				putFromLoadValidator.registerPendingPut(session, KEY1, txTimestamp);

				PutFromLoadValidator.Lock lock = putFromLoadValidator.acquirePutFromLoadLock(session, KEY1, txTimestamp);
				try {
					assertNotNull(lock);
				} finally {
					if (lock != null) {
						putFromLoadValidator.releasePutFromLoadLock(KEY1, lock);
					}
				}
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
			return null;
		}

(startLine=501 endLine=522 srcPath=/root/NewExperiment/hibernateFilter/01668/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/access/PutFromLoadValidatorUnitTest.java)
		public Void call() throws Exception {
			try {
				long txTimestamp = System.currentTimeMillis(); // this should be acquired before UserTransaction.begin()
				SharedSessionContractImplementor session = mock (SharedSessionContractImplementor.class);
				PutFromLoadValidator.Lock lock = testee.acquirePutFromLoadLock(session, KEY1, txTimestamp);
				try {
					if (expectSuccess) {
						assertNotNull(lock);
					} else {
						assertNull(lock);
					}
				}
				finally {
					if (lock != null) {
						testee.releasePutFromLoadLock(KEY1, lock);
					}
				}
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
			return null;
		}

commonMethod: 
(startLine=13 endLine=16 srcPath=/root/NewExperiment/hibernateFilter/01669/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/util/TestTimeService.java)
   @Override
   public long wallClockTime() {
      return time;
   }


, Instance #
frags: 
(startLine=405 endLine=431 srcPath=/root/NewExperiment/hibernateFilter/01684/hibernate-core/src/main/java/org/hibernate/cfg/AbstractPropertyHolder.java)
	private static Map<String, JoinColumn[]> buildJoinColumnOverride(XAnnotatedElement element, String path) {
		Map<String, JoinColumn[]> columnOverride = new HashMap<String, JoinColumn[]>();
		if ( element == null ) return columnOverride;
		AssociationOverride singleOverride = element.getAnnotation( AssociationOverride.class );
		AssociationOverrides multipleOverrides = element.getAnnotation( AssociationOverrides.class );
		AssociationOverride[] overrides;
		if ( singleOverride != null ) {
			overrides = new AssociationOverride[] { singleOverride };
		}
		else if ( multipleOverrides != null ) {
			overrides = multipleOverrides.value();
		}
		else {
			overrides = null;
		}

		//fill overridden columns
		if ( overrides != null ) {
			for (AssociationOverride depAttr : overrides) {
				columnOverride.put(
						StringHelper.qualify( path, depAttr.name() ),
						depAttr.joinColumns()
				);
			}
		}
		return columnOverride;
	}

(startLine=433 endLine=461 srcPath=/root/NewExperiment/hibernateFilter/01684/hibernate-core/src/main/java/org/hibernate/cfg/AbstractPropertyHolder.java)
	private static Map<String, JoinTable> buildJoinTableOverride(XAnnotatedElement element, String path) {
		Map<String, JoinTable> tableOverride = new HashMap<String, JoinTable>();
		if ( element == null ) return tableOverride;
		AssociationOverride singleOverride = element.getAnnotation( AssociationOverride.class );
		AssociationOverrides multipleOverrides = element.getAnnotation( AssociationOverrides.class );
		AssociationOverride[] overrides;
		if ( singleOverride != null ) {
			overrides = new AssociationOverride[] { singleOverride };
		}
		else if ( multipleOverrides != null ) {
			overrides = multipleOverrides.value();
		}
		else {
			overrides = null;
		}

		//fill overridden tables
		if ( overrides != null ) {
			for (AssociationOverride depAttr : overrides) {
				if ( depAttr.joinColumns().length == 0 ) {
					tableOverride.put(
							StringHelper.qualify( path, depAttr.name() ),
							depAttr.joinTable()
					);
				}
			}
		}
		return tableOverride;
	}

commonMethod: 
(startLine=465 endLine=480 srcPath=/root/NewExperiment/hibernateFilter/01685/hibernate-core/src/main/java/org/hibernate/cfg/AbstractPropertyHolder.java)
	private static AssociationOverride[] buildAssociationOverrides(XAnnotatedElement element, String path) {
		AssociationOverride singleOverride = element.getAnnotation( AssociationOverride.class );
		AssociationOverrides pluralOverrides = element.getAnnotation( AssociationOverrides.class );

		AssociationOverride[] overrides;
		if ( singleOverride != null ) {
			overrides = new AssociationOverride[] { singleOverride };
		}
		else if ( pluralOverrides != null ) {
			overrides = pluralOverrides.value();
		}
		else {
			overrides = null;
		}
		return overrides;
	}


, Instance #
frags: 
(startLine=1963 endLine=1989 srcPath=/root/NewExperiment/hibernateFilter/01690/hibernate-core/src/main/java/org/hibernate/boot/internal/InFlightMetadataCollectorImpl.java)
			if ( StringHelper.isEmpty( keyName ) ) {
				final Identifier keyNameIdentifier = getMetadataBuildingOptions().getImplicitNamingStrategy().determineUniqueKeyName(
						new ImplicitUniqueKeyNameSource() {
							@Override
							public MetadataBuildingContext getBuildingContext() {
								return buildingContext;
							}

							@Override
							public Identifier getTableName() {
								return table.getNameIdentifier();
							}

							private List<Identifier> columnNameIdentifiers;

							@Override
							public List<Identifier> getColumnNames() {
								// be lazy about building these
								if ( columnNameIdentifiers == null ) {
									columnNameIdentifiers = toIdentifiers( columnNames );
								}
								return columnNameIdentifiers;
							}
						}
				);
				keyName = keyNameIdentifier.render( getDatabase().getJdbcEnvironment().getDialect() );
			}

(startLine=2002 endLine=2028 srcPath=/root/NewExperiment/hibernateFilter/01690/hibernate-core/src/main/java/org/hibernate/boot/internal/InFlightMetadataCollectorImpl.java)
			if ( StringHelper.isEmpty( keyName ) ) {
				final Identifier keyNameIdentifier = getMetadataBuildingOptions().getImplicitNamingStrategy().determineIndexName(
						new ImplicitIndexNameSource() {
							@Override
							public MetadataBuildingContext getBuildingContext() {
								return buildingContext;
							}

							@Override
							public Identifier getTableName() {
								return table.getNameIdentifier();
							}

							private List<Identifier> columnNameIdentifiers;

							@Override
							public List<Identifier> getColumnNames() {
								// be lazy about building these
								if ( columnNameIdentifiers == null ) {
									columnNameIdentifiers = toIdentifiers( columnNames );
								}
								return columnNameIdentifiers;
							}
						}
				);
				keyName = keyNameIdentifier.render( getDatabase().getJdbcEnvironment().getDialect() );
			}

commonMethod: 
(startLine=23 endLine=48 srcPath=/root/NewExperiment/hibernateFilter/01691/hibernate-core/src/main/java/org/hibernate/boot/model/naming/Identifier.java)
	/**
	 * Means to generate an {@link Identifier} instance from its simple text form.
	 * <p/>
	 * If passed text is {@code null}, {@code null} is returned.
	 * <p/>
	 * If passed text is surrounded in quote markers, the generated Identifier
	 * is considered quoted.  Quote markers include back-ticks (`), and
	 * double-quotes (").
	 *
	 * @param text The text form
	 *
	 * @return The identifier form, or {@code null} if text was {@code null}
	 */
	public static Identifier toIdentifier(String text) {
		if ( StringHelper.isEmpty( text ) ) {
			return null;
		}
		final String trimmedText = text.trim();
		if ( isQuoted( trimmedText ) ) {
			final String bareName = trimmedText.substring( 1, trimmedText.length() - 1 );
			return new Identifier( bareName, true );
		}
		else {
			return new Identifier( trimmedText, false );
		}
	}


]