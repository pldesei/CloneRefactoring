[Instance #
frags: 
(startLine=247 endLine=261 srcPath=/root/NewExperiment/elasticsearchFilter/00028/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/MapperService.java)
        if (dotIndex != -1) {
            String possibleType = smartName.substring(0, dotIndex);
            DocumentMapper possibleDocMapper = mappers.get(possibleType);
            if (possibleDocMapper != null) {
                String possibleName = smartName.substring(dotIndex + 1);
                FieldMappers mappers = possibleDocMapper.mappers().fullName(possibleName);
                if (mappers != null) {
                    return mappers;
                }
                mappers = possibleDocMapper.mappers().indexName(possibleName);
                if (mappers != null) {
                    return mappers;
                }
            }
        }

(startLine=282 endLine=296 srcPath=/root/NewExperiment/elasticsearchFilter/00028/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/MapperService.java)
        if (dotIndex != -1) {
            String possibleType = smartName.substring(0, dotIndex);
            DocumentMapper possibleDocMapper = mappers.get(possibleType);
            if (possibleDocMapper != null) {
                String possibleName = smartName.substring(dotIndex + 1);
                FieldMappers mappers = possibleDocMapper.mappers().fullName(possibleName);
                if (mappers != null) {
                    return new SmartNameFieldMappers(mappers, possibleDocMapper);
                }
                mappers = possibleDocMapper.mappers().indexName(possibleName);
                if (mappers != null) {
                    return new SmartNameFieldMappers(mappers, possibleDocMapper);
                }
            }
        }

commonMethod: 
(startLine=114 endLine=123 srcPath=/root/NewExperiment/elasticsearchFilter/00029/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/DocumentFieldMappers.java)
    /**
     * Tries to find first based on {@link #fullName(String)}, then by {@link #indexName(String)}.
     */
    public FieldMappers smartName(String name) {
        FieldMappers fieldMappers = fullName(name);
        if (fieldMappers != null) {
            return fieldMappers;
        }
        return indexName(name);
    }


, Instance #
frags: 
(startLine=79 endLine=97 srcPath=/root/NewExperiment/elasticsearchFilter/00049/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchQueryAndFetchAction.java)
        @Override protected void moveToSecondPhase() {
            sortedShardList = searchPhaseController.sortDocs(queryFetchResults.values());
            final InternalSearchResponse internalResponse = searchPhaseController.merge(sortedShardList, queryFetchResults, queryFetchResults);
            String scrollIdX = null;
            if (request.scroll() != null) {
                scrollIdX = buildScrollId(request.searchType(), queryFetchResults.values());
            }
            final String scrollId = scrollIdX;
            searchCache.releaseQueryFetchResults(queryFetchResults);
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
                    }
                });
            } else {
                listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
            }
        }

(startLine=165 endLine=183 srcPath=/root/NewExperiment/elasticsearchFilter/00049/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchDfsQueryAndFetchAction.java)
        private void innerFinishHim() {
            sortedShardList = searchPhaseController.sortDocs(queryFetchResults.values());
            final InternalSearchResponse internalResponse = searchPhaseController.merge(sortedShardList, queryFetchResults, queryFetchResults);
            String scrollIdX = null;
            if (request.scroll() != null) {
                scrollIdX = buildScrollId(request.searchType(), queryFetchResults.values());
            }
            final String scrollId = scrollIdX;
            searchCache.releaseQueryFetchResults(queryFetchResults);
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
                    }
                });
            } else {
                listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
            }
        }

(startLine=255 endLine=273 srcPath=/root/NewExperiment/elasticsearchFilter/00049/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchDfsQueryThenFetchAction.java)
        private void innerFinishHim() {
            final InternalSearchResponse internalResponse = searchPhaseController.merge(sortedShardList, queryResults, fetchResults);
            String scrollIdX = null;
            if (request.scroll() != null) {
                scrollIdX = TransportSearchHelper.buildScrollId(request.searchType(), fetchResults.values());
            }
            final String scrollId = scrollIdX;
            searchCache.releaseQueryResults(queryResults);
            searchCache.releaseFetchResults(fetchResults);
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
                    }
                });
            } else {
                listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
            }
        }

commonMethod: 
(startLine=238 endLine=248 srcPath=/root/NewExperiment/elasticsearchFilter/00050/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java)
        protected void invokeListener(final SearchResponse response) {
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(response);
                    }
                });
            } else {
                listener.onResponse(response);
            }
        }


, Instance #
frags: 
(startLine=165 endLine=183 srcPath=/root/NewExperiment/elasticsearchFilter/00049/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchDfsQueryAndFetchAction.java)
        private void innerFinishHim() {
            sortedShardList = searchPhaseController.sortDocs(queryFetchResults.values());
            final InternalSearchResponse internalResponse = searchPhaseController.merge(sortedShardList, queryFetchResults, queryFetchResults);
            String scrollIdX = null;
            if (request.scroll() != null) {
                scrollIdX = buildScrollId(request.searchType(), queryFetchResults.values());
            }
            final String scrollId = scrollIdX;
            searchCache.releaseQueryFetchResults(queryFetchResults);
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
                    }
                });
            } else {
                listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
            }
        }

(startLine=255 endLine=273 srcPath=/root/NewExperiment/elasticsearchFilter/00049/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchDfsQueryThenFetchAction.java)
        private void innerFinishHim() {
            final InternalSearchResponse internalResponse = searchPhaseController.merge(sortedShardList, queryResults, fetchResults);
            String scrollIdX = null;
            if (request.scroll() != null) {
                scrollIdX = TransportSearchHelper.buildScrollId(request.searchType(), fetchResults.values());
            }
            final String scrollId = scrollIdX;
            searchCache.releaseQueryResults(queryResults);
            searchCache.releaseFetchResults(fetchResults);
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
                    }
                });
            } else {
                listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
            }
        }

commonMethod: 
(startLine=74 endLine=77 srcPath=/root/NewExperiment/elasticsearchFilter/00050/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchCache.java)
    public void releaseDfsResults(Collection<DfsSearchResult> dfsResults) {
        dfsResults.clear();
        cacheDfsResults.offer(dfsResults);
    }


, Instance #
frags: 
(startLine=255 endLine=273 srcPath=/root/NewExperiment/elasticsearchFilter/00049/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchDfsQueryThenFetchAction.java)
        private void innerFinishHim() {
            final InternalSearchResponse internalResponse = searchPhaseController.merge(sortedShardList, queryResults, fetchResults);
            String scrollIdX = null;
            if (request.scroll() != null) {
                scrollIdX = TransportSearchHelper.buildScrollId(request.searchType(), fetchResults.values());
            }
            final String scrollId = scrollIdX;
            searchCache.releaseQueryResults(queryResults);
            searchCache.releaseFetchResults(fetchResults);
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
                    }
                });
            } else {
                listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
            }
        }

(startLine=79 endLine=97 srcPath=/root/NewExperiment/elasticsearchFilter/00049/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchQueryAndFetchAction.java)
        @Override protected void moveToSecondPhase() {
            sortedShardList = searchPhaseController.sortDocs(queryFetchResults.values());
            final InternalSearchResponse internalResponse = searchPhaseController.merge(sortedShardList, queryFetchResults, queryFetchResults);
            String scrollIdX = null;
            if (request.scroll() != null) {
                scrollIdX = buildScrollId(request.searchType(), queryFetchResults.values());
            }
            final String scrollId = scrollIdX;
            searchCache.releaseQueryFetchResults(queryFetchResults);
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
                    }
                });
            } else {
                listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
            }
        }

(startLine=165 endLine=183 srcPath=/root/NewExperiment/elasticsearchFilter/00049/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchDfsQueryAndFetchAction.java)
        private void innerFinishHim() {
            sortedShardList = searchPhaseController.sortDocs(queryFetchResults.values());
            final InternalSearchResponse internalResponse = searchPhaseController.merge(sortedShardList, queryFetchResults, queryFetchResults);
            String scrollIdX = null;
            if (request.scroll() != null) {
                scrollIdX = buildScrollId(request.searchType(), queryFetchResults.values());
            }
            final String scrollId = scrollIdX;
            searchCache.releaseQueryFetchResults(queryFetchResults);
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
                    }
                });
            } else {
                listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
            }
        }

commonMethod: 
(startLine=238 endLine=248 srcPath=/root/NewExperiment/elasticsearchFilter/00050/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java)
        protected void invokeListener(final SearchResponse response) {
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(response);
                    }
                });
            } else {
                listener.onResponse(response);
            }
        }


, Instance #
frags: 
(startLine=255 endLine=273 srcPath=/root/NewExperiment/elasticsearchFilter/00049/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchDfsQueryThenFetchAction.java)
        private void innerFinishHim() {
            final InternalSearchResponse internalResponse = searchPhaseController.merge(sortedShardList, queryResults, fetchResults);
            String scrollIdX = null;
            if (request.scroll() != null) {
                scrollIdX = TransportSearchHelper.buildScrollId(request.searchType(), fetchResults.values());
            }
            final String scrollId = scrollIdX;
            searchCache.releaseQueryResults(queryResults);
            searchCache.releaseFetchResults(fetchResults);
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
                    }
                });
            } else {
                listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
            }
        }

(startLine=165 endLine=183 srcPath=/root/NewExperiment/elasticsearchFilter/00049/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchDfsQueryAndFetchAction.java)
        private void innerFinishHim() {
            sortedShardList = searchPhaseController.sortDocs(queryFetchResults.values());
            final InternalSearchResponse internalResponse = searchPhaseController.merge(sortedShardList, queryFetchResults, queryFetchResults);
            String scrollIdX = null;
            if (request.scroll() != null) {
                scrollIdX = buildScrollId(request.searchType(), queryFetchResults.values());
            }
            final String scrollId = scrollIdX;
            searchCache.releaseQueryFetchResults(queryFetchResults);
            if (request.listenerThreaded()) {
                threadPool.execute(new Runnable() {
                    @Override public void run() {
                        listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
                    }
                });
            } else {
                listener.onResponse(new SearchResponse(internalResponse, scrollId, expectedSuccessfulOps, successulOps.get(), buildShardFailures()));
            }
        }

commonMethod: 
(startLine=74 endLine=77 srcPath=/root/NewExperiment/elasticsearchFilter/00050/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchCache.java)
    public void releaseDfsResults(Collection<DfsSearchResult> dfsResults) {
        dfsResults.clear();
        cacheDfsResults.offer(dfsResults);
    }


, Instance #
frags: 
(startLine=119 endLine=133 srcPath=/root/NewExperiment/elasticsearchFilter/00129/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/support/MapperQueryParser.java)
    @Override protected Query getPrefixQuery(String field, String termStr) throws ParseException {
        String indexedNameField = field;
        currentMapper = null;
        if (mapperService != null) {
            MapperService.SmartNameFieldMappers fieldMappers = mapperService.smartName(field);
            if (fieldMappers != null) {
                currentMapper = fieldMappers.fieldMappers().mapper();
                if (currentMapper != null) {
                    indexedNameField = currentMapper.names().indexName();
                }
                return wrapSmartNameQuery(super.getPrefixQuery(indexedNameField, termStr), fieldMappers, indexCache);
            }
        }
        return super.getPrefixQuery(indexedNameField, termStr);
    }

(startLine=135 endLine=149 srcPath=/root/NewExperiment/elasticsearchFilter/00129/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/support/MapperQueryParser.java)
    @Override protected Query getFuzzyQuery(String field, String termStr, float minSimilarity) throws ParseException {
        String indexedNameField = field;
        currentMapper = null;
        if (mapperService != null) {
            MapperService.SmartNameFieldMappers fieldMappers = mapperService.smartName(field);
            if (fieldMappers != null) {
                currentMapper = fieldMappers.fieldMappers().mapper();
                if (currentMapper != null) {
                    indexedNameField = currentMapper.names().indexName();
                }
                return wrapSmartNameQuery(super.getFuzzyQuery(indexedNameField, termStr, minSimilarity), fieldMappers, indexCache);
            }
        }
        return super.getFuzzyQuery(indexedNameField, termStr, minSimilarity);
    }

(startLine=151 endLine=165 srcPath=/root/NewExperiment/elasticsearchFilter/00129/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/support/MapperQueryParser.java)
    @Override protected Query getWildcardQuery(String field, String termStr) throws ParseException {
        String indexedNameField = field;
        currentMapper = null;
        if (mapperService != null) {
            MapperService.SmartNameFieldMappers fieldMappers = mapperService.smartName(field);
            if (fieldMappers != null) {
                currentMapper = fieldMappers.fieldMappers().mapper();
                if (currentMapper != null) {
                    indexedNameField = currentMapper.names().indexName();
                }
                return wrapSmartNameQuery(super.getWildcardQuery(indexedNameField, termStr), fieldMappers, indexCache);
            }
        }
        return super.getWildcardQuery(indexedNameField, termStr);
    }

commonMethod: 
(startLine=76 endLine=78 srcPath=/root/NewExperiment/elasticsearchFilter/00130/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/xcontent/QueryParseContext.java)
    public MapperService mapperService() {
        return mapperService;
    }


, Instance #
frags: 
(startLine=132 endLine=170 srcPath=/root/NewExperiment/elasticsearchFilter/00130/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/AnalysisModule.java)
        @Override public void processTokenFilters(MapBinder<String, TokenFilterFactoryFactory> binder, Map<String, Settings> groupSettings) {
            // add defaults
            if (!groupSettings.containsKey("stop")) {
                binder.addBinding("stop").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, StopTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("asciifolding")) {
                binder.addBinding("asciifolding").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, ASCIIFoldingTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("length")) {
                binder.addBinding("length").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, LengthTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("lowercase")) {
                binder.addBinding("lowercase").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, LowerCaseTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("porterStem")) {
                binder.addBinding("porterStem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, PorterStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("porter_stem")) {
                binder.addBinding("porter_stem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, PorterStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("standard")) {
                binder.addBinding("standard").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, StandardTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("nGram")) {
                binder.addBinding("nGram").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, NGramTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("ngram")) {
                binder.addBinding("ngram").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, NGramTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("edgeNGram")) {
                binder.addBinding("edgeNGram").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, EdgeNGramTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("edge_ngram")) {
                binder.addBinding("edge_ngram").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, EdgeNGramTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("shingle")) {
                binder.addBinding("shingle").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, ShingleTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
        }

(startLine=211 endLine=248 srcPath=/root/NewExperiment/elasticsearchFilter/00130/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/AnalysisModule.java)
        @Override public void processTokenFilters(MapBinder<String, TokenFilterFactoryFactory> binder, Map<String, Settings> groupSettings) {
            if (!groupSettings.containsKey("arabicStem")) {
                binder.addBinding("arabicStem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, ArabicStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("arabic_stem")) {
                binder.addBinding("arabic_stem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, ArabicStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("brazilianStem")) {
                binder.addBinding("brazilianStem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, BrazilianStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("brazilian_stem")) {
                binder.addBinding("brazilian_stem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, BrazilianStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("dutchStem")) {
                binder.addBinding("dutchStem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, DutchStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("dutch_stem")) {
                binder.addBinding("dutch_stem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, DutchStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("frenchStem")) {
                binder.addBinding("frenchStem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, FrenchStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("french_stem")) {
                binder.addBinding("french_stem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, FrenchStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("germanStem")) {
                binder.addBinding("germanStem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, GermanStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("german_stem")) {
                binder.addBinding("german_stem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, GermanStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("russianStem")) {
                binder.addBinding("russianStem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, RussianStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
            if (!groupSettings.containsKey("russian_stem")) {
                binder.addBinding("russian_stem").toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, RussianStemTokenFilterFactory.class)).in(Scopes.SINGLETON);
            }
        }

commonMethod: 
(startLine=61 endLine=65 srcPath=/root/NewExperiment/elasticsearchFilter/00131/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/AnalysisModule.java)
            public void processTokenFilter(String name, Class<? extends TokenFilterFactory> tokenFilterFactory) {
                if (!groupSettings.containsKey(name)) {
                    binder.addBinding(name).toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, tokenFilterFactory)).in(Scopes.SINGLETON);
                }
            }


, Instance #
frags: 
(startLine=51 endLine=70 srcPath=/root/NewExperiment/elasticsearchFilter/00185/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/fs/NioFsStore.java)
    @Inject public NioFsStore(ShardId shardId, @IndexSettings Settings indexSettings, IndexStore indexStore, ByteBufferCache byteBufferCache) throws IOException {
        super(shardId, indexSettings);
        // by default, we don't need to sync to disk, since we use the gateway
        this.syncToDisk = componentSettings.getAsBoolean("sync_to_disk", false);
        LockFactory lockFactory = buildLockFactory();
        File location = ((FsIndexStore) indexStore).shardIndexLocation(shardId);
        location.mkdirs();
        this.fsDirectory = new CustomNioFSDirectory(location, lockFactory, syncToDisk);

        SwitchDirectory switchDirectory = buildSwitchDirectoryIfNeeded(fsDirectory, byteBufferCache);
        if (switchDirectory != null) {
            suggestUseCompoundFile = false;
            logger.debug("Using [nio_fs] Store with path [{}], cache [true] with extensions [{}]", fsDirectory.getFile(), switchDirectory.primaryExtensions());
            directory = switchDirectory;
        } else {
            suggestUseCompoundFile = true;
            directory = fsDirectory;
            logger.debug("Using [nio_fs] Store with path [{}]", fsDirectory.getFile());
        }
    }

(startLine=51 endLine=70 srcPath=/root/NewExperiment/elasticsearchFilter/00185/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/fs/SimpleFsStore.java)
    @Inject public SimpleFsStore(ShardId shardId, @IndexSettings Settings indexSettings, IndexStore indexStore, ByteBufferCache byteBufferCache) throws IOException {
        super(shardId, indexSettings);
        // by default, we don't need to sync to disk, since we use the gateway
        this.syncToDisk = componentSettings.getAsBoolean("sync_to_disk", false);
        LockFactory lockFactory = buildLockFactory();
        File location = ((FsIndexStore) indexStore).shardIndexLocation(shardId);
        location.mkdirs();
        this.fsDirectory = new CustomSimpleFSDirectory(location, lockFactory, syncToDisk);

        SwitchDirectory switchDirectory = buildSwitchDirectoryIfNeeded(fsDirectory, byteBufferCache);
        if (switchDirectory != null) {
            suggestUseCompoundFile = false;
            logger.debug("Using [simple_fs] Store with path [{}], cache [true] with extensions [{}]", fsDirectory.getFile(), switchDirectory.primaryExtensions());
            directory = switchDirectory;
        } else {
            suggestUseCompoundFile = true;
            directory = fsDirectory;
            logger.debug("Using [simple_fs] Store with path [{}]", fsDirectory.getFile());
        }
    }

(startLine=51 endLine=70 srcPath=/root/NewExperiment/elasticsearchFilter/00185/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/fs/MmapFsStore.java)
    @Inject public MmapFsStore(ShardId shardId, @IndexSettings Settings indexSettings, IndexStore indexStore, ByteBufferCache byteBufferCache) throws IOException {
        super(shardId, indexSettings);
        // by default, we don't need to sync to disk, since we use the gateway
        this.syncToDisk = componentSettings.getAsBoolean("sync_to_disk", false);
        LockFactory lockFactory = buildLockFactory();
        File location = ((FsIndexStore) indexStore).shardIndexLocation(shardId);
        location.mkdirs();
        this.fsDirectory = new CustomMMapDirectory(location, lockFactory, syncToDisk);

        SwitchDirectory switchDirectory = buildSwitchDirectoryIfNeeded(fsDirectory, byteBufferCache);
        if (switchDirectory != null) {
            suggestUseCompoundFile = false;
            logger.debug("Using [mmap_fs] Store with path [{}], cache [true] with extensions [{}]", fsDirectory.getFile(), switchDirectory.primaryExtensions());
            directory = switchDirectory;
        } else {
            suggestUseCompoundFile = true;
            directory = fsDirectory;
            logger.debug("Using [mmap_fs] Store with path [{}]", fsDirectory.getFile());
        }
    }

commonMethod: 
(startLine=61 endLine=63 srcPath=/root/NewExperiment/elasticsearchFilter/00186/modules/elasticsearch/src/main/java/org/elasticsearch/index/store/support/AbstractStore.java)
    protected Directory wrapDirectory(Directory dir) throws IOException {
        return new StoreDirectory(dir);
    }


, Instance #
frags: 
(startLine=116 endLine=148 srcPath=/root/NewExperiment/elasticsearchFilter/00204/modules/elasticsearch/src/main/java/org/elasticsearch/search/facets/histogram/HistogramFacetBuilder.java)
    @Override public void toXContent(XContentBuilder builder, Params params) throws IOException {
        if (keyFieldName == null) {
            throw new SearchSourceBuilderException("field must be set on histogram facet for facet [" + name + "]");
        }
        if (interval < 0) {
            throw new SearchSourceBuilderException("interval must be set on histogram facet for facet [" + name + "]");
        }
        builder.startObject(name);

        builder.startObject(HistogramFacetCollectorParser.NAME);
        if (valueFieldName != null && !keyFieldName.equals(valueFieldName)) {
            builder.field("key_field", keyFieldName);
            builder.field("value_field", valueFieldName);
        } else {
            builder.field("field", keyFieldName);
        }
        builder.field("interval", interval);
        if (comparatorType != null) {
            builder.field("comparator", comparatorType.description());
        }
        builder.endObject();

        if (filter != null) {
            builder.field("filter");
            filter.toXContent(builder, params);
        }

        if (global != null) {
            builder.field("global", global);
        }

        builder.endObject();
    }

(startLine=83 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00204/modules/elasticsearch/src/main/java/org/elasticsearch/search/facets/histogram/HistogramScriptFacetBuilder.java)
    @Override public void toXContent(XContentBuilder builder, Params params) throws IOException {
        if (keyScript == null) {
            throw new SearchSourceBuilderException("key_script must be set on histogram script facet for facet [" + name + "]");
        }
        if (valueScript == null) {
            throw new SearchSourceBuilderException("value_script must be set on histogram script facet for facet [" + name + "]");
        }
        builder.startObject(name);

        builder.startObject(HistogramFacetCollectorParser.NAME);
        builder.field("key_script", keyScript);
        builder.field("value_script", valueScript);
        if (interval > 0) { // interval is optional in script facet, can be defined by the key script
            builder.field("interval", interval);
        }
        if (this.params != null) {
            builder.field("params");
            builder.map(this.params);
        }
        if (comparatorType != null) {
            builder.field("comparator", comparatorType.description());
        }
        builder.endObject();

        if (filter != null) {
            builder.field("filter");
            filter.toXContent(builder, params);
        }

        if (global != null) {
            builder.field("global", global);
        }

        builder.endObject();
    }

commonMethod: 
(startLine=53 endLine=62 srcPath=/root/NewExperiment/elasticsearchFilter/00205/modules/elasticsearch/src/main/java/org/elasticsearch/search/facets/AbstractFacetBuilder.java)
    protected void addFilterFacetAndGlobal(XContentBuilder builder, Params params) throws IOException {
        if (facetFilter != null) {
            builder.field("facet_filter");
            facetFilter.toXContent(builder, params);
        }

        if (global != null) {
            builder.field("global", global);
        }
    }


, Instance #
frags: 
(startLine=54 endLine=74 srcPath=/root/NewExperiment/elasticsearchFilter/00204/modules/elasticsearch/src/main/java/org/elasticsearch/search/facets/statistical/StatisticalFacetBuilder.java)
    @Override public void toXContent(XContentBuilder builder, Params params) throws IOException {
        if (fieldName == null) {
            throw new SearchSourceBuilderException("field must be set on statistical facet for facet [" + name + "]");
        }
        builder.startObject(name);

        builder.startObject(StatisticalFacetCollectorParser.NAME);
        builder.field("field", fieldName);
        builder.endObject();

        if (filter != null) {
            builder.field("filter");
            filter.toXContent(builder, params);
        }

        if (global != null) {
            builder.field("global", global);
        }

        builder.endObject();
    }

(startLine=56 endLine=73 srcPath=/root/NewExperiment/elasticsearchFilter/00204/modules/elasticsearch/src/main/java/org/elasticsearch/search/facets/query/QueryFacetBuilder.java)
    @Override public void toXContent(XContentBuilder builder, Params params) throws IOException {
        if (query == null) {
            throw new SearchSourceBuilderException("query must be set on query facet for facet [" + name + "]");
        }
        builder.startObject(name);
        builder.field(QueryFacetCollectorParser.NAME);
        query.toXContent(builder, params);

        if (filter != null) {
            builder.field("filter");
            filter.toXContent(builder, params);
        }

        if (global != null) {
            builder.field("global", global);
        }
        builder.endObject();
    }

commonMethod: 
(startLine=53 endLine=62 srcPath=/root/NewExperiment/elasticsearchFilter/00205/modules/elasticsearch/src/main/java/org/elasticsearch/search/facets/AbstractFacetBuilder.java)
    protected void addFilterFacetAndGlobal(XContentBuilder builder, Params params) throws IOException {
        if (facetFilter != null) {
            builder.field("facet_filter");
            facetFilter.toXContent(builder, params);
        }

        if (global != null) {
            builder.field("global", global);
        }
    }


, Instance #
frags: 
(startLine=83 endLine=90 srcPath=/root/NewExperiment/elasticsearchFilter/00220/modules/elasticsearch/src/main/java/org/elasticsearch/transport/local/LocalTransportChannel.java)
        } catch (NotSerializableException e) {
            stream = BytesStreamOutput.Cached.cached();
            writeResponseExceptionHeader(stream);
            RemoteTransportException tx = new RemoteTransportException(targetTransport.nodeName(), targetTransport.boundAddress().boundAddress(), action, new NotSerializableTransportException(error));
            ThrowableObjectOutputStream too = new ThrowableObjectOutputStream(stream);
            too.writeObject(tx);
            too.close();
        }

(startLine=87 endLine=94 srcPath=/root/NewExperiment/elasticsearchFilter/00220/modules/elasticsearch/src/main/java/org/elasticsearch/transport/netty/NettyTransportChannel.java)
        } catch (NotSerializableException e) {
            stream = BytesStreamOutput.Cached.cached();
            writeResponseExceptionHeader(stream);
            RemoteTransportException tx = new RemoteTransportException(transport.nodeName(), transport.wrapAddress(channel.getLocalAddress()), action, new NotSerializableTransportException(error));
            ThrowableObjectOutputStream too = new ThrowableObjectOutputStream(stream);
            too.writeObject(tx);
            too.close();
        }

commonMethod: 
(startLine=52 endLine=59 srcPath=/root/NewExperiment/elasticsearchFilter/00221/modules/elasticsearch/src/main/java/org/elasticsearch/common/io/stream/CachedStreamOutput.java)
    /**
     * Returns the cached thread local byte stream, with its internal stream cleared.
     */
    public static BytesStreamOutput cachedBytes() {
        BytesStreamOutput os = cache.get().get().bytes;
        os.reset();
        return os;
    }


, Instance #
frags: 
(startLine=45 endLine=61 srcPath=/root/NewExperiment/elasticsearchFilter/00235/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/DutchAnalyzerProvider.java)
    @Inject public DutchAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name);
        String[] stopWords = settings.getAsArray("stopwords", null);
        if (stopWords != null) {
            this.stopWords = ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            this.stopWords = DutchAnalyzer.getDefaultStopSet();
        }

        String[] stemExclusion = settings.getAsArray("stem_exclusion");
        if (stemExclusion.length > 0) {
            this.stemExclusion = ImmutableSet.copyOf(Iterators.forArray(stemExclusion));
        } else {
            this.stemExclusion = ImmutableSet.of();
        }
        analyzer = new DutchAnalyzer(Lucene.VERSION, this.stopWords, this.stemExclusion);
    }

(startLine=45 endLine=61 srcPath=/root/NewExperiment/elasticsearchFilter/00235/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/FrenchAnalyzerProvider.java)
    @Inject public FrenchAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name);
        String[] stopWords = settings.getAsArray("stopwords", null);
        if (stopWords != null) {
            this.stopWords = ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            this.stopWords = FrenchAnalyzer.getDefaultStopSet();
        }

        String[] stemExclusion = settings.getAsArray("stem_exclusion");
        if (stemExclusion.length > 0) {
            this.stemExclusion = ImmutableSet.copyOf(Iterators.forArray(stemExclusion));
        } else {
            this.stemExclusion = ImmutableSet.of();
        }
        analyzer = new FrenchAnalyzer(Lucene.ANALYZER_VERSION, this.stopWords, this.stemExclusion);
    }

(startLine=45 endLine=61 srcPath=/root/NewExperiment/elasticsearchFilter/00235/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/GermanAnalyzerProvider.java)
    @Inject public GermanAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name);
        String[] stopWords = settings.getAsArray("stopwords", null);
        if (stopWords != null) {
            this.stopWords = ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            this.stopWords = GermanAnalyzer.getDefaultStopSet();
        }

        String[] stemExclusion = settings.getAsArray("stem_exclusion");
        if (stemExclusion.length > 0) {
            this.stemExclusion = ImmutableSet.copyOf(Iterators.forArray(stemExclusion));
        } else {
            this.stemExclusion = ImmutableSet.of();
        }
        analyzer = new GermanAnalyzer(Lucene.ANALYZER_VERSION, this.stopWords, this.stemExclusion);
    }

(startLine=45 endLine=61 srcPath=/root/NewExperiment/elasticsearchFilter/00235/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/BrazilianAnalyzerProvider.java)
    @Inject public BrazilianAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name);
        String[] stopWords = settings.getAsArray("stopwords", null);
        if (stopWords != null) {
            this.stopWords = ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            this.stopWords = BrazilianAnalyzer.getDefaultStopSet();
        }

        String[] stemExclusion = settings.getAsArray("stem_exclusion");
        if (stemExclusion.length > 0) {
            this.stemExclusion = ImmutableSet.copyOf(Iterators.forArray(stemExclusion));
        } else {
            this.stemExclusion = ImmutableSet.of();
        }
        analyzer = new BrazilianAnalyzer(Lucene.ANALYZER_VERSION, this.stopWords, this.stemExclusion);
    }

commonMethod: 
(startLine=38 endLine=49 srcPath=/root/NewExperiment/elasticsearchFilter/00236/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/Analysis.java)
    public static Set<?> parseStopWords(Settings settings, Set<?> defaultStopWords) {
        String value = settings.get("stopwords");
        if (value != null && "_none_".equals(value)) {
            return ImmutableSet.of();
        }
        String[] stopWords = settings.getAsArray("stopwords", null);
        if (stopWords != null) {
            return ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            return defaultStopWords;
        }
    }


, Instance #
frags: 
(startLine=43 endLine=53 srcPath=/root/NewExperiment/elasticsearchFilter/00235/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/CjkAnalyzerProvider.java)
    @Inject public CjkAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name);
        String[] stopWords = settings.getAsArray("stopwords", null);
        if (stopWords != null) {
            this.stopWords = ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            this.stopWords = CJKAnalyzer.getDefaultStopSet();
        }

        analyzer = new CJKAnalyzer(Lucene.ANALYZER_VERSION, this.stopWords);
    }

(startLine=43 endLine=52 srcPath=/root/NewExperiment/elasticsearchFilter/00235/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/ArabicAnalyzerProvider.java)
    @Inject public ArabicAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name);
        String[] stopWords = settings.getAsArray("stopwords", null);
        if (stopWords != null) {
            this.stopWords = ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            this.stopWords = ArabicAnalyzer.getDefaultStopSet();
        }
        arabicAnalyzer = new ArabicAnalyzer(Lucene.ANALYZER_VERSION, this.stopWords);
    }

(startLine=43 endLine=53 srcPath=/root/NewExperiment/elasticsearchFilter/00235/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/PersianAnalyzerProvider.java)
    @Inject public PersianAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name);
        String[] stopWords = settings.getAsArray("stopwords", null);
        if (stopWords != null) {
            this.stopWords = ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            this.stopWords = PersianAnalyzer.getDefaultStopSet();
        }

        analyzer = new PersianAnalyzer(Lucene.ANALYZER_VERSION, this.stopWords);
    }

(startLine=43 endLine=53 srcPath=/root/NewExperiment/elasticsearchFilter/00235/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/GreekAnalyzerProvider.java)
    @Inject public GreekAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name);
        String[] stopWords = settings.getAsArray("stopwords", null);
        if (stopWords != null) {
            this.stopWords = ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            this.stopWords = GreekAnalyzer.getDefaultStopSet();
        }

        analyzer = new GreekAnalyzer(Lucene.ANALYZER_VERSION, this.stopWords);
    }

(startLine=43 endLine=53 srcPath=/root/NewExperiment/elasticsearchFilter/00235/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/CzechAnalyzerProvider.java)
    @Inject public CzechAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name);
        String[] stopWords = settings.getAsArray("stopwords", null);
        if (stopWords != null) {
            this.stopWords = ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            this.stopWords = CzechAnalyzer.getDefaultStopSet();
        }

        analyzer = new CzechAnalyzer(Lucene.ANALYZER_VERSION, this.stopWords);
    }

commonMethod: 
(startLine=38 endLine=49 srcPath=/root/NewExperiment/elasticsearchFilter/00236/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/Analysis.java)
    public static Set<?> parseStopWords(Settings settings, Set<?> defaultStopWords) {
        String value = settings.get("stopwords");
        if (value != null && "_none_".equals(value)) {
            return ImmutableSet.of();
        }
        String[] stopWords = settings.getAsArray("stopwords", null);
        if (stopWords != null) {
            return ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            return defaultStopWords;
        }
    }


, Instance #
frags: 
(startLine=118 endLine=131 srcPath=/root/NewExperiment/elasticsearchFilter/00259/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/xcontent/GeoPolygonFilterParser.java)
                        } else if (token.isValue()) {
                            GeoPolygonFilter.Point point = new GeoPolygonFilter.Point();
                            String value = parser.text();
                            int comma = value.indexOf(',');
                            if (comma != -1) {
                                point.lat = Double.parseDouble(value.substring(0, comma).trim());
                                point.lon = Double.parseDouble(value.substring(comma + 1).trim());
                            } else {
                                double[] values = GeoHashUtils.decode(value);
                                point.lat = values[0];
                                point.lon = values[1];
                            }
                            points.add(point);
                        }

(startLine=127 endLine=138 srcPath=/root/NewExperiment/elasticsearchFilter/00259/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/xcontent/GeoBoundingBoxFilterParser.java)
                    if (point != null) {
                        String value = parser.text();
                        int comma = value.indexOf(',');
                        if (comma != -1) {
                            point.lat = Double.parseDouble(value.substring(0, comma).trim());
                            point.lon = Double.parseDouble(value.substring(comma + 1).trim());
                        } else {
                            double[] values = GeoHashUtils.decode(value);
                            point.lat = values[0];
                            point.lon = values[1];
                        }
                    }

commonMethod: 
(startLine=115 endLine=164 srcPath=/root/NewExperiment/elasticsearchFilter/00260/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/geo/GeoHashUtils.java)
    /**
     * Decodes the given geohash into a latitude and longitude
     *
     * @param geohash Geohash to deocde
     * @return Array with the latitude at index 0, and longitude at index 1
     */
    public static double[] decode(String geohash) {
//        double[] latInterval = {-90.0, 90.0};
//        double[] lngInterval = {-180.0, 180.0};
        double latInterval0 = -90.0;
        double latInterval1 = 90.0;
        double lngInterval0 = -180.0;
        double lngInterval1 = 180.0;

        boolean isEven = true;

        double latitude;
        double longitude;
        for (int i = 0; i < geohash.length(); i++) {
            final int cd = DECODE_MAP.get(geohash.charAt(i));

            for (int mask : BITS) {
                if (isEven) {
                    if ((cd & mask) != 0) {
//                        lngInterval[0] = (lngInterval[0] + lngInterval[1]) / 2D;
                        lngInterval0 = (lngInterval0 + lngInterval1) / 2D;
                    } else {
//                        lngInterval[1] = (lngInterval[0] + lngInterval[1]) / 2D;
                        lngInterval1 = (lngInterval0 + lngInterval1) / 2D;
                    }
                } else {
                    if ((cd & mask) != 0) {
//                        latInterval[0] = (latInterval[0] + latInterval[1]) / 2D;
                        latInterval0 = (latInterval0 + latInterval1) / 2D;
                    } else {
//                        latInterval[1] = (latInterval[0] + latInterval[1]) / 2D;
                        latInterval1 = (latInterval0 + latInterval1) / 2D;
                    }
                }
                isEven = !isEven;
            }

        }
//        latitude = (latInterval[0] + latInterval[1]) / 2D;
        latitude = (latInterval0 + latInterval1) / 2D;
//        longitude = (lngInterval[0] + lngInterval[1]) / 2D;
        longitude = (lngInterval0 + lngInterval1) / 2D;

        return new double[]{latitude, longitude};
    }


, Instance #
frags: 
(startLine=105 endLine=115 srcPath=/root/NewExperiment/elasticsearchFilter/00259/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/xcontent/GeoPolygonFilterParser.java)
                                } else if (token.isValue()) {
                                    if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.LAT)) {
                                        point.lat = parser.doubleValue();
                                    } else if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.LON)) {
                                        point.lon = parser.doubleValue();
                                    } else if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.GEOHASH)) {
                                        double[] values = GeoHashUtils.decode(parser.text());
                                        point.lat = values[0];
                                        point.lon = values[1];
                                    }
                                }

(startLine=102 endLine=112 srcPath=/root/NewExperiment/elasticsearchFilter/00259/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/xcontent/GeoBoundingBoxFilterParser.java)
                        } else if (token.isValue()) {
                            if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.LAT)) {
                                point.lat = parser.doubleValue();
                            } else if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.LON)) {
                                point.lon = parser.doubleValue();
                            } else if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.GEOHASH)) {
                                double[] values = GeoHashUtils.decode(parser.text());
                                point.lat = values[0];
                                point.lon = values[1];
                            }
                        }

commonMethod: 
(startLine=115 endLine=164 srcPath=/root/NewExperiment/elasticsearchFilter/00260/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/geo/GeoHashUtils.java)
    /**
     * Decodes the given geohash into a latitude and longitude
     *
     * @param geohash Geohash to deocde
     * @return Array with the latitude at index 0, and longitude at index 1
     */
    public static double[] decode(String geohash) {
//        double[] latInterval = {-90.0, 90.0};
//        double[] lngInterval = {-180.0, 180.0};
        double latInterval0 = -90.0;
        double latInterval1 = 90.0;
        double lngInterval0 = -180.0;
        double lngInterval1 = 180.0;

        boolean isEven = true;

        double latitude;
        double longitude;
        for (int i = 0; i < geohash.length(); i++) {
            final int cd = DECODE_MAP.get(geohash.charAt(i));

            for (int mask : BITS) {
                if (isEven) {
                    if ((cd & mask) != 0) {
//                        lngInterval[0] = (lngInterval[0] + lngInterval[1]) / 2D;
                        lngInterval0 = (lngInterval0 + lngInterval1) / 2D;
                    } else {
//                        lngInterval[1] = (lngInterval[0] + lngInterval[1]) / 2D;
                        lngInterval1 = (lngInterval0 + lngInterval1) / 2D;
                    }
                } else {
                    if ((cd & mask) != 0) {
//                        latInterval[0] = (latInterval[0] + latInterval[1]) / 2D;
                        latInterval0 = (latInterval0 + latInterval1) / 2D;
                    } else {
//                        latInterval[1] = (latInterval[0] + latInterval[1]) / 2D;
                        latInterval1 = (latInterval0 + latInterval1) / 2D;
                    }
                }
                isEven = !isEven;
            }

        }
//        latitude = (latInterval[0] + latInterval[1]) / 2D;
        latitude = (latInterval0 + latInterval1) / 2D;
//        longitude = (lngInterval[0] + lngInterval[1]) / 2D;
        longitude = (lngInterval0 + lngInterval1) / 2D;

        return new double[]{latitude, longitude};
    }


, Instance #
frags: 
(startLine=100 endLine=118 srcPath=/root/NewExperiment/elasticsearchFilter/00259/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/xcontent/GeoPolygonFilterParser.java)
                        } else if (token == XContentParser.Token.START_OBJECT) {
                            GeoPolygonFilter.Point point = new GeoPolygonFilter.Point();
                            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                                if (token == XContentParser.Token.FIELD_NAME) {
                                    currentFieldName = parser.currentName();
                                } else if (token.isValue()) {
                                    if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.LAT)) {
                                        point.lat = parser.doubleValue();
                                    } else if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.LON)) {
                                        point.lon = parser.doubleValue();
                                    } else if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.GEOHASH)) {
                                        double[] values = GeoHashUtils.decode(parser.text());
                                        point.lat = values[0];
                                        point.lon = values[1];
                                    }
                                }
                            }
                            points.add(point);
                        } else if (token.isValue()) {

(startLine=98 endLine=114 srcPath=/root/NewExperiment/elasticsearchFilter/00259/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/xcontent/GeoBoundingBoxFilterParser.java)
                if (point != null) {
                    while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                        if (token == XContentParser.Token.FIELD_NAME) {
                            currentFieldName = parser.currentName();
                        } else if (token.isValue()) {
                            if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.LAT)) {
                                point.lat = parser.doubleValue();
                            } else if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.LON)) {
                                point.lon = parser.doubleValue();
                            } else if (currentFieldName.equals(XContentGeoPointFieldMapper.Names.GEOHASH)) {
                                double[] values = GeoHashUtils.decode(parser.text());
                                point.lat = values[0];
                                point.lon = values[1];
                            }
                        }
                    }
                }

commonMethod: 
(startLine=115 endLine=164 srcPath=/root/NewExperiment/elasticsearchFilter/00260/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/geo/GeoHashUtils.java)
    /**
     * Decodes the given geohash into a latitude and longitude
     *
     * @param geohash Geohash to deocde
     * @return Array with the latitude at index 0, and longitude at index 1
     */
    public static double[] decode(String geohash) {
//        double[] latInterval = {-90.0, 90.0};
//        double[] lngInterval = {-180.0, 180.0};
        double latInterval0 = -90.0;
        double latInterval1 = 90.0;
        double lngInterval0 = -180.0;
        double lngInterval1 = 180.0;

        boolean isEven = true;

        double latitude;
        double longitude;
        for (int i = 0; i < geohash.length(); i++) {
            final int cd = DECODE_MAP.get(geohash.charAt(i));

            for (int mask : BITS) {
                if (isEven) {
                    if ((cd & mask) != 0) {
//                        lngInterval[0] = (lngInterval[0] + lngInterval[1]) / 2D;
                        lngInterval0 = (lngInterval0 + lngInterval1) / 2D;
                    } else {
//                        lngInterval[1] = (lngInterval[0] + lngInterval[1]) / 2D;
                        lngInterval1 = (lngInterval0 + lngInterval1) / 2D;
                    }
                } else {
                    if ((cd & mask) != 0) {
//                        latInterval[0] = (latInterval[0] + latInterval[1]) / 2D;
                        latInterval0 = (latInterval0 + latInterval1) / 2D;
                    } else {
//                        latInterval[1] = (latInterval[0] + latInterval[1]) / 2D;
                        latInterval1 = (latInterval0 + latInterval1) / 2D;
                    }
                }
                isEven = !isEven;
            }

        }
//        latitude = (latInterval[0] + latInterval[1]) / 2D;
        latitude = (latInterval0 + latInterval1) / 2D;
//        longitude = (lngInterval[0] + lngInterval[1]) / 2D;
        longitude = (lngInterval0 + lngInterval1) / 2D;

        return new double[]{latitude, longitude};
    }


, Instance #
frags: 
(startLine=52 endLine=105 srcPath=/root/NewExperiment/elasticsearchFilter/00297/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/xcontent/OrFilterParser.java)
    @Override public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {
        XContentParser parser = parseContext.parser();

        ArrayList<Filter> filters = newArrayList();

        boolean cache = true;

        String filterName = null;
        String currentFieldName = null;
        XContentParser.Token token = parser.currentToken();
        if (token == XContentParser.Token.START_ARRAY) {
            while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                filters.add(parseContext.parseInnerFilter());
            }
        } else {
            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                if (token == XContentParser.Token.FIELD_NAME) {
                    currentFieldName = parser.currentName();
                } else if (token == XContentParser.Token.START_ARRAY) {
                    if ("filters".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                            filters.add(parseContext.parseInnerFilter());
                        }
                    } else {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                            filters.add(parseContext.parseInnerFilter());
                        }
                    }
                } else if (token.isValue()) {
                    if ("_cache".equals(currentFieldName)) {
                        cache = parser.booleanValue();
                    } else if ("_name".equals(currentFieldName)) {
                        filterName = parser.text();
                    }
                }
            }
        }

        if (filters.isEmpty()) {
            throw new QueryParsingException(index, "[or] filter requires 'filters' to be set on it'");
        }

        if (cache) {
            for (int i = 0; i < filters.size(); i++) {
                filters.set(i, parseContext.cacheFilterIfPossible(filters.get(i)));
            }
        }
        // no need to cache this one
        OrFilter filter = new OrFilter(filters);
        if (filterName != null) {
            parseContext.addNamedFilter(filterName, filter);
        }
        return filter;
    }

(startLine=52 endLine=105 srcPath=/root/NewExperiment/elasticsearchFilter/00297/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/xcontent/AndFilterParser.java)
    @Override public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {
        XContentParser parser = parseContext.parser();

        ArrayList<Filter> filters = newArrayList();

        boolean cache = true;

        String filterName = null;
        String currentFieldName = null;
        XContentParser.Token token = parser.currentToken();
        if (token == XContentParser.Token.START_ARRAY) {
            while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                filters.add(parseContext.parseInnerFilter());
            }
        } else {
            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                if (token == XContentParser.Token.FIELD_NAME) {
                    currentFieldName = parser.currentName();
                } else if (token == XContentParser.Token.START_ARRAY) {
                    if ("filters".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                            filters.add(parseContext.parseInnerFilter());
                        }
                    } else {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                            filters.add(parseContext.parseInnerFilter());
                        }
                    }
                } else if (token.isValue()) {
                    if ("_cache".equals(currentFieldName)) {
                        cache = parser.booleanValue();
                    } else if ("_name".equals(currentFieldName)) {
                        filterName = parser.text();
                    }
                }
            }
        }

        if (filters.isEmpty()) {
            throw new QueryParsingException(index, "[or] filter requires 'filters' to be set on it'");
        }

        if (cache) {
            for (int i = 0; i < filters.size(); i++) {
                filters.set(i, parseContext.cacheFilterIfPossible(filters.get(i)));
            }
        }
        // no need to cache this one
        AndFilter filter = new AndFilter(filters);
        if (filterName != null) {
            parseContext.addNamedFilter(filterName, filter);
        }
        return filter;
    }

commonMethod: 
(startLine=111 endLine=113 srcPath=/root/NewExperiment/elasticsearchFilter/00298/modules/elasticsearch/src/main/java/org/elasticsearch/index/query/xcontent/QueryParseContext.java)
    public Filter cacheFilter(Filter filter) {
        return indexQueryParser.indexCache.filter().cache(filter);
    }


, Instance #
frags: 
(startLine=230 endLine=236 srcPath=/root/NewExperiment/elasticsearchFilter/00335/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java)
                    if (!mapperService.hasMapping(mappingType)) {
                        if (logger.isDebugEnabled()) {
                            logger.debug("[{}] adding mapping [{}], source [{}]", index, mappingType, mappingSource.string());
                        }
                        mapperService.add(mappingType, mappingSource.string());
                        nodeMappingCreatedAction.nodeMappingCreated(new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId()));
                    } else {

(startLine=238 endLine=245 srcPath=/root/NewExperiment/elasticsearchFilter/00335/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java)
                        if (!mappingSource.equals(existingMapper.mappingSource())) {
                            // mapping changed, update it
                            if (logger.isDebugEnabled()) {
                                logger.debug("[{}] updating mapping [{}], source [{}]", index, mappingType, mappingSource.string());
                            }
                            mapperService.add(mappingType, mappingSource.string());
                            nodeMappingCreatedAction.nodeMappingCreated(new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId()));
                        }

commonMethod: 
(startLine=246 endLine=272 srcPath=/root/NewExperiment/elasticsearchFilter/00336/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java)
    private void processMapping(ClusterChangedEvent event, String index, MapperService mapperService, String mappingType, CompressedString mappingSource) {
        if (!seenMappings.containsKey(new Tuple<String, String>(index, mappingType))) {
            seenMappings.put(new Tuple<String, String>(index, mappingType), true);
        }

        try {
            if (!mapperService.hasMapping(mappingType)) {
                if (logger.isDebugEnabled()) {
                    logger.debug("[{}] adding mapping [{}], source [{}]", index, mappingType, mappingSource.string());
                }
                mapperService.add(mappingType, mappingSource.string());
                nodeMappingCreatedAction.nodeMappingCreated(new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId()));
            } else {
                DocumentMapper existingMapper = mapperService.documentMapper(mappingType);
                if (!mappingSource.equals(existingMapper.mappingSource())) {
                    // mapping changed, update it
                    if (logger.isDebugEnabled()) {
                        logger.debug("[{}] updating mapping [{}], source [{}]", index, mappingType, mappingSource.string());
                    }
                    mapperService.add(mappingType, mappingSource.string());
                    nodeMappingCreatedAction.nodeMappingCreated(new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId()));
                }
            }
        } catch (Exception e) {
            logger.warn("[{}] failed to add mapping [{}], source [{}]", e, index, mappingType, mappingSource);
        }
    }


, Instance #
frags: 
(startLine=230 endLine=236 srcPath=/root/NewExperiment/elasticsearchFilter/00335/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java)
                    if (!mapperService.hasMapping(mappingType)) {
                        if (logger.isDebugEnabled()) {
                            logger.debug("[{}] adding mapping [{}], source [{}]", index, mappingType, mappingSource.string());
                        }
                        mapperService.add(mappingType, mappingSource.string());
                        nodeMappingCreatedAction.nodeMappingCreated(new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId()));
                    } else {

(startLine=238 endLine=245 srcPath=/root/NewExperiment/elasticsearchFilter/00335/modules/elasticsearch/src/main/java/org/elasticsearch/indices/cluster/IndicesClusterStateService.java)
                        if (!mappingSource.equals(existingMapper.mappingSource())) {
                            // mapping changed, update it
                            if (logger.isDebugEnabled()) {
                                logger.debug("[{}] updating mapping [{}], source [{}]", index, mappingType, mappingSource.string());
                            }
                            mapperService.add(mappingType, mappingSource.string());
                            nodeMappingCreatedAction.nodeMappingCreated(new NodeMappingCreatedAction.NodeMappingCreatedResponse(index, mappingType, event.state().nodes().localNodeId()));
                        }

commonMethod: 
(startLine=175 endLine=177 srcPath=/root/NewExperiment/elasticsearchFilter/00336/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java)
    public MappingMetaData mapping(String mappingType) {
        return mappings.get(mappingType);
    }


, Instance #
frags: 
(startLine=210 endLine=217 srcPath=/root/NewExperiment/elasticsearchFilter/00344/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java)
    @Override public Engine.Create prepareCreate(SourceToParse source) throws ElasticSearchException {
        DocumentMapper docMapper = mapperService.type(source.type());
        if (docMapper == null) {
            throw new DocumentMapperNotFoundException("No mapper found for type [" + source.type() + "]");
        }
        ParsedDocument doc = docMapper.parse(source);
        return new Engine.Create(doc);
    }

(startLine=228 endLine=235 srcPath=/root/NewExperiment/elasticsearchFilter/00344/modules/elasticsearch/src/main/java/org/elasticsearch/index/shard/service/InternalIndexShard.java)
    @Override public Engine.Index prepareIndex(SourceToParse source) throws ElasticSearchException {
        DocumentMapper docMapper = mapperService.type(source.type());
        if (docMapper == null) {
            throw new DocumentMapperNotFoundException("No mapper found for type [" + source.type() + "]");
        }
        ParsedDocument doc = docMapper.parse(source);
        return new Engine.Index(docMapper.uidMapper().term(doc.uid()), doc);
    }

commonMethod: 
(startLine=215 endLine=232 srcPath=/root/NewExperiment/elasticsearchFilter/00345/modules/elasticsearch/src/main/java/org/elasticsearch/index/mapper/MapperService.java)
    public DocumentMapper documentMapperWithAutoCreate(String type) {
        DocumentMapper mapper = mappers.get(type);
        if (mapper != null) {
            return mapper;
        }
        if (!dynamic) {
            return null;
        }
        // go ahead and dynamically create it
        synchronized (mutex) {
            mapper = mappers.get(type);
            if (mapper != null) {
                return mapper;
            }
            add(type, null);
            return mappers.get(type);
        }
    }


, Instance #
frags: 
(startLine=226 endLine=252 srcPath=/root/NewExperiment/elasticsearchFilter/00390/modules/elasticsearch/src/main/java/org/elasticsearch/transport/local/LocalTransport.java)
    private void handleResponse(StreamInput buffer, final TransportResponseHandler handler) {
        final Streamable streamable = handler.newInstance();
        try {
            streamable.readFrom(buffer);
        } catch (Exception e) {
            handleException(handler, new TransportSerializationException("Failed to deserialize response of type [" + streamable.getClass().getName() + "]", e));
            return;
        }
        if (handler.spawn()) {
            threadPool.execute(new Runnable() {
                @SuppressWarnings({"unchecked"}) @Override public void run() {
                    try {
                        handler.handleResponse(streamable);
                    } catch (Exception e) {
                        handleException(handler, new ResponseHandlerFailureTransportException(e));
                    }
                }
            });
        } else {
            try {
                //noinspection unchecked
                handler.handleResponse(streamable);
            } catch (Exception e) {
                handleException(handler, new ResponseHandlerFailureTransportException(e));
            }
        }
    }

(startLine=121 endLine=147 srcPath=/root/NewExperiment/elasticsearchFilter/00390/modules/elasticsearch/src/main/java/org/elasticsearch/transport/netty/MessageChannelHandler.java)
    private void handleResponse(StreamInput buffer, final TransportResponseHandler handler) {
        final Streamable streamable = handler.newInstance();
        try {
            streamable.readFrom(buffer);
        } catch (Exception e) {
            handleException(handler, new TransportSerializationException("Failed to deserialize response of type [" + streamable.getClass().getName() + "]", e));
            return;
        }
        try {
            if (handler.spawn()) {
                threadPool.execute(new Runnable() {
                    @SuppressWarnings({"unchecked"}) @Override public void run() {
                        try {
                            handler.handleResponse(streamable);
                        } catch (Exception e) {
                            handleException(handler, new ResponseHandlerFailureTransportException(e));
                        }
                    }
                });
            } else {
                //noinspection unchecked
                handler.handleResponse(streamable);
            }
        } catch (Exception e) {
            handleException(handler, new ResponseHandlerFailureTransportException(e));
        }
    }

commonMethod: 
(startLine=87 endLine=93 srcPath=/root/NewExperiment/elasticsearchFilter/00391/modules/elasticsearch/src/main/java/org/elasticsearch/threadpool/ThreadPool.java)
    public Executor executor(String name) {
        Executor executor = executors.get(name);
        if (executor == null) {
            throw new ElasticSearchIllegalArgumentException("No executor found for [" + name + "]");
        }
        return executor;
    }


, Instance #
frags: 
(startLine=118 endLine=163 srcPath=/root/NewExperiment/elasticsearchFilter/00390/modules/elasticsearch/src/main/java/org/elasticsearch/action/support/single/custom/TransportSingleCustomOperationAction.java)
        private void performFirst() {
            if (request.preferLocalShard()) {
                while (shardsIt.hasNextActive()) {
                    final ShardRouting shard = shardsIt.nextActive();
                    if (shard.currentNodeId().equals(nodes.localNodeId())) {
                        if (request.operationThreaded()) {
                            request.beforeLocalFork();
                            threadPool.execute(new Runnable() {
                                @Override public void run() {
                                    try {
                                        Response response = shardOperation(request, shard.id());
                                        listener.onResponse(response);
                                    } catch (Exception e) {
                                        onFailure(shard, e);
                                    }
                                }
                            });
                            return;
                        } else {
                            try {
                                final Response response = shardOperation(request, shard.id());
                                if (request.listenerThreaded()) {
                                    threadPool.execute(new Runnable() {
                                        @Override public void run() {
                                            listener.onResponse(response);
                                        }
                                    });
                                } else {
                                    listener.onResponse(response);
                                }
                                return;
                            } catch (Exception e) {
                                onFailure(shard, e);
                            }
                        }
                    }
                }
            } else {
                perform(null);
            }
            if (!shardsIt.hasNextActive()) {
                // no local node get, go remote
                shardsIt.reset();
                perform(null);
            }
        }

(startLine=169 endLine=203 srcPath=/root/NewExperiment/elasticsearchFilter/00390/modules/elasticsearch/src/main/java/org/elasticsearch/action/support/single/custom/TransportSingleCustomOperationAction.java)
                if (shard.currentNodeId().equals(nodes.localNodeId())) {
                    // we don't prefer local shard, so try and do it here
                    if (!request.preferLocalShard()) {
                        if (request.operationThreaded()) {
                            request.beforeLocalFork();
                            threadPool.execute(new Runnable() {
                                @Override public void run() {
                                    try {
                                        Response response = shardOperation(request, shard.id());
                                        listener.onResponse(response);
                                    } catch (Exception e) {
                                        onFailure(shard, e);
                                    }
                                }
                            });
                            return;
                        } else {
                            try {
                                final Response response = shardOperation(request, shard.id());
                                if (request.listenerThreaded()) {
                                    threadPool.execute(new Runnable() {
                                        @Override public void run() {
                                            listener.onResponse(response);
                                        }
                                    });
                                } else {
                                    listener.onResponse(response);
                                }
                                return;
                            } catch (Exception e) {
                                onFailure(shard, e);
                            }
                        }
                    }
                } else {

(startLine=122 endLine=162 srcPath=/root/NewExperiment/elasticsearchFilter/00390/modules/elasticsearch/src/main/java/org/elasticsearch/action/support/single/shard/TransportShardSingleOperationAction.java)
        private void performFirst() {
            while (shardIt.hasNextActive()) {
                final ShardRouting shard = shardIt.nextActive();
                if (shard.currentNodeId().equals(nodes.localNodeId())) {
                    if (request.operationThreaded()) {
                        threadPool.execute(new Runnable() {
                            @Override public void run() {
                                try {
                                    Response response = shardOperation(request, shard.id());
                                    listener.onResponse(response);
                                } catch (Exception e) {
                                    onFailure(shard, e);
                                }
                            }
                        });
                        return;
                    } else {
                        try {
                            final Response response = shardOperation(request, shard.id());
                            if (request.listenerThreaded()) {
                                threadPool.execute(new Runnable() {
                                    @Override public void run() {
                                        listener.onResponse(response);
                                    }
                                });
                            } else {
                                listener.onResponse(response);
                            }
                            return;
                        } catch (Exception e) {
                            onFailure(shard, e);
                        }
                    }
                }
            }
            if (!shardIt.hasNextActive()) {
                // no local node get, go remote
                shardIt.reset();
                perform(null);
            }
        }

commonMethod: 
(startLine=87 endLine=93 srcPath=/root/NewExperiment/elasticsearchFilter/00391/modules/elasticsearch/src/main/java/org/elasticsearch/threadpool/ThreadPool.java)
    public Executor executor(String name) {
        Executor executor = executors.get(name);
        if (executor == null) {
            throw new ElasticSearchIllegalArgumentException("No executor found for [" + name + "]");
        }
        return executor;
    }


, Instance #
frags: 
(startLine=126 endLine=182 srcPath=/root/NewExperiment/elasticsearchFilter/00390/modules/elasticsearch/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java)
        public void start() {
            // count the local operations, and perform the non local ones
            int localOperations = 0;
            for (final ShardIterator shardIt : shardsIts) {
                final ShardRouting shard = shardIt.nextActiveOrNull();
                if (shard != null) {
                    if (shard.currentNodeId().equals(nodes.localNodeId())) {
                        localOperations++;
                    } else {
                        // do the remote operation here, the localAsync flag is not relevant
                        performFirstPhase(shardIt.reset());
                    }
                } else {
                    // really, no shards active in this group
                    onFirstPhaseResult(null, shardIt, null);
                }
            }
            // we have local operations, perform them now
            if (localOperations > 0) {
                if (request.operationThreading() == SearchOperationThreading.SINGLE_THREAD) {
                    request.beforeLocalFork();
                    threadPool.execute(new Runnable() {
                        @Override public void run() {
                            for (final ShardIterator shardIt : shardsIts) {
                                final ShardRouting shard = shardIt.reset().nextActiveOrNull();
                                if (shard != null) {
                                    if (shard.currentNodeId().equals(nodes.localNodeId())) {
                                        performFirstPhase(shardIt.reset());
                                    }
                                }
                            }
                        }
                    });
                } else {
                    boolean localAsync = request.operationThreading() == SearchOperationThreading.THREAD_PER_SHARD;
                    if (localAsync) {
                        request.beforeLocalFork();
                    }
                    for (final ShardIterator shardIt : shardsIts) {
                        final ShardRouting shard = shardIt.reset().nextActiveOrNull();
                        if (shard != null) {
                            if (shard.currentNodeId().equals(nodes.localNodeId())) {
                                if (localAsync) {
                                    threadPool.execute(new Runnable() {
                                        @Override public void run() {
                                            performFirstPhase(shardIt.reset());
                                        }
                                    });
                                } else {
                                    performFirstPhase(shardIt.reset());
                                }
                            }
                        }
                    }
                }
            }
        }

(startLine=165 endLine=217 srcPath=/root/NewExperiment/elasticsearchFilter/00390/modules/elasticsearch/src/main/java/org/elasticsearch/action/support/broadcast/TransportBroadcastOperationAction.java)
        public void start() {
            if (shardsIts.size() == 0) {
                // no shards
                listener.onResponse(newResponse(request, new AtomicReferenceArray(0), clusterState));
            }
            // count the local operations, and perform the non local ones
            int localOperations = 0;
            for (final ShardIterator shardIt : shardsIts) {
                final ShardRouting shard = nextShardOrNull(shardIt);
                if (shard != null) {
                    if (shard.currentNodeId().equals(nodes.localNodeId())) {
                        localOperations++;
                    } else {
                        // do the remote operation here, the localAsync flag is not relevant
                        performOperation(shardIt.reset(), true);
                    }
                } else {
                    // really, no shards active in this group
                    onOperation(null, shardIt, null, false);
                }
            }
            // we have local operations, perform them now
            if (localOperations > 0) {
                if (request.operationThreading() == BroadcastOperationThreading.SINGLE_THREAD) {
                    request.beforeLocalFork();
                    threadPool.execute(new Runnable() {
                        @Override public void run() {
                            for (final ShardIterator shardIt : shardsIts) {
                                final ShardRouting shard = nextShardOrNull(shardIt.reset());
                                if (shard != null) {
                                    if (shard.currentNodeId().equals(nodes.localNodeId())) {
                                        performOperation(shardIt.reset(), false);
                                    }
                                }
                            }
                        }
                    });
                } else {
                    boolean localAsync = request.operationThreading() == BroadcastOperationThreading.THREAD_PER_SHARD;
                    if (localAsync) {
                        request.beforeLocalFork();
                    }
                    for (final ShardIterator shardIt : shardsIts) {
                        final ShardRouting shard = nextShardOrNull(shardIt.reset());
                        if (shard != null) {
                            if (shard.currentNodeId().equals(nodes.localNodeId())) {
                                performOperation(shardIt.reset(), localAsync);
                            }
                        }
                    }
                }
            }
        }

commonMethod: 
(startLine=87 endLine=93 srcPath=/root/NewExperiment/elasticsearchFilter/00391/modules/elasticsearch/src/main/java/org/elasticsearch/threadpool/ThreadPool.java)
    public Executor executor(String name) {
        Executor executor = executors.get(name);
        if (executor == null) {
            throw new ElasticSearchIllegalArgumentException("No executor found for [" + name + "]");
        }
        return executor;
    }


, Instance #
frags: 
(startLine=168 endLine=193 srcPath=/root/NewExperiment/elasticsearchFilter/00402/modules/elasticsearch/src/main/java/org/elasticsearch/rest/action/admin/indices/status/RestIndicesStatusAction.java)
                                if (shardStatus.peerRecoveryStatus() != null) {
                                    PeerRecoveryStatus peerRecoveryStatus = shardStatus.peerRecoveryStatus();
                                    builder.startObject("peer_recovery");
                                    builder.field("stage", peerRecoveryStatus.stage());
                                    builder.field("start_time_in_millis", peerRecoveryStatus.startTime());
                                    builder.field("time", peerRecoveryStatus.time());
                                    builder.field("time_in_millis", peerRecoveryStatus.time().millis());

                                    builder.startObject("index");
                                    builder.field("progress", peerRecoveryStatus.indexRecoveryProgress());
                                    builder.field("size", peerRecoveryStatus.indexSize());
                                    builder.field("size_in_bytes", peerRecoveryStatus.indexSize().bytes());
                                    builder.field("reused_size", peerRecoveryStatus.reusedIndexSize());
                                    builder.field("reused_size_in_bytes", peerRecoveryStatus.reusedIndexSize().bytes());
                                    builder.field("expected_recovered_size", peerRecoveryStatus.expectedRecoveredIndexSize());
                                    builder.field("expected_recovered_size_in_bytes", peerRecoveryStatus.expectedRecoveredIndexSize().bytes());
                                    builder.field("recovered_size", peerRecoveryStatus.recoveredIndexSize());
                                    builder.field("recovered_size_in_bytes", peerRecoveryStatus.recoveredIndexSize().bytes());
                                    builder.endObject();

                                    builder.startObject("translog");
                                    builder.field("recovered", peerRecoveryStatus.recoveredTranslogOperations());
                                    builder.endObject();

                                    builder.endObject();
                                }

(startLine=195 endLine=220 srcPath=/root/NewExperiment/elasticsearchFilter/00402/modules/elasticsearch/src/main/java/org/elasticsearch/rest/action/admin/indices/status/RestIndicesStatusAction.java)
                                if (shardStatus.gatewayRecoveryStatus() != null) {
                                    GatewayRecoveryStatus gatewayRecoveryStatus = shardStatus.gatewayRecoveryStatus();
                                    builder.startObject("gateway_recovery");
                                    builder.field("stage", gatewayRecoveryStatus.stage());
                                    builder.field("start_time_in_millis", gatewayRecoveryStatus.startTime());
                                    builder.field("time", gatewayRecoveryStatus.time());
                                    builder.field("time_in_millis", gatewayRecoveryStatus.time().millis());

                                    builder.startObject("index");
                                    builder.field("progress", gatewayRecoveryStatus.indexRecoveryProgress());
                                    builder.field("size", gatewayRecoveryStatus.indexSize());
                                    builder.field("size_in_bytes", gatewayRecoveryStatus.indexSize().bytes());
                                    builder.field("reused_size", gatewayRecoveryStatus.reusedIndexSize());
                                    builder.field("reused_size_in_bytes", gatewayRecoveryStatus.reusedIndexSize().bytes());
                                    builder.field("expected_recovered_size", gatewayRecoveryStatus.expectedRecoveredIndexSize());
                                    builder.field("expected_recovered_size_in_bytes", gatewayRecoveryStatus.expectedRecoveredIndexSize().bytes());
                                    builder.field("recovered_size", gatewayRecoveryStatus.recoveredIndexSize());
                                    builder.field("recovered_size_in_bytes", gatewayRecoveryStatus.recoveredIndexSize().bytes());
                                    builder.endObject();

                                    builder.startObject("translog");
                                    builder.field("recovered", gatewayRecoveryStatus.recoveredTranslogOperations());
                                    builder.endObject();

                                    builder.endObject();
                                }

commonMethod: 
(startLine=138 endLine=308 srcPath=/root/NewExperiment/elasticsearchFilter/00403/modules/elasticsearch/src/main/java/org/elasticsearch/action/admin/indices/status/IndicesStatusResponse.java)
    public XContentBuilder toXContent(XContentBuilder builder, Params params, @Nullable SettingsFilter settingsFilter) throws IOException {
        builder.startObject(Fields.INDICES);
        for (IndexStatus indexStatus : indices().values()) {
            builder.startObject(indexStatus.index(), XContentBuilder.FieldCaseConversion.NONE);

            builder.array(Fields.ALIASES, indexStatus.settings().getAsArray("index.aliases"));

            builder.startObject(Fields.SETTINGS);
            Settings settings = indexStatus.settings();
            if (settingsFilter != null) {
                settings = settingsFilter.filterSettings(settings);
            }
            for (Map.Entry<String, String> entry : settings.getAsMap().entrySet()) {
                builder.field(entry.getKey(), entry.getValue());
            }
            builder.endObject();

            builder.startObject(Fields.INDEX);
            if (indexStatus.storeSize() != null) {
                builder.field(Fields.PRIMARY_SIZE, indexStatus.primaryStoreSize().toString());
                builder.field(Fields.PRIMARY_SIZE_IN_BYTES, indexStatus.primaryStoreSize().bytes());
                builder.field(Fields.SIZE, indexStatus.storeSize().toString());
                builder.field(Fields.SIZE_IN_BYTES, indexStatus.storeSize().bytes());
            }
            builder.endObject();
            if (indexStatus.translogOperations() != -1) {
                builder.startObject(Fields.TRANSLOG);
                builder.field(Fields.OPERATIONS, indexStatus.translogOperations());
                builder.endObject();
            }

            if (indexStatus.docs() != null) {
                builder.startObject(Fields.DOCS);
                builder.field(Fields.NUM_DOCS, indexStatus.docs().numDocs());
                builder.field(Fields.MAX_DOC, indexStatus.docs().maxDoc());
                builder.field(Fields.DELETED_DOCS, indexStatus.docs().deletedDocs());
                builder.endObject();
            }

            MergeStats mergeStats = indexStatus.mergeStats();
            if (mergeStats != null) {
                mergeStats.toXContent(builder, params);
            }

            builder.startObject(Fields.SHARDS);
            for (IndexShardStatus indexShardStatus : indexStatus) {
                builder.startArray(Integer.toString(indexShardStatus.shardId().id()));
                for (ShardStatus shardStatus : indexShardStatus) {
                    builder.startObject();

                    builder.startObject(Fields.ROUTING)
                            .field(Fields.STATE, shardStatus.shardRouting().state())
                            .field(Fields.PRIMARY, shardStatus.shardRouting().primary())
                            .field(Fields.NODE, shardStatus.shardRouting().currentNodeId())
                            .field(Fields.RELOCATING_NODE, shardStatus.shardRouting().relocatingNodeId())
                            .field(Fields.SHARD, shardStatus.shardRouting().shardId().id())
                            .field(Fields.INDEX, shardStatus.shardRouting().shardId().index().name())
                            .endObject();

                    builder.field(Fields.STATE, shardStatus.state());
                    if (shardStatus.storeSize() != null) {
                        builder.startObject(Fields.INDEX);
                        builder.field(Fields.SIZE, shardStatus.storeSize().toString());
                        builder.field(Fields.SIZE_IN_BYTES, shardStatus.storeSize().bytes());
                        builder.endObject();
                    }
                    if (shardStatus.translogId() != -1) {
                        builder.startObject(Fields.TRANSLOG);
                        builder.field(Fields.ID, shardStatus.translogId());
                        builder.field(Fields.OPERATIONS, shardStatus.translogOperations());
                        builder.endObject();
                    }

                    if (shardStatus.docs() != null) {
                        builder.startObject(Fields.DOCS);
                        builder.field(Fields.NUM_DOCS, shardStatus.docs().numDocs());
                        builder.field(Fields.MAX_DOC, shardStatus.docs().maxDoc());
                        builder.field(Fields.DELETED_DOCS, shardStatus.docs().deletedDocs());
                        builder.endObject();
                    }

                    mergeStats = shardStatus.mergeStats();
                    if (mergeStats != null) {
                        mergeStats.toXContent(builder, params);
                    }

                    if (shardStatus.peerRecoveryStatus() != null) {
                        PeerRecoveryStatus peerRecoveryStatus = shardStatus.peerRecoveryStatus();
                        builder.startObject(Fields.PEER_RECOVERY);
                        builder.field(Fields.STAGE, peerRecoveryStatus.stage());
                        builder.field(Fields.START_TIME_IN_MILLIS, peerRecoveryStatus.startTime());
                        builder.field(Fields.TIME, peerRecoveryStatus.time());
                        builder.field(Fields.TIME_IN_MILLIS, peerRecoveryStatus.time().millis());

                        builder.startObject(Fields.INDEX);
                        builder.field(Fields.PROGRESS, peerRecoveryStatus.indexRecoveryProgress());
                        builder.field(Fields.SIZE, peerRecoveryStatus.indexSize());
                        builder.field(Fields.SIZE_IN_BYTES, peerRecoveryStatus.indexSize().bytes());
                        builder.field(Fields.REUSED_SIZE, peerRecoveryStatus.reusedIndexSize());
                        builder.field(Fields.REUSED_SIZE_IN_BYTES, peerRecoveryStatus.reusedIndexSize().bytes());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE, peerRecoveryStatus.expectedRecoveredIndexSize());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE_IN_BYTES, peerRecoveryStatus.expectedRecoveredIndexSize().bytes());
                        builder.field(Fields.RECOVERED_SIZE, peerRecoveryStatus.recoveredIndexSize());
                        builder.field(Fields.RECOVERED_SIZE_IN_BYTES, peerRecoveryStatus.recoveredIndexSize().bytes());
                        builder.endObject();

                        builder.startObject(Fields.TRANSLOG);
                        builder.field(Fields.RECOVERED, peerRecoveryStatus.recoveredTranslogOperations());
                        builder.endObject();

                        builder.endObject();
                    }

                    if (shardStatus.gatewayRecoveryStatus() != null) {
                        GatewayRecoveryStatus gatewayRecoveryStatus = shardStatus.gatewayRecoveryStatus();
                        builder.startObject(Fields.GATEWAY_RECOVERY);
                        builder.field(Fields.STAGE, gatewayRecoveryStatus.stage());
                        builder.field(Fields.START_TIME_IN_MILLIS, gatewayRecoveryStatus.startTime());
                        builder.field(Fields.TIME, gatewayRecoveryStatus.time());
                        builder.field(Fields.TIME_IN_MILLIS, gatewayRecoveryStatus.time().millis());

                        builder.startObject(Fields.INDEX);
                        builder.field(Fields.PROGRESS, gatewayRecoveryStatus.indexRecoveryProgress());
                        builder.field(Fields.SIZE, gatewayRecoveryStatus.indexSize());
                        builder.field(Fields.SIZE, gatewayRecoveryStatus.indexSize().bytes());
                        builder.field(Fields.REUSED_SIZE, gatewayRecoveryStatus.reusedIndexSize());
                        builder.field(Fields.REUSED_SIZE_IN_BYTES, gatewayRecoveryStatus.reusedIndexSize().bytes());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE, gatewayRecoveryStatus.expectedRecoveredIndexSize());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE_IN_BYTES, gatewayRecoveryStatus.expectedRecoveredIndexSize().bytes());
                        builder.field(Fields.RECOVERED_SIZE, gatewayRecoveryStatus.recoveredIndexSize());
                        builder.field(Fields.RECOVERED_SIZE_IN_BYTES, gatewayRecoveryStatus.recoveredIndexSize().bytes());
                        builder.endObject();

                        builder.startObject(Fields.TRANSLOG);
                        builder.field(Fields.RECOVERED, gatewayRecoveryStatus.recoveredTranslogOperations());
                        builder.endObject();

                        builder.endObject();
                    }

                    if (shardStatus.gatewaySnapshotStatus() != null) {
                        GatewaySnapshotStatus gatewaySnapshotStatus = shardStatus.gatewaySnapshotStatus();
                        builder.startObject(Fields.GATEWAY_SNAPSHOT);
                        builder.field(Fields.STAGE, gatewaySnapshotStatus.stage());
                        builder.field(Fields.START_TIME_IN_MILLIS, gatewaySnapshotStatus.startTime());
                        builder.field(Fields.TIME, gatewaySnapshotStatus.time());
                        builder.field(Fields.TIME_IN_MILLIS, gatewaySnapshotStatus.time().millis());

                        builder.startObject(Fields.INDEX);
                        builder.field(Fields.SIZE, gatewaySnapshotStatus.indexSize());
                        builder.field(Fields.SIZE_IN_BYTES, gatewaySnapshotStatus.indexSize().bytes());
                        builder.endObject();

                        builder.startObject(Fields.TRANSLOG);
                        builder.field(Fields.EXPECTED_OPERATIONS, gatewaySnapshotStatus.expectedNumberOfOperations());
                        builder.endObject();

                        builder.endObject();
                    }

                    builder.endObject();
                }
                builder.endArray();
            }
            builder.endObject();

            builder.endObject();
        }
        builder.endObject();
        return builder;
    }


, Instance #
frags: 
(startLine=48 endLine=61 srcPath=/root/NewExperiment/elasticsearchFilter/00415/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/LZFOutputStream.java)
    public void write(final byte[] buffer, final int offset, final int length) throws IOException {
        int inputCursor = offset;
        int remainingBytes = length;
        while (remainingBytes > 0) {
            if (position >= outputBuffer.length) {
                writeCompressedBlock();
            }
            int chunkLength = (remainingBytes > (outputBuffer.length - position)) ? outputBuffer.length - position : remainingBytes;
            System.arraycopy(buffer, inputCursor, outputBuffer, position, chunkLength);
            position += chunkLength;
            remainingBytes -= chunkLength;
            inputCursor += chunkLength;
        }
    }

(startLine=57 endLine=70 srcPath=/root/NewExperiment/elasticsearchFilter/00415/modules/elasticsearch/src/main/java/org/elasticsearch/common/io/stream/LZFStreamOutput.java)
    @Override public void writeBytes(byte[] b, int offset, int length) throws IOException {
        int inputCursor = offset;
        int remainingBytes = length;
        while (remainingBytes > 0) {
            if (position >= outputBuffer.length) {
                writeCompressedBlock();
            }
            int chunkLength = (remainingBytes > (outputBuffer.length - position)) ? outputBuffer.length - position : remainingBytes;
            System.arraycopy(b, inputCursor, outputBuffer, position, chunkLength);
            position += chunkLength;
            remainingBytes -= chunkLength;
            inputCursor += chunkLength;
        }
    }

commonMethod: 
(startLine=112 endLine=135 srcPath=/root/NewExperiment/elasticsearchFilter/00416/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/ChunkEncoder.java)
    /**
     * Method for encoding individual chunk, writing it to given output stream.
     */
    public void encodeAndWriteChunk(byte[] data, int offset, int len, OutputStream out)
            throws IOException {
        byte[] headerBuf = _headerBuffer;
        if (headerBuf == null) {
            _headerBuffer = headerBuf = new byte[LZFChunk.MAX_HEADER_LEN];
        }
        if (len >= MIN_BLOCK_TO_COMPRESS) {
            /* If we have non-trivial block, and can compress it by at least
             * 2 bytes (since header is 2 bytes longer), let's compress:
             */
            int compLen = tryCompress(data, offset, offset + len, _encodeBuffer, 0);
            if (compLen < (len - 2)) { // nah; just return uncompressed
                LZFChunk.writeCompressedHeader(len, compLen, out, headerBuf);
                out.write(_encodeBuffer, 0, compLen);
                return;
            }
        }
        // Otherwise leave uncompressed:
        LZFChunk.writeNonCompressedHeader(len, out, headerBuf);
        out.write(data, offset, len);
    }


, Instance #
frags: 
(startLine=51 endLine=60 srcPath=/root/NewExperiment/elasticsearchFilter/00415/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/LZFOutputStream.java)
        while (remainingBytes > 0) {
            if (position >= outputBuffer.length) {
                writeCompressedBlock();
            }
            int chunkLength = (remainingBytes > (outputBuffer.length - position)) ? outputBuffer.length - position : remainingBytes;
            System.arraycopy(buffer, inputCursor, outputBuffer, position, chunkLength);
            position += chunkLength;
            remainingBytes -= chunkLength;
            inputCursor += chunkLength;
        }

(startLine=60 endLine=69 srcPath=/root/NewExperiment/elasticsearchFilter/00415/modules/elasticsearch/src/main/java/org/elasticsearch/common/io/stream/LZFStreamOutput.java)
        while (remainingBytes > 0) {
            if (position >= outputBuffer.length) {
                writeCompressedBlock();
            }
            int chunkLength = (remainingBytes > (outputBuffer.length - position)) ? outputBuffer.length - position : remainingBytes;
            System.arraycopy(b, inputCursor, outputBuffer, position, chunkLength);
            position += chunkLength;
            remainingBytes -= chunkLength;
            inputCursor += chunkLength;
        }

commonMethod: 
(startLine=112 endLine=135 srcPath=/root/NewExperiment/elasticsearchFilter/00416/modules/elasticsearch/src/main/java/org/elasticsearch/common/compress/lzf/ChunkEncoder.java)
    /**
     * Method for encoding individual chunk, writing it to given output stream.
     */
    public void encodeAndWriteChunk(byte[] data, int offset, int len, OutputStream out)
            throws IOException {
        byte[] headerBuf = _headerBuffer;
        if (headerBuf == null) {
            _headerBuffer = headerBuf = new byte[LZFChunk.MAX_HEADER_LEN];
        }
        if (len >= MIN_BLOCK_TO_COMPRESS) {
            /* If we have non-trivial block, and can compress it by at least
             * 2 bytes (since header is 2 bytes longer), let's compress:
             */
            int compLen = tryCompress(data, offset, offset + len, _encodeBuffer, 0);
            if (compLen < (len - 2)) { // nah; just return uncompressed
                LZFChunk.writeCompressedHeader(len, compLen, out, headerBuf);
                out.write(_encodeBuffer, 0, compLen);
                return;
            }
        }
        // Otherwise leave uncompressed:
        LZFChunk.writeNonCompressedHeader(len, out, headerBuf);
        out.write(data, offset, len);
    }


, Instance #
frags: 
(startLine=150 endLine=159 srcPath=/root/NewExperiment/elasticsearchFilter/00417/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/longs/TermsLongFacetCollector.java)
        } else {
            // we need to fetch facets of "size * numberOfShards" because of problems in how they are distributed across shards
            BoundedTreeSet<InternalLongTermsFacet.LongEntry> ordered = new BoundedTreeSet<InternalLongTermsFacet.LongEntry>(comparatorType.comparator(), size * numberOfShards);
            for (TLongIntIterator it = facets.iterator(); it.hasNext();) {
                it.advance();
                ordered.add(new InternalLongTermsFacet.LongEntry(it.key(), it.value()));
            }
            pushFacets(facets);
            return new InternalLongTermsFacet(facetName, comparatorType, size, ordered, aggregator.missing());
        }

(startLine=147 endLine=156 srcPath=/root/NewExperiment/elasticsearchFilter/00417/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/ip/TermsIpFacetCollector.java)
        } else {
            // we need to fetch facets of "size * numberOfShards" because of problems in how they are distributed across shards
            BoundedTreeSet<InternalIpTermsFacet.LongEntry> ordered = new BoundedTreeSet<InternalIpTermsFacet.LongEntry>(comparatorType.comparator(), size * numberOfShards);
            for (TLongIntIterator it = facets.iterator(); it.hasNext();) {
                it.advance();
                ordered.add(new InternalIpTermsFacet.LongEntry(it.key(), it.value()));
            }
            pushFacets(facets);
            return new InternalIpTermsFacet(facetName, comparatorType, size, ordered, aggregator.missing());
        }

commonMethod: 
(startLine=215 endLine=223 srcPath=/root/NewExperiment/elasticsearchFilter/00418/modules/elasticsearch/src/main/java/org/elasticsearch/common/CacheRecycler.java)
    public static void pushLongIntMap(TLongIntHashMap map) {
        SoftReference<Deque<TLongIntHashMap>> ref = longIntHashMap.get();
        Deque<TLongIntHashMap> deque = ref == null ? null : ref.get();
        if (deque == null) {
            deque = new ArrayDeque<TLongIntHashMap>();
            longIntHashMap.set(new SoftReference<Deque<TLongIntHashMap>>(deque));
        }
        deque.add(map);
    }


, Instance #
frags: 
(startLine=186 endLine=212 srcPath=/root/NewExperiment/elasticsearchFilter/00425/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/datehistogram/InternalCountDateHistogramFacet.java)
    @Override public Facet reduce(String name, List<Facet> facets) {
        if (facets.size() == 1) {
            return facets.get(0);
        }
        TLongLongHashMap counts = null;

        InternalCountDateHistogramFacet firstHistoFacet = (InternalCountDateHistogramFacet) facets.get(0);
        for (Facet facet : facets) {
            InternalCountDateHistogramFacet histoFacet = (InternalCountDateHistogramFacet) facet;
            if (!histoFacet.counts.isEmpty()) {
                if (counts == null) {
                    counts = histoFacet.counts;
                } else {
                    for (TLongLongIterator it = histoFacet.counts.iterator(); it.hasNext();) {
                        it.advance();
                        counts.adjustOrPutValue(it.key(), it.value(), it.value());
                    }
                }
            }
        }
        if (counts == null) {
            counts = InternalCountDateHistogramFacet.EMPTY_LONG_LONG_MAP;
        }
        firstHistoFacet.counts = counts;

        return firstHistoFacet;
    }

(startLine=187 endLine=213 srcPath=/root/NewExperiment/elasticsearchFilter/00425/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/histogram/unbounded/InternalCountHistogramFacet.java)
    @Override public Facet reduce(String name, List<Facet> facets) {
        if (facets.size() == 1) {
            return facets.get(0);
        }
        TLongLongHashMap counts = null;

        InternalCountHistogramFacet firstHistoFacet = (InternalCountHistogramFacet) facets.get(0);
        for (Facet facet : facets) {
            InternalCountHistogramFacet histoFacet = (InternalCountHistogramFacet) facet;
            if (!histoFacet.counts.isEmpty()) {
                if (counts == null) {
                    counts = histoFacet.counts;
                } else {
                    for (TLongLongIterator it = histoFacet.counts.iterator(); it.hasNext();) {
                        it.advance();
                        counts.adjustOrPutValue(it.key(), it.value(), it.value());
                    }
                }
            }
        }
        if (counts == null) {
            counts = InternalCountHistogramFacet.EMPTY_LONG_LONG_MAP;
        }
        firstHistoFacet.counts = counts;

        return firstHistoFacet;
    }

commonMethod: 
(startLine=108 endLine=121 srcPath=/root/NewExperiment/elasticsearchFilter/00426/modules/elasticsearch/src/main/java/org/elasticsearch/common/CacheRecycler.java)
    public static TLongLongHashMap popLongLongMap() {
        SoftReference<Deque<TLongLongHashMap>> ref = longLongHashMap.get();
        Deque<TLongLongHashMap> deque = ref == null ? null : ref.get();
        if (deque == null) {
            deque = new ArrayDeque<TLongLongHashMap>();
            longLongHashMap.set(new SoftReference<Deque<TLongLongHashMap>>(deque));
        }
        if (deque.isEmpty()) {
            return new TLongLongHashMap();
        }
        TLongLongHashMap map = deque.pollFirst();
        map.clear();
        return map;
    }


, Instance #
frags: 
(startLine=242 endLine=256 srcPath=/root/NewExperiment/elasticsearchFilter/00425/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/datehistogram/InternalCountDateHistogramFacet.java)
    @Override public void readFrom(StreamInput in) throws IOException {
        name = in.readUTF();
        comparatorType = ComparatorType.fromId(in.readByte());

        int size = in.readVInt();
        if (size == 0) {
            counts = EMPTY_LONG_LONG_MAP;
        } else {
            counts = new TLongLongHashMap(size);
            for (int i = 0; i < size; i++) {
                long key = in.readLong();
                counts.put(key, in.readVLong());
            }
        }
    }

(startLine=243 endLine=257 srcPath=/root/NewExperiment/elasticsearchFilter/00425/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/histogram/unbounded/InternalCountHistogramFacet.java)
    @Override public void readFrom(StreamInput in) throws IOException {
        name = in.readUTF();
        comparatorType = ComparatorType.fromId(in.readByte());

        int size = in.readVInt();
        if (size == 0) {
            counts = EMPTY_LONG_LONG_MAP;
        } else {
            counts = new TLongLongHashMap(size);
            for (int i = 0; i < size; i++) {
                long key = in.readLong();
                counts.put(key, in.readVLong());
            }
        }
    }

commonMethod: 
(startLine=108 endLine=121 srcPath=/root/NewExperiment/elasticsearchFilter/00426/modules/elasticsearch/src/main/java/org/elasticsearch/common/CacheRecycler.java)
    public static TLongLongHashMap popLongLongMap() {
        SoftReference<Deque<TLongLongHashMap>> ref = longLongHashMap.get();
        Deque<TLongLongHashMap> deque = ref == null ? null : ref.get();
        if (deque == null) {
            deque = new ArrayDeque<TLongLongHashMap>();
            longLongHashMap.set(new SoftReference<Deque<TLongLongHashMap>>(deque));
        }
        if (deque.isEmpty()) {
            return new TLongLongHashMap();
        }
        TLongLongHashMap map = deque.pollFirst();
        map.clear();
        return map;
    }


, Instance #
frags: 
(startLine=193 endLine=205 srcPath=/root/NewExperiment/elasticsearchFilter/00425/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/datehistogram/InternalCountDateHistogramFacet.java)
        for (Facet facet : facets) {
            InternalCountDateHistogramFacet histoFacet = (InternalCountDateHistogramFacet) facet;
            if (!histoFacet.counts.isEmpty()) {
                if (counts == null) {
                    counts = histoFacet.counts;
                } else {
                    for (TLongLongIterator it = histoFacet.counts.iterator(); it.hasNext();) {
                        it.advance();
                        counts.adjustOrPutValue(it.key(), it.value(), it.value());
                    }
                }
            }
        }

(startLine=194 endLine=206 srcPath=/root/NewExperiment/elasticsearchFilter/00425/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/histogram/unbounded/InternalCountHistogramFacet.java)
        for (Facet facet : facets) {
            InternalCountHistogramFacet histoFacet = (InternalCountHistogramFacet) facet;
            if (!histoFacet.counts.isEmpty()) {
                if (counts == null) {
                    counts = histoFacet.counts;
                } else {
                    for (TLongLongIterator it = histoFacet.counts.iterator(); it.hasNext();) {
                        it.advance();
                        counts.adjustOrPutValue(it.key(), it.value(), it.value());
                    }
                }
            }
        }

commonMethod: 
(startLine=108 endLine=121 srcPath=/root/NewExperiment/elasticsearchFilter/00426/modules/elasticsearch/src/main/java/org/elasticsearch/common/CacheRecycler.java)
    public static TLongLongHashMap popLongLongMap() {
        SoftReference<Deque<TLongLongHashMap>> ref = longLongHashMap.get();
        Deque<TLongLongHashMap> deque = ref == null ? null : ref.get();
        if (deque == null) {
            deque = new ArrayDeque<TLongLongHashMap>();
            longLongHashMap.set(new SoftReference<Deque<TLongLongHashMap>>(deque));
        }
        if (deque.isEmpty()) {
            return new TLongLongHashMap();
        }
        TLongLongHashMap map = deque.pollFirst();
        map.clear();
        return map;
    }


, Instance #
frags: 
(startLine=195 endLine=204 srcPath=/root/NewExperiment/elasticsearchFilter/00428/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/search/facet/TermsFacetSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch()
                    .setQuery(matchAllQuery())
                    .addFacet(termsFacet("s_value").field("s_value").executionHint("map"))
                    .execute().actionGet();
            if (searchResponse.hits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits");
            }
            totalQueryTime += searchResponse.tookInMillis();
        }

(startLine=295 endLine=304 srcPath=/root/NewExperiment/elasticsearchFilter/00428/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/search/facet/TermsFacetSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch()
                    .setQuery(matchAllQuery())
                    .addFacet(termsFacet("sm_value").field("sm_value").executionHint("map"))
                    .execute().actionGet();
            if (searchResponse.hits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits");
            }
            totalQueryTime += searchResponse.tookInMillis();
        }

commonMethod: 
(startLine=180 endLine=218 srcPath=/root/NewExperiment/elasticsearchFilter/00429/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/search/facet/TermsFacetSearchBenchmark.java)
    private static StatsResult terms(String name, String field, String executionHint) {
        long totalQueryTime;// LM VALUE

        client.admin().indices().prepareClearCache().setFieldDataCache(true).execute().actionGet();

        System.out.println("--> Warmup (" + name + ")...");
        // run just the child query, warm up first
        for (int j = 0; j < QUERY_WARMUP; j++) {
            SearchResponse searchResponse = client.prepareSearch()
                    .setSearchType(SearchType.COUNT)
                    .setQuery(matchAllQuery())
                    .addFacet(termsFacet(field).field(field).executionHint(executionHint))
                    .execute().actionGet();
            if (j == 0) {
                System.out.println("--> Loading (" + field + "): took: " + searchResponse.took());
            }
            if (searchResponse.hits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits");
            }
        }
        System.out.println("--> Warmup (" + name + ") DONE");


        System.out.println("--> Running (" + name + ")...");
        totalQueryTime = 0;
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch()
                    .setSearchType(SearchType.COUNT)
                    .setQuery(matchAllQuery())
                    .addFacet(termsFacet(field).field(field).executionHint(executionHint))
                    .execute().actionGet();
            if (searchResponse.hits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits");
            }
            totalQueryTime += searchResponse.tookInMillis();
        }
        System.out.println("--> Terms Facet (" + field + "), hint(" + executionHint + "): " + (totalQueryTime / QUERY_COUNT) + "ms");
        return new StatsResult(name, totalQueryTime);
    }


, Instance #
frags: 
(startLine=147 endLine=158 srcPath=/root/NewExperiment/elasticsearchFilter/00428/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/search/facet/TermsFacetSearchBenchmark.java)
        for (int j = 0; j < QUERY_WARMUP; j++) {
            SearchResponse searchResponse = client.prepareSearch()
                    .setQuery(matchAllQuery())
                    .addFacet(termsFacet("s_value").field("s_value"))
                    .execute().actionGet();
            if (j == 0) {
                System.out.println("--> Loading (s_value) took: " + searchResponse.took());
            }
            if (searchResponse.hits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits");
            }
        }

(startLine=180 endLine=191 srcPath=/root/NewExperiment/elasticsearchFilter/00428/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/search/facet/TermsFacetSearchBenchmark.java)
        for (int j = 0; j < QUERY_WARMUP; j++) {
            SearchResponse searchResponse = client.prepareSearch()
                    .setQuery(matchAllQuery())
                    .addFacet(termsFacet("s_value").field("s_value").executionHint("map"))
                    .execute().actionGet();
            if (j == 0) {
                System.out.println("--> Loading (s_value) took: " + searchResponse.took());
            }
            if (searchResponse.hits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits");
            }
        }

(startLine=245 endLine=256 srcPath=/root/NewExperiment/elasticsearchFilter/00428/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/search/facet/TermsFacetSearchBenchmark.java)
        for (int j = 0; j < QUERY_WARMUP; j++) {
            SearchResponse searchResponse = client.prepareSearch()
                    .setQuery(matchAllQuery())
                    .addFacet(termsFacet("sm_value").field("sm_value"))
                    .execute().actionGet();
            if (j == 0) {
                System.out.println("--> Loading (sm_value) took: " + searchResponse.took());
            }
            if (searchResponse.hits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits");
            }
        }

(startLine=279 endLine=290 srcPath=/root/NewExperiment/elasticsearchFilter/00428/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/search/facet/TermsFacetSearchBenchmark.java)
        for (int j = 0; j < QUERY_WARMUP; j++) {
            SearchResponse searchResponse = client.prepareSearch()
                    .setQuery(matchAllQuery())
                    .addFacet(termsFacet("sm_value").field("sm_value").executionHint("map"))
                    .execute().actionGet();
            if (j == 0) {
                System.out.println("--> Loading (sm_value) took: " + searchResponse.took());
            }
            if (searchResponse.hits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits");
            }
        }

(startLine=314 endLine=325 srcPath=/root/NewExperiment/elasticsearchFilter/00428/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/search/facet/TermsFacetSearchBenchmark.java)
        for (int j = 0; j < QUERY_WARMUP; j++) {
            SearchResponse searchResponse = client.prepareSearch()
                    .setQuery(matchAllQuery())
                    .addFacet(termsFacet("lm_value").field("lm_value"))
                    .execute().actionGet();
            if (j == 0) {
                System.out.println("--> Loading (lm_value) took: " + searchResponse.took());
            }
            if (searchResponse.hits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits");
            }
        }

commonMethod: 
(startLine=180 endLine=218 srcPath=/root/NewExperiment/elasticsearchFilter/00429/modules/benchmark/micro/src/main/java/org/elasticsearch/benchmark/search/facet/TermsFacetSearchBenchmark.java)
    private static StatsResult terms(String name, String field, String executionHint) {
        long totalQueryTime;// LM VALUE

        client.admin().indices().prepareClearCache().setFieldDataCache(true).execute().actionGet();

        System.out.println("--> Warmup (" + name + ")...");
        // run just the child query, warm up first
        for (int j = 0; j < QUERY_WARMUP; j++) {
            SearchResponse searchResponse = client.prepareSearch()
                    .setSearchType(SearchType.COUNT)
                    .setQuery(matchAllQuery())
                    .addFacet(termsFacet(field).field(field).executionHint(executionHint))
                    .execute().actionGet();
            if (j == 0) {
                System.out.println("--> Loading (" + field + "): took: " + searchResponse.took());
            }
            if (searchResponse.hits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits");
            }
        }
        System.out.println("--> Warmup (" + name + ") DONE");


        System.out.println("--> Running (" + name + ")...");
        totalQueryTime = 0;
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch()
                    .setSearchType(SearchType.COUNT)
                    .setQuery(matchAllQuery())
                    .addFacet(termsFacet(field).field(field).executionHint(executionHint))
                    .execute().actionGet();
            if (searchResponse.hits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits");
            }
            totalQueryTime += searchResponse.tookInMillis();
        }
        System.out.println("--> Terms Facet (" + field + "), hint(" + executionHint + "): " + (totalQueryTime / QUERY_COUNT) + "ms");
        return new StatsResult(name, totalQueryTime);
    }


, Instance #
frags: 
(startLine=42 endLine=53 srcPath=/root/NewExperiment/elasticsearchFilter/00445/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/GermanAnalyzerProvider.java)
    @Inject public GermanAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name, settings);
        Set<?> stopWords = Analysis.parseStopWords(settings, GermanAnalyzer.getDefaultStopSet());

        String[] stemExclusion = settings.getAsArray("stem_exclusion");
        if (stemExclusion.length > 0) {
            this.stemExclusion = ImmutableSet.copyOf(Iterators.forArray(stemExclusion));
        } else {
            this.stemExclusion = ImmutableSet.of();
        }
        analyzer = new GermanAnalyzer(version, stopWords, this.stemExclusion);
    }

(startLine=42 endLine=52 srcPath=/root/NewExperiment/elasticsearchFilter/00445/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/BrazilianAnalyzerProvider.java)
    @Inject public BrazilianAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name, settings);
        Set<?> stopWords = Analysis.parseStopWords(settings, BrazilianAnalyzer.getDefaultStopSet());
        String[] stemExclusion = settings.getAsArray("stem_exclusion");
        if (stemExclusion.length > 0) {
            this.stemExclusion = ImmutableSet.copyOf(Iterators.forArray(stemExclusion));
        } else {
            this.stemExclusion = ImmutableSet.of();
        }
        analyzer = new BrazilianAnalyzer(version, stopWords, this.stemExclusion);
    }

(startLine=42 endLine=53 srcPath=/root/NewExperiment/elasticsearchFilter/00445/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/DutchAnalyzerProvider.java)
    @Inject public DutchAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name, settings);
        Set<?> stopWords = Analysis.parseStopWords(settings, DutchAnalyzer.getDefaultStopSet());

        String[] stemExclusion = settings.getAsArray("stem_exclusion");
        if (stemExclusion.length > 0) {
            this.stemExclusion = ImmutableSet.copyOf(Iterators.forArray(stemExclusion));
        } else {
            this.stemExclusion = ImmutableSet.of();
        }
        analyzer = new DutchAnalyzer(version, stopWords, this.stemExclusion);
    }

(startLine=42 endLine=53 srcPath=/root/NewExperiment/elasticsearchFilter/00445/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/FrenchAnalyzerProvider.java)
    @Inject public FrenchAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name, settings);
        Set<?> stopWords = Analysis.parseStopWords(settings, FrenchAnalyzer.getDefaultStopSet());

        String[] stemExclusion = settings.getAsArray("stem_exclusion");
        if (stemExclusion.length > 0) {
            this.stemExclusion = ImmutableSet.copyOf(Iterators.forArray(stemExclusion));
        } else {
            this.stemExclusion = ImmutableSet.of();
        }
        analyzer = new FrenchAnalyzer(version, stopWords, this.stemExclusion);
    }

commonMethod: 
(startLine=45 endLine=60 srcPath=/root/NewExperiment/elasticsearchFilter/00446/modules/elasticsearch/src/main/java/org/elasticsearch/index/analysis/Analysis.java)
    public static Set<?> parseStemExclusion(Settings settings, Set<?> defaultStemExclusion) {
        String value = settings.get("stem_exclusion");
        if (value != null) {
            if ("_none_".equals(value)) {
                return ImmutableSet.of();
            } else {
                return ImmutableSet.copyOf(Strings.commaDelimitedListToSet(value));
            }
        }
        String[] stopWords = settings.getAsArray("stem_exclusion", null);
        if (stopWords != null) {
            return ImmutableSet.copyOf(Iterators.forArray(stopWords));
        } else {
            return defaultStemExclusion;
        }
    }


, Instance #
frags: 
(startLine=57 endLine=76 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java)
    @Override protected void doMerge(MergePolicy.OneMerge merge) throws IOException {
        long time = System.currentTimeMillis();
        currentMerges.incrementAndGet();
        if (logger.isTraceEnabled()) {
            logger.trace("merge [{}] starting...", merge.info.name);
        }
        try {
            super.doMerge(merge);
        } finally {
            currentMerges.decrementAndGet();
            totalMerges.incrementAndGet();
            long took = System.currentTimeMillis() - time;
            totalMergeTime.addAndGet(took);
            if (took > 20000) { // if more than 20 seconds, DEBUG log it
                logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            } else if (logger.isTraceEnabled()) {
                logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            }
        }
    }

(startLine=59 endLine=85 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java)
    synchronized public void merge(IndexWriter writer) throws CorruptIndexException, IOException {
        while (true) {
            MergePolicy.OneMerge merge = writer.getNextMerge();
            if (merge == null)
                break;

            if (logger.isTraceEnabled()) {
                logger.trace("merge [{}] starting...", merge.info.name);
            }

            long time = System.currentTimeMillis();
            currentMerges.incrementAndGet();
            try {
                writer.merge(merge);
            } finally {
                currentMerges.decrementAndGet();
                totalMerges.incrementAndGet();
                long took = System.currentTimeMillis() - time;
                totalMergeTime.addAndGet(took);
                if (took > 20000) { // if more than 20 seconds, DEBUG log it
                    logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                } else if (logger.isTraceEnabled()) {
                    logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                }
            }
        }
    }

commonMethod: 
(startLine=30 endLine=32 srcPath=/root/NewExperiment/elasticsearchFilter/00514/modules/elasticsearch/src/main/java/org/elasticsearch/common/metrics/CounterMetric.java)
    public void inc() {
        counter.increment();
    }


, Instance #
frags: 
(startLine=57 endLine=76 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java)
    @Override protected void doMerge(MergePolicy.OneMerge merge) throws IOException {
        long time = System.currentTimeMillis();
        currentMerges.incrementAndGet();
        if (logger.isTraceEnabled()) {
            logger.trace("merge [{}] starting...", merge.info.name);
        }
        try {
            super.doMerge(merge);
        } finally {
            currentMerges.decrementAndGet();
            totalMerges.incrementAndGet();
            long took = System.currentTimeMillis() - time;
            totalMergeTime.addAndGet(took);
            if (took > 20000) { // if more than 20 seconds, DEBUG log it
                logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            } else if (logger.isTraceEnabled()) {
                logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            }
        }
    }

(startLine=59 endLine=85 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java)
    synchronized public void merge(IndexWriter writer) throws CorruptIndexException, IOException {
        while (true) {
            MergePolicy.OneMerge merge = writer.getNextMerge();
            if (merge == null)
                break;

            if (logger.isTraceEnabled()) {
                logger.trace("merge [{}] starting...", merge.info.name);
            }

            long time = System.currentTimeMillis();
            currentMerges.incrementAndGet();
            try {
                writer.merge(merge);
            } finally {
                currentMerges.decrementAndGet();
                totalMerges.incrementAndGet();
                long took = System.currentTimeMillis() - time;
                totalMergeTime.addAndGet(took);
                if (took > 20000) { // if more than 20 seconds, DEBUG log it
                    logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                } else if (logger.isTraceEnabled()) {
                    logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                }
            }
        }
    }

commonMethod: 
(startLine=31 endLine=34 srcPath=/root/NewExperiment/elasticsearchFilter/00514/modules/elasticsearch/src/main/java/org/elasticsearch/common/metrics/MeanMetric.java)
    public void inc(long n) {
        counter.increment();
        sum.add(n);
    }


, Instance #
frags: 
(startLine=57 endLine=76 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java)
    @Override protected void doMerge(MergePolicy.OneMerge merge) throws IOException {
        long time = System.currentTimeMillis();
        currentMerges.incrementAndGet();
        if (logger.isTraceEnabled()) {
            logger.trace("merge [{}] starting...", merge.info.name);
        }
        try {
            super.doMerge(merge);
        } finally {
            currentMerges.decrementAndGet();
            totalMerges.incrementAndGet();
            long took = System.currentTimeMillis() - time;
            totalMergeTime.addAndGet(took);
            if (took > 20000) { // if more than 20 seconds, DEBUG log it
                logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            } else if (logger.isTraceEnabled()) {
                logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            }
        }
    }

(startLine=59 endLine=85 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java)
    synchronized public void merge(IndexWriter writer) throws CorruptIndexException, IOException {
        while (true) {
            MergePolicy.OneMerge merge = writer.getNextMerge();
            if (merge == null)
                break;

            if (logger.isTraceEnabled()) {
                logger.trace("merge [{}] starting...", merge.info.name);
            }

            long time = System.currentTimeMillis();
            currentMerges.incrementAndGet();
            try {
                writer.merge(merge);
            } finally {
                currentMerges.decrementAndGet();
                totalMerges.incrementAndGet();
                long took = System.currentTimeMillis() - time;
                totalMergeTime.addAndGet(took);
                if (took > 20000) { // if more than 20 seconds, DEBUG log it
                    logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                } else if (logger.isTraceEnabled()) {
                    logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                }
            }
        }
    }

commonMethod: 
(startLine=38 endLine=40 srcPath=/root/NewExperiment/elasticsearchFilter/00514/modules/elasticsearch/src/main/java/org/elasticsearch/common/metrics/CounterMetric.java)
    public void dec() {
        counter.decrement();
    }


, Instance #
frags: 
(startLine=65 endLine=75 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java)
        } finally {
            currentMerges.decrementAndGet();
            totalMerges.incrementAndGet();
            long took = System.currentTimeMillis() - time;
            totalMergeTime.addAndGet(took);
            if (took > 20000) { // if more than 20 seconds, DEBUG log it
                logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            } else if (logger.isTraceEnabled()) {
                logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            }
        }

(startLine=73 endLine=83 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java)
            } finally {
                currentMerges.decrementAndGet();
                totalMerges.incrementAndGet();
                long took = System.currentTimeMillis() - time;
                totalMergeTime.addAndGet(took);
                if (took > 20000) { // if more than 20 seconds, DEBUG log it
                    logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                } else if (logger.isTraceEnabled()) {
                    logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                }
            }

commonMethod: 
(startLine=30 endLine=32 srcPath=/root/NewExperiment/elasticsearchFilter/00514/modules/elasticsearch/src/main/java/org/elasticsearch/common/metrics/CounterMetric.java)
    public void inc() {
        counter.increment();
    }


, Instance #
frags: 
(startLine=65 endLine=75 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java)
        } finally {
            currentMerges.decrementAndGet();
            totalMerges.incrementAndGet();
            long took = System.currentTimeMillis() - time;
            totalMergeTime.addAndGet(took);
            if (took > 20000) { // if more than 20 seconds, DEBUG log it
                logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            } else if (logger.isTraceEnabled()) {
                logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            }
        }

(startLine=73 endLine=83 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java)
            } finally {
                currentMerges.decrementAndGet();
                totalMerges.incrementAndGet();
                long took = System.currentTimeMillis() - time;
                totalMergeTime.addAndGet(took);
                if (took > 20000) { // if more than 20 seconds, DEBUG log it
                    logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                } else if (logger.isTraceEnabled()) {
                    logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                }
            }

commonMethod: 
(startLine=31 endLine=34 srcPath=/root/NewExperiment/elasticsearchFilter/00514/modules/elasticsearch/src/main/java/org/elasticsearch/common/metrics/MeanMetric.java)
    public void inc(long n) {
        counter.increment();
        sum.add(n);
    }


, Instance #
frags: 
(startLine=65 endLine=75 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingConcurrentMergeScheduler.java)
        } finally {
            currentMerges.decrementAndGet();
            totalMerges.incrementAndGet();
            long took = System.currentTimeMillis() - time;
            totalMergeTime.addAndGet(took);
            if (took > 20000) { // if more than 20 seconds, DEBUG log it
                logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            } else if (logger.isTraceEnabled()) {
                logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
            }
        }

(startLine=73 endLine=83 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/apache/lucene/index/TrackingSerialMergeScheduler.java)
            } finally {
                currentMerges.decrementAndGet();
                totalMerges.incrementAndGet();
                long took = System.currentTimeMillis() - time;
                totalMergeTime.addAndGet(took);
                if (took > 20000) { // if more than 20 seconds, DEBUG log it
                    logger.debug("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                } else if (logger.isTraceEnabled()) {
                    logger.trace("merge [{}] done, took [{}]", merge.info.name, TimeValue.timeValueMillis(took));
                }
            }

commonMethod: 
(startLine=38 endLine=40 srcPath=/root/NewExperiment/elasticsearchFilter/00514/modules/elasticsearch/src/main/java/org/elasticsearch/common/metrics/CounterMetric.java)
    public void dec() {
        counter.decrement();
    }


, Instance #
frags: 
(startLine=87 endLine=105 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/support/AbstractWeightedFilterCache.java)
    @Override public void clear() {
        for (Object readerKey : seenReaders.keySet()) {
            Boolean removed = seenReaders.remove(readerKey);
            if (removed == null) {
                return;
            }
            seenReadersCount.decrementAndGet();
            ConcurrentMap<FilterCacheKey, FilterCacheValue<DocSet>> cache = cache();
            for (FilterCacheKey key : cache.keySet()) {
                if (key.readerKey() == readerKey) {
                    FilterCacheValue<DocSet> removed2 = cache.remove(key);
                    if (removed2 != null) {
                        totalCount.decrementAndGet();
                        totalSizeInBytes.addAndGet(-removed2.value().sizeInBytes());
                    }
                }
            }
        }
    }

(startLine=111 endLine=129 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/support/AbstractWeightedFilterCache.java)
    @Override public void clear(IndexReader reader) {
        // we add the seen reader before we add the first cache entry for this reader
        // so, if we don't see it here, its won't be in the cache
        Boolean removed = seenReaders.remove(reader.getCoreCacheKey());
        if (removed == null) {
            return;
        }
        seenReadersCount.decrementAndGet();
        ConcurrentMap<FilterCacheKey, FilterCacheValue<DocSet>> cache = cache();
        for (FilterCacheKey key : cache.keySet()) {
            if (key.readerKey() == reader.getCoreCacheKey()) {
                FilterCacheValue<DocSet> removed2 = cache.remove(key);
                if (removed2 != null) {
                    totalCount.decrementAndGet();
                    totalSizeInBytes.addAndGet(-removed2.value().sizeInBytes());
                }
            }
        }
    }

commonMethod: 
(startLine=36 endLine=39 srcPath=/root/NewExperiment/elasticsearchFilter/00514/modules/elasticsearch/src/main/java/org/elasticsearch/common/metrics/MeanMetric.java)
    public void dec(long n) {
        counter.decrement();
        sum.add(-n);
    }


, Instance #
frags: 
(startLine=87 endLine=105 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/support/AbstractWeightedFilterCache.java)
    @Override public void clear() {
        for (Object readerKey : seenReaders.keySet()) {
            Boolean removed = seenReaders.remove(readerKey);
            if (removed == null) {
                return;
            }
            seenReadersCount.decrementAndGet();
            ConcurrentMap<FilterCacheKey, FilterCacheValue<DocSet>> cache = cache();
            for (FilterCacheKey key : cache.keySet()) {
                if (key.readerKey() == readerKey) {
                    FilterCacheValue<DocSet> removed2 = cache.remove(key);
                    if (removed2 != null) {
                        totalCount.decrementAndGet();
                        totalSizeInBytes.addAndGet(-removed2.value().sizeInBytes());
                    }
                }
            }
        }
    }

(startLine=111 endLine=129 srcPath=/root/NewExperiment/elasticsearchFilter/00513/modules/elasticsearch/src/main/java/org/elasticsearch/index/cache/filter/support/AbstractWeightedFilterCache.java)
    @Override public void clear(IndexReader reader) {
        // we add the seen reader before we add the first cache entry for this reader
        // so, if we don't see it here, its won't be in the cache
        Boolean removed = seenReaders.remove(reader.getCoreCacheKey());
        if (removed == null) {
            return;
        }
        seenReadersCount.decrementAndGet();
        ConcurrentMap<FilterCacheKey, FilterCacheValue<DocSet>> cache = cache();
        for (FilterCacheKey key : cache.keySet()) {
            if (key.readerKey() == reader.getCoreCacheKey()) {
                FilterCacheValue<DocSet> removed2 = cache.remove(key);
                if (removed2 != null) {
                    totalCount.decrementAndGet();
                    totalSizeInBytes.addAndGet(-removed2.value().sizeInBytes());
                }
            }
        }
    }

commonMethod: 
(startLine=38 endLine=40 srcPath=/root/NewExperiment/elasticsearchFilter/00514/modules/elasticsearch/src/main/java/org/elasticsearch/common/metrics/CounterMetric.java)
    public void dec() {
        counter.decrement();
    }


, Instance #
frags: 
(startLine=75 endLine=91 srcPath=/root/NewExperiment/elasticsearchFilter/00532/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/search/XBooleanFilter.java)
        if (shouldFilters != null) {
            for (int i = 0; i < shouldFilters.size(); i++) {
                if (res == null) {
                    res = new OpenBitSetDISI(getDISI(shouldFilters, i, reader), reader.maxDoc());
                } else {
                    DocIdSet dis = shouldFilters.get(i).getDocIdSet(reader);
                    if (dis instanceof OpenBitSet) {
                        // optimized case for OpenBitSets
                        res.or((OpenBitSet) dis);
                    } else if (dis instanceof OpenBitDocSet) {
                        res.or(((OpenBitDocSet) dis).set());
                    } else {
                        res.inPlaceOr(getDISI(shouldFilters, i, reader));
                    }
                }
            }
        }

(startLine=112 endLine=128 srcPath=/root/NewExperiment/elasticsearchFilter/00532/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/search/XBooleanFilter.java)
        if (mustFilters != null) {
            for (int i = 0; i < mustFilters.size(); i++) {
                if (res == null) {
                    res = new OpenBitSetDISI(getDISI(mustFilters, i, reader), reader.maxDoc());
                } else {
                    DocIdSet dis = mustFilters.get(i).getDocIdSet(reader);
                    if (dis instanceof OpenBitSet) {
                        // optimized case for OpenBitSets
                        res.and((OpenBitSet) dis);
                    } else if (dis instanceof OpenBitDocSet) {
                        res.and(((OpenBitDocSet) dis).set());
                    } else {
                        res.inPlaceAnd(getDISI(mustFilters, i, reader));
                    }
                }
            }
        }

commonMethod: 
(startLine=34 endLine=41 srcPath=/root/NewExperiment/elasticsearchFilter/00533/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/docset/DocSets.java)
    public static FixedBitSet createFixedBitSet(DocIdSetIterator disi, int numBits) throws IOException {
        FixedBitSet set = new FixedBitSet(numBits);
        int doc;
        while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
            set.set(doc);
        }
        return set;
    }


, Instance #
frags: 
(startLine=79 endLine=89 srcPath=/root/NewExperiment/elasticsearchFilter/00532/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/search/XBooleanFilter.java)
                } else {
                    DocIdSet dis = shouldFilters.get(i).getDocIdSet(reader);
                    if (dis instanceof OpenBitSet) {
                        // optimized case for OpenBitSets
                        res.or((OpenBitSet) dis);
                    } else if (dis instanceof OpenBitDocSet) {
                        res.or(((OpenBitDocSet) dis).set());
                    } else {
                        res.inPlaceOr(getDISI(shouldFilters, i, reader));
                    }
                }

(startLine=98 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/00532/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/search/XBooleanFilter.java)
                } else {
                    DocIdSet dis = notFilters.get(i).getDocIdSet(reader);
                    if (dis instanceof OpenBitSet) {
                        // optimized case for OpenBitSets
                        res.andNot((OpenBitSet) dis);
                    } else if (dis instanceof OpenBitDocSet) {
                        res.andNot(((OpenBitDocSet) dis).set());
                    } else {
                        res.inPlaceNot(getDISI(notFilters, i, reader));
                    }
                }

(startLine=116 endLine=126 srcPath=/root/NewExperiment/elasticsearchFilter/00532/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/search/XBooleanFilter.java)
                } else {
                    DocIdSet dis = mustFilters.get(i).getDocIdSet(reader);
                    if (dis instanceof OpenBitSet) {
                        // optimized case for OpenBitSets
                        res.and((OpenBitSet) dis);
                    } else if (dis instanceof OpenBitDocSet) {
                        res.and(((OpenBitDocSet) dis).set());
                    } else {
                        res.inPlaceAnd(getDISI(mustFilters, i, reader));
                    }
                }

commonMethod: 
(startLine=34 endLine=41 srcPath=/root/NewExperiment/elasticsearchFilter/00533/modules/elasticsearch/src/main/java/org/elasticsearch/common/lucene/docset/DocSets.java)
    public static FixedBitSet createFixedBitSet(DocIdSetIterator disi, int numBits) throws IOException {
        FixedBitSet set = new FixedBitSet(numBits);
        int doc;
        while ((doc = disi.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
            set.set(doc);
        }
        return set;
    }


, Instance #
frags: 
(startLine=73 endLine=119 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/ints/TermsIntFacetCollector.java)
                                  ImmutableSet<String> excluded, String scriptLang, String script, Map<String, Object> params) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms int facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.INT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of int type, can't run terms int facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (script != null) {
            this.script = context.scriptService().search(context.lookup(), scriptLang, script, params);
        } else {
            this.script = null;
        }

        if (this.script == null && excluded.isEmpty()) {
            aggregator = new StaticAggregatorValueProc(CacheRecycler.popIntIntMap());
        } else {
            aggregator = new AggregatorValueProc(CacheRecycler.popIntIntMap(), excluded, this.script);
        }

        if (allTerms) {
            try {
                for (IndexReader reader : context.searcher().subReaders()) {
                    IntFieldData fieldData = (IntFieldData) fieldDataCache.cache(fieldDataType, reader, indexFieldName);
                    fieldData.forEachValue(aggregator);
                }
            } catch (Exception e) {
                throw new FacetPhaseExecutionException(facetName, "failed to load all terms", e);
            }
        }
    }

(startLine=73 endLine=119 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/floats/TermsFloatFacetCollector.java)
                                    ImmutableSet<String> excluded, String scriptLang, String script, Map<String, Object> params) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms float facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.FLOAT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't is not of float type, can't run terms float facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (script != null) {
            this.script = context.scriptService().search(context.lookup(), scriptLang, script, params);
        } else {
            this.script = null;
        }

        if (this.script == null && excluded.isEmpty()) {
            aggregator = new StaticAggregatorValueProc(CacheRecycler.popFloatIntMap());
        } else {
            aggregator = new AggregatorValueProc(CacheRecycler.popFloatIntMap(), excluded, this.script);
        }

        if (allTerms) {
            try {
                for (IndexReader reader : context.searcher().subReaders()) {
                    FloatFieldData fieldData = (FloatFieldData) fieldDataCache.cache(fieldDataType, reader, indexFieldName);
                    fieldData.forEachValue(aggregator);
                }
            } catch (Exception e) {
                throw new FacetPhaseExecutionException(facetName, "failed to load all terms", e);
            }
        }
    }

(startLine=83 endLine=129 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/longs/TermsLongFacetCollector.java)
                                   ImmutableSet<String> excluded, String scriptLang, String script, Map<String, Object> params) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms long facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.LONG) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of long type, can't run terms long facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (script != null) {
            this.script = context.scriptService().search(context.lookup(), scriptLang, script, params);
        } else {
            this.script = null;
        }

        if (this.script == null && excluded.isEmpty()) {
            aggregator = new StaticAggregatorValueProc(CacheRecycler.popLongIntMap());
        } else {
            aggregator = new AggregatorValueProc(CacheRecycler.popLongIntMap(), excluded, this.script);
        }

        if (allTerms) {
            try {
                for (IndexReader reader : context.searcher().subReaders()) {
                    LongFieldData fieldData = (LongFieldData) fieldDataCache.cache(fieldDataType, reader, indexFieldName);
                    fieldData.forEachValue(aggregator);
                }
            } catch (Exception e) {
                throw new FacetPhaseExecutionException(facetName, "failed to load all terms", e);
            }
        }
    }

(startLine=73 endLine=119 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/shorts/TermsShortFacetCollector.java)
                                    ImmutableSet<String> excluded, String scriptLang, String script, Map<String, Object> params) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms short facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.SHORT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of short type, can't run terms short facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (script != null) {
            this.script = context.scriptService().search(context.lookup(), scriptLang, script, params);
        } else {
            this.script = null;
        }

        if (this.script == null && excluded.isEmpty()) {
            aggregator = new StaticAggregatorValueProc(CacheRecycler.popShortIntMap());
        } else {
            aggregator = new AggregatorValueProc(CacheRecycler.popShortIntMap(), excluded, this.script);
        }

        if (allTerms) {
            try {
                for (IndexReader reader : context.searcher().subReaders()) {
                    ShortFieldData fieldData = (ShortFieldData) fieldDataCache.cache(fieldDataType, reader, indexFieldName);
                    fieldData.forEachValue(aggregator);
                }
            } catch (Exception e) {
                throw new FacetPhaseExecutionException(facetName, "failed to load all terms", e);
            }
        }
    }

(startLine=73 endLine=119 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/doubles/TermsDoubleFacetCollector.java)
                                     ImmutableSet<String> excluded, String scriptLang, String script, Map<String, Object> params) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms double facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.DOUBLE) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of double type, can't run terms double facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (script != null) {
            this.script = context.scriptService().search(context.lookup(), scriptLang, script, params);
        } else {
            this.script = null;
        }

        if (this.script == null && excluded.isEmpty()) {
            aggregator = new StaticAggregatorValueProc(CacheRecycler.popDoubleIntMap());
        } else {
            aggregator = new AggregatorValueProc(CacheRecycler.popDoubleIntMap(), excluded, this.script);
        }

        if (allTerms) {
            try {
                for (IndexReader reader : context.searcher().subReaders()) {
                    DoubleFieldData fieldData = (DoubleFieldData) fieldDataCache.cache(fieldDataType, reader, indexFieldName);
                    fieldData.forEachValue(aggregator);
                }
            } catch (Exception e) {
                throw new FacetPhaseExecutionException(facetName, "failed to load all terms", e);
            }
        }
    }

(startLine=70 endLine=116 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/ip/TermsIpFacetCollector.java)
                                 String scriptLang, String script, Map<String, Object> params) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms long facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.LONG) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of long type, can't run terms long facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (script != null) {
            this.script = context.scriptService().search(context.lookup(), scriptLang, script, params);
        } else {
            this.script = null;
        }

        if (this.script == null) {
            aggregator = new StaticAggregatorValueProc(CacheRecycler.popLongIntMap());
        } else {
            aggregator = new AggregatorValueProc(CacheRecycler.popLongIntMap(), this.script);
        }

        if (allTerms) {
            try {
                for (IndexReader reader : context.searcher().subReaders()) {
                    LongFieldData fieldData = (LongFieldData) fieldDataCache.cache(fieldDataType, reader, indexFieldName);
                    fieldData.forEachValue(aggregator);
                }
            } catch (Exception e) {
                throw new FacetPhaseExecutionException(facetName, "failed to load all terms", e);
            }
        }
    }

commonMethod: 
(startLine=538 endLine=540 srcPath=/root/NewExperiment/elasticsearchFilter/00545/modules/elasticsearch/src/main/java/org/elasticsearch/search/internal/SearchContext.java)
    public MapperService.SmartNameFieldMappers smartFieldMappers(String name) {
        return mapperService().smartName(name, types);
    }


, Instance #
frags: 
(startLine=76 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/ints/TermsIntOrdinalsFacetCollector.java)
                                          ImmutableSet<String> excluded) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms int facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.INT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of int type, can't run terms int facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (excluded == null || excluded.isEmpty()) {
            this.excluded = null;
        } else {
            this.excluded = new TIntHashSet(excluded.size());
            for (String s : excluded) {
                this.excluded.add(Integer.parseInt(s));
            }
        }

        // minCount is offset by -1
        if (allTerms) {
            minCount = -1;
        } else {
            minCount = 0;
        }

        this.aggregators = new ArrayList<ReaderAggregator>(context.searcher().subReaders().length);
    }

(startLine=79 endLine=118 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/strings/TermsStringOrdinalsFacetCollector.java)
                                             ImmutableSet<String> excluded, Pattern pattern) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms long facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.STRING) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of string type, can't run terms string facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (excluded == null || excluded.isEmpty()) {
            this.excluded = null;
        } else {
            this.excluded = excluded;
        }
        this.matcher = pattern != null ? pattern.matcher("") : null;

        // minCount is offset by -1
        if (allTerms) {
            minCount = -1;
        } else {
            minCount = 0;
        }

        this.aggregators = new ArrayList<ReaderAggregator>(context.searcher().subReaders().length);
    }

(startLine=76 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/floats/TermsFloatOrdinalsFacetCollector.java)
                                            ImmutableSet<String> excluded) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms float facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.FLOAT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of float type, can't run terms float facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (excluded == null || excluded.isEmpty()) {
            this.excluded = null;
        } else {
            this.excluded = new TFloatHashSet(excluded.size());
            for (String s : excluded) {
                this.excluded.add(Float.parseFloat(s));
            }
        }

        // minCount is offset by -1
        if (allTerms) {
            minCount = -1;
        } else {
            minCount = 0;
        }

        this.aggregators = new ArrayList<ReaderAggregator>(context.searcher().subReaders().length);
    }

(startLine=76 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/longs/TermsLongOrdinalsFacetCollector.java)
                                           ImmutableSet<String> excluded) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms long facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.LONG) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of long type, can't run terms long facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (excluded == null || excluded.isEmpty()) {
            this.excluded = null;
        } else {
            this.excluded = new TLongHashSet(excluded.size());
            for (String s : excluded) {
                this.excluded.add(Long.parseLong(s));
            }
        }

        // minCount is offset by -1
        if (allTerms) {
            minCount = -1;
        } else {
            minCount = 0;
        }

        this.aggregators = new ArrayList<ReaderAggregator>(context.searcher().subReaders().length);
    }

(startLine=76 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/shorts/TermsShortOrdinalsFacetCollector.java)
                                            ImmutableSet<String> excluded) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms short facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.SHORT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of short type, can't run terms short facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (excluded == null || excluded.isEmpty()) {
            this.excluded = null;
        } else {
            this.excluded = new TShortHashSet(excluded.size());
            for (String s : excluded) {
                this.excluded.add(Short.parseShort(s));
            }
        }

        // minCount is offset by -1
        if (allTerms) {
            minCount = -1;
        } else {
            minCount = 0;
        }

        this.aggregators = new ArrayList<ReaderAggregator>(context.searcher().subReaders().length);
    }

(startLine=76 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/doubles/TermsDoubleOrdinalsFacetCollector.java)
                                             ImmutableSet<String> excluded) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms double facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.DOUBLE) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of double type, can't run terms double facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (excluded == null || excluded.isEmpty()) {
            this.excluded = null;
        } else {
            this.excluded = new TDoubleHashSet(excluded.size());
            for (String s : excluded) {
                this.excluded.add(Double.parseDouble(s));
            }
        }

        // minCount is offset by -1
        if (allTerms) {
            minCount = -1;
        } else {
            minCount = 0;
        }

        this.aggregators = new ArrayList<ReaderAggregator>(context.searcher().subReaders().length);
    }

(startLine=76 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/ip/TermsIpOrdinalsFacetCollector.java)
                                         ImmutableSet<String> excluded) {
        super(facetName);
        this.fieldDataCache = context.fieldDataCache();
        this.size = size;
        this.comparatorType = comparatorType;
        this.numberOfShards = context.numberOfShards();

        MapperService.SmartNameFieldMappers smartMappers = context.mapperService().smartName(fieldName);
        if (smartMappers == null || !smartMappers.hasMapper()) {
            throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't have a type, can't run terms long facet collector on it");
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.LONG) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of long type, can't run terms long facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

        if (excluded == null || excluded.isEmpty()) {
            this.excluded = null;
        } else {
            this.excluded = new TLongHashSet(excluded.size());
            for (String s : excluded) {
                this.excluded.add(Long.parseLong(s));
            }
        }

        // minCount is offset by -1
        if (allTerms) {
            minCount = -1;
        } else {
            minCount = 0;
        }

        this.aggregators = new ArrayList<ReaderAggregator>(context.searcher().subReaders().length);
    }

commonMethod: 
(startLine=538 endLine=540 srcPath=/root/NewExperiment/elasticsearchFilter/00545/modules/elasticsearch/src/main/java/org/elasticsearch/search/internal/SearchContext.java)
    public MapperService.SmartNameFieldMappers smartFieldMappers(String name) {
        return mapperService().smartName(name, types);
    }


, Instance #
frags: 
(startLine=86 endLine=98 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/ints/TermsIntOrdinalsFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.INT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of int type, can't run terms int facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=83 endLine=95 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/ints/TermsIntFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.INT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of int type, can't run terms int facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=89 endLine=101 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/strings/TermsStringOrdinalsFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.STRING) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of string type, can't run terms string facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=83 endLine=95 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/bytes/TermsByteFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.BYTE) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of byte type, can't run terms short facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=86 endLine=98 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/bytes/TermsByteOrdinalsFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.BYTE) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of byte type, can't run terms byte facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=86 endLine=98 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/floats/TermsFloatOrdinalsFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.FLOAT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of float type, can't run terms float facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=83 endLine=95 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/floats/TermsFloatFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.FLOAT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] doesn't is not of float type, can't run terms float facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=93 endLine=105 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/longs/TermsLongFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.LONG) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of long type, can't run terms long facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=86 endLine=98 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/longs/TermsLongOrdinalsFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.LONG) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of long type, can't run terms long facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=86 endLine=98 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/shorts/TermsShortOrdinalsFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.SHORT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of short type, can't run terms short facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=83 endLine=95 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/shorts/TermsShortFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.SHORT) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of short type, can't run terms short facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=86 endLine=98 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/doubles/TermsDoubleOrdinalsFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.DOUBLE) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of double type, can't run terms double facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=83 endLine=95 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/doubles/TermsDoubleFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.DOUBLE) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of double type, can't run terms double facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=80 endLine=92 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/ip/TermsIpFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.LONG) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of long type, can't run terms long facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

(startLine=86 endLine=98 srcPath=/root/NewExperiment/elasticsearchFilter/00544/modules/elasticsearch/src/main/java/org/elasticsearch/search/facet/terms/ip/TermsIpOrdinalsFacetCollector.java)
        } else {
            // add type filter if there is exact doc mapper associated with it
            if (smartMappers.hasDocMapper()) {
                setFilter(context.filterCache().cache(smartMappers.docMapper().typeFilter()));
            }

            if (smartMappers.mapper().fieldDataType() != FieldDataType.DefaultTypes.LONG) {
                throw new ElasticSearchIllegalArgumentException("Field [" + fieldName + "] is not of long type, can't run terms long facet collector on it");
            }

            this.indexFieldName = smartMappers.mapper().names().indexName();
            this.fieldDataType = smartMappers.mapper().fieldDataType();
        }

commonMethod: 
(startLine=538 endLine=540 srcPath=/root/NewExperiment/elasticsearchFilter/00545/modules/elasticsearch/src/main/java/org/elasticsearch/search/internal/SearchContext.java)
    public MapperService.SmartNameFieldMappers smartFieldMappers(String name) {
        return mapperService().smartName(name, types);
    }


, Instance #
frags: 
(startLine=90 endLine=105 srcPath=/root/NewExperiment/elasticsearchFilter/00554/modules/elasticsearch/src/main/java/org/elasticsearch/rest/action/admin/indices/mapping/get/RestGetMappingAction.java)
                        for (MappingMetaData mappingMd : indexMetaData.mappings().values()) {
                            if (!types.isEmpty() && !types.contains(mappingMd.type())) {
                                // filter this type out...
                                continue;
                            }
                            foundType = true;
                            byte[] mappingSource = mappingMd.source().uncompressed();
                            XContentParser parser = XContentFactory.xContent(mappingSource).createParser(mappingSource);
                            Map<String, Object> mapping = parser.map();
                            if (mapping.size() == 1 && mapping.containsKey(mappingMd.type())) {
                                // the type name is the root value, reduce it
                                mapping = (Map<String, Object>) mapping.get(mappingMd.type());
                            }
                            builder.field(mappingMd.type());
                            builder.map(mapping);
                        }

(startLine=114 endLine=128 srcPath=/root/NewExperiment/elasticsearchFilter/00554/modules/elasticsearch/src/main/java/org/elasticsearch/rest/action/admin/indices/mapping/get/RestGetMappingAction.java)
                            for (MappingMetaData mappingMd : indexMetaData.mappings().values()) {
                                if (!types.isEmpty() && !types.contains(mappingMd.type())) {
                                    // filter this type out...
                                    continue;
                                }
                                byte[] mappingSource = mappingMd.source().uncompressed();
                                XContentParser parser = XContentFactory.xContent(mappingSource).createParser(mappingSource);
                                Map<String, Object> mapping = parser.map();
                                if (mapping.size() == 1 && mapping.containsKey(mappingMd.type())) {
                                    // the type name is the root value, reduce it
                                    mapping = (Map<String, Object>) mapping.get(mappingMd.type());
                                }
                                builder.field(mappingMd.type());
                                builder.map(mapping);
                            }

commonMethod: 
(startLine=335 endLine=345 srcPath=/root/NewExperiment/elasticsearchFilter/00555/modules/elasticsearch/src/main/java/org/elasticsearch/cluster/metadata/MappingMetaData.java)
    /**
     * Converts the serialized compressed form of the mappings into a parsed map.
     */
    public Map<String, Object> sourceAsMap() throws IOException {
        Map<String, Object> mapping = XContentHelper.convertToMap(source.compressed(), 0, source.compressed().length).v2();
        if (mapping.size() == 1 && mapping.containsKey(type())) {
            // the type name is the root value, reduce it
            mapping = (Map<String, Object>) mapping.get(type());
        }
        return mapping;
    }


, Instance #
frags: 
(startLine=360 endLine=387 srcPath=/root/NewExperiment/elasticsearchFilter/00584/src/main/java/org/elasticsearch/index/translog/Translog.java)
        public void readFrom(StreamInput in) throws IOException {
            int version = in.readVInt(); // version
            id = in.readUTF();
            type = in.readUTF();
            sourceOffset = 0;
            sourceLength = in.readVInt();
            source = new byte[sourceLength];
            in.readFully(source);
            if (version >= 1) {
                if (in.readBoolean()) {
                    routing = in.readUTF();
                }
            }
            if (version >= 2) {
                if (in.readBoolean()) {
                    parent = in.readUTF();
                }
            }
            if (version >= 3) {
                this.version = in.readLong();
            }
            if (version >= 4) {
                this.timestamp = in.readLong();
            }
            if (version >= 5) {
                this.ttl = in.readLong();
            }
        }

(startLine=533 endLine=560 srcPath=/root/NewExperiment/elasticsearchFilter/00584/src/main/java/org/elasticsearch/index/translog/Translog.java)
        public void readFrom(StreamInput in) throws IOException {
            int version = in.readVInt(); // version
            id = in.readUTF();
            type = in.readUTF();
            sourceOffset = 0;
            sourceLength = in.readVInt();
            source = new byte[sourceLength];
            in.readFully(source);
            if (version >= 1) {
                if (in.readBoolean()) {
                    routing = in.readUTF();
                }
            }
            if (version >= 2) {
                if (in.readBoolean()) {
                    parent = in.readUTF();
                }
            }
            if (version >= 3) {
                this.version = in.readLong();
            }
            if (version >= 4) {
                this.timestamp = in.readLong();
            }
            if (version >= 5) {
                this.ttl = in.readLong();
            }
        }

commonMethod: 
(startLine=61 endLine=67 srcPath=/root/NewExperiment/elasticsearchFilter/00585/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java)
    /**
     * Reads a bytes reference from this stream, might hold an actual reference to the underlying
     * bytes of the stream.
     */
    public BytesHolder readBytesReference() throws IOException {
        return readBytesHolder();
    }


, Instance #
frags: 
(startLine=390 endLine=411 srcPath=/root/NewExperiment/elasticsearchFilter/00584/src/main/java/org/elasticsearch/index/translog/Translog.java)
        public void writeTo(StreamOutput out) throws IOException {
            out.writeVInt(5); // version
            out.writeUTF(id);
            out.writeUTF(type);
            out.writeVInt(sourceLength);
            out.writeBytes(source, sourceOffset, sourceLength);
            if (routing == null) {
                out.writeBoolean(false);
            } else {
                out.writeBoolean(true);
                out.writeUTF(routing);
            }
            if (parent == null) {
                out.writeBoolean(false);
            } else {
                out.writeBoolean(true);
                out.writeUTF(parent);
            }
            out.writeLong(version);
            out.writeLong(timestamp);
            out.writeLong(ttl);
        }

(startLine=563 endLine=584 srcPath=/root/NewExperiment/elasticsearchFilter/00584/src/main/java/org/elasticsearch/index/translog/Translog.java)
        public void writeTo(StreamOutput out) throws IOException {
            out.writeVInt(5); // version
            out.writeUTF(id);
            out.writeUTF(type);
            out.writeVInt(sourceLength);
            out.writeBytes(source, sourceOffset, sourceLength);
            if (routing == null) {
                out.writeBoolean(false);
            } else {
                out.writeBoolean(true);
                out.writeUTF(routing);
            }
            if (parent == null) {
                out.writeBoolean(false);
            } else {
                out.writeBoolean(true);
                out.writeUTF(parent);
            }
            out.writeLong(version);
            out.writeLong(timestamp);
            out.writeLong(ttl);
        }

commonMethod: 
(startLine=74 endLine=81 srcPath=/root/NewExperiment/elasticsearchFilter/00585/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java)
    public void writeBytesHolder(@Nullable BytesHolder bytes) throws IOException {
        if (bytes == null) {
            writeVInt(0);
        } else {
            writeVInt(bytes.length());
            writeBytes(bytes.bytes(), bytes.offset(), bytes.length());
        }
    }


, Instance #
frags: 
(startLine=126 endLine=151 srcPath=/root/NewExperiment/elasticsearchFilter/00585/src/main/java/org/elasticsearch/action/deletebyquery/ShardDeleteByQueryRequest.java)
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeVInt(querySource.length);
        out.writeBytes(querySource);
        out.writeVInt(shardId);
        out.writeVInt(types.length);
        for (String type : types) {
            out.writeUTF(type);
        }
        if (routing != null) {
            out.writeVInt(routing.size());
            for (String r : routing) {
                out.writeUTF(r);
            }
        } else {
            out.writeVInt(0);
        }
        if (filteringAliases != null) {
            out.writeVInt(filteringAliases.length);
            for (String alias : filteringAliases) {
                out.writeUTF(alias);
            }
        } else {
            out.writeVInt(0);
        }
    }

(startLine=134 endLine=158 srcPath=/root/NewExperiment/elasticsearchFilter/00585/src/main/java/org/elasticsearch/action/deletebyquery/IndexDeleteByQueryRequest.java)
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeVInt(querySource.length);
        out.writeBytes(querySource);
        out.writeVInt(types.length);
        for (String type : types) {
            out.writeUTF(type);
        }
        if (routing != null) {
            out.writeVInt(routing.size());
            for (String r : routing) {
                out.writeUTF(r);
            }
        } else {
            out.writeVInt(0);
        }
        if (filteringAliases != null) {
            out.writeVInt(filteringAliases.length);
            for (String alias : filteringAliases) {
                out.writeUTF(alias);
            }
        } else {
            out.writeVInt(0);
        }
    }

commonMethod: 
(startLine=74 endLine=81 srcPath=/root/NewExperiment/elasticsearchFilter/00586/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java)
    public void writeBytesHolder(@Nullable BytesHolder bytes) throws IOException {
        if (bytes == null) {
            writeVInt(0);
        } else {
            writeVInt(bytes.length());
            writeBytes(bytes.bytes(), bytes.offset(), bytes.length());
        }
    }


, Instance #
frags: 
(startLine=209 endLine=216 srcPath=/root/NewExperiment/elasticsearchFilter/00596/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java)
                } catch (Exception e) {
                    StringBuilder sb = new StringBuilder("failed to execute cluster state update, state:\nversion [").append(clusterState.version()).append("], source [").append(source).append("]\n");
                    sb.append(clusterState.nodes().prettyPrint());
                    sb.append(clusterState.routingTable().prettyPrint());
                    sb.append(clusterState.readOnlyRoutingNodes().prettyPrint());
                    logger.warn(sb.toString(), e);
                    return;
                }

(startLine=237 endLine=243 srcPath=/root/NewExperiment/elasticsearchFilter/00596/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java)
                        if (logger.isTraceEnabled()) {
                            StringBuilder sb = new StringBuilder("cluster state updated:\nversion [").append(clusterState.version()).append("], source [").append(source).append("]\n");
                            sb.append(clusterState.nodes().prettyPrint());
                            sb.append(clusterState.routingTable().prettyPrint());
                            sb.append(clusterState.readOnlyRoutingNodes().prettyPrint());
                            logger.trace(sb.toString());
                        } else if (logger.isDebugEnabled()) {

(startLine=301 endLine=307 srcPath=/root/NewExperiment/elasticsearchFilter/00596/src/main/java/org/elasticsearch/cluster/service/InternalClusterService.java)
                    } catch (Exception e) {
                        StringBuilder sb = new StringBuilder("failed to apply updated cluster state:\nversion [").append(clusterState.version()).append("], source [").append(source).append("]\n");
                        sb.append(clusterState.nodes().prettyPrint());
                        sb.append(clusterState.routingTable().prettyPrint());
                        sb.append(clusterState.readOnlyRoutingNodes().prettyPrint());
                        logger.warn(sb.toString(), e);
                    }

commonMethod: 
(startLine=104 endLine=106 srcPath=/root/NewExperiment/elasticsearchFilter/00597/src/main/java/org/elasticsearch/cluster/block/ClusterBlocks.java)
    public boolean hasGlobalBlock(ClusterBlock block) {
        return global.contains(block);
    }


, Instance #
frags: 
(startLine=54 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00599/src/main/java/org/elasticsearch/index/query/IdsQueryParser.java)
    public Query parse(QueryParseContext parseContext) throws IOException, QueryParsingException {
        XContentParser parser = parseContext.parser();

        List<String> ids = new ArrayList<String>();
        Collection<String> types = null;
        String currentFieldName = null;
        float boost = 1.0f;
        XContentParser.Token token;
        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
            if (token == XContentParser.Token.FIELD_NAME) {
                currentFieldName = parser.currentName();
            } else if (token == XContentParser.Token.START_ARRAY) {
                if ("values".equals(currentFieldName)) {
                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                        String value = parser.textOrNull();
                        if (value == null) {
                            throw new QueryParsingException(parseContext.index(), "No value specified for term filter");
                        }
                        ids.add(value);
                    }
                } else if ("types".equals(currentFieldName) || "type".equals(currentFieldName)) {
                    types = new ArrayList<String>();
                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                        String value = parser.textOrNull();
                        if (value == null) {
                            throw new QueryParsingException(parseContext.index(), "No type specified for term filter");
                        }
                        types.add(value);
                    }
                } else {
                    throw new QueryParsingException(parseContext.index(), "[ids] query does not support [" + currentFieldName + "]");
                }
            } else if (token.isValue()) {
                if ("type".equals(currentFieldName) || "_type".equals(currentFieldName)) {
                    types = ImmutableList.of(parser.text());
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else {
                    throw new QueryParsingException(parseContext.index(), "[ids] query does not support [" + currentFieldName + "]");
                }
            }
        }

        if (ids.size() == 0) {
            throw new QueryParsingException(parseContext.index(), "[ids] query, no ids values provided");
        }

        if (types == null || types.isEmpty()) {
            SearchContext searchContext = SearchContext.current();
            if (searchContext.hasTypes()) {
                types = Arrays.asList(searchContext.types());
            } else {
                types = parseContext.mapperService().types();
            }
        } else if (types.size() == 1 && Iterables.getFirst(types, null).equals("_all")) {
            types = parseContext.mapperService().types();
        }

        UidFilter filter = new UidFilter(types, ids, parseContext.indexCache().bloomCache());
        // no need for constant score filter, since we don't cache the filter, and it always takes deletes into account
        ConstantScoreQuery query = new ConstantScoreQuery(filter);
        query.setBoost(boost);
        return query;
    }

(startLine=50 endLine=113 srcPath=/root/NewExperiment/elasticsearchFilter/00599/src/main/java/org/elasticsearch/index/query/IdsFilterParser.java)
    public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {
        XContentParser parser = parseContext.parser();

        List<String> ids = new ArrayList<String>();
        Collection<String> types = null;
        String filterName = null;
        String currentFieldName = null;
        XContentParser.Token token;
        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
            if (token == XContentParser.Token.FIELD_NAME) {
                currentFieldName = parser.currentName();
            } else if (token == XContentParser.Token.START_ARRAY) {
                if ("values".equals(currentFieldName)) {
                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                        String value = parser.textOrNull();
                        if (value == null) {
                            throw new QueryParsingException(parseContext.index(), "No value specified for term filter");
                        }
                        ids.add(value);
                    }
                } else if ("types".equals(currentFieldName) || "type".equals(currentFieldName)) {
                    types = new ArrayList<String>();
                    while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                        String value = parser.textOrNull();
                        if (value == null) {
                            throw new QueryParsingException(parseContext.index(), "No type specified for term filter");
                        }
                        types.add(value);
                    }
                } else {
                    throw new QueryParsingException(parseContext.index(), "[ids] filter does not support [" + currentFieldName + "]");
                }
            } else if (token.isValue()) {
                if ("type".equals(currentFieldName) || "_type".equals(currentFieldName)) {
                    types = ImmutableList.of(parser.text());
                } else if ("_name".equals(currentFieldName)) {
                    filterName = parser.text();
                } else {
                    throw new QueryParsingException(parseContext.index(), "[ids] filter does not support [" + currentFieldName + "]");
                }
            }
        }

        if (ids.size() == 0) {
            throw new QueryParsingException(parseContext.index(), "[ids] filter, no ids values provided");
        }

        if (types == null || types.isEmpty()) {
            SearchContext searchContext = SearchContext.current();
            if (searchContext.hasTypes()) {
                types = Arrays.asList(searchContext.types());
            } else {
                types = parseContext.mapperService().types();
            }
        } else if (types.size() == 1 && Iterables.getFirst(types, null).equals("_all")) {
            types = parseContext.mapperService().types();
        }

        UidFilter filter = new UidFilter(types, ids, parseContext.indexCache().bloomCache());
        if (filterName != null) {
            parseContext.addNamedFilter(filterName, filter);
        }
        return filter;
    }

commonMethod: 
(startLine=263 endLine=272 srcPath=/root/NewExperiment/elasticsearchFilter/00600/src/main/java/org/elasticsearch/index/query/QueryParseContext.java)
    /**
     * Returns the narrowed down explicit types, or, if not set, all types.
     */
    public Collection<String> queryTypes() {
        String[] types = getTypes();
        if (types == null || types.length == 0) {
            return mapperService().types();
        }
        return Arrays.asList(types);
    }


, Instance #
frags: 
(startLine=275 endLine=338 srcPath=/root/NewExperiment/elasticsearchFilter/00620/src/main/java/org/elasticsearch/cluster/metadata/IndexTemplateMetaData.java)
        public static IndexTemplateMetaData fromXContent(XContentParser parser) throws IOException {
            Builder builder = new Builder(parser.currentName());

            String currentFieldName = null;
            XContentParser.Token token = parser.nextToken();
            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                if (token == XContentParser.Token.FIELD_NAME) {
                    currentFieldName = parser.currentName();
                } else if (token == XContentParser.Token.START_OBJECT) {
                    if ("settings".equals(currentFieldName)) {
                        ImmutableSettings.Builder settingsBuilder = ImmutableSettings.settingsBuilder();
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            String key = parser.currentName();
                            token = parser.nextToken();
                            String value = parser.text();
                            settingsBuilder.put(key, value);
                        }
                        builder.settings(settingsBuilder.build());
                    } else if ("mappings".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            if (token == XContentParser.Token.FIELD_NAME) {
                                currentFieldName = parser.currentName();
                            } else if (token == XContentParser.Token.START_OBJECT) {
                                String mappingType = currentFieldName;
                                Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map();
                                builder.putMapping(mappingType, XContentFactory.jsonBuilder().map(mappingSource).string());
                            }
                        }
                    } else {
                        // check if its a custom index metadata
                        IndexMetaData.Custom.Factory<IndexMetaData.Custom> factory = IndexMetaData.lookupFactory(currentFieldName);
                        if (factory == null) {
                            //TODO warn
                            parser.skipChildren();
                        } else {
                            builder.putCustom(factory.type(), factory.fromXContent(parser));
                        }
                    }
                } else if (token == XContentParser.Token.START_ARRAY) {
                    if ("mappings".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                            Map<String, Object> mapping = parser.mapOrdered();
                            if (mapping.size() == 1) {
                                String mappingType = mapping.keySet().iterator().next();
                                String mappingSource = XContentFactory.jsonBuilder().map(mapping).string();

                                if (mappingSource == null) {
                                    // crap, no mapping source, warn?
                                } else {
                                    builder.putMapping(mappingType, mappingSource);
                                }
                            }
                        }
                    }
                } else if (token.isValue()) {
                    if ("template".equals(currentFieldName)) {
                        builder.template(parser.text());
                    } else if ("order".equals(currentFieldName)) {
                        builder.order(parser.intValue());
                    }
                }
            }
            return builder.build();
        }

(startLine=552 endLine=620 srcPath=/root/NewExperiment/elasticsearchFilter/00620/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java)
        public static IndexMetaData fromXContent(XContentParser parser) throws IOException {
            if (parser.currentToken() == XContentParser.Token.START_OBJECT) {
                parser.nextToken();
            }
            Builder builder = new Builder(parser.currentName());

            String currentFieldName = null;
            XContentParser.Token token = parser.nextToken();
            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                if (token == XContentParser.Token.FIELD_NAME) {
                    currentFieldName = parser.currentName();
                } else if (token == XContentParser.Token.START_OBJECT) {
                    if ("settings".equals(currentFieldName)) {
                        ImmutableSettings.Builder settingsBuilder = settingsBuilder();
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            String key = parser.currentName();
                            token = parser.nextToken();
                            String value = parser.text();
                            settingsBuilder.put(key, value);
                        }
                        builder.settings(settingsBuilder.build());
                    } else if ("mappings".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            if (token == XContentParser.Token.FIELD_NAME) {
                                currentFieldName = parser.currentName();
                            } else if (token == XContentParser.Token.START_OBJECT) {
                                String mappingType = currentFieldName;
                                Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map();
                                builder.putMapping(new MappingMetaData(mappingType, mappingSource));
                            }
                        }
                    } else if ("aliases".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            builder.putAlias(AliasMetaData.Builder.fromXContent(parser));
                        }
                    } else {
                        // check if its a custom index metadata
                        Custom.Factory<Custom> factory = lookupFactory(currentFieldName);
                        if (factory == null) {
                            //TODO warn
                            parser.skipChildren();
                        } else {
                            builder.putCustom(factory.type(), factory.fromXContent(parser));
                        }
                    }
                } else if (token == XContentParser.Token.START_ARRAY) {
                    if ("mappings".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {
                            if (token == XContentParser.Token.VALUE_EMBEDDED_OBJECT) {
                                builder.putMapping(new MappingMetaData(new CompressedString(parser.binaryValue())));
                            } else {
                                Map<String, Object> mapping = parser.mapOrdered();
                                if (mapping.size() == 1) {
                                    String mappingType = mapping.keySet().iterator().next();
                                    builder.putMapping(new MappingMetaData(mappingType, mapping));
                                }
                            }
                        }
                    }
                } else if (token.isValue()) {
                    if ("state".equals(currentFieldName)) {
                        builder.state(State.fromString(parser.text()));
                    } else if ("version".equals(currentFieldName)) {
                        builder.version(parser.longValue());
                    }
                }
            }
            return builder.build();
        }

commonMethod: 
(startLine=39 endLine=48 srcPath=/root/NewExperiment/elasticsearchFilter/00621/src/main/java/org/elasticsearch/common/settings/loader/SettingsLoader.java)
        public static Map<String, String> loadNestedFromMap(@Nullable Map map) {
            Map<String, String> settings = newHashMap();
            if (map == null) {
                return settings;
            }
            StringBuilder sb = new StringBuilder();
            List<String> path = newArrayList();
            serializeMap(settings, sb, path, map);
            return settings;
        }


, Instance #
frags: 
(startLine=283 endLine=313 srcPath=/root/NewExperiment/elasticsearchFilter/00620/src/main/java/org/elasticsearch/cluster/metadata/IndexTemplateMetaData.java)
                } else if (token == XContentParser.Token.START_OBJECT) {
                    if ("settings".equals(currentFieldName)) {
                        ImmutableSettings.Builder settingsBuilder = ImmutableSettings.settingsBuilder();
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            String key = parser.currentName();
                            token = parser.nextToken();
                            String value = parser.text();
                            settingsBuilder.put(key, value);
                        }
                        builder.settings(settingsBuilder.build());
                    } else if ("mappings".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            if (token == XContentParser.Token.FIELD_NAME) {
                                currentFieldName = parser.currentName();
                            } else if (token == XContentParser.Token.START_OBJECT) {
                                String mappingType = currentFieldName;
                                Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map();
                                builder.putMapping(mappingType, XContentFactory.jsonBuilder().map(mappingSource).string());
                            }
                        }
                    } else {
                        // check if its a custom index metadata
                        IndexMetaData.Custom.Factory<IndexMetaData.Custom> factory = IndexMetaData.lookupFactory(currentFieldName);
                        if (factory == null) {
                            //TODO warn
                            parser.skipChildren();
                        } else {
                            builder.putCustom(factory.type(), factory.fromXContent(parser));
                        }
                    }
                } else if (token == XContentParser.Token.START_ARRAY) {

(startLine=563 endLine=597 srcPath=/root/NewExperiment/elasticsearchFilter/00620/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java)
                } else if (token == XContentParser.Token.START_OBJECT) {
                    if ("settings".equals(currentFieldName)) {
                        ImmutableSettings.Builder settingsBuilder = settingsBuilder();
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            String key = parser.currentName();
                            token = parser.nextToken();
                            String value = parser.text();
                            settingsBuilder.put(key, value);
                        }
                        builder.settings(settingsBuilder.build());
                    } else if ("mappings".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            if (token == XContentParser.Token.FIELD_NAME) {
                                currentFieldName = parser.currentName();
                            } else if (token == XContentParser.Token.START_OBJECT) {
                                String mappingType = currentFieldName;
                                Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map();
                                builder.putMapping(new MappingMetaData(mappingType, mappingSource));
                            }
                        }
                    } else if ("aliases".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            builder.putAlias(AliasMetaData.Builder.fromXContent(parser));
                        }
                    } else {
                        // check if its a custom index metadata
                        Custom.Factory<Custom> factory = lookupFactory(currentFieldName);
                        if (factory == null) {
                            //TODO warn
                            parser.skipChildren();
                        } else {
                            builder.putCustom(factory.type(), factory.fromXContent(parser));
                        }
                    }
                } else if (token == XContentParser.Token.START_ARRAY) {

(startLine=902 endLine=938 srcPath=/root/NewExperiment/elasticsearchFilter/00620/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java)
            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                if (token == XContentParser.Token.FIELD_NAME) {
                    currentFieldName = parser.currentName();
                } else if (token == XContentParser.Token.START_OBJECT) {
                    if ("settings".equals(currentFieldName)) {
                        ImmutableSettings.Builder settingsBuilder = settingsBuilder();
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            String key = parser.currentName();
                            token = parser.nextToken();
                            String value = parser.text();
                            settingsBuilder.put(key, value);
                        }
                        builder.persistentSettings(settingsBuilder.build());
                    } else if ("indices".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            builder.put(IndexMetaData.Builder.fromXContent(parser), false);
                        }
                    } else if ("templates".equals(currentFieldName)) {
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            builder.put(IndexTemplateMetaData.Builder.fromXContent(parser));
                        }
                    } else {
                        // check if its a custom index metadata
                        Custom.Factory<Custom> factory = lookupFactory(currentFieldName);
                        if (factory == null) {
                            //TODO warn
                            parser.skipChildren();
                        } else {
                            builder.putCustom(factory.type(), factory.fromXContent(parser));
                        }
                    }
                } else if (token.isValue()) {
                    if ("version".equals(currentFieldName)) {
                        builder.version = parser.longValue();
                    }
                }
            }

commonMethod: 
(startLine=39 endLine=48 srcPath=/root/NewExperiment/elasticsearchFilter/00621/src/main/java/org/elasticsearch/common/settings/loader/SettingsLoader.java)
        public static Map<String, String> loadNestedFromMap(@Nullable Map map) {
            Map<String, String> settings = newHashMap();
            if (map == null) {
                return settings;
            }
            StringBuilder sb = new StringBuilder();
            List<String> path = newArrayList();
            serializeMap(settings, sb, path, map);
            return settings;
        }


, Instance #
frags: 
(startLine=906 endLine=915 srcPath=/root/NewExperiment/elasticsearchFilter/00620/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java)
                    if ("settings".equals(currentFieldName)) {
                        ImmutableSettings.Builder settingsBuilder = settingsBuilder();
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            String key = parser.currentName();
                            token = parser.nextToken();
                            String value = parser.text();
                            settingsBuilder.put(key, value);
                        }
                        builder.persistentSettings(settingsBuilder.build());
                    } else if ("indices".equals(currentFieldName)) {

(startLine=284 endLine=293 srcPath=/root/NewExperiment/elasticsearchFilter/00620/src/main/java/org/elasticsearch/cluster/metadata/IndexTemplateMetaData.java)
                    if ("settings".equals(currentFieldName)) {
                        ImmutableSettings.Builder settingsBuilder = ImmutableSettings.settingsBuilder();
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            String key = parser.currentName();
                            token = parser.nextToken();
                            String value = parser.text();
                            settingsBuilder.put(key, value);
                        }
                        builder.settings(settingsBuilder.build());
                    } else if ("mappings".equals(currentFieldName)) {

(startLine=564 endLine=573 srcPath=/root/NewExperiment/elasticsearchFilter/00620/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java)
                    if ("settings".equals(currentFieldName)) {
                        ImmutableSettings.Builder settingsBuilder = settingsBuilder();
                        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                            String key = parser.currentName();
                            token = parser.nextToken();
                            String value = parser.text();
                            settingsBuilder.put(key, value);
                        }
                        builder.settings(settingsBuilder.build());
                    } else if ("mappings".equals(currentFieldName)) {

commonMethod: 
(startLine=39 endLine=48 srcPath=/root/NewExperiment/elasticsearchFilter/00621/src/main/java/org/elasticsearch/common/settings/loader/SettingsLoader.java)
        public static Map<String, String> loadNestedFromMap(@Nullable Map map) {
            Map<String, String> settings = newHashMap();
            if (map == null) {
                return settings;
            }
            StringBuilder sb = new StringBuilder();
            List<String> path = newArrayList();
            serializeMap(settings, sb, path, map);
            return settings;
        }


, Instance #
frags: 
(startLine=41 endLine=54 srcPath=/root/NewExperiment/elasticsearchFilter/00620/src/main/java/org/elasticsearch/common/settings/loader/YamlSettingsLoader.java)
    public Map<String, String> load(String source) throws IOException {
        // replace tabs with whitespace (yaml does not accept tabs, but many users might use it still...)
        source = source.replace("\t", "  ");
        Yaml yaml = new Yaml();
        Map<Object, Object> yamlMap = (Map<Object, Object>) yaml.load(source);
        StringBuilder sb = new StringBuilder();
        Map<String, String> settings = newHashMap();
        if (yamlMap == null) {
            return settings;
        }
        List<String> path = newArrayList();
        serializeMap(settings, sb, path, yamlMap);
        return settings;
    }

(startLine=57 endLine=68 srcPath=/root/NewExperiment/elasticsearchFilter/00620/src/main/java/org/elasticsearch/common/settings/loader/YamlSettingsLoader.java)
    public Map<String, String> load(byte[] source) throws IOException {
        Yaml yaml = new Yaml();
        Map<Object, Object> yamlMap = (Map<Object, Object>) yaml.load(new FastByteArrayInputStream(source));
        StringBuilder sb = new StringBuilder();
        Map<String, String> settings = newHashMap();
        if (yamlMap == null) {
            return settings;
        }
        List<String> path = newArrayList();
        serializeMap(settings, sb, path, yamlMap);
        return settings;
    }

commonMethod: 
(startLine=39 endLine=48 srcPath=/root/NewExperiment/elasticsearchFilter/00621/src/main/java/org/elasticsearch/common/settings/loader/SettingsLoader.java)
        public static Map<String, String> loadNestedFromMap(@Nullable Map map) {
            Map<String, String> settings = newHashMap();
            if (map == null) {
                return settings;
            }
            StringBuilder sb = new StringBuilder();
            List<String> path = newArrayList();
            serializeMap(settings, sb, path, map);
            return settings;
        }


, Instance #
frags: 
(startLine=169 endLine=178 srcPath=/root/NewExperiment/elasticsearchFilter/00629/src/main/java/org/elasticsearch/search/internal/InternalSearchHit.java)
    public BytesHolder sourceRef() {
        if (LZF.isCompressed(source.bytes(), source.offset(), source.length())) {
            try {
                this.source = new BytesHolder(LZFDecoder.decode(source.bytes(), source.offset(), source.length()));
            } catch (IOException e) {
                throw new ElasticSearchParseException("failed to decompress source", e);
            }
        }
        return this.source;
    }

(startLine=170 endLine=179 srcPath=/root/NewExperiment/elasticsearchFilter/00629/src/main/java/org/elasticsearch/index/get/GetResult.java)
    public BytesHolder sourceRef() {
        if (LZF.isCompressed(source.bytes(), source.offset(), source.length())) {
            try {
                this.source = new BytesHolder(LZFDecoder.decode(source.bytes(), source.offset(), source.length()));
            } catch (IOException e) {
                throw new ElasticSearchParseException("failed to decompress source", e);
            }
        }
        return this.source;
    }

commonMethod: 
(startLine=97 endLine=106 srcPath=/root/NewExperiment/elasticsearchFilter/00630/src/main/java/org/elasticsearch/common/compress/CompressorFactory.java)
    /**
     * Uncompress the provided data, data can be detected as compressed using {@link #isCompressed(byte[], int, int)}.
     */
    public static BytesHolder uncompressIfNeeded(BytesHolder bytes) throws IOException {
        Compressor compressor = compressor(bytes);
        if (compressor != null) {
            return new BytesHolder(compressor.uncompress(bytes.bytes(), bytes.offset(), bytes.length()));
        }
        return bytes;
    }


, Instance #
frags: 
(startLine=300 endLine=310 srcPath=/root/NewExperiment/elasticsearchFilter/00643/src/main/java/org/elasticsearch/action/search/SearchRequest.java)
    public SearchRequest source(XContentBuilder builder) {
        try {
            this.source = builder.underlyingBytes();
            this.sourceOffset = 0;
            this.sourceLength = builder.underlyingBytesLength();
            this.sourceUnsafe = false;
            return this;
        } catch (IOException e) {
            throw new ElasticSearchGenerationException("Failed to generate [" + builder + "]", e);
        }
    }

(startLine=379 endLine=389 srcPath=/root/NewExperiment/elasticsearchFilter/00643/src/main/java/org/elasticsearch/action/search/SearchRequest.java)
    public SearchRequest extraSource(XContentBuilder builder) {
        try {
            this.extraSource = builder.underlyingBytes();
            this.extraSourceOffset = 0;
            this.extraSourceLength = builder.underlyingBytesLength();
            this.extraSourceUnsafe = false;
            return this;
        } catch (IOException e) {
            throw new ElasticSearchGenerationException("Failed to generate [" + builder + "]", e);
        }
    }

(startLine=360 endLine=370 srcPath=/root/NewExperiment/elasticsearchFilter/00643/src/main/java/org/elasticsearch/action/mlt/MoreLikeThisRequest.java)
    public MoreLikeThisRequest searchSource(XContentBuilder builder) {
        try {
            this.searchSource = builder.underlyingBytes();
            this.searchSourceOffset = 0;
            this.searchSourceLength = builder.underlyingBytesLength();
            this.searchSourceUnsafe = false;
            return this;
        } catch (IOException e) {
            throw new ElasticSearchGenerationException("Failed to generate [" + builder + "]", e);
        }
    }

(startLine=162 endLine=172 srcPath=/root/NewExperiment/elasticsearchFilter/00643/src/main/java/org/elasticsearch/action/deletebyquery/DeleteByQueryRequest.java)
    public DeleteByQueryRequest query(XContentBuilder builder) {
        try {
            this.querySource = builder.underlyingBytes();
            this.querySourceOffset = 0;
            this.querySourceLength = builder.underlyingBytesLength();
            this.querySourceUnsafe = false;
            return this;
        } catch (IOException e) {
            throw new ElasticSearchGenerationException("Failed to generate [" + builder + "]", e);
        }
    }

(startLine=195 endLine=205 srcPath=/root/NewExperiment/elasticsearchFilter/00643/src/main/java/org/elasticsearch/action/count/CountRequest.java)
    public CountRequest query(XContentBuilder builder) {
        try {
            this.querySource = builder.underlyingBytes();
            this.querySourceOffset = 0;
            this.querySourceLength = builder.underlyingBytesLength();
            this.querySourceUnsafe = false;
            return this;
        } catch (IOException e) {
            throw new ElasticSearchGenerationException("Failed to generate [" + builder + "]", e);
        }
    }

(startLine=149 endLine=159 srcPath=/root/NewExperiment/elasticsearchFilter/00643/src/main/java/org/elasticsearch/action/admin/indices/validate/query/ValidateQueryRequest.java)
    public ValidateQueryRequest query(XContentBuilder builder) {
        try {
            this.querySource = builder.underlyingBytes();
            this.querySourceOffset = 0;
            this.querySourceLength = builder.underlyingBytesLength();
            this.querySourceUnsafe = false;
            return this;
        } catch (IOException e) {
            throw new ElasticSearchGenerationException("Failed to generate [" + builder + "]", e);
        }
    }

commonMethod: 
(startLine=1044 endLine=1048 srcPath=/root/NewExperiment/elasticsearchFilter/00644/src/main/java/org/elasticsearch/common/xcontent/XContentBuilder.java)
    @Override
    public BytesReference bytes() {
        close();
        return ((BytesStream) bos).bytes();
    }


, Instance #
frags: 
(startLine=164 endLine=174 srcPath=/root/NewExperiment/elasticsearchFilter/00664/src/main/java/org/elasticsearch/rest/action/admin/cluster/state/RestClusterStateAction.java)
                            for (Map.Entry<String, CompressedString> entry : templateMetaData.mappings().entrySet()) {
                                byte[] mappingSource = entry.getValue().uncompressed();
                                XContentParser parser = XContentFactory.xContent(mappingSource).createParser(mappingSource);
                                Map<String, Object> mapping = parser.map();
                                if (mapping.size() == 1 && mapping.containsKey(entry.getKey())) {
                                    // the type name is the root value, reduce it
                                    mapping = (Map<String, Object>) mapping.get(entry.getKey());
                                }
                                builder.field(entry.getKey());
                                builder.map(mapping);
                            }

(startLine=196 endLine=206 srcPath=/root/NewExperiment/elasticsearchFilter/00664/src/main/java/org/elasticsearch/rest/action/admin/cluster/state/RestClusterStateAction.java)
                            for (Map.Entry<String, MappingMetaData> entry : indexMetaData.mappings().entrySet()) {
                                byte[] mappingSource = entry.getValue().source().uncompressed();
                                XContentParser parser = XContentFactory.xContent(mappingSource).createParser(mappingSource);
                                Map<String, Object> mapping = parser.map();
                                if (mapping.size() == 1 && mapping.containsKey(entry.getKey())) {
                                    // the type name is the root value, reduce it
                                    mapping = (Map<String, Object>) mapping.get(entry.getKey());
                                }
                                builder.field(entry.getKey());
                                builder.map(mapping);
                            }

commonMethod: 
(startLine=207 endLine=210 srcPath=/root/NewExperiment/elasticsearchFilter/00665/src/main/java/org/elasticsearch/cluster/ClusterState.java)
    public ClusterState settingsFilter(SettingsFilter settingsFilter) {
        this.settingsFilter = settingsFilter;
        return this;
    }


, Instance #
frags: 
(startLine=96 endLine=121 srcPath=/root/NewExperiment/elasticsearchFilter/00682/src/main/java/org/elasticsearch/action/deletebyquery/ShardDeleteByQueryRequest.java)
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        querySource = in.readBytesReference();
        shardId = in.readVInt();
        int typesSize = in.readVInt();
        if (typesSize > 0) {
            types = new String[typesSize];
            for (int i = 0; i < typesSize; i++) {
                types[i] = in.readUTF();
            }
        }
        int routingSize = in.readVInt();
        if (routingSize > 0) {
            routing = new THashSet<String>(routingSize);
            for (int i = 0; i < routingSize; i++) {
                routing.add(in.readUTF());
            }
        }
        int aliasesSize = in.readVInt();
        if (aliasesSize > 0) {
            filteringAliases = new String[aliasesSize];
            for (int i = 0; i < aliasesSize; i++) {
                filteringAliases[i] = in.readUTF();
            }
        }
    }

(startLine=93 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00682/src/main/java/org/elasticsearch/action/deletebyquery/IndexDeleteByQueryRequest.java)
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        querySource = in.readBytesReference();
        int typesSize = in.readVInt();
        if (typesSize > 0) {
            types = new String[typesSize];
            for (int i = 0; i < typesSize; i++) {
                types[i] = in.readUTF();
            }
        }
        int routingSize = in.readVInt();
        if (routingSize > 0) {
            routing = new THashSet<String>(routingSize);
            for (int i = 0; i < routingSize; i++) {
                routing.add(in.readUTF());
            }
        }
        int aliasesSize = in.readVInt();
        if (aliasesSize > 0) {
            filteringAliases = new String[aliasesSize];
            for (int i = 0; i < aliasesSize; i++) {
                filteringAliases[i] = in.readUTF();
            }
        }
    }

commonMethod: 
(startLine=194 endLine=221 srcPath=/root/NewExperiment/elasticsearchFilter/00683/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java)
    public String readString() throws IOException {
        int charCount = readVInt();
        char[] chars = CachedStreamInput.getCharArray(charCount);
        int c, charIndex = 0;
        while (charIndex < charCount) {
            c = readByte() & 0xff;
            switch (c >> 4) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    chars[charIndex++] = (char) c;
                    break;
                case 12:
                case 13:
                    chars[charIndex++] = (char) ((c & 0x1F) << 6 | readByte() & 0x3F);
                    break;
                case 14:
                    chars[charIndex++] = (char) ((c & 0x0F) << 12 | (readByte() & 0x3F) << 6 | (readByte() & 0x3F) << 0);
                    break;
            }
        }
        return new String(chars, 0, charCount);
    }


, Instance #
frags: 
(startLine=107 endLine=150 srcPath=/root/NewExperiment/elasticsearchFilter/00686/src/main/java/org/elasticsearch/index/cache/id/simple/SimpleIdCache.java)
                for (IndexReader reader : readers) {
                    if (idReaders.containsKey(reader.getCoreCacheKey())) {
                        // no need, continue
                        continue;
                    }

                    if (reader instanceof SegmentReader) {
                        ((SegmentReader) reader).addCoreClosedListener(this);
                    }
                    HashMap<String, TypeBuilder> readerBuilder = new HashMap<String, TypeBuilder>();
                    builders.put(reader.getCoreCacheKey(), readerBuilder);

                    String field = StringHelper.intern(UidFieldMapper.NAME);
                    TermDocs termDocs = reader.termDocs();
                    TermEnum termEnum = reader.terms(new Term(field));
                    try {
                        do {
                            Term term = termEnum.term();
                            if (term == null || term.field() != field) break;
                            // TODO we can optimize this, since type is the prefix, and we get terms ordered
                            // so, only need to move to the next type once its different
                            Uid uid = Uid.createUid(term.text());

                            TypeBuilder typeBuilder = readerBuilder.get(uid.type());
                            if (typeBuilder == null) {
                                typeBuilder = new TypeBuilder(reader);
                                readerBuilder.put(StringHelper.intern(uid.type()), typeBuilder);
                            }

                            HashedBytesArray idAsBytes = checkIfCanReuse(builders, new HashedBytesArray(uid.id()));
                            termDocs.seek(termEnum);
                            while (termDocs.next()) {
                                // when traversing, make sure to ignore deleted docs, so the key->docId will be correct
                                if (!reader.isDeleted(termDocs.doc())) {
                                    typeBuilder.idToDoc.put(idAsBytes, termDocs.doc());
                                    typeBuilder.docToId[termDocs.doc()] = idAsBytes;
                                }
                            }
                        } while (termEnum.next());
                    } finally {
                        termDocs.close();
                        termEnum.close();
                    }
                }

(startLine=154 endLine=201 srcPath=/root/NewExperiment/elasticsearchFilter/00686/src/main/java/org/elasticsearch/index/cache/id/simple/SimpleIdCache.java)
                for (IndexReader reader : readers) {
                    if (idReaders.containsKey(reader.getCoreCacheKey())) {
                        // no need, continue
                        continue;
                    }

                    Map<String, TypeBuilder> readerBuilder = builders.get(reader.getCoreCacheKey());

                    String field = StringHelper.intern(ParentFieldMapper.NAME);
                    TermDocs termDocs = reader.termDocs();
                    TermEnum termEnum = reader.terms(new Term(field));
                    try {
                        do {
                            Term term = termEnum.term();
                            if (term == null || term.field() != field) break;
                            // TODO we can optimize this, since type is the prefix, and we get terms ordered
                            // so, only need to move to the next type once its different
                            Uid uid = Uid.createUid(term.text());

                            TypeBuilder typeBuilder = readerBuilder.get(uid.type());
                            if (typeBuilder == null) {
                                typeBuilder = new TypeBuilder(reader);
                                readerBuilder.put(StringHelper.intern(uid.type()), typeBuilder);
                            }

                            HashedBytesArray idAsBytes = checkIfCanReuse(builders, new HashedBytesArray(uid.id()));
                            boolean added = false; // optimize for when all the docs are deleted for this id

                            termDocs.seek(termEnum);
                            while (termDocs.next()) {
                                // ignore deleted docs while we are at it
                                if (!reader.isDeleted(termDocs.doc())) {
                                    if (!added) {
                                        typeBuilder.parentIdsValues.add(idAsBytes);
                                        added = true;
                                    }
                                    typeBuilder.parentIdsOrdinals[termDocs.doc()] = typeBuilder.t;
                                }
                            }
                            if (added) {
                                typeBuilder.t++;
                            }
                        } while (termEnum.next());
                    } finally {
                        termDocs.close();
                        termEnum.close();
                    }
                }

commonMethod: 
(startLine=110 endLine=129 srcPath=/root/NewExperiment/elasticsearchFilter/00687/src/main/java/org/elasticsearch/index/mapper/Uid.java)
    public static HashedBytesArray[] splitUidIntoTypeAndId(BytesRef uid) {
        int loc = -1;
        for (int i = uid.offset; i < uid.length; i++) {
            if (uid.bytes[i] == 0x23) { // 0x23 is equal to '#'
                loc = i;
                break;
            }
        }

        if (loc == -1) {
            return null;
        }

        byte[] type = new byte[loc - uid.offset];
        System.arraycopy(uid.bytes, uid.offset, type, 0, type.length);

        byte[] id = new byte[uid.length - type.length -1];
        System.arraycopy(uid.bytes, loc + 1, id, 0, id.length);
        return new HashedBytesArray[]{new HashedBytesArray(type), new HashedBytesArray(id)};
    }


, Instance #
frags: 
(startLine=122 endLine=146 srcPath=/root/NewExperiment/elasticsearchFilter/00686/src/main/java/org/elasticsearch/index/cache/id/simple/SimpleIdCache.java)
                    try {
                        do {
                            Term term = termEnum.term();
                            if (term == null || term.field() != field) break;
                            // TODO we can optimize this, since type is the prefix, and we get terms ordered
                            // so, only need to move to the next type once its different
                            Uid uid = Uid.createUid(term.text());

                            TypeBuilder typeBuilder = readerBuilder.get(uid.type());
                            if (typeBuilder == null) {
                                typeBuilder = new TypeBuilder(reader);
                                readerBuilder.put(StringHelper.intern(uid.type()), typeBuilder);
                            }

                            HashedBytesArray idAsBytes = checkIfCanReuse(builders, new HashedBytesArray(uid.id()));
                            termDocs.seek(termEnum);
                            while (termDocs.next()) {
                                // when traversing, make sure to ignore deleted docs, so the key->docId will be correct
                                if (!reader.isDeleted(termDocs.doc())) {
                                    typeBuilder.idToDoc.put(idAsBytes, termDocs.doc());
                                    typeBuilder.docToId[termDocs.doc()] = idAsBytes;
                                }
                            }
                        } while (termEnum.next());
                    } finally {

(startLine=165 endLine=197 srcPath=/root/NewExperiment/elasticsearchFilter/00686/src/main/java/org/elasticsearch/index/cache/id/simple/SimpleIdCache.java)
                    try {
                        do {
                            Term term = termEnum.term();
                            if (term == null || term.field() != field) break;
                            // TODO we can optimize this, since type is the prefix, and we get terms ordered
                            // so, only need to move to the next type once its different
                            Uid uid = Uid.createUid(term.text());

                            TypeBuilder typeBuilder = readerBuilder.get(uid.type());
                            if (typeBuilder == null) {
                                typeBuilder = new TypeBuilder(reader);
                                readerBuilder.put(StringHelper.intern(uid.type()), typeBuilder);
                            }

                            HashedBytesArray idAsBytes = checkIfCanReuse(builders, new HashedBytesArray(uid.id()));
                            boolean added = false; // optimize for when all the docs are deleted for this id

                            termDocs.seek(termEnum);
                            while (termDocs.next()) {
                                // ignore deleted docs while we are at it
                                if (!reader.isDeleted(termDocs.doc())) {
                                    if (!added) {
                                        typeBuilder.parentIdsValues.add(idAsBytes);
                                        added = true;
                                    }
                                    typeBuilder.parentIdsOrdinals[termDocs.doc()] = typeBuilder.t;
                                }
                            }
                            if (added) {
                                typeBuilder.t++;
                            }
                        } while (termEnum.next());
                    } finally {

commonMethod: 
(startLine=110 endLine=129 srcPath=/root/NewExperiment/elasticsearchFilter/00687/src/main/java/org/elasticsearch/index/mapper/Uid.java)
    public static HashedBytesArray[] splitUidIntoTypeAndId(BytesRef uid) {
        int loc = -1;
        for (int i = uid.offset; i < uid.length; i++) {
            if (uid.bytes[i] == 0x23) { // 0x23 is equal to '#'
                loc = i;
                break;
            }
        }

        if (loc == -1) {
            return null;
        }

        byte[] type = new byte[loc - uid.offset];
        System.arraycopy(uid.bytes, uid.offset, type, 0, type.length);

        byte[] id = new byte[uid.length - type.length -1];
        System.arraycopy(uid.bytes, loc + 1, id, 0, id.length);
        return new HashedBytesArray[]{new HashedBytesArray(type), new HashedBytesArray(id)};
    }


, Instance #
frags: 
(startLine=107 endLine=123 srcPath=/root/NewExperiment/elasticsearchFilter/00693/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceFilter.java)
    public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptedDocs) throws IOException {
        DocSet boundingBoxDocSet = null;
        if (boundingBoxFilter != null) {
            DocIdSet docIdSet = boundingBoxFilter.getDocIdSet(context, acceptedDocs);
            if (docIdSet == null) {
                return null;
            }
            boundingBoxDocSet = DocSets.convert(context.reader(), docIdSet);
        }
        final GeoPointFieldData fieldData = (GeoPointFieldData) fieldDataCache.cache(GeoPointFieldDataType.TYPE, context.reader(), fieldName);
        GeoDistanceDocSet distDocSet = new GeoDistanceDocSet(context.reader().maxDoc(), fieldData, fixedSourceDistance, distanceBoundingCheck, distance);
        if (boundingBoxDocSet == null) {
            return distDocSet;
        } else {
            return new AndDocSet(ImmutableList.of(boundingBoxDocSet, distDocSet));
        }
    }

(startLine=123 endLine=139 srcPath=/root/NewExperiment/elasticsearchFilter/00693/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceRangeFilter.java)
    public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptedDocs) throws IOException {
        DocSet boundingBoxDocSet = null;
        if (boundingBoxFilter != null) {
            DocIdSet docIdSet = boundingBoxFilter.getDocIdSet(context, acceptedDocs);
            if (docIdSet == null) {
                return null;
            }
            boundingBoxDocSet = DocSets.convert(context.reader(), docIdSet);
        }
        final GeoPointFieldData fieldData = (GeoPointFieldData) fieldDataCache.cache(GeoPointFieldDataType.TYPE, context.reader(), fieldName);
        GeoDistanceRangeDocSet distDocSet = new GeoDistanceRangeDocSet(context.reader().maxDoc(), fieldData, fixedSourceDistance, distanceBoundingCheck, inclusiveLowerPoint, inclusiveUpperPoint);
        if (boundingBoxDocSet == null) {
            return distDocSet;
        } else {
            return new AndDocSet(ImmutableList.of(boundingBoxDocSet, distDocSet));
        }
    }

commonMethod: 
(startLine=36 endLine=41 srcPath=/root/NewExperiment/elasticsearchFilter/00694/src/main/java/org/elasticsearch/common/lucene/docset/DocIdSets.java)
    /**
     * Is it an empty {@link DocIdSet}?
     */
    public static boolean isEmpty(@Nullable DocIdSet set) {
        return set == null || set == DocIdSet.EMPTY_DOCIDSET;
    }


, Instance #
frags: 
(startLine=159 endLine=165 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            if (fieldMapper instanceof IpFieldMapper) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsIpFacetCollector(facetName, field, size, comparatorType, allTerms, context, scriptLang, script, params);
                } else {
                    return new TermsIpOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, null);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.LONG) {

(startLine=165 endLine=171 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.LONG) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsLongFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsLongOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.DOUBLE) {

(startLine=177 endLine=183 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.INT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsIntFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsIntOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.FLOAT) {

(startLine=183 endLine=189 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.FLOAT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsFloatFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsFloatOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.SHORT) {

(startLine=189 endLine=195 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.SHORT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsShortFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsShortOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.BYTE) {

(startLine=195 endLine=201 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.BYTE) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsByteFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsByteOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.STRING) {

commonMethod: 
(startLine=358 endLine=360 srcPath=/root/NewExperiment/elasticsearchFilter/00714/src/main/java/org/elasticsearch/search/internal/SearchContext.java)
    public IndexFieldDataService fieldData() {
        return indexService.fieldData();
    }


, Instance #
frags: 
(startLine=159 endLine=165 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            if (fieldMapper instanceof IpFieldMapper) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsIpFacetCollector(facetName, field, size, comparatorType, allTerms, context, scriptLang, script, params);
                } else {
                    return new TermsIpOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, null);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.LONG) {

(startLine=165 endLine=171 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.LONG) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsLongFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsLongOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.DOUBLE) {

(startLine=177 endLine=183 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.INT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsIntFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsIntOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.FLOAT) {

(startLine=183 endLine=189 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.FLOAT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsFloatFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsFloatOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.SHORT) {

(startLine=189 endLine=195 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.SHORT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsShortFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsShortOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.BYTE) {

(startLine=195 endLine=201 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.BYTE) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsByteFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsByteOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.STRING) {

commonMethod: 
(startLine=111 endLine=113 srcPath=/root/NewExperiment/elasticsearchFilter/00714/src/main/java/org/elasticsearch/index/fielddata/IndexFieldDataService.java)
    public <IFD extends IndexFieldData> IFD getForField(FieldMapper mapper) {
        return getForField(mapper.names(), mapper.fieldDataType());
    }


, Instance #
frags: 
(startLine=159 endLine=165 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            if (fieldMapper instanceof IpFieldMapper) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsIpFacetCollector(facetName, field, size, comparatorType, allTerms, context, scriptLang, script, params);
                } else {
                    return new TermsIpOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, null);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.LONG) {

(startLine=165 endLine=171 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.LONG) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsLongFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsLongOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.DOUBLE) {

(startLine=177 endLine=183 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.INT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsIntFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsIntOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.FLOAT) {

(startLine=183 endLine=189 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.FLOAT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsFloatFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsFloatOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.SHORT) {

(startLine=189 endLine=195 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.SHORT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsShortFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsShortOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.BYTE) {

(startLine=195 endLine=201 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.BYTE) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsByteFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsByteOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.STRING) {

commonMethod: 
(startLine=192 endLine=194 srcPath=/root/NewExperiment/elasticsearchFilter/00714/src/main/java/org/elasticsearch/script/ScriptService.java)
    public SearchScript search(SearchLookup lookup, String lang, String script, @Nullable Map<String, Object> vars) {
        return search(compile(lang, script), lookup, vars);
    }


, Instance #
frags: 
(startLine=159 endLine=165 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            if (fieldMapper instanceof IpFieldMapper) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsIpFacetCollector(facetName, field, size, comparatorType, allTerms, context, scriptLang, script, params);
                } else {
                    return new TermsIpOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, null);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.LONG) {

(startLine=165 endLine=171 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.LONG) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsLongFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsLongOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.DOUBLE) {

(startLine=177 endLine=183 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.INT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsIntFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsIntOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.FLOAT) {

(startLine=183 endLine=189 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.FLOAT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsFloatFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsFloatOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.SHORT) {

(startLine=189 endLine=195 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.SHORT) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsShortFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsShortOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.BYTE) {

(startLine=195 endLine=201 srcPath=/root/NewExperiment/elasticsearchFilter/00713/src/main/java/org/elasticsearch/search/facet/terms/TermsFacetProcessor.java)
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.BYTE) {
                if (script != null || "map".equals(executionHint)) {
                    return new TermsByteFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded, scriptLang, script, params);
                } else {
                    return new TermsByteOrdinalsFacetCollector(facetName, field, size, comparatorType, allTerms, context, excluded);
                }
            } else if (fieldMapper.fieldDataType() == FieldDataType.DefaultTypes.STRING) {

commonMethod: 
(startLine=541 endLine=547 srcPath=/root/NewExperiment/elasticsearchFilter/00714/src/main/java/org/elasticsearch/search/internal/SearchContext.java)
    public SearchLookup lookup() {
        // TODO: The types should take into account the parsing context in QueryParserContext...
        if (searchLookup == null) {
            searchLookup = new SearchLookup(mapperService(), fieldData(), request.types());
        }
        return searchLookup;
    }


, Instance #
frags: 
(startLine=106 endLine=124 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/index/query/GeoPolygonFilterParser.java)
                                } else if (token == XContentParser.Token.START_OBJECT) {
                                    Point point = new Point();
                                    while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                                        if (token == XContentParser.Token.FIELD_NAME) {
                                            currentFieldName = parser.currentName();
                                        } else if (token.isValue()) {
                                            if (currentFieldName.equals(GeoPointFieldMapper.Names.LAT)) {
                                                point.lat = parser.doubleValue();
                                            } else if (currentFieldName.equals(GeoPointFieldMapper.Names.LON)) {
                                                point.lon = parser.doubleValue();
                                            } else if (currentFieldName.equals(GeoPointFieldMapper.Names.GEOHASH)) {
                                                double[] values = GeoHashUtils.decode(parser.text());
                                                point.lat = values[0];
                                                point.lon = values[1];
                                            }
                                        }
                                    }
                                    points.add(point);
                                } else if (token.isValue()) {

(startLine=103 endLine=119 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxFilterParser.java)
                        if (point != null) {
                            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
                                if (token == XContentParser.Token.FIELD_NAME) {
                                    currentFieldName = parser.currentName();
                                } else if (token.isValue()) {
                                    if (currentFieldName.equals(GeoPointFieldMapper.Names.LAT)) {
                                        point.lat = parser.doubleValue();
                                    } else if (currentFieldName.equals(GeoPointFieldMapper.Names.LON)) {
                                        point.lon = parser.doubleValue();
                                    } else if (currentFieldName.equals(GeoPointFieldMapper.Names.GEOHASH)) {
                                        double[] values = GeoHashUtils.decode(parser.text());
                                        point.lat = values[0];
                                        point.lon = values[1];
                                    }
                                }
                            }
                        }

commonMethod: 
(startLine=54 endLine=63 srcPath=/root/NewExperiment/elasticsearchFilter/00717/src/main/java/org/elasticsearch/common/geo/GeoPoint.java)
    public GeoPoint resetFromString(String value) {
        int comma = value.indexOf(',');
        if (comma != -1) {
            lat = Double.parseDouble(value.substring(0, comma).trim());
            lon = Double.parseDouble(value.substring(comma + 1).trim());
        } else {
            resetFromGeoHash(value);
        }
        return this;
    }


, Instance #
frags: 
(startLine=111 endLine=121 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/index/query/GeoPolygonFilterParser.java)
                                        } else if (token.isValue()) {
                                            if (currentFieldName.equals(GeoPointFieldMapper.Names.LAT)) {
                                                point.lat = parser.doubleValue();
                                            } else if (currentFieldName.equals(GeoPointFieldMapper.Names.LON)) {
                                                point.lon = parser.doubleValue();
                                            } else if (currentFieldName.equals(GeoPointFieldMapper.Names.GEOHASH)) {
                                                double[] values = GeoHashUtils.decode(parser.text());
                                                point.lat = values[0];
                                                point.lon = values[1];
                                            }
                                        }

(startLine=107 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxFilterParser.java)
                                } else if (token.isValue()) {
                                    if (currentFieldName.equals(GeoPointFieldMapper.Names.LAT)) {
                                        point.lat = parser.doubleValue();
                                    } else if (currentFieldName.equals(GeoPointFieldMapper.Names.LON)) {
                                        point.lon = parser.doubleValue();
                                    } else if (currentFieldName.equals(GeoPointFieldMapper.Names.GEOHASH)) {
                                        double[] values = GeoHashUtils.decode(parser.text());
                                        point.lat = values[0];
                                        point.lon = values[1];
                                    }
                                }

commonMethod: 
(startLine=54 endLine=63 srcPath=/root/NewExperiment/elasticsearchFilter/00717/src/main/java/org/elasticsearch/common/geo/GeoPoint.java)
    public GeoPoint resetFromString(String value) {
        int comma = value.indexOf(',');
        if (comma != -1) {
            lat = Double.parseDouble(value.substring(0, comma).trim());
            lon = Double.parseDouble(value.substring(comma + 1).trim());
        } else {
            resetFromGeoHash(value);
        }
        return this;
    }


, Instance #
frags: 
(startLine=90 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortParser.java)
            } else if (token.isValue()) {
                if ("reverse".equals(currentName)) {
                    reverse = parser.booleanValue();
                } else if ("order".equals(currentName)) {
                    reverse = "desc".equals(parser.text());
                } else if (currentName.equals("unit")) {
                    unit = DistanceUnit.fromString(parser.text());
                } else if (currentName.equals("distance_type") || currentName.equals("distanceType")) {
                    geoDistance = GeoDistance.fromString(parser.text());
                } else if ("normalize".equals(currentName)) {
                    normalizeLat = parser.booleanValue();
                    normalizeLon = parser.booleanValue();
                } else {
                    // assume the value is the actual value
                    String value = parser.text();
                    int comma = value.indexOf(',');
                    if (comma != -1) {
                        lat = Double.parseDouble(value.substring(0, comma).trim());
                        lon = Double.parseDouble(value.substring(comma + 1).trim());
                    } else {
                        double[] values = GeoHashUtils.decode(value);
                        lat = values[0];
                        lon = values[1];
                    }

                    fieldName = currentName;
                }
            }

(startLine=138 endLine=167 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/search/facet/geodistance/GeoDistanceFacetProcessor.java)
            } else if (token.isValue()) {
                if (currentName.equals("unit")) {
                    unit = DistanceUnit.fromString(parser.text());
                } else if (currentName.equals("distance_type") || currentName.equals("distanceType")) {
                    geoDistance = GeoDistance.fromString(parser.text());
                } else if ("value_field".equals(currentName) || "valueField".equals(currentName)) {
                    valueFieldName = parser.text();
                } else if ("value_script".equals(currentName) || "valueScript".equals(currentName)) {
                    valueScript = parser.text();
                } else if ("lang".equals(currentName)) {
                    scriptLang = parser.text();
                } else if ("normalize".equals(currentName)) {
                    normalizeLat = parser.booleanValue();
                    normalizeLon = parser.booleanValue();
                } else {
                    // assume the value is the actual value
                    String value = parser.text();
                    int comma = value.indexOf(',');
                    if (comma != -1) {
                        lat = Double.parseDouble(value.substring(0, comma).trim());
                        lon = Double.parseDouble(value.substring(comma + 1).trim());
                    } else {
                        double[] values = GeoHashUtils.decode(value);
                        lat = values[0];
                        lon = values[1];
                    }

                    fieldName = currentName;
                }
            }

commonMethod: 
(startLine=54 endLine=63 srcPath=/root/NewExperiment/elasticsearchFilter/00717/src/main/java/org/elasticsearch/common/geo/GeoPoint.java)
    public GeoPoint resetFromString(String value) {
        int comma = value.indexOf(',');
        if (comma != -1) {
            lat = Double.parseDouble(value.substring(0, comma).trim());
            lon = Double.parseDouble(value.substring(comma + 1).trim());
        } else {
            resetFromGeoHash(value);
        }
        return this;
    }


, Instance #
frags: 
(startLine=102 endLine=116 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/search/sort/GeoDistanceSortParser.java)
                } else {
                    // assume the value is the actual value
                    String value = parser.text();
                    int comma = value.indexOf(',');
                    if (comma != -1) {
                        lat = Double.parseDouble(value.substring(0, comma).trim());
                        lon = Double.parseDouble(value.substring(comma + 1).trim());
                    } else {
                        double[] values = GeoHashUtils.decode(value);
                        lat = values[0];
                        lon = values[1];
                    }

                    fieldName = currentName;
                }

(startLine=152 endLine=166 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/search/facet/geodistance/GeoDistanceFacetProcessor.java)
                } else {
                    // assume the value is the actual value
                    String value = parser.text();
                    int comma = value.indexOf(',');
                    if (comma != -1) {
                        lat = Double.parseDouble(value.substring(0, comma).trim());
                        lon = Double.parseDouble(value.substring(comma + 1).trim());
                    } else {
                        double[] values = GeoHashUtils.decode(value);
                        lat = values[0];
                        lon = values[1];
                    }

                    fieldName = currentName;
                }

(startLine=144 endLine=157 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/index/query/GeoDistanceFilterParser.java)
                } else {
                    // assume the value is the actual value
                    String value = parser.text();
                    int comma = value.indexOf(',');
                    if (comma != -1) {
                        lat = Double.parseDouble(value.substring(0, comma).trim());
                        lon = Double.parseDouble(value.substring(comma + 1).trim());
                    } else {
                        double[] values = GeoHashUtils.decode(value);
                        lat = values[0];
                        lon = values[1];
                    }
                    fieldName = currentFieldName;
                }

(startLine=124 endLine=137 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/index/query/GeoPolygonFilterParser.java)
                                } else if (token.isValue()) {
                                    Point point = new Point();
                                    String value = parser.text();
                                    int comma = value.indexOf(',');
                                    if (comma != -1) {
                                        point.lat = Double.parseDouble(value.substring(0, comma).trim());
                                        point.lon = Double.parseDouble(value.substring(comma + 1).trim());
                                    } else {
                                        double[] values = GeoHashUtils.decode(value);
                                        point.lat = values[0];
                                        point.lon = values[1];
                                    }
                                    points.add(point);
                                }

(startLine=131 endLine=142 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/index/query/GeoBoundingBoxFilterParser.java)
                            if (point != null) {
                                String value = parser.text();
                                int comma = value.indexOf(',');
                                if (comma != -1) {
                                    point.lat = Double.parseDouble(value.substring(0, comma).trim());
                                    point.lon = Double.parseDouble(value.substring(comma + 1).trim());
                                } else {
                                    double[] values = GeoHashUtils.decode(value);
                                    point.lat = values[0];
                                    point.lon = values[1];
                                }
                            }

(startLine=188 endLine=201 srcPath=/root/NewExperiment/elasticsearchFilter/00716/src/main/java/org/elasticsearch/index/query/GeoDistanceRangeFilterParser.java)
                } else {
                    // assume the value is the actual value
                    String value = parser.text();
                    int comma = value.indexOf(',');
                    if (comma != -1) {
                        lat = Double.parseDouble(value.substring(0, comma).trim());
                        lon = Double.parseDouble(value.substring(comma + 1).trim());
                    } else {
                        double[] values = GeoHashUtils.decode(value);
                        lat = values[0];
                        lon = values[1];
                    }
                    fieldName = currentFieldName;
                }

commonMethod: 
(startLine=54 endLine=63 srcPath=/root/NewExperiment/elasticsearchFilter/00717/src/main/java/org/elasticsearch/common/geo/GeoPoint.java)
    public GeoPoint resetFromString(String value) {
        int comma = value.indexOf(',');
        if (comma != -1) {
            lat = Double.parseDouble(value.substring(0, comma).trim());
            lon = Double.parseDouble(value.substring(comma + 1).trim());
        } else {
            resetFromGeoHash(value);
        }
        return this;
    }


, Instance #
frags: 
(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
    public FloatArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return FloatArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TFloatArrayList values = new TFloatArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_FLOAT_PARSER.parseFloat(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            float[] sValues = new float[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new FloatArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new FloatArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new FloatArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new float[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
    public LongArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return LongArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TLongArrayList values = new TLongArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_LONG_PARSER.parseLong(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            long[] sValues = new long[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new LongArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new LongArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new LongArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new long[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
    public DoubleArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return DoubleArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TDoubleArrayList values = new TDoubleArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_DOUBLE_PARSER.parseDouble(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            double[] sValues = new double[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new DoubleArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new DoubleArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new DoubleArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new double[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
    public ShortArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ShortArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TShortArrayList values = new TShortArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((short) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((short) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            short[] sValues = new short[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ShortArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ShortArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ShortArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new short[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
    public ByteArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ByteArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TByteArrayList values = new TByteArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((byte) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((byte) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            byte[] sValues = new byte[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ByteArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ByteArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ByteArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new byte[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
    public IntArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return IntArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TIntArrayList values = new TIntArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            int[] sValues = new int[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new IntArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new IntArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new IntArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new int[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

commonMethod: 
(startLine=177 endLine=207 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * Builds an {@link Ordinals} instance from the builders current state. 
     */
    public Ordinals build(Settings settings) {
        if (numMultiValuedDocs == 0) {
            return new SingleArrayOrdinals(ords, getNumOrds());
        }
        final String multiOrdinals = settings.get("multi_ordinals", "sparse");
        if ("flat".equals(multiOrdinals)) {
            final ArrayList<int[]> ordinalBuffer = new ArrayList<int[]>();
            for (int i = 0; i < ords.length; i++) {
                IntArrayRef docOrds = docOrds(i);
                while (ordinalBuffer.size() < docOrds.size()) {
                    ordinalBuffer.add(new int[ords.length]);
                }
                for (int j = docOrds.start; j < docOrds.end; j++) {
                    ordinalBuffer.get(j)[i] = docOrds.values[j];
                }
            }
            int[][] nativeOrdinals = new int[ordinalBuffer.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinalBuffer.get(i);
            }
            return new MultiFlatArrayOrdinals(nativeOrdinals, getNumOrds());
        } else if ("sparse".equals(multiOrdinals)) {
            int multiOrdinalsMaxDocs = settings.getAsInt("multi_ordinals_max_docs", 16777216 /* Equal to 64MB per storeage array */);
            return new SparseMultiArrayOrdinals(this, multiOrdinalsMaxDocs);
        } else {
            throw new ElasticSearchIllegalArgumentException("no applicable fielddata multi_ordinals value, got [" + multiOrdinals + "]");
        }
    }


, Instance #
frags: 
(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
    public FloatArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return FloatArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TFloatArrayList values = new TFloatArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_FLOAT_PARSER.parseFloat(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            float[] sValues = new float[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new FloatArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new FloatArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new FloatArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new float[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
    public LongArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return LongArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TLongArrayList values = new TLongArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_LONG_PARSER.parseLong(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            long[] sValues = new long[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new LongArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new LongArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new LongArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new long[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
    public DoubleArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return DoubleArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TDoubleArrayList values = new TDoubleArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_DOUBLE_PARSER.parseDouble(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            double[] sValues = new double[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new DoubleArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new DoubleArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new DoubleArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new double[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
    public ShortArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ShortArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TShortArrayList values = new TShortArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((short) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((short) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            short[] sValues = new short[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ShortArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ShortArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ShortArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new short[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
    public ByteArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ByteArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TByteArrayList values = new TByteArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((byte) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((byte) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            byte[] sValues = new byte[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ByteArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ByteArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ByteArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new byte[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
    public IntArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return IntArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TIntArrayList values = new TIntArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            int[] sValues = new int[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new IntArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new IntArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new IntArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new int[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

commonMethod: 
(startLine=275 endLine=313 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * This method iterates all terms in the given {@link TermsEnum} and
     * associates each terms ordinal with the terms documents. The caller must
     * exhaust the returned {@link BytesRefIterator} which returns all values
     * where the first returned value is associted with the ordinal <tt>1</tt>
     * etc.
     * <p>
     * If the {@link TermsEnum} contains prefix coded numerical values the terms
     * enum should be wrapped with either {@link #wrapNumeric32Bit(TermsEnum)}
     * or {@link #wrapNumeric64Bit(TermsEnum)} depending on its precision. If
     * the {@link TermsEnum} is not wrapped the returned
     * {@link BytesRefIterator} will contain partial precision terms rather than
     * only full-precision terms.
     * </p>
     */
    public BytesRefIterator buildFromTerms(final TermsEnum termsEnum, final Bits liveDocs) throws IOException {
        return new BytesRefIterator() {
            private DocsEnum docsEnum = null;

            @Override
            public BytesRef next() throws IOException {
                BytesRef ref;
                if ((ref = termsEnum.next()) != null) {
                    docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);
                    nextOrdinal();
                    int docId;
                    while((docId = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {
                        addDoc(docId);
                    }
                }
                return ref;
            }

            @Override
            public Comparator<BytesRef> getComparator() {
                return termsEnum.getComparator();
            }
        };
    }


, Instance #
frags: 
(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
    public FloatArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return FloatArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TFloatArrayList values = new TFloatArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_FLOAT_PARSER.parseFloat(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            float[] sValues = new float[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new FloatArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new FloatArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new FloatArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new float[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
    public LongArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return LongArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TLongArrayList values = new TLongArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_LONG_PARSER.parseLong(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            long[] sValues = new long[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new LongArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new LongArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new LongArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new long[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
    public DoubleArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return DoubleArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TDoubleArrayList values = new TDoubleArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_DOUBLE_PARSER.parseDouble(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            double[] sValues = new double[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new DoubleArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new DoubleArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new DoubleArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new double[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
    public ShortArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ShortArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TShortArrayList values = new TShortArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((short) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((short) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            short[] sValues = new short[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ShortArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ShortArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ShortArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new short[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
    public ByteArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ByteArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TByteArrayList values = new TByteArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((byte) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((byte) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            byte[] sValues = new byte[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ByteArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ByteArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ByteArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new byte[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
    public IntArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return IntArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TIntArrayList values = new TIntArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            int[] sValues = new int[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new IntArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new IntArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new IntArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new int[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

commonMethod: 
(startLine=161 endLine=175 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * Builds a {@link FixedBitSet} where each documents bit is that that has one or more ordinals associated with it.
     * if every document has an ordinal associated with it this method returns <code>null</code>
     */
    public FixedBitSet buildDocsWithValuesSet() {
        if (numDocsWithValue == this.ords.length)
            return null;
        final FixedBitSet bitSet = new FixedBitSet(this.ords.length);
        for (int i = 0; i < ords.length; i++) {
            if (ords[i] != 0) {
                bitSet.set(i);
            }
        }
        return bitSet;
    }


, Instance #
frags: 
(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
    public FloatArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return FloatArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TFloatArrayList values = new TFloatArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_FLOAT_PARSER.parseFloat(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            float[] sValues = new float[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new FloatArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new FloatArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new FloatArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new float[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
    public LongArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return LongArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TLongArrayList values = new TLongArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_LONG_PARSER.parseLong(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            long[] sValues = new long[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new LongArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new LongArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new LongArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new long[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
    public DoubleArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return DoubleArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TDoubleArrayList values = new TDoubleArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_DOUBLE_PARSER.parseDouble(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            double[] sValues = new double[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new DoubleArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new DoubleArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new DoubleArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new double[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
    public ShortArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ShortArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TShortArrayList values = new TShortArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((short) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((short) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            short[] sValues = new short[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ShortArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ShortArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ShortArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new short[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
    public IntArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return IntArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TIntArrayList values = new TIntArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            int[] sValues = new int[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new IntArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new IntArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new IntArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new int[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
    public ByteArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ByteArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TByteArrayList values = new TByteArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((byte) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((byte) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            byte[] sValues = new byte[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ByteArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ByteArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ByteArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new byte[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

commonMethod: 
(startLine=177 endLine=207 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * Builds an {@link Ordinals} instance from the builders current state. 
     */
    public Ordinals build(Settings settings) {
        if (numMultiValuedDocs == 0) {
            return new SingleArrayOrdinals(ords, getNumOrds());
        }
        final String multiOrdinals = settings.get("multi_ordinals", "sparse");
        if ("flat".equals(multiOrdinals)) {
            final ArrayList<int[]> ordinalBuffer = new ArrayList<int[]>();
            for (int i = 0; i < ords.length; i++) {
                IntArrayRef docOrds = docOrds(i);
                while (ordinalBuffer.size() < docOrds.size()) {
                    ordinalBuffer.add(new int[ords.length]);
                }
                for (int j = docOrds.start; j < docOrds.end; j++) {
                    ordinalBuffer.get(j)[i] = docOrds.values[j];
                }
            }
            int[][] nativeOrdinals = new int[ordinalBuffer.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinalBuffer.get(i);
            }
            return new MultiFlatArrayOrdinals(nativeOrdinals, getNumOrds());
        } else if ("sparse".equals(multiOrdinals)) {
            int multiOrdinalsMaxDocs = settings.getAsInt("multi_ordinals_max_docs", 16777216 /* Equal to 64MB per storeage array */);
            return new SparseMultiArrayOrdinals(this, multiOrdinalsMaxDocs);
        } else {
            throw new ElasticSearchIllegalArgumentException("no applicable fielddata multi_ordinals value, got [" + multiOrdinals + "]");
        }
    }


, Instance #
frags: 
(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
    public FloatArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return FloatArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TFloatArrayList values = new TFloatArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_FLOAT_PARSER.parseFloat(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            float[] sValues = new float[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new FloatArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new FloatArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new FloatArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new float[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
    public LongArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return LongArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TLongArrayList values = new TLongArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_LONG_PARSER.parseLong(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            long[] sValues = new long[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new LongArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new LongArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new LongArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new long[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
    public DoubleArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return DoubleArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TDoubleArrayList values = new TDoubleArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_DOUBLE_PARSER.parseDouble(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            double[] sValues = new double[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new DoubleArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new DoubleArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new DoubleArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new double[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
    public ShortArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ShortArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TShortArrayList values = new TShortArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((short) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((short) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            short[] sValues = new short[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ShortArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ShortArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ShortArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new short[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
    public IntArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return IntArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TIntArrayList values = new TIntArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            int[] sValues = new int[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new IntArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new IntArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new IntArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new int[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
    public ByteArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ByteArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TByteArrayList values = new TByteArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((byte) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((byte) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            byte[] sValues = new byte[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ByteArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ByteArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ByteArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new byte[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

commonMethod: 
(startLine=275 endLine=313 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * This method iterates all terms in the given {@link TermsEnum} and
     * associates each terms ordinal with the terms documents. The caller must
     * exhaust the returned {@link BytesRefIterator} which returns all values
     * where the first returned value is associted with the ordinal <tt>1</tt>
     * etc.
     * <p>
     * If the {@link TermsEnum} contains prefix coded numerical values the terms
     * enum should be wrapped with either {@link #wrapNumeric32Bit(TermsEnum)}
     * or {@link #wrapNumeric64Bit(TermsEnum)} depending on its precision. If
     * the {@link TermsEnum} is not wrapped the returned
     * {@link BytesRefIterator} will contain partial precision terms rather than
     * only full-precision terms.
     * </p>
     */
    public BytesRefIterator buildFromTerms(final TermsEnum termsEnum, final Bits liveDocs) throws IOException {
        return new BytesRefIterator() {
            private DocsEnum docsEnum = null;

            @Override
            public BytesRef next() throws IOException {
                BytesRef ref;
                if ((ref = termsEnum.next()) != null) {
                    docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);
                    nextOrdinal();
                    int docId;
                    while((docId = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {
                        addDoc(docId);
                    }
                }
                return ref;
            }

            @Override
            public Comparator<BytesRef> getComparator() {
                return termsEnum.getComparator();
            }
        };
    }


, Instance #
frags: 
(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
    public FloatArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return FloatArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TFloatArrayList values = new TFloatArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_FLOAT_PARSER.parseFloat(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            float[] sValues = new float[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new FloatArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new FloatArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new FloatArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new float[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
    public LongArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return LongArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TLongArrayList values = new TLongArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_LONG_PARSER.parseLong(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            long[] sValues = new long[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new LongArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new LongArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new LongArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new long[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
    public DoubleArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return DoubleArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TDoubleArrayList values = new TDoubleArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_DOUBLE_PARSER.parseDouble(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            double[] sValues = new double[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new DoubleArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new DoubleArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new DoubleArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new double[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
    public ShortArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ShortArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TShortArrayList values = new TShortArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((short) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((short) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            short[] sValues = new short[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ShortArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ShortArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ShortArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new short[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
    public IntArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return IntArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TIntArrayList values = new TIntArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add(0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            int[] sValues = new int[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new IntArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new IntArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new IntArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new int[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

(startLine=81 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
    public ByteArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();

        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ByteArrayAtomicFieldData.EMPTY;
        }

        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TByteArrayList values = new TByteArrayList();
        ArrayList<int[]> ordinals = new ArrayList<int[]>();
        int[] idx = new int[reader.maxDoc()];
        ordinals.add(new int[reader.maxDoc()]);

        values.add((byte) 0); // first "t" indicates null value
        int termOrd = 1;  // current term number

        TermsEnum termsEnum = terms.iterator(null);
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((byte) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {
            if (e.getClass().getName().endsWith("StopFillCacheException")) {
                // all is well, in case numeric parsers are used.
            } else {
                throw e;
            }
        }

        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            byte[] sValues = new byte[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ByteArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ByteArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ByteArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new byte[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }
    }

commonMethod: 
(startLine=161 endLine=175 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * Builds a {@link FixedBitSet} where each documents bit is that that has one or more ordinals associated with it.
     * if every document has an ordinal associated with it this method returns <code>null</code>
     */
    public FixedBitSet buildDocsWithValuesSet() {
        if (numDocsWithValue == this.ords.length)
            return null;
        final FixedBitSet bitSet = new FixedBitSet(this.ords.length);
        for (int i = 0; i < ords.length; i++) {
            if (ords[i] != 0) {
                bitSet.set(i);
            }
        }
        return bitSet;
    }


, Instance #
frags: 
(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            float[] sValues = new float[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new FloatArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new FloatArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            long[] sValues = new long[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new LongArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new LongArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            double[] sValues = new double[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new DoubleArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new DoubleArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            short[] sValues = new short[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ShortArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ShortArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            byte[] sValues = new byte[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ByteArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ByteArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            int[] sValues = new int[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new IntArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new IntArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

commonMethod: 
(startLine=275 endLine=313 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * This method iterates all terms in the given {@link TermsEnum} and
     * associates each terms ordinal with the terms documents. The caller must
     * exhaust the returned {@link BytesRefIterator} which returns all values
     * where the first returned value is associted with the ordinal <tt>1</tt>
     * etc.
     * <p>
     * If the {@link TermsEnum} contains prefix coded numerical values the terms
     * enum should be wrapped with either {@link #wrapNumeric32Bit(TermsEnum)}
     * or {@link #wrapNumeric64Bit(TermsEnum)} depending on its precision. If
     * the {@link TermsEnum} is not wrapped the returned
     * {@link BytesRefIterator} will contain partial precision terms rather than
     * only full-precision terms.
     * </p>
     */
    public BytesRefIterator buildFromTerms(final TermsEnum termsEnum, final Bits liveDocs) throws IOException {
        return new BytesRefIterator() {
            private DocsEnum docsEnum = null;

            @Override
            public BytesRef next() throws IOException {
                BytesRef ref;
                if ((ref = termsEnum.next()) != null) {
                    docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);
                    nextOrdinal();
                    int docId;
                    while((docId = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {
                        addDoc(docId);
                    }
                }
                return ref;
            }

            @Override
            public Comparator<BytesRef> getComparator() {
                return termsEnum.getComparator();
            }
        };
    }


, Instance #
frags: 
(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            float[] sValues = new float[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new FloatArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new FloatArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            short[] sValues = new short[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ShortArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ShortArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            byte[] sValues = new byte[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ByteArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ByteArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            int[] sValues = new int[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new IntArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new IntArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

commonMethod: 
(startLine=258 endLine=273 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * A {@link TermsEnum} that iterates only full precision prefix coded 32 bit values.
     * @see #buildFromTerms(TermsEnum, Bits)
     */
    public TermsEnum wrapNumeric32Bit(TermsEnum termsEnum) {
        return new FilteredTermsEnum(termsEnum, false) {
            
            @Override
            protected AcceptStatus accept(BytesRef term) throws IOException {
                if (NumericUtils.getPrefixCodedIntShift(term) > 0) {
                    return AcceptStatus.END;
                } // we stop accepting terms once we moved across the prefix codec terms - redundant values!
                return AcceptStatus.YES;
            }
        };
    }


, Instance #
frags: 
(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            float[] sValues = new float[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new FloatArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new FloatArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            long[] sValues = new long[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new LongArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new LongArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            double[] sValues = new double[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new DoubleArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new DoubleArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            short[] sValues = new short[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ShortArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ShortArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            byte[] sValues = new byte[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new ByteArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ByteArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            int[] sValues = new int[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new IntArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new IntArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

commonMethod: 
(startLine=161 endLine=175 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * Builds a {@link FixedBitSet} where each documents bit is that that has one or more ordinals associated with it.
     * if every document has an ordinal associated with it this method returns <code>null</code>
     */
    public FixedBitSet buildDocsWithValuesSet() {
        if (numDocsWithValue == this.ords.length)
            return null;
        final FixedBitSet bitSet = new FixedBitSet(this.ords.length);
        for (int i = 0; i < ords.length; i++) {
            if (ords[i] != 0) {
                bitSet.set(i);
            }
        }
        return bitSet;
    }


, Instance #
frags: 
(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            long[] sValues = new long[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new LongArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new LongArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

(startLine=125 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
        if (ordinals.size() == 1) {
            int[] nativeOrdinals = ordinals.get(0);
            FixedBitSet set = new FixedBitSet(reader.maxDoc());
            double[] sValues = new double[reader.maxDoc()];
            boolean allHaveValue = true;
            for (int i = 0; i < nativeOrdinals.length; i++) {
                int nativeOrdinal = nativeOrdinals[i];
                if (nativeOrdinal == 0) {
                    allHaveValue = false;
                } else {
                    set.set(i);
                    sValues[i] = values.get(nativeOrdinal);
                }
            }
            if (allHaveValue) {
                return new DoubleArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new DoubleArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {

commonMethod: 
(startLine=242 endLine=256 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * A {@link TermsEnum} that iterates only full precision prefix coded 64 bit values.
     * @see #buildFromTerms(TermsEnum, Bits)
     */
    public TermsEnum wrapNumeric64Bit(TermsEnum termsEnum) {
        return new FilteredTermsEnum(termsEnum, false) {
            @Override
            protected AcceptStatus accept(BytesRef term) throws IOException {
                if (NumericUtils.getPrefixCodedLongShift(term) > 0) {
                    return AcceptStatus.END;
                } // we stop accepting terms once we moved across the prefix codec terms - redundant values!
                return AcceptStatus.YES;
            }
        };
    }


, Instance #
frags: 
(startLine=96 endLine=114 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ConcreteBytesRefIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(BytesRef.deepCopyOf(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_FLOAT_PARSER.parseFloat(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_LONG_PARSER.parseLong(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_DOUBLE_PARSER.parseDouble(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((short) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((byte) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

commonMethod: 
(startLine=275 endLine=313 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * This method iterates all terms in the given {@link TermsEnum} and
     * associates each terms ordinal with the terms documents. The caller must
     * exhaust the returned {@link BytesRefIterator} which returns all values
     * where the first returned value is associted with the ordinal <tt>1</tt>
     * etc.
     * <p>
     * If the {@link TermsEnum} contains prefix coded numerical values the terms
     * enum should be wrapped with either {@link #wrapNumeric32Bit(TermsEnum)}
     * or {@link #wrapNumeric64Bit(TermsEnum)} depending on its precision. If
     * the {@link TermsEnum} is not wrapped the returned
     * {@link BytesRefIterator} will contain partial precision terms rather than
     * only full-precision terms.
     * </p>
     */
    public BytesRefIterator buildFromTerms(final TermsEnum termsEnum, final Bits liveDocs) throws IOException {
        return new BytesRefIterator() {
            private DocsEnum docsEnum = null;

            @Override
            public BytesRef next() throws IOException {
                BytesRef ref;
                if ((ref = termsEnum.next()) != null) {
                    docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);
                    nextOrdinal();
                    int docId;
                    while((docId = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {
                        addDoc(docId);
                    }
                }
                return ref;
            }

            @Override
            public Comparator<BytesRef> getComparator() {
                return termsEnum.getComparator();
            }
        };
    }


, Instance #
frags: 
(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_FLOAT_PARSER.parseFloat(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((short) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((byte) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

commonMethod: 
(startLine=258 endLine=273 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * A {@link TermsEnum} that iterates only full precision prefix coded 32 bit values.
     * @see #buildFromTerms(TermsEnum, Bits)
     */
    public TermsEnum wrapNumeric32Bit(TermsEnum termsEnum) {
        return new FilteredTermsEnum(termsEnum, false) {
            
            @Override
            protected AcceptStatus accept(BytesRef term) throws IOException {
                if (NumericUtils.getPrefixCodedIntShift(term) > 0) {
                    return AcceptStatus.END;
                } // we stop accepting terms once we moved across the prefix codec terms - redundant values!
                return AcceptStatus.YES;
            }
        };
    }


, Instance #
frags: 
(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_FLOAT_PARSER.parseFloat(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_LONG_PARSER.parseLong(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_DOUBLE_PARSER.parseDouble(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((short) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add((byte) FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_INT_PARSER.parseInt(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

commonMethod: 
(startLine=161 endLine=175 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * Builds a {@link FixedBitSet} where each documents bit is that that has one or more ordinals associated with it.
     * if every document has an ordinal associated with it this method returns <code>null</code>
     */
    public FixedBitSet buildDocsWithValuesSet() {
        if (numDocsWithValue == this.ords.length)
            return null;
        final FixedBitSet bitSet = new FixedBitSet(this.ords.length);
        for (int i = 0; i < ords.length; i++) {
            if (ords[i] != 0) {
                bitSet.set(i);
            }
        }
        return bitSet;
    }


, Instance #
frags: 
(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_LONG_PARSER.parseLong(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

(startLine=99 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
        try {
            DocsEnum docsEnum = null;
            for (BytesRef term = termsEnum.next(); term != null; term = termsEnum.next()) {
                values.add(FieldCache.NUMERIC_UTILS_DOUBLE_PARSER.parseDouble(term));
                docsEnum = termsEnum.docs(reader.getLiveDocs(), docsEnum, 0);
                for (int docId = docsEnum.nextDoc(); docId != DocsEnum.NO_MORE_DOCS; docId = docsEnum.nextDoc()) {
                    int[] ordinal;
                    if (idx[docId] >= ordinals.size()) {
                        ordinal = new int[reader.maxDoc()];
                        ordinals.add(ordinal);
                    } else {
                        ordinal = ordinals.get(idx[docId]);
                    }
                    ordinal[docId] = termOrd;
                    idx[docId]++;
                }
                termOrd++;
            }
        } catch (RuntimeException e) {

commonMethod: 
(startLine=242 endLine=256 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * A {@link TermsEnum} that iterates only full precision prefix coded 64 bit values.
     * @see #buildFromTerms(TermsEnum, Bits)
     */
    public TermsEnum wrapNumeric64Bit(TermsEnum termsEnum) {
        return new FilteredTermsEnum(termsEnum, false) {
            @Override
            protected AcceptStatus accept(BytesRef term) throws IOException {
                if (NumericUtils.getPrefixCodedLongShift(term) > 0) {
                    return AcceptStatus.END;
                } // we stop accepting terms once we moved across the prefix codec terms - redundant values!
                return AcceptStatus.YES;
            }
        };
    }


, Instance #
frags: 
(startLine=144 endLine=153 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ConcreteBytesRefIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ConcreteBytesRefAtomicFieldData(
                    values.toArray(new BytesRef[values.size()]),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new FloatArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new float[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new LongArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new long[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new DoubleArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new double[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ShortArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new short[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ByteArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new byte[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new IntArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new int[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=176 endLine=186 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/PagedBytesIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new PagedBytesAtomicFieldData(
                    bytesReader,
                    termOrdToBytesOffsetReader,
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

commonMethod: 
(startLine=315 endLine=322 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * Closes this builder and release all resources.
     */
    @Override
    public void close() throws IOException {
        pool.reset(true, false);
        offsets = null;
    }


, Instance #
frags: 
(startLine=144 endLine=153 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ConcreteBytesRefIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ConcreteBytesRefAtomicFieldData(
                    values.toArray(new BytesRef[values.size()]),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new FloatArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new float[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new LongArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new long[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new DoubleArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new double[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ShortArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new short[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ByteArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new byte[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new IntArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new int[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

commonMethod: 
(startLine=275 endLine=313 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * This method iterates all terms in the given {@link TermsEnum} and
     * associates each terms ordinal with the terms documents. The caller must
     * exhaust the returned {@link BytesRefIterator} which returns all values
     * where the first returned value is associted with the ordinal <tt>1</tt>
     * etc.
     * <p>
     * If the {@link TermsEnum} contains prefix coded numerical values the terms
     * enum should be wrapped with either {@link #wrapNumeric32Bit(TermsEnum)}
     * or {@link #wrapNumeric64Bit(TermsEnum)} depending on its precision. If
     * the {@link TermsEnum} is not wrapped the returned
     * {@link BytesRefIterator} will contain partial precision terms rather than
     * only full-precision terms.
     * </p>
     */
    public BytesRefIterator buildFromTerms(final TermsEnum termsEnum, final Bits liveDocs) throws IOException {
        return new BytesRefIterator() {
            private DocsEnum docsEnum = null;

            @Override
            public BytesRef next() throws IOException {
                BytesRef ref;
                if ((ref = termsEnum.next()) != null) {
                    docsEnum = termsEnum.docs(liveDocs, docsEnum, DocsEnum.FLAG_NONE);
                    nextOrdinal();
                    int docId;
                    while((docId = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {
                        addDoc(docId);
                    }
                }
                return ref;
            }

            @Override
            public Comparator<BytesRef> getComparator() {
                return termsEnum.getComparator();
            }
        };
    }


, Instance #
frags: 
(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new FloatArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new float[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ShortArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new short[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ByteArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new byte[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new IntArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new int[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

commonMethod: 
(startLine=258 endLine=273 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * A {@link TermsEnum} that iterates only full precision prefix coded 32 bit values.
     * @see #buildFromTerms(TermsEnum, Bits)
     */
    public TermsEnum wrapNumeric32Bit(TermsEnum termsEnum) {
        return new FilteredTermsEnum(termsEnum, false) {
            
            @Override
            protected AcceptStatus accept(BytesRef term) throws IOException {
                if (NumericUtils.getPrefixCodedIntShift(term) > 0) {
                    return AcceptStatus.END;
                } // we stop accepting terms once we moved across the prefix codec terms - redundant values!
                return AcceptStatus.YES;
            }
        };
    }


, Instance #
frags: 
(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new FloatArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new float[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new LongArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new long[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new DoubleArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new double[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ShortArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new short[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new ByteArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new byte[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new IntArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new int[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

commonMethod: 
(startLine=161 endLine=175 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * Builds a {@link FixedBitSet} where each documents bit is that that has one or more ordinals associated with it.
     * if every document has an ordinal associated with it this method returns <code>null</code>
     */
    public FixedBitSet buildDocsWithValuesSet() {
        if (numDocsWithValue == this.ords.length)
            return null;
        final FixedBitSet bitSet = new FixedBitSet(this.ords.length);
        for (int i = 0; i < ords.length; i++) {
            if (ords[i] != 0) {
                bitSet.set(i);
            }
        }
        return bitSet;
    }


, Instance #
frags: 
(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/LongArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new LongArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new long[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

(startLine=144 endLine=154 srcPath=/root/NewExperiment/elasticsearchFilter/00729/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
        } else {
            int[][] nativeOrdinals = new int[ordinals.size()][];
            for (int i = 0; i < nativeOrdinals.length; i++) {
                nativeOrdinals[i] = ordinals.get(i);
            }
            return new DoubleArrayAtomicFieldData.WithOrdinals(
                    values.toArray(new double[values.size()]),
                    reader.maxDoc(),
                    Ordinals.Factories.createFromFlatOrdinals(nativeOrdinals, termOrd, fieldDataType.getSettings())
            );
        }

commonMethod: 
(startLine=242 endLine=256 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/main/java/org/elasticsearch/index/fielddata/ordinals/OrdinalsBuilder.java)
    /**
     * A {@link TermsEnum} that iterates only full precision prefix coded 64 bit values.
     * @see #buildFromTerms(TermsEnum, Bits)
     */
    public TermsEnum wrapNumeric64Bit(TermsEnum termsEnum) {
        return new FilteredTermsEnum(termsEnum, false) {
            @Override
            protected AcceptStatus accept(BytesRef term) throws IOException {
                if (NumericUtils.getPrefixCodedLongShift(term) > 0) {
                    return AcceptStatus.END;
                } // we stop accepting terms once we moved across the prefix codec terms - redundant values!
                return AcceptStatus.YES;
            }
        };
    }


, Instance #
frags: 
(startLine=75 endLine=118 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/test/java/org/elasticsearch/test/integration/gateway/none/RecoverAfterNodesTests.java)
    public void testRecoverAfterMasterNodes() throws Exception {
        logger.info("--> start master_node (1)");
        startNode("master1", settingsBuilder().put("gateway.recover_after_master_nodes", 2).put("node.data", false).put("node.master", true));
        assertThat(client("master1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));

        logger.info("--> start data_node (1)");
        startNode("data1", settingsBuilder().put("gateway.recover_after_master_nodes", 2).put("node.data", true).put("node.master", false));
        assertThat(client("master1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));
        assertThat(client("data1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));

        logger.info("--> start data_node (2)");
        startNode("data2", settingsBuilder().put("gateway.recover_after_master_nodes", 2).put("node.data", true).put("node.master", false));
        assertThat(client("master1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));
        assertThat(client("data1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));
        assertThat(client("data2").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));

        logger.info("--> start master_node (2)");
        startNode("master2", settingsBuilder().put("gateway.recover_after_master_nodes", 2).put("node.data", false).put("node.master", true));
        Thread.sleep(300);
        assertThat(client("master1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA).isEmpty(),
                equalTo(true));
        assertThat(client("master2").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA).isEmpty(),
                equalTo(true));
        assertThat(client("data1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA).isEmpty(),
                equalTo(true));
        assertThat(client("data2").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA).isEmpty(),
                equalTo(true));
    }

(startLine=121 endLine=163 srcPath=/root/NewExperiment/elasticsearchFilter/00730/src/test/java/org/elasticsearch/test/integration/gateway/none/RecoverAfterNodesTests.java)
    public void testRecoverAfterDataNodes() {
        logger.info("--> start master_node (1)");
        startNode("master1", settingsBuilder().put("gateway.recover_after_data_nodes", 2).put("node.data", false).put("node.master", true));
        assertThat(client("master1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));

        logger.info("--> start data_node (1)");
        startNode("data1", settingsBuilder().put("gateway.recover_after_data_nodes", 2).put("node.data", true).put("node.master", false));
        assertThat(client("master1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));
        assertThat(client("data1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));

        logger.info("--> start master_node (2)");
        startNode("master2", settingsBuilder().put("gateway.recover_after_data_nodes", 2).put("node.data", false).put("node.master", true));
        assertThat(client("master1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));
        assertThat(client("data1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));
        assertThat(client("master2").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA),
                hasItem(GatewayService.STATE_NOT_RECOVERED_BLOCK));

        logger.info("--> start data_node (2)");
        startNode("data2", settingsBuilder().put("gateway.recover_after_data_nodes", 2).put("node.data", true).put("node.master", false));
        assertThat(client("master1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA).isEmpty(),
                equalTo(true));
        assertThat(client("master2").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA).isEmpty(),
                equalTo(true));
        assertThat(client("data1").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA).isEmpty(),
                equalTo(true));
        assertThat(client("data2").admin().cluster().prepareState().setLocal(true).execute().actionGet()
                .state().blocks().global(ClusterBlockLevel.METADATA).isEmpty(),
                equalTo(true));
    }

commonMethod: 
(startLine=159 endLine=168 srcPath=/root/NewExperiment/elasticsearchFilter/00731/src/test/java/org/elasticsearch/test/integration/AbstractNodesTests.java)
    public ImmutableSet<ClusterBlock> waitForNoBlocks(TimeValue timeout, String node) throws InterruptedException {
        long start = System.currentTimeMillis();
        ImmutableSet<ClusterBlock> blocks;
        do {
            blocks = client(node).admin().cluster().prepareState().setLocal(true).execute().actionGet()
                    .state().blocks().global(ClusterBlockLevel.METADATA);
        }
        while (!blocks.isEmpty() && (System.currentTimeMillis() - start) < timeout.millis());
        return blocks;
    }


, Instance #
frags: 
(startLine=71 endLine=83 srcPath=/root/NewExperiment/elasticsearchFilter/00740/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/ShardClearIndicesCacheRequest.java)
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        filterCache = in.readBoolean();
        fieldDataCache = in.readBoolean();
        idCache = in.readBoolean();
        int size = in.readVInt();
        if (size > 0) {
            fields = new String[size];
            for (int i = 0; i < size; i++) {
                fields[i] = in.readString();
            }
        }
    }

(startLine=84 endLine=96 srcPath=/root/NewExperiment/elasticsearchFilter/00740/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/ClearIndicesCacheRequest.java)
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        filterCache = in.readBoolean();
        fieldDataCache = in.readBoolean();
        idCache = in.readBoolean();
        int size = in.readVInt();
        if (size > 0) {
            fields = new String[size];
            for (int i = 0; i < size; i++) {
                fields[i] = in.readString();
            }
        }
    }

commonMethod: 
(startLine=279 endLine=289 srcPath=/root/NewExperiment/elasticsearchFilter/00741/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java)
    public String[] readStringArray() throws IOException {
        int size = readVInt();
        if (size == 0) {
            return Strings.EMPTY_ARRAY;
        }
        String[] ret = new String[size];
        for (int i = 0; i < size; i++) {
            ret[i] = readString();
        }
        return ret;
    }


, Instance #
frags: 
(startLine=86 endLine=99 srcPath=/root/NewExperiment/elasticsearchFilter/00740/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/ShardClearIndicesCacheRequest.java)
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeBoolean(filterCache);
        out.writeBoolean(fieldDataCache);
        out.writeBoolean(idCache);
        if (fields == null) {
            out.writeVInt(0);
        } else {
            out.writeVInt(fields.length);
            for (String field : fields) {
                out.writeString(field);
            }
        }
    }

(startLine=98 endLine=111 srcPath=/root/NewExperiment/elasticsearchFilter/00740/src/main/java/org/elasticsearch/action/admin/indices/cache/clear/ClearIndicesCacheRequest.java)
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeBoolean(filterCache);
        out.writeBoolean(fieldDataCache);
        out.writeBoolean(idCache);
        if (fields == null) {
            out.writeVInt(0);
        } else {
            out.writeVInt(fields.length);
            for (String field : fields) {
                out.writeString(field);
            }
        }
    }

commonMethod: 
(startLine=276 endLine=288 srcPath=/root/NewExperiment/elasticsearchFilter/00741/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java)
    /**
     * Writes a string array, for nullable string, writes it as 0 (empty string).
     */
    public void writeStringArrayNullable(@Nullable String[] array) throws IOException {
        if (array == null) {
            writeVInt(0);
        } else {
            writeVInt(array.length);
            for (String s : array) {
                writeString(s);
            }
        }
    }


, Instance #
frags: 
(startLine=151 endLine=163 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollQueryAndFetchAction.java)
                if (request.operationThreading() == SearchOperationThreading.SINGLE_THREAD) {
                    threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                        @Override
                        public void run() {
                            for (Tuple<String, Long> target : scrollId.context()) {
                                DiscoveryNode node = nodes.get(target.v1());
                                if (node != null && nodes.localNodeId().equals(node.id())) {
                                    executePhase(node, target.v2());
                                }
                            }
                        }
                    });
                } else {

(startLine=157 endLine=169 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollScanAction.java)
                if (request.operationThreading() == SearchOperationThreading.SINGLE_THREAD) {
                    threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                        @Override
                        public void run() {
                            for (Tuple<String, Long> target : scrollId.context()) {
                                DiscoveryNode node = nodes.get(target.v1());
                                if (node != null && nodes.localNodeId().equals(node.id())) {
                                    executePhase(node, target.v2());
                                }
                            }
                        }
                    });
                } else {

(startLine=157 endLine=169 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollQueryThenFetchAction.java)
                if (request.operationThreading() == SearchOperationThreading.SINGLE_THREAD) {
                    threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                        @Override
                        public void run() {
                            for (Tuple<String, Long> target : scrollId.context()) {
                                DiscoveryNode node = nodes.get(target.v1());
                                if (node != null && nodes.localNodeId().equals(node.id())) {
                                    executeQueryPhase(counter, node, target.v2());
                                }
                            }
                        }
                    });
                } else {

commonMethod: 
(startLine=52 endLine=54 srcPath=/root/NewExperiment/elasticsearchFilter/00743/src/main/java/org/elasticsearch/action/search/type/ParsedScrollId.java)
    public String getSource() {
        return source;
    }


, Instance #
frags: 
(startLine=151 endLine=163 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollQueryAndFetchAction.java)
                if (request.operationThreading() == SearchOperationThreading.SINGLE_THREAD) {
                    threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                        @Override
                        public void run() {
                            for (Tuple<String, Long> target : scrollId.context()) {
                                DiscoveryNode node = nodes.get(target.v1());
                                if (node != null && nodes.localNodeId().equals(node.id())) {
                                    executePhase(node, target.v2());
                                }
                            }
                        }
                    });
                } else {

(startLine=157 endLine=169 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollScanAction.java)
                if (request.operationThreading() == SearchOperationThreading.SINGLE_THREAD) {
                    threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                        @Override
                        public void run() {
                            for (Tuple<String, Long> target : scrollId.context()) {
                                DiscoveryNode node = nodes.get(target.v1());
                                if (node != null && nodes.localNodeId().equals(node.id())) {
                                    executePhase(node, target.v2());
                                }
                            }
                        }
                    });
                } else {

(startLine=157 endLine=169 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollQueryThenFetchAction.java)
                if (request.operationThreading() == SearchOperationThreading.SINGLE_THREAD) {
                    threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                        @Override
                        public void run() {
                            for (Tuple<String, Long> target : scrollId.context()) {
                                DiscoveryNode node = nodes.get(target.v1());
                                if (node != null && nodes.localNodeId().equals(node.id())) {
                                    executeQueryPhase(counter, node, target.v2());
                                }
                            }
                        }
                    });
                } else {

commonMethod: 
(startLine=60 endLine=62 srcPath=/root/NewExperiment/elasticsearchFilter/00743/src/main/java/org/elasticsearch/action/search/type/ParsedScrollId.java)
    public Tuple<String, Long>[] getContext() {
        return context;
    }


, Instance #
frags: 
(startLine=163 endLine=180 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollQueryAndFetchAction.java)
                } else {
                    boolean localAsync = request.operationThreading() == SearchOperationThreading.THREAD_PER_SHARD;
                    for (final Tuple<String, Long> target : scrollId.context()) {
                        final DiscoveryNode node = nodes.get(target.v1());
                        if (node != null && nodes.localNodeId().equals(node.id())) {
                            if (localAsync) {
                                threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                                    @Override
                                    public void run() {
                                        executePhase(node, target.v2());
                                    }
                                });
                            } else {
                                executePhase(node, target.v2());
                            }
                        }
                    }
                }

(startLine=169 endLine=186 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollScanAction.java)
                } else {
                    boolean localAsync = request.operationThreading() == SearchOperationThreading.THREAD_PER_SHARD;
                    for (final Tuple<String, Long> target : scrollId.context()) {
                        final DiscoveryNode node = nodes.get(target.v1());
                        if (node != null && nodes.localNodeId().equals(node.id())) {
                            if (localAsync) {
                                threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                                    @Override
                                    public void run() {
                                        executePhase(node, target.v2());
                                    }
                                });
                            } else {
                                executePhase(node, target.v2());
                            }
                        }
                    }
                }

(startLine=169 endLine=186 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollQueryThenFetchAction.java)
                } else {
                    boolean localAsync = request.operationThreading() == SearchOperationThreading.THREAD_PER_SHARD;
                    for (final Tuple<String, Long> target : scrollId.context()) {
                        final DiscoveryNode node = nodes.get(target.v1());
                        if (node != null && nodes.localNodeId().equals(node.id())) {
                            if (localAsync) {
                                threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                                    @Override
                                    public void run() {
                                        executeQueryPhase(counter, node, target.v2());
                                    }
                                });
                            } else {
                                executeQueryPhase(counter, node, target.v2());
                            }
                        }
                    }
                }

commonMethod: 
(startLine=52 endLine=54 srcPath=/root/NewExperiment/elasticsearchFilter/00743/src/main/java/org/elasticsearch/action/search/type/ParsedScrollId.java)
    public String getSource() {
        return source;
    }


, Instance #
frags: 
(startLine=163 endLine=180 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollQueryAndFetchAction.java)
                } else {
                    boolean localAsync = request.operationThreading() == SearchOperationThreading.THREAD_PER_SHARD;
                    for (final Tuple<String, Long> target : scrollId.context()) {
                        final DiscoveryNode node = nodes.get(target.v1());
                        if (node != null && nodes.localNodeId().equals(node.id())) {
                            if (localAsync) {
                                threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                                    @Override
                                    public void run() {
                                        executePhase(node, target.v2());
                                    }
                                });
                            } else {
                                executePhase(node, target.v2());
                            }
                        }
                    }
                }

(startLine=169 endLine=186 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollScanAction.java)
                } else {
                    boolean localAsync = request.operationThreading() == SearchOperationThreading.THREAD_PER_SHARD;
                    for (final Tuple<String, Long> target : scrollId.context()) {
                        final DiscoveryNode node = nodes.get(target.v1());
                        if (node != null && nodes.localNodeId().equals(node.id())) {
                            if (localAsync) {
                                threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                                    @Override
                                    public void run() {
                                        executePhase(node, target.v2());
                                    }
                                });
                            } else {
                                executePhase(node, target.v2());
                            }
                        }
                    }
                }

(startLine=169 endLine=186 srcPath=/root/NewExperiment/elasticsearchFilter/00742/src/main/java/org/elasticsearch/action/search/type/TransportSearchScrollQueryThenFetchAction.java)
                } else {
                    boolean localAsync = request.operationThreading() == SearchOperationThreading.THREAD_PER_SHARD;
                    for (final Tuple<String, Long> target : scrollId.context()) {
                        final DiscoveryNode node = nodes.get(target.v1());
                        if (node != null && nodes.localNodeId().equals(node.id())) {
                            if (localAsync) {
                                threadPool.executor(ThreadPool.Names.SEARCH).execute(new Runnable() {
                                    @Override
                                    public void run() {
                                        executeQueryPhase(counter, node, target.v2());
                                    }
                                });
                            } else {
                                executeQueryPhase(counter, node, target.v2());
                            }
                        }
                    }
                }

commonMethod: 
(startLine=60 endLine=62 srcPath=/root/NewExperiment/elasticsearchFilter/00743/src/main/java/org/elasticsearch/action/search/type/ParsedScrollId.java)
    public Tuple<String, Long>[] getContext() {
        return context;
    }


, Instance #
frags: 
(startLine=1354 endLine=1372 srcPath=/root/NewExperiment/elasticsearchFilter/00748/src/main/java/jsr166e/extra/ReadMostlyVector.java)
        public int indexOf(Object o) {
            final SequenceLock lock = list.lock;
            long seq = lock.awaitAvailability();
            Object[] items = list.array;
            int c = list.count;
            if (c <= items.length) {
                int idx = list.validatedIndexOf(o, items, offset,
                                                offset + size, seq);
                if (lock.getSequence() == seq)
                    return idx < 0 ? -1 : idx - offset;
            }
            lock.lock();
            try {
                int idx = list.rawIndexOf(o, offset, offset + size);
                return idx < 0 ? -1 : idx - offset;
            } finally {
                lock.unlock();
            }
        }

(startLine=1382 endLine=1400 srcPath=/root/NewExperiment/elasticsearchFilter/00748/src/main/java/jsr166e/extra/ReadMostlyVector.java)
        public int lastIndexOf(Object o) {
            final SequenceLock lock = list.lock;
            long seq = lock.awaitAvailability();
            Object[] items = list.array;
            int c = list.count;
            if (c <= items.length) {
                int idx = list.validatedLastIndexOf(o, items, offset+size-1,
                                                    offset, seq);
                if (lock.getSequence() == seq)
                    return idx < 0 ? -1 : idx - offset;
            }
            lock.lock();
            try {
                int idx = list.rawLastIndexOf(o, offset + size - 1, offset);
                return idx < 0 ? -1 : idx - offset;
            } finally {
                lock.unlock();
            }
        }

commonMethod: 
(startLine=531 endLine=555 srcPath=/root/NewExperiment/elasticsearchFilter/00749/src/main/java/jsr166e/StampedLock.java)
    /**
     * If the lock state matches the given stamp, releases the
     * non-exclusive lock.
     *
     * @param stamp a stamp returned by a read-lock operation
     * @throws IllegalMonitorStateException if the stamp does
     * not match the current state of this lock
     */
    public void unlockRead(long stamp) {
        long s, m; WNode h;
        for (;;) {
            if (((s = state) & SBITS) != (stamp & SBITS) ||
                (stamp & ABITS) == 0L || (m = s & ABITS) == 0L || m == WBIT)
                throw new IllegalMonitorStateException();
            if (m < RFULL) {
                if (U.compareAndSwapLong(this, STATE, s, s - RUNIT)) {
                    if (m == RUNIT && (h = whead) != null && h.status != 0)
                        release(h);
                    break;
                }
            }
            else if (tryDecReaderOverflow(s) != 0L)
                break;
        }
    }


, Instance #
frags: 
(startLine=1354 endLine=1372 srcPath=/root/NewExperiment/elasticsearchFilter/00748/src/main/java/jsr166e/extra/ReadMostlyVector.java)
        public int indexOf(Object o) {
            final SequenceLock lock = list.lock;
            long seq = lock.awaitAvailability();
            Object[] items = list.array;
            int c = list.count;
            if (c <= items.length) {
                int idx = list.validatedIndexOf(o, items, offset,
                                                offset + size, seq);
                if (lock.getSequence() == seq)
                    return idx < 0 ? -1 : idx - offset;
            }
            lock.lock();
            try {
                int idx = list.rawIndexOf(o, offset, offset + size);
                return idx < 0 ? -1 : idx - offset;
            } finally {
                lock.unlock();
            }
        }

(startLine=1382 endLine=1400 srcPath=/root/NewExperiment/elasticsearchFilter/00748/src/main/java/jsr166e/extra/ReadMostlyVector.java)
        public int lastIndexOf(Object o) {
            final SequenceLock lock = list.lock;
            long seq = lock.awaitAvailability();
            Object[] items = list.array;
            int c = list.count;
            if (c <= items.length) {
                int idx = list.validatedLastIndexOf(o, items, offset+size-1,
                                                    offset, seq);
                if (lock.getSequence() == seq)
                    return idx < 0 ? -1 : idx - offset;
            }
            lock.lock();
            try {
                int idx = list.rawLastIndexOf(o, offset + size - 1, offset);
                return idx < 0 ? -1 : idx - offset;
            } finally {
                lock.unlock();
            }
        }

commonMethod: 
(startLine=402 endLine=413 srcPath=/root/NewExperiment/elasticsearchFilter/00749/src/main/java/jsr166e/StampedLock.java)
    /**
     * Non-exclusively acquires the lock, blocking if necessary
     * until available.
     *
     * @return a stamp that can be used to unlock or convert mode
     */
    public long readLock() {
        long s, next;  // bypass acquireRead on fully unlocked case only
        return ((((s = state) & ABITS) == 0L &&
                 U.compareAndSwapLong(this, STATE, s, next = s + RUNIT)) ?
                next : acquireRead(false, 0L));
    }


, Instance #
frags: 
(startLine=1390 endLine=1514 srcPath=/root/NewExperiment/elasticsearchFilter/00748/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                                                 MappingFunction<? super K, ?> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int count = 0;
        for (Node[] tab = table;;) {
            Node f; int i, fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    count = 1;
                    try {
                        if ((val = mf.map(k)) != null)
                            node.val = val;
                    } finally {
                        if (val == null)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean added = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            if (p != null)
                                val = p.val;
                            else if ((val = mf.map(k)) != null) {
                                added = true;
                                count = 2;
                                t.putTreeNode(h, k, val);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        break;
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & HASH_BITS) == h && (fv = f.val) != null &&
                     ((fk = f.key) == k || k.equals(fk)))
                return fv;
            else {
                Node g = f.next;
                if (g != null) {
                    for (Node e = g;;) {
                        Object ek, ev;
                        if ((e.hash & HASH_BITS) == h && (ev = e.val) != null &&
                            ((ek = e.key) == k || k.equals(ek)))
                            return ev;
                        if ((e = e.next) == null) {
                            checkForResize();
                            break;
                        }
                    }
                }
                if (((fh = f.hash) & LOCKED) != 0) {
                    checkForResize();
                    f.tryAwaitLock(tab, i);
                }
                else if (tabAt(tab, i) == f && f.casHash(fh, fh | LOCKED)) {
                    boolean added = false;
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            for (Node e = f;; ++count) {
                                Object ek, ev;
                                if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                    val = ev;
                                    break;
                                }
                                Node last = e;
                                if ((e = e.next) == null) {
                                    if ((val = mf.map(k)) != null) {
                                        added = true;
                                        last.next = new Node(h, k, val, null);
                                        if (count >= TREE_THRESHOLD)
                                            replaceWithTreeBin(tab, i, k);
                                    }
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (!f.casHash(fh | LOCKED, fh)) {
                            f.hash = fh;
                            synchronized (f) { f.notifyAll(); };
                        }
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        if (tab.length <= 64)
                            count = 2;
                        break;
                    }
                }
            }
        }
        if (val == null)
            throw new NullPointerException();
        counter.add(1L);
        if (count > 1)
            checkForResize();
        return val;
    }

(startLine=1519 endLine=1628 srcPath=/root/NewExperiment/elasticsearchFilter/00748/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                                         RemappingFunction<? super K, V> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        boolean added = false;
        int count = 0;
        for (Node[] tab = table;;) {
            Node f; int i, fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    try {
                        count = 1;
                        if ((val = mf.remap(k, null)) != null) {
                            node.val = val;
                            added = true;
                        }
                    } finally {
                        if (!added)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            Object pv = (p == null) ? null : p.val;
                            if ((val = mf.remap(k, (V)pv)) != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    count = 2;
                                    added = true;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0)
                        break;
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.remap(k, (V)ev);
                                if (val != null)
                                    e.val = val;
                                break;
                            }
                            Node last = e;
                            if ((e = e.next) == null) {
                                if ((val = mf.remap(k, null)) != null) {
                                    last.next = new Node(h, k, val, null);
                                    added = true;
                                    if (count >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (tab.length <= 64)
                        count = 2;
                    break;
                }
            }
        }
        if (val == null)
            throw new NullPointerException();
        if (added) {
            counter.add(1L);
            if (count > 1)
                checkForResize();
        }
        return val;
    }

commonMethod: 
(startLine=984 endLine=1154 srcPath=/root/NewExperiment/elasticsearchFilter/00749/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Removes the given node, that must be present before this
         * call.  This is messier than typical red-black deletion code
         * because we cannot swap the contents of an interior node
         * with a leaf successor that is pinned by "next" pointers
         * that are accessible independently of lock. So instead we
         * swap the tree linkages.
         */
        final void deleteTreeNode(TreeNode<V> p) {
            TreeNode<V> next = (TreeNode<V>)p.next; // unlink traversal pointers
            TreeNode<V> pred = p.prev;
            if (pred == null)
                first = next;
            else
                pred.next = next;
            if (next != null)
                next.prev = pred;
            TreeNode<V> replacement;
            TreeNode<V> pl = p.left;
            TreeNode<V> pr = p.right;
            if (pl != null && pr != null) {
                TreeNode<V> s = pr, sl;
                while ((sl = s.left) != null) // find successor
                    s = sl;
                boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                TreeNode<V> sr = s.right;
                TreeNode<V> pp = p.parent;
                if (s == pr) { // p was s's direct parent
                    p.parent = s;
                    s.right = p;
                }
                else {
                    TreeNode<V> sp = s.parent;
                    if ((p.parent = sp) != null) {
                        if (s == sp.left)
                            sp.left = p;
                        else
                            sp.right = p;
                    }
                    if ((s.right = pr) != null)
                        pr.parent = s;
                }
                p.left = null;
                if ((p.right = sr) != null)
                    sr.parent = p;
                if ((s.left = pl) != null)
                    pl.parent = s;
                if ((s.parent = pp) == null)
                    root = s;
                else if (p == pp.left)
                    pp.left = s;
                else
                    pp.right = s;
                replacement = sr;
            }
            else
                replacement = (pl != null) ? pl : pr;
            TreeNode<V> pp = p.parent;
            if (replacement == null) {
                if (pp == null) {
                    root = null;
                    return;
                }
                replacement = p;
            }
            else {
                replacement.parent = pp;
                if (pp == null)
                    root = replacement;
                else if (p == pp.left)
                    pp.left = replacement;
                else
                    pp.right = replacement;
                p.left = p.right = p.parent = null;
            }
            if (!p.red) { // rebalance, from CLR
                TreeNode<V> x = replacement;
                while (x != null) {
                    TreeNode<V> xp, xpl;
                    if (x.red || (xp = x.parent) == null) {
                        x.red = false;
                        break;
                    }
                    if (x == (xpl = xp.left)) {
                        TreeNode<V> sib = xp.right;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateLeft(xp);
                            sib = (xp = x.parent) == null ? null : xp.right;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode<V> sl = sib.left, sr = sib.right;
                            if ((sr == null || !sr.red) &&
                                (sl == null || !sl.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sr == null || !sr.red) {
                                    if (sl != null)
                                        sl.red = false;
                                    sib.red = true;
                                    rotateRight(sib);
                                    sib = (xp = x.parent) == null ?
                                        null : xp.right;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sr = sib.right) != null)
                                        sr.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateLeft(xp);
                                }
                                x = root;
                            }
                        }
                    }
                    else { // symmetric
                        TreeNode<V> sib = xpl;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateRight(xp);
                            sib = (xp = x.parent) == null ? null : xp.left;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode<V> sl = sib.left, sr = sib.right;
                            if ((sl == null || !sl.red) &&
                                (sr == null || !sr.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sl == null || !sl.red) {
                                    if (sr != null)
                                        sr.red = false;
                                    sib.red = true;
                                    rotateLeft(sib);
                                    sib = (xp = x.parent) == null ?
                                        null : xp.left;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sl = sib.left) != null)
                                        sl.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateRight(xp);
                                }
                                x = root;
                            }
                        }
                    }
                }
            }
            if (p == replacement && (pp = p.parent) != null) {
                if (p == pp.left) // detach pointers
                    pp.left = null;
                else if (p == pp.right)
                    pp.right = null;
                p.parent = null;
            }
        }


, Instance #
frags: 
(startLine=1390 endLine=1514 srcPath=/root/NewExperiment/elasticsearchFilter/00748/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                                                 MappingFunction<? super K, ?> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int count = 0;
        for (Node[] tab = table;;) {
            Node f; int i, fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    count = 1;
                    try {
                        if ((val = mf.map(k)) != null)
                            node.val = val;
                    } finally {
                        if (val == null)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean added = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            if (p != null)
                                val = p.val;
                            else if ((val = mf.map(k)) != null) {
                                added = true;
                                count = 2;
                                t.putTreeNode(h, k, val);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        break;
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & HASH_BITS) == h && (fv = f.val) != null &&
                     ((fk = f.key) == k || k.equals(fk)))
                return fv;
            else {
                Node g = f.next;
                if (g != null) {
                    for (Node e = g;;) {
                        Object ek, ev;
                        if ((e.hash & HASH_BITS) == h && (ev = e.val) != null &&
                            ((ek = e.key) == k || k.equals(ek)))
                            return ev;
                        if ((e = e.next) == null) {
                            checkForResize();
                            break;
                        }
                    }
                }
                if (((fh = f.hash) & LOCKED) != 0) {
                    checkForResize();
                    f.tryAwaitLock(tab, i);
                }
                else if (tabAt(tab, i) == f && f.casHash(fh, fh | LOCKED)) {
                    boolean added = false;
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            for (Node e = f;; ++count) {
                                Object ek, ev;
                                if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                    val = ev;
                                    break;
                                }
                                Node last = e;
                                if ((e = e.next) == null) {
                                    if ((val = mf.map(k)) != null) {
                                        added = true;
                                        last.next = new Node(h, k, val, null);
                                        if (count >= TREE_THRESHOLD)
                                            replaceWithTreeBin(tab, i, k);
                                    }
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (!f.casHash(fh | LOCKED, fh)) {
                            f.hash = fh;
                            synchronized (f) { f.notifyAll(); };
                        }
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        if (tab.length <= 64)
                            count = 2;
                        break;
                    }
                }
            }
        }
        if (val == null)
            throw new NullPointerException();
        counter.add(1L);
        if (count > 1)
            checkForResize();
        return val;
    }

(startLine=1519 endLine=1628 srcPath=/root/NewExperiment/elasticsearchFilter/00748/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                                         RemappingFunction<? super K, V> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        boolean added = false;
        int count = 0;
        for (Node[] tab = table;;) {
            Node f; int i, fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    try {
                        count = 1;
                        if ((val = mf.remap(k, null)) != null) {
                            node.val = val;
                            added = true;
                        }
                    } finally {
                        if (!added)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            Object pv = (p == null) ? null : p.val;
                            if ((val = mf.remap(k, (V)pv)) != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    count = 2;
                                    added = true;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0)
                        break;
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.remap(k, (V)ev);
                                if (val != null)
                                    e.val = val;
                                break;
                            }
                            Node last = e;
                            if ((e = e.next) == null) {
                                if ((val = mf.remap(k, null)) != null) {
                                    last.next = new Node(h, k, val, null);
                                    added = true;
                                    if (count >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (tab.length <= 64)
                        count = 2;
                    break;
                }
            }
        }
        if (val == null)
            throw new NullPointerException();
        if (added) {
            counter.add(1L);
            if (count > 1)
                checkForResize();
        }
        return val;
    }

commonMethod: 
(startLine=984 endLine=1154 srcPath=/root/NewExperiment/elasticsearchFilter/00749/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Removes the given node, that must be present before this
         * call.  This is messier than typical red-black deletion code
         * because we cannot swap the contents of an interior node
         * with a leaf successor that is pinned by "next" pointers
         * that are accessible independently of lock. So instead we
         * swap the tree linkages.
         */
        final void deleteTreeNode(TreeNode<V> p) {
            TreeNode<V> next = (TreeNode<V>)p.next; // unlink traversal pointers
            TreeNode<V> pred = p.prev;
            if (pred == null)
                first = next;
            else
                pred.next = next;
            if (next != null)
                next.prev = pred;
            TreeNode<V> replacement;
            TreeNode<V> pl = p.left;
            TreeNode<V> pr = p.right;
            if (pl != null && pr != null) {
                TreeNode<V> s = pr, sl;
                while ((sl = s.left) != null) // find successor
                    s = sl;
                boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                TreeNode<V> sr = s.right;
                TreeNode<V> pp = p.parent;
                if (s == pr) { // p was s's direct parent
                    p.parent = s;
                    s.right = p;
                }
                else {
                    TreeNode<V> sp = s.parent;
                    if ((p.parent = sp) != null) {
                        if (s == sp.left)
                            sp.left = p;
                        else
                            sp.right = p;
                    }
                    if ((s.right = pr) != null)
                        pr.parent = s;
                }
                p.left = null;
                if ((p.right = sr) != null)
                    sr.parent = p;
                if ((s.left = pl) != null)
                    pl.parent = s;
                if ((s.parent = pp) == null)
                    root = s;
                else if (p == pp.left)
                    pp.left = s;
                else
                    pp.right = s;
                replacement = sr;
            }
            else
                replacement = (pl != null) ? pl : pr;
            TreeNode<V> pp = p.parent;
            if (replacement == null) {
                if (pp == null) {
                    root = null;
                    return;
                }
                replacement = p;
            }
            else {
                replacement.parent = pp;
                if (pp == null)
                    root = replacement;
                else if (p == pp.left)
                    pp.left = replacement;
                else
                    pp.right = replacement;
                p.left = p.right = p.parent = null;
            }
            if (!p.red) { // rebalance, from CLR
                TreeNode<V> x = replacement;
                while (x != null) {
                    TreeNode<V> xp, xpl;
                    if (x.red || (xp = x.parent) == null) {
                        x.red = false;
                        break;
                    }
                    if (x == (xpl = xp.left)) {
                        TreeNode<V> sib = xp.right;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateLeft(xp);
                            sib = (xp = x.parent) == null ? null : xp.right;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode<V> sl = sib.left, sr = sib.right;
                            if ((sr == null || !sr.red) &&
                                (sl == null || !sl.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sr == null || !sr.red) {
                                    if (sl != null)
                                        sl.red = false;
                                    sib.red = true;
                                    rotateRight(sib);
                                    sib = (xp = x.parent) == null ?
                                        null : xp.right;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sr = sib.right) != null)
                                        sr.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateLeft(xp);
                                }
                                x = root;
                            }
                        }
                    }
                    else { // symmetric
                        TreeNode<V> sib = xpl;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateRight(xp);
                            sib = (xp = x.parent) == null ? null : xp.left;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode<V> sl = sib.left, sr = sib.right;
                            if ((sl == null || !sl.red) &&
                                (sr == null || !sr.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sl == null || !sl.red) {
                                    if (sr != null)
                                        sr.red = false;
                                    sib.red = true;
                                    rotateLeft(sib);
                                    sib = (xp = x.parent) == null ?
                                        null : xp.left;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sl = sib.left) != null)
                                        sl.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateRight(xp);
                                }
                                x = root;
                            }
                        }
                    }
                }
            }
            if (p == replacement && (pp = p.parent) != null) {
                if (p == pp.left) // detach pointers
                    pp.left = null;
                else if (p == pp.right)
                    pp.right = null;
                p.parent = null;
            }
        }


, Instance #
frags: 
(startLine=1467 endLine=1505 srcPath=/root/NewExperiment/elasticsearchFilter/00748/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                else if (tabAt(tab, i) == f && f.casHash(fh, fh | LOCKED)) {
                    boolean added = false;
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            for (Node e = f;; ++count) {
                                Object ek, ev;
                                if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                    val = ev;
                                    break;
                                }
                                Node last = e;
                                if ((e = e.next) == null) {
                                    if ((val = mf.map(k)) != null) {
                                        added = true;
                                        last.next = new Node(h, k, val, null);
                                        if (count >= TREE_THRESHOLD)
                                            replaceWithTreeBin(tab, i, k);
                                    }
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (!f.casHash(fh | LOCKED, fh)) {
                            f.hash = fh;
                            synchronized (f) { f.notifyAll(); };
                        }
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        if (tab.length <= 64)
                            count = 2;
                        break;
                    }
                }

(startLine=1581 endLine=1618 srcPath=/root/NewExperiment/elasticsearchFilter/00748/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.remap(k, (V)ev);
                                if (val != null)
                                    e.val = val;
                                break;
                            }
                            Node last = e;
                            if ((e = e.next) == null) {
                                if ((val = mf.remap(k, null)) != null) {
                                    last.next = new Node(h, k, val, null);
                                    added = true;
                                    if (count >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (tab.length <= 64)
                        count = 2;
                    break;
                }
            }

commonMethod: 
(startLine=984 endLine=1154 srcPath=/root/NewExperiment/elasticsearchFilter/00749/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Removes the given node, that must be present before this
         * call.  This is messier than typical red-black deletion code
         * because we cannot swap the contents of an interior node
         * with a leaf successor that is pinned by "next" pointers
         * that are accessible independently of lock. So instead we
         * swap the tree linkages.
         */
        final void deleteTreeNode(TreeNode<V> p) {
            TreeNode<V> next = (TreeNode<V>)p.next; // unlink traversal pointers
            TreeNode<V> pred = p.prev;
            if (pred == null)
                first = next;
            else
                pred.next = next;
            if (next != null)
                next.prev = pred;
            TreeNode<V> replacement;
            TreeNode<V> pl = p.left;
            TreeNode<V> pr = p.right;
            if (pl != null && pr != null) {
                TreeNode<V> s = pr, sl;
                while ((sl = s.left) != null) // find successor
                    s = sl;
                boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                TreeNode<V> sr = s.right;
                TreeNode<V> pp = p.parent;
                if (s == pr) { // p was s's direct parent
                    p.parent = s;
                    s.right = p;
                }
                else {
                    TreeNode<V> sp = s.parent;
                    if ((p.parent = sp) != null) {
                        if (s == sp.left)
                            sp.left = p;
                        else
                            sp.right = p;
                    }
                    if ((s.right = pr) != null)
                        pr.parent = s;
                }
                p.left = null;
                if ((p.right = sr) != null)
                    sr.parent = p;
                if ((s.left = pl) != null)
                    pl.parent = s;
                if ((s.parent = pp) == null)
                    root = s;
                else if (p == pp.left)
                    pp.left = s;
                else
                    pp.right = s;
                replacement = sr;
            }
            else
                replacement = (pl != null) ? pl : pr;
            TreeNode<V> pp = p.parent;
            if (replacement == null) {
                if (pp == null) {
                    root = null;
                    return;
                }
                replacement = p;
            }
            else {
                replacement.parent = pp;
                if (pp == null)
                    root = replacement;
                else if (p == pp.left)
                    pp.left = replacement;
                else
                    pp.right = replacement;
                p.left = p.right = p.parent = null;
            }
            if (!p.red) { // rebalance, from CLR
                TreeNode<V> x = replacement;
                while (x != null) {
                    TreeNode<V> xp, xpl;
                    if (x.red || (xp = x.parent) == null) {
                        x.red = false;
                        break;
                    }
                    if (x == (xpl = xp.left)) {
                        TreeNode<V> sib = xp.right;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateLeft(xp);
                            sib = (xp = x.parent) == null ? null : xp.right;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode<V> sl = sib.left, sr = sib.right;
                            if ((sr == null || !sr.red) &&
                                (sl == null || !sl.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sr == null || !sr.red) {
                                    if (sl != null)
                                        sl.red = false;
                                    sib.red = true;
                                    rotateRight(sib);
                                    sib = (xp = x.parent) == null ?
                                        null : xp.right;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sr = sib.right) != null)
                                        sr.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateLeft(xp);
                                }
                                x = root;
                            }
                        }
                    }
                    else { // symmetric
                        TreeNode<V> sib = xpl;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateRight(xp);
                            sib = (xp = x.parent) == null ? null : xp.left;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode<V> sl = sib.left, sr = sib.right;
                            if ((sl == null || !sl.red) &&
                                (sr == null || !sr.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sl == null || !sl.red) {
                                    if (sr != null)
                                        sr.red = false;
                                    sib.red = true;
                                    rotateLeft(sib);
                                    sib = (xp = x.parent) == null ?
                                        null : xp.left;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sl = sib.left) != null)
                                        sl.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateRight(xp);
                                }
                                x = root;
                            }
                        }
                    }
                }
            }
            if (p == replacement && (pp = p.parent) != null) {
                if (p == pp.left) // detach pointers
                    pp.left = null;
                else if (p == pp.right)
                    pp.right = null;
                p.parent = null;
            }
        }


, Instance #
frags: 
(startLine=619 endLine=628 srcPath=/root/NewExperiment/elasticsearchFilter/00750/src/test/java/org/elasticsearch/test/unit/index/engine/AbstractSimpleEngineTests.java)
    public void testVersioningNewIndex() {
        ParsedDocument doc = new ParsedDocument("1", "1", "test", null, -1, -1, testDocument("1"), Lucene.STANDARD_ANALYZER, B_1, false);
        Engine.Index index = new Engine.Index(null, newUid("1"), doc);
        engine.index(index);
        assertThat(index.version(), equalTo(1l));

        index = new Engine.Index(null, newUid("1"), doc).version(index.version()).origin(REPLICA);
        replicaEngine.index(index);
        assertThat(index.version(), equalTo(1l));
    }

(startLine=631 endLine=640 srcPath=/root/NewExperiment/elasticsearchFilter/00750/src/test/java/org/elasticsearch/test/unit/index/engine/AbstractSimpleEngineTests.java)
    public void testExternalVersioningNewIndex() {
        ParsedDocument doc = new ParsedDocument("1", "1", "test", null, -1, -1, testDocument("1"), Lucene.STANDARD_ANALYZER, B_1, false);
        Engine.Index index = new Engine.Index(null, newUid("1"), doc).versionType(VersionType.EXTERNAL).version(12);
        engine.index(index);
        assertThat(index.version(), equalTo(12l));

        index = new Engine.Index(null, newUid("1"), doc).version(index.version()).origin(REPLICA);
        replicaEngine.index(index);
        assertThat(index.version(), equalTo(12l));
    }

commonMethod: 
(startLine=127 endLine=131 srcPath=/root/NewExperiment/elasticsearchFilter/00751/src/test/java/org/elasticsearch/test/unit/index/engine/AbstractSimpleEngineTests.java)
    private ParsedDocument testParsedDocument(String uid, String id, String type, String routing, long timestamp, long ttl, Document document, Analyzer analyzer, BytesReference source, boolean mappingsModified) {
        UidField uidField = new UidField("_uid", uid, 0);
        document.add(uidField);
        return new ParsedDocument(uidField, id, type, routing, timestamp, ttl, Arrays.asList(document), analyzer, source, mappingsModified);
    }


, Instance #
frags: 
(startLine=595 endLine=604 srcPath=/root/NewExperiment/elasticsearchFilter/00750/src/test/java/org/elasticsearch/test/unit/index/engine/AbstractSimpleEngineTests.java)
    public void testVersioningNewCreate() {
        ParsedDocument doc = new ParsedDocument("1", "1", "test", null, -1, -1, testDocument("1"), Lucene.STANDARD_ANALYZER, B_1, false);
        Engine.Create create = new Engine.Create(null, newUid("1"), doc);
        engine.create(create);
        assertThat(create.version(), equalTo(1l));

        create = new Engine.Create(null, newUid("1"), doc).version(create.version()).origin(REPLICA);
        replicaEngine.create(create);
        assertThat(create.version(), equalTo(1l));
    }

(startLine=607 endLine=616 srcPath=/root/NewExperiment/elasticsearchFilter/00750/src/test/java/org/elasticsearch/test/unit/index/engine/AbstractSimpleEngineTests.java)
    public void testExternalVersioningNewCreate() {
        ParsedDocument doc = new ParsedDocument("1", "1", "test", null, -1, -1, testDocument("1"), Lucene.STANDARD_ANALYZER, B_1, false);
        Engine.Create create = new Engine.Create(null, newUid("1"), doc).versionType(VersionType.EXTERNAL).version(12);
        engine.create(create);
        assertThat(create.version(), equalTo(12l));

        create = new Engine.Create(null, newUid("1"), doc).version(create.version()).origin(REPLICA);
        replicaEngine.create(create);
        assertThat(create.version(), equalTo(12l));
    }

commonMethod: 
(startLine=127 endLine=131 srcPath=/root/NewExperiment/elasticsearchFilter/00751/src/test/java/org/elasticsearch/test/unit/index/engine/AbstractSimpleEngineTests.java)
    private ParsedDocument testParsedDocument(String uid, String id, String type, String routing, long timestamp, long ttl, Document document, Analyzer analyzer, BytesReference source, boolean mappingsModified) {
        UidField uidField = new UidField("_uid", uid, 0);
        document.add(uidField);
        return new ParsedDocument(uidField, id, type, routing, timestamp, ttl, Arrays.asList(document), analyzer, source, mappingsModified);
    }


, Instance #
frags: 
(startLine=595 endLine=604 srcPath=/root/NewExperiment/elasticsearchFilter/00750/src/test/java/org/elasticsearch/test/unit/index/engine/AbstractSimpleEngineTests.java)
    public void testVersioningNewCreate() {
        ParsedDocument doc = new ParsedDocument("1", "1", "test", null, -1, -1, testDocument("1"), Lucene.STANDARD_ANALYZER, B_1, false);
        Engine.Create create = new Engine.Create(null, newUid("1"), doc);
        engine.create(create);
        assertThat(create.version(), equalTo(1l));

        create = new Engine.Create(null, newUid("1"), doc).version(create.version()).origin(REPLICA);
        replicaEngine.create(create);
        assertThat(create.version(), equalTo(1l));
    }

(startLine=607 endLine=616 srcPath=/root/NewExperiment/elasticsearchFilter/00750/src/test/java/org/elasticsearch/test/unit/index/engine/AbstractSimpleEngineTests.java)
    public void testExternalVersioningNewCreate() {
        ParsedDocument doc = new ParsedDocument("1", "1", "test", null, -1, -1, testDocument("1"), Lucene.STANDARD_ANALYZER, B_1, false);
        Engine.Create create = new Engine.Create(null, newUid("1"), doc).versionType(VersionType.EXTERNAL).version(12);
        engine.create(create);
        assertThat(create.version(), equalTo(12l));

        create = new Engine.Create(null, newUid("1"), doc).version(create.version()).origin(REPLICA);
        replicaEngine.create(create);
        assertThat(create.version(), equalTo(12l));
    }

(startLine=619 endLine=628 srcPath=/root/NewExperiment/elasticsearchFilter/00750/src/test/java/org/elasticsearch/test/unit/index/engine/AbstractSimpleEngineTests.java)
    public void testVersioningNewIndex() {
        ParsedDocument doc = new ParsedDocument("1", "1", "test", null, -1, -1, testDocument("1"), Lucene.STANDARD_ANALYZER, B_1, false);
        Engine.Index index = new Engine.Index(null, newUid("1"), doc);
        engine.index(index);
        assertThat(index.version(), equalTo(1l));

        index = new Engine.Index(null, newUid("1"), doc).version(index.version()).origin(REPLICA);
        replicaEngine.index(index);
        assertThat(index.version(), equalTo(1l));
    }

(startLine=631 endLine=640 srcPath=/root/NewExperiment/elasticsearchFilter/00750/src/test/java/org/elasticsearch/test/unit/index/engine/AbstractSimpleEngineTests.java)
    public void testExternalVersioningNewIndex() {
        ParsedDocument doc = new ParsedDocument("1", "1", "test", null, -1, -1, testDocument("1"), Lucene.STANDARD_ANALYZER, B_1, false);
        Engine.Index index = new Engine.Index(null, newUid("1"), doc).versionType(VersionType.EXTERNAL).version(12);
        engine.index(index);
        assertThat(index.version(), equalTo(12l));

        index = new Engine.Index(null, newUid("1"), doc).version(index.version()).origin(REPLICA);
        replicaEngine.index(index);
        assertThat(index.version(), equalTo(12l));
    }

commonMethod: 
(startLine=127 endLine=131 srcPath=/root/NewExperiment/elasticsearchFilter/00751/src/test/java/org/elasticsearch/test/unit/index/engine/AbstractSimpleEngineTests.java)
    private ParsedDocument testParsedDocument(String uid, String id, String type, String routing, long timestamp, long ttl, Document document, Analyzer analyzer, BytesReference source, boolean mappingsModified) {
        UidField uidField = new UidField("_uid", uid, 0);
        document.add(uidField);
        return new ParsedDocument(uidField, id, type, routing, timestamp, ttl, Arrays.asList(document), analyzer, source, mappingsModified);
    }


, Instance #
frags: 
(startLine=158 endLine=180 srcPath=/root/NewExperiment/elasticsearchFilter/00763/src/main/java/org/elasticsearch/search/suggest/phrase/PhraseSuggestParser.java)
                } else if ("laplace".equals(fieldName)) {
                    ensureNoSmoothing(suggestion);
                    double theAlpha = 0.5;

                    while ((token = parser.nextToken()) != Token.END_OBJECT) {
                        if (token == XContentParser.Token.FIELD_NAME) {
                            fieldName = parser.currentName();
                        }
                        if (token.isValue()) {
                            if ("alpha".equals(fieldName)) {
                                theAlpha = parser.doubleValue();
                            }
                        }
                    }
                    final double alpha = theAlpha;
                    suggestion.setModel( new WordScorer.WordScorerFactory() {
                        @Override
                        public WordScorer newScorer(IndexReader reader, String field, double realWordLikelyhood, BytesRef separator) throws IOException {
                            return new LaplaceScorer(reader, field, realWordLikelyhood, separator, alpha);
                        }
                    });

                } else if ("stupid_backoff".equals(fieldName)) {

(startLine=180 endLine=201 srcPath=/root/NewExperiment/elasticsearchFilter/00763/src/main/java/org/elasticsearch/search/suggest/phrase/PhraseSuggestParser.java)
                } else if ("stupid_backoff".equals(fieldName)) {
                    ensureNoSmoothing(suggestion);
                    double theDiscount = 0.4;
                    while ((token = parser.nextToken()) != Token.END_OBJECT) {
                        if (token == XContentParser.Token.FIELD_NAME) {
                            fieldName = parser.currentName();
                        }
                        if (token.isValue()) {
                            if ("discount".equals(fieldName)) {
                                theDiscount = parser.doubleValue();
                            }
                        }
                    }
                    final double discount = theDiscount; 
                    suggestion.setModel( new WordScorer.WordScorerFactory() {
                        @Override
                        public WordScorer newScorer(IndexReader reader, String field, double realWordLikelyhood, BytesRef separator) throws IOException {
                            return new StupidBackoffScorer(reader, field, realWordLikelyhood, separator, discount);
                        }
                    });
                   
                } else {

commonMethod: 
(startLine=157 endLine=250 srcPath=/root/NewExperiment/elasticsearchFilter/00764/src/main/java/org/elasticsearch/search/suggest/phrase/PhraseSuggestParser.java)
    public void parseSmoothingModel(XContentParser parser, PhraseSuggestionContext suggestion, String fieldName) throws IOException {
        XContentParser.Token token;
        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
            if (token == XContentParser.Token.FIELD_NAME) {
                fieldName = parser.currentName();
                break;
            }
        }
        if ("linear".equals(fieldName)) {
            ensureNoSmoothing(suggestion);
            final double[] lambdas = new double[3];
            while ((token = parser.nextToken()) != Token.END_OBJECT) {
                if (token == XContentParser.Token.FIELD_NAME) {
                    fieldName = parser.currentName();
                }
                if (token.isValue()) {
                    if ("trigram_lambda".equals(fieldName)) {
                        lambdas[0] = parser.doubleValue();
                        if (lambdas[0] < 0) {
                            throw new ElasticSearchIllegalArgumentException("trigram_lambda must be positive");
                        }
                    } else if ("bigram_lambda".equals(fieldName)) {
                        lambdas[1] = parser.doubleValue();
                        if (lambdas[1] < 0) {
                            throw new ElasticSearchIllegalArgumentException("bigram_lambda must be positive");
                        }
                    } else if ("unigram_lambda".equals(fieldName)) {
                        lambdas[2] = parser.doubleValue();
                        if (lambdas[2] < 0) {
                            throw new ElasticSearchIllegalArgumentException("unigram_lambda must be positive");
                        }
                    } else {
                        throw new ElasticSearchIllegalArgumentException("suggester[phrase][smoothing][linear] doesn't support field [" + fieldName + "]");
                    }
                }
            }
            double sum = 0.0d;
            for (int i = 0; i < lambdas.length; i++) {
                sum += lambdas[i];
            }
            if (Math.abs(sum - 1.0) > 0.001) {
                throw new ElasticSearchIllegalArgumentException("linear smoothing lambdas must sum to 1");
            }
            suggestion.setModel(new WordScorer.WordScorerFactory() {
                @Override
                public WordScorer newScorer(IndexReader reader, String field, double realWordLikelyhood, BytesRef separator)
                        throws IOException {
                    return new LinearInterpoatingScorer(reader, field, realWordLikelyhood, separator, lambdas[0], lambdas[1],
                            lambdas[2]);
                }
            });
        } else if ("laplace".equals(fieldName)) {
            ensureNoSmoothing(suggestion);
            double theAlpha = 0.5;

            while ((token = parser.nextToken()) != Token.END_OBJECT) {
                if (token == XContentParser.Token.FIELD_NAME) {
                    fieldName = parser.currentName();
                }
                if (token.isValue() && "alpha".equals(fieldName)) {
                        theAlpha = parser.doubleValue();
                }
            }
            final double alpha = theAlpha;
            suggestion.setModel( new WordScorer.WordScorerFactory() {
                @Override
                public WordScorer newScorer(IndexReader reader, String field, double realWordLikelyhood, BytesRef separator) throws IOException {
                    return new LaplaceScorer(reader, field, realWordLikelyhood, separator, alpha);
                }
            });

        } else if ("stupid_backoff".equals(fieldName)) {
            ensureNoSmoothing(suggestion);
            double theDiscount = 0.4;
            while ((token = parser.nextToken()) != Token.END_OBJECT) {
                if (token == XContentParser.Token.FIELD_NAME) {
                    fieldName = parser.currentName();
                }
                if (token.isValue() && "discount".equals(fieldName)) {
                    theDiscount = parser.doubleValue();
                }
            }
            final double discount = theDiscount; 
            suggestion.setModel( new WordScorer.WordScorerFactory() {
                @Override
                public WordScorer newScorer(IndexReader reader, String field, double realWordLikelyhood, BytesRef separator) throws IOException {
                    return new StupidBackoffScorer(reader, field, realWordLikelyhood, separator, discount);
                }
            });
           
        } else {
            throw new ElasticSearchIllegalArgumentException("suggester[phrase] doesn't support object field [" + fieldName + "]");
        }
    }


, Instance #
frags: 
(startLine=257 endLine=267 srcPath=/root/NewExperiment/elasticsearchFilter/00774/src/main/java/org/elasticsearch/index/fielddata/plain/ConcreteBytesRefAtomicFieldData.java)
            public void forEachValueInDoc(int docId, ValueInDocProc proc) {
                Ordinals.Docs.Iter iter = ordinals.getIter(docId);
                int ord = iter.next();
                if (ord == 0) {
                    proc.onMissing(docId);
                    return;
                }
                do {
                    proc.onValue(docId, values[ord]);
                } while ((ord = iter.next()) != 0);
            }

(startLine=263 endLine=274 srcPath=/root/NewExperiment/elasticsearchFilter/00774/src/main/java/org/elasticsearch/index/fielddata/plain/PagedBytesAtomicFieldData.java)
            public void forEachValueInDoc(int docId, ValueInDocProc proc) {
                Ordinals.Docs.Iter iter = ordinals.getIter(docId);
                int ord = iter.next();
                if (ord == 0) {
                    proc.onMissing(docId);
                    return;
                }
                do {
                    bytes.fill(scratch, termOrdToBytesOffset.get(ord));
                    proc.onValue(docId, scratch);
                } while ((ord = iter.next()) != 0);
            }

commonMethod: 
(startLine=372 endLine=384 srcPath=/root/NewExperiment/elasticsearchFilter/00775/src/main/java/org/elasticsearch/index/fielddata/BytesValues.java)
        protected void forEachValueInDocMulti(int docId, ValueInDocProc proc) {
            assert isMultiValued();
            Ordinals.Docs.Iter iter = ordinals.getIter(docId);
            int ord = iter.next();
            if (ord == 0) {
                proc.onMissing(docId);
                return;
            }
            do {
                getValueScratchByOrd(ord, scratch);
                proc.onValue(docId, scratch);
            } while ((ord = iter.next()) != 0);
        }


, Instance #
frags: 
(startLine=239 endLine=249 srcPath=/root/NewExperiment/elasticsearchFilter/00774/src/main/java/org/elasticsearch/index/fielddata/plain/ConcreteBytesRefAtomicFieldData.java)
            public BytesRefArrayRef getValues(int docId) {
                IntArrayRef ords = ordinals.getOrds(docId);
                int size = ords.size();
                if (size == 0) return BytesRefArrayRef.EMPTY;

                arrayScratch.reset(size);
                for (int i = ords.start; i < ords.end; i++) {
                    arrayScratch.values[arrayScratch.end++] = values[ords.values[i]];
                }
                return arrayScratch;
            }

(startLine=243 endLine=255 srcPath=/root/NewExperiment/elasticsearchFilter/00774/src/main/java/org/elasticsearch/index/fielddata/plain/PagedBytesAtomicFieldData.java)
            public BytesRefArrayRef getValues(int docId) {
                IntArrayRef ords = ordinals.getOrds(docId);
                int size = ords.size();
                if (size == 0) return BytesRefArrayRef.EMPTY;

                arrayScratch.reset(size);
                for (int i = ords.start; i < ords.end; i++) {
                    final BytesRef bytesRef = new BytesRef();
                    bytes.fill(bytesRef, termOrdToBytesOffset.get(ords.values[i]));
                    arrayScratch.values[arrayScratch.end++] = bytesRef;
                }
                return arrayScratch;
            }

commonMethod: 
(startLine=358 endLine=370 srcPath=/root/NewExperiment/elasticsearchFilter/00775/src/main/java/org/elasticsearch/index/fielddata/BytesValues.java)
        protected BytesRefArrayRef getValuesMulti(int docId) {
            assert isMultiValued();
            IntArrayRef ords = ordinals.getOrds(docId);
            int size = ords.size();
            if (size == 0) {
                return BytesRefArrayRef.EMPTY;
            }
            arrayScratch.reset(size);
            for (int i = ords.start; i < ords.end; i++) {
                arrayScratch.values[arrayScratch.end++] = getValueScratchByOrd(ords.values[i], new BytesRef());
            }
            return arrayScratch;
        }


, Instance #
frags: 
(startLine=236 endLine=350 srcPath=/root/NewExperiment/elasticsearchFilter/00775/src/test/java/org/elasticsearch/test/unit/index/fielddata/StringFieldDataTests.java)
    public void testSingleValueWithMissing() throws Exception {
        fillSingleValueWithMissing();
        IndexFieldData indexFieldData = getForField("value");
        AtomicFieldData fieldData = indexFieldData.load(refreshReader());

        assertThat(fieldData.getNumDocs(), equalTo(3));

        BytesValues bytesValues = fieldData
                .getBytesValues();

        assertThat(bytesValues.isMultiValued(), equalTo(false));

        assertThat(bytesValues.hasValue(0), equalTo(true));
        assertThat(bytesValues.hasValue(1), equalTo(false));
        assertThat(bytesValues.hasValue(2), equalTo(true));

        assertThat(bytesValues.getValue(0), equalTo(new BytesRef(two())));
        assertThat(bytesValues.getValue(1), nullValue());
        assertThat(bytesValues.getValue(2), equalTo(new BytesRef(three())));

        BytesRef bytesRef = new BytesRef();
        assertThat(bytesValues.getValueScratch(0, bytesRef), equalTo(new BytesRef(two())));
        assertThat(bytesRef, equalTo(new BytesRef(two())));
        assertThat(bytesValues.getValueScratch(1, bytesRef), equalTo(new BytesRef()));
        assertThat(bytesRef, equalTo(new BytesRef()));
        assertThat(bytesValues.getValueScratch(2, bytesRef), equalTo(new BytesRef(three())));
        assertThat(bytesRef, equalTo(new BytesRef(three())));


        BytesRefArrayRef bytesRefArrayRef = bytesValues.getValues(0);
        assertThat(bytesRefArrayRef.size(), equalTo(1));
        assertThat(bytesRefArrayRef.values[bytesRefArrayRef.start], equalTo(new BytesRef(two())));

        bytesRefArrayRef = bytesValues.getValues(1);
        assertThat(bytesRefArrayRef.size(), equalTo(0));

        bytesRefArrayRef = bytesValues.getValues(2);
        assertThat(bytesRefArrayRef.size(), equalTo(1));
        assertThat(bytesRefArrayRef.values[bytesRefArrayRef.start], equalTo(new BytesRef(three())));

        BytesValues.Iter bytesValuesIter = bytesValues.getIter(0);
        assertThat(bytesValuesIter.hasNext(), equalTo(true));
        assertThat(bytesValuesIter.next(), equalTo(new BytesRef(two())));
        assertThat(bytesValuesIter.hasNext(), equalTo(false));

        bytesValuesIter = bytesValues.getIter(1);
        assertThat(bytesValuesIter.hasNext(), equalTo(false));

        bytesValues.forEachValueInDoc(0, new BytesValuesVerifierProc(0).addExpected(two()));
        bytesValues.forEachValueInDoc(1, new BytesValuesVerifierProc(1).addMissing());
        bytesValues.forEachValueInDoc(2, new BytesValuesVerifierProc(2).addExpected(three()));

        HashedBytesValues hashedBytesValues = fieldData.getHashedBytesValues();

        assertThat(hashedBytesValues.hasValue(0), equalTo(true));
        assertThat(hashedBytesValues.hasValue(1), equalTo(false));
        assertThat(hashedBytesValues.hasValue(2), equalTo(true));

        assertThat(hashedBytesValues.getValue(0), equalTo(new HashedBytesRef(two())));
        assertThat(hashedBytesValues.getValue(1), nullValue());
        assertThat(hashedBytesValues.getValue(2), equalTo(new HashedBytesRef(three())));

        HashedBytesValues.Iter hashedBytesValuesIter = hashedBytesValues.getIter(0);
        assertThat(hashedBytesValuesIter.hasNext(), equalTo(true));
        assertThat(hashedBytesValuesIter.next(), equalTo(new HashedBytesRef(two())));
        assertThat(hashedBytesValuesIter.hasNext(), equalTo(false));

        hashedBytesValuesIter = hashedBytesValues.getIter(1);
        assertThat(hashedBytesValuesIter.hasNext(), equalTo(false));

        hashedBytesValues.forEachValueInDoc(0, new HashedBytesValuesVerifierProc(0).addExpected(two()));
        hashedBytesValues.forEachValueInDoc(1, new HashedBytesValuesVerifierProc(1).addMissing());
        hashedBytesValues.forEachValueInDoc(2, new HashedBytesValuesVerifierProc(2).addExpected(three()));

        StringValues stringValues = fieldData.getStringValues();

        assertThat(stringValues.hasValue(0), equalTo(true));
        assertThat(stringValues.hasValue(1), equalTo(false));
        assertThat(stringValues.hasValue(2), equalTo(true));

        assertThat(stringValues.getValue(0), equalTo(two()));
        assertThat(stringValues.getValue(1), nullValue());
        assertThat(stringValues.getValue(2), equalTo(three()));

        StringArrayRef stringArrayRef;
        stringArrayRef = stringValues.getValues(0);
        assertThat(stringArrayRef.size(), equalTo(1));
        assertThat(stringArrayRef.values[stringArrayRef.start], equalTo(two()));

        stringArrayRef = stringValues.getValues(1);
        assertThat(stringArrayRef.size(), equalTo(0));

        stringArrayRef = stringValues.getValues(2);
        assertThat(stringArrayRef.size(), equalTo(1));
        assertThat(stringArrayRef.values[stringArrayRef.start], equalTo(three()));

        StringValues.Iter stringValuesIter = stringValues.getIter(0);
        assertThat(stringValuesIter.hasNext(), equalTo(true));
        assertThat(stringValuesIter.next(), equalTo(two()));
        assertThat(stringValuesIter.hasNext(), equalTo(false));

        stringValuesIter = stringValues.getIter(1);
        assertThat(stringValuesIter.hasNext(), equalTo(false));

        stringValuesIter = stringValues.getIter(2);
        assertThat(stringValuesIter.hasNext(), equalTo(true));
        assertThat(stringValuesIter.next(), equalTo(three()));
        assertThat(stringValuesIter.hasNext(), equalTo(false));

        stringValues.forEachValueInDoc(0, new StringValuesVerifierProc(0).addExpected(two()));
        stringValues.forEachValueInDoc(1, new StringValuesVerifierProc(1).addMissing());
        stringValues.forEachValueInDoc(2, new StringValuesVerifierProc(2).addExpected(three()));

        // TODO properly support missing....
    }

(startLine=525 endLine=644 srcPath=/root/NewExperiment/elasticsearchFilter/00775/src/test/java/org/elasticsearch/test/unit/index/fielddata/StringFieldDataTests.java)
    public void testMultiValueWithMissing() throws Exception {
        fillMultiValueWithMissing();
        IndexFieldData indexFieldData = getForField("value");
        AtomicFieldData fieldData = indexFieldData.load(refreshReader());

        assertThat(fieldData.getNumDocs(), equalTo(3));

        BytesValues bytesValues = fieldData.getBytesValues();

        assertThat(bytesValues.isMultiValued(), equalTo(true));

        assertThat(bytesValues.hasValue(0), equalTo(true));
        assertThat(bytesValues.hasValue(1), equalTo(false));
        assertThat(bytesValues.hasValue(2), equalTo(true));

        assertThat(bytesValues.getValue(0), equalTo(new BytesRef(two())));
        assertThat(bytesValues.getValue(1), nullValue());
        assertThat(bytesValues.getValue(2), equalTo(new BytesRef(three())));

        BytesRef bytesRef = new BytesRef();
        assertThat(bytesValues.getValueScratch(0, bytesRef), equalTo(new BytesRef(two())));
        assertThat(bytesRef, equalTo(new BytesRef(two())));
        assertThat(bytesValues.getValueScratch(1, bytesRef), equalTo(new BytesRef()));
        assertThat(bytesRef, equalTo(new BytesRef()));
        assertThat(bytesValues.getValueScratch(2, bytesRef), equalTo(new BytesRef(three())));
        assertThat(bytesRef, equalTo(new BytesRef(three())));


        BytesRefArrayRef bytesRefArrayRef = bytesValues.getValues(0);
        assertThat(bytesRefArrayRef.size(), equalTo(2));
        assertThat(bytesRefArrayRef.values[bytesRefArrayRef.start], equalTo(new BytesRef(two())));
        assertThat(bytesRefArrayRef.values[bytesRefArrayRef.start + 1], equalTo(new BytesRef(four())));

        bytesRefArrayRef = bytesValues.getValues(1);
        assertThat(bytesRefArrayRef.size(), equalTo(0));

        bytesRefArrayRef = bytesValues.getValues(2);
        assertThat(bytesRefArrayRef.size(), equalTo(1));
        assertThat(bytesRefArrayRef.values[bytesRefArrayRef.start], equalTo(new BytesRef(three())));

        BytesValues.Iter bytesValuesIter = bytesValues.getIter(0);
        assertThat(bytesValuesIter.hasNext(), equalTo(true));
        assertThat(bytesValuesIter.next(), equalTo(new BytesRef(two())));
        assertThat(bytesValuesIter.hasNext(), equalTo(true));
        assertThat(bytesValuesIter.next(), equalTo(new BytesRef(four())));
        assertThat(bytesValuesIter.hasNext(), equalTo(false));

        bytesValuesIter = bytesValues.getIter(1);
        assertThat(bytesValuesIter.hasNext(), equalTo(false));

        bytesValues.forEachValueInDoc(0, new BytesValuesVerifierProc(0).addExpected(two()).addExpected(four()));
        bytesValues.forEachValueInDoc(1, new BytesValuesVerifierProc(1).addMissing());
        bytesValues.forEachValueInDoc(2, new BytesValuesVerifierProc(2).addExpected(three()));

        HashedBytesValues hashedBytesValues = fieldData.getHashedBytesValues();

        assertThat(hashedBytesValues.hasValue(0), equalTo(true));
        assertThat(hashedBytesValues.hasValue(1), equalTo(false));
        assertThat(hashedBytesValues.hasValue(2), equalTo(true));

        assertThat(hashedBytesValues.getValue(0), equalTo(new HashedBytesRef(two())));
        assertThat(hashedBytesValues.getValue(1), nullValue());
        assertThat(hashedBytesValues.getValue(2), equalTo(new HashedBytesRef(three())));

        HashedBytesValues.Iter hashedBytesValuesIter = hashedBytesValues.getIter(0);
        assertThat(hashedBytesValuesIter.hasNext(), equalTo(true));
        assertThat(hashedBytesValuesIter.next(), equalTo(new HashedBytesRef(two())));
        assertThat(hashedBytesValuesIter.hasNext(), equalTo(true));
        assertThat(hashedBytesValuesIter.next(), equalTo(new HashedBytesRef(four())));
        assertThat(hashedBytesValuesIter.hasNext(), equalTo(false));

        hashedBytesValuesIter = hashedBytesValues.getIter(1);
        assertThat(hashedBytesValuesIter.hasNext(), equalTo(false));

        hashedBytesValues.forEachValueInDoc(0, new HashedBytesValuesVerifierProc(0).addExpected(two()).addExpected(four()));
        hashedBytesValues.forEachValueInDoc(1, new HashedBytesValuesVerifierProc(1).addMissing());
        hashedBytesValues.forEachValueInDoc(2, new HashedBytesValuesVerifierProc(2).addExpected(three()));

        StringValues stringValues = fieldData.getStringValues();

        assertThat(stringValues.hasValue(0), equalTo(true));
        assertThat(stringValues.hasValue(1), equalTo(false));
        assertThat(stringValues.hasValue(2), equalTo(true));

        assertThat(stringValues.getValue(0), equalTo(two()));
        assertThat(stringValues.getValue(1), nullValue());
        assertThat(stringValues.getValue(2), equalTo(three()));

        StringArrayRef stringArrayRef;
        stringArrayRef = stringValues.getValues(0);
        assertThat(stringArrayRef.size(), equalTo(2));
        assertThat(stringArrayRef.values[stringArrayRef.start], equalTo(two()));
        assertThat(stringArrayRef.values[stringArrayRef.start + 1], equalTo(four()));

        stringArrayRef = stringValues.getValues(1);
        assertThat(stringArrayRef.size(), equalTo(0));

        stringArrayRef = stringValues.getValues(2);
        assertThat(stringArrayRef.size(), equalTo(1));
        assertThat(stringArrayRef.values[stringArrayRef.start], equalTo(three()));

        StringValues.Iter stringValuesIter = stringValues.getIter(0);
        assertThat(stringValuesIter.hasNext(), equalTo(true));
        assertThat(stringValuesIter.next(), equalTo(two()));
        assertThat(stringValuesIter.hasNext(), equalTo(true));
        assertThat(stringValuesIter.next(), equalTo(four()));
        assertThat(stringValuesIter.hasNext(), equalTo(false));

        stringValuesIter = stringValues.getIter(1);
        assertThat(stringValuesIter.hasNext(), equalTo(false));

        stringValuesIter = stringValues.getIter(2);
        assertThat(stringValuesIter.hasNext(), equalTo(true));
        assertThat(stringValuesIter.next(), equalTo(three()));
        assertThat(stringValuesIter.hasNext(), equalTo(false));

        stringValues.forEachValueInDoc(0, new StringValuesVerifierProc(0).addExpected(two()).addExpected(four()));
        stringValues.forEachValueInDoc(1, new StringValuesVerifierProc(1).addMissing());
        stringValues.forEachValueInDoc(2, new StringValuesVerifierProc(2).addExpected(three()));
    }

commonMethod: 
(startLine=198 endLine=201 srcPath=/root/NewExperiment/elasticsearchFilter/00776/src/test/java/org/elasticsearch/test/unit/index/fielddata/StringFieldDataTests.java)
    private HashedBytesRef convert(BytesValues values, int doc) {
        BytesRef ref = new BytesRef();
        return new HashedBytesRef(ref, values.getValueHashed(doc, ref));
    }


, Instance #
frags: 
(startLine=125 endLine=145 srcPath=/root/NewExperiment/elasticsearchFilter/00786/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
    static IntArrayAtomicFieldData build(AtomicReader reader, OrdinalsBuilder builder, Ordinals build, BuilderIntegers values) {
        if (!build.isMultiValued()) {
            Docs ordinals = build.ordinals();
            int[] sValues = new int[reader.maxDoc()];
            int maxDoc = reader.maxDoc();
            for (int i = 0; i < maxDoc; i++) {
                sValues[i] = values.get(ordinals.getOrd(i));
            }
            final FixedBitSet set = builder.buildDocsWithValuesSet();
            if (set == null) {
                return new IntArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new IntArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            return new IntArrayAtomicFieldData.WithOrdinals(
                    values.toArray(),
                    reader.maxDoc(),
                    build);
        }
    }

(startLine=126 endLine=143 srcPath=/root/NewExperiment/elasticsearchFilter/00786/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
    static ShortArrayAtomicFieldData build(AtomicReader reader, OrdinalsBuilder builder, Ordinals build, BuilderShorts values) {
        if (!build.isMultiValued()) {
            Docs ordinals = build.ordinals();
            short[] sValues = new short[reader.maxDoc()];
            int maxDoc = reader.maxDoc();
            for (int i = 0; i < maxDoc; i++) {
                sValues[i] = values.get(ordinals.getOrd(i));
            }
            final FixedBitSet set = builder.buildDocsWithValuesSet();
            if (set == null) {
                return new ShortArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ShortArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            return new ShortArrayAtomicFieldData.WithOrdinals(values.toArray(), reader.maxDoc(), build);
        }
    }

(startLine=125 endLine=142 srcPath=/root/NewExperiment/elasticsearchFilter/00786/src/main/java/org/elasticsearch/index/fielddata/plain/ByteArrayIndexFieldData.java)
    static ByteArrayAtomicFieldData build(AtomicReader reader, OrdinalsBuilder builder, Ordinals build, BuilderBytes values) {
        if (!build.isMultiValued()) {
            Docs ordinals = build.ordinals();
            byte[] sValues = new byte[reader.maxDoc()];
            int maxDoc = reader.maxDoc();
            for (int i = 0; i < maxDoc; i++) {
                sValues[i] = values.get(ordinals.getOrd(i));
            }
            final FixedBitSet set = builder.buildDocsWithValuesSet();
            if (set == null) {
                return new ByteArrayAtomicFieldData.Single(sValues, reader.maxDoc());
            } else {
                return new ByteArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
            }
        } else {
            return new ByteArrayAtomicFieldData.WithOrdinals(values.toArray(), reader.maxDoc(), build);
        }
    }

commonMethod: 
(startLine=40 endLine=47 srcPath=/root/NewExperiment/elasticsearchFilter/00787/src/main/java/org/elasticsearch/index/fielddata/IndexFieldData.java)
        /**
         * Should single value cross documents case be optimized to remove ords. Note, this optimization
         * might not be supported by all Field Data implementations, but the ones that do, should consult
         * this method to check if it should be done or not.
         */
        public static boolean removeOrdsOnSingleValue(FieldDataType fieldDataType) {
            return !"always".equals(fieldDataType.getSettings().get("ordinals"));
        }


, Instance #
frags: 
(startLine=96 endLine=114 srcPath=/root/NewExperiment/elasticsearchFilter/00797/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
        try {
            BytesRefIterator iter = builder.buildFromTerms(builder.wrapNumeric32Bit(terms.iterator(null)), reader.getLiveDocs());
            BytesRef term;
            while ((term = iter.next()) != null) {
                values.add(NumericUtils.prefixCodedToInt(term));
            }
            Ordinals build = builder.build(fieldDataType.getSettings());
            return build(reader, fieldDataType, builder, build, new BuilderIntegers() {
                @Override
                public int get(int index) {
                    return values.get(index);
                }

                @Override
                public int[] toArray() {
                    return values.toArray();
                }
            });
        } finally {

(startLine=96 endLine=115 srcPath=/root/NewExperiment/elasticsearchFilter/00797/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
        try {
            BytesRefIterator iter = builder.buildFromTerms(builder.wrapNumeric32Bit(terms.iterator(null)), reader.getLiveDocs());
            BytesRef term;
            while ((term = iter.next()) != null) {
                values.add((short) NumericUtils.prefixCodedToInt(term));
            }

            Ordinals build = builder.build(fieldDataType.getSettings());
            return build(reader, fieldDataType, builder, build, new BuilderShorts() {
                @Override
                public short get(int index) {
                    return values.get(index);
                }

                @Override
                public short[] toArray() {
                    return values.toArray();
                }
            });
        } finally {

commonMethod: 
(startLine=154 endLine=158 srcPath=/root/NewExperiment/elasticsearchFilter/00798/src/main/java/org/elasticsearch/common/settings/Settings.java)
    /**
     * Returns the setting value (as boolean) associated with the setting key. If it does not exists,
     * returns the default value provided.
     */
    Boolean getAsBoolean(String setting, Boolean defaultValue) throws SettingsException;


, Instance #
frags: 
(startLine=85 endLine=117 srcPath=/root/NewExperiment/elasticsearchFilter/00797/src/main/java/org/elasticsearch/index/fielddata/plain/IntArrayIndexFieldData.java)
    public IntArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();
        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return IntArrayAtomicFieldData.EMPTY;
        }
        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TIntArrayList values = new TIntArrayList();

        values.add(0); // first "t" indicates null value
        OrdinalsBuilder builder = new OrdinalsBuilder(terms, reader.maxDoc());
        try {
            BytesRefIterator iter = builder.buildFromTerms(builder.wrapNumeric32Bit(terms.iterator(null)), reader.getLiveDocs());
            BytesRef term;
            while ((term = iter.next()) != null) {
                values.add(NumericUtils.prefixCodedToInt(term));
            }
            Ordinals build = builder.build(fieldDataType.getSettings());
            return build(reader, fieldDataType, builder, build, new BuilderIntegers() {
                @Override
                public int get(int index) {
                    return values.get(index);
                }

                @Override
                public int[] toArray() {
                    return values.toArray();
                }
            });
        } finally {
            builder.close();
        }
    }

(startLine=85 endLine=118 srcPath=/root/NewExperiment/elasticsearchFilter/00797/src/main/java/org/elasticsearch/index/fielddata/plain/ShortArrayIndexFieldData.java)
    public ShortArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();
        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return ShortArrayAtomicFieldData.EMPTY;
        }
        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TShortArrayList values = new TShortArrayList();

        values.add((short) 0); // first "t" indicates null value
        OrdinalsBuilder builder = new OrdinalsBuilder(terms, reader.maxDoc());
        try {
            BytesRefIterator iter = builder.buildFromTerms(builder.wrapNumeric32Bit(terms.iterator(null)), reader.getLiveDocs());
            BytesRef term;
            while ((term = iter.next()) != null) {
                values.add((short) NumericUtils.prefixCodedToInt(term));
            }

            Ordinals build = builder.build(fieldDataType.getSettings());
            return build(reader, fieldDataType, builder, build, new BuilderShorts() {
                @Override
                public short get(int index) {
                    return values.get(index);
                }

                @Override
                public short[] toArray() {
                    return values.toArray();
                }
            });
        } finally {
            builder.close();
        }
    }

commonMethod: 
(startLine=154 endLine=158 srcPath=/root/NewExperiment/elasticsearchFilter/00798/src/main/java/org/elasticsearch/common/settings/Settings.java)
    /**
     * Returns the setting value (as boolean) associated with the setting key. If it does not exists,
     * returns the default value provided.
     */
    Boolean getAsBoolean(String setting, Boolean defaultValue) throws SettingsException;


, Instance #
frags: 
(startLine=52 endLine=128 srcPath=/root/NewExperiment/elasticsearchFilter/00801/src/main/java/org/elasticsearch/index/query/HasParentFilterParser.java)
    public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {
        XContentParser parser = parseContext.parser();

        Query query = null;
        boolean queryFound = false;
        String parentType = null;

        String filterName = null;
        String currentFieldName = null;
        XContentParser.Token token;
        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
            if (token == XContentParser.Token.FIELD_NAME) {
                currentFieldName = parser.currentName();
            } else if (token == XContentParser.Token.START_OBJECT) {
                if ("query".equals(currentFieldName)) {
                    // TODO handle `query` element before `type` element...
                    String[] origTypes = QueryParseContext.setTypesWithPrevious(parentType == null ? null : new String[]{parentType});
                    try {
                        query = parseContext.parseInnerQuery();
                        queryFound = true;
                    } finally {
                        QueryParseContext.setTypes(origTypes);
                    }
                } else if ("filter".equals(currentFieldName)) {
                    // TODO handle `filter` element before `type` element...
                    String[] origTypes = QueryParseContext.setTypesWithPrevious(parentType == null ? null : new String[]{parentType});
                    try {
                        Filter innerFilter = parseContext.parseInnerFilter();
                        query = new XConstantScoreQuery(innerFilter);
                        queryFound = true;
                    } finally {
                        QueryParseContext.setTypes(origTypes);
                    }
                } else {
                    throw new QueryParsingException(parseContext.index(), "[has_parent] filter does not support [" + currentFieldName + "]");
                }
            } else if (token.isValue()) {
                if ("type".equals(currentFieldName) || "parent_type".equals(currentFieldName) || "parentType".equals(currentFieldName)) {
                    parentType = parser.text();
                } else if ("_scope".equals(currentFieldName)) {
                    throw new QueryParsingException(parseContext.index(), "the [_scope] support in [has_parent] filter has been removed, use a filter as a facet_filter in the relevant global facet");
                } else if ("_name".equals(currentFieldName)) {
                    filterName = parser.text();
                } else {
                    throw new QueryParsingException(parseContext.index(), "[has_parent] filter does not support [" + currentFieldName + "]");
                }
            }
        }
        if (!queryFound) {
            throw new QueryParsingException(parseContext.index(), "[parent] filter requires 'query' field");
        }
        if (query == null) {
            return null;
        }

        if (parentType == null) {
            throw new QueryParsingException(parseContext.index(), "[parent] filter requires 'parent_type' field");
        }

        DocumentMapper parentDocMapper = parseContext.mapperService().documentMapper(parentType);
        if (parentDocMapper == null) {
            throw new QueryParsingException(parseContext.index(), "[parent] filter configured 'parent_type' [" + parentType + "] is not a valid type");
        }

        // wrap the query with type query
        query = new XFilteredQuery(query, parseContext.cacheFilter(parentDocMapper.typeFilter(), null));

        SearchContext searchContext = SearchContext.current();

        HasParentFilter parentFilter = HasParentFilter.create(query, parentType, searchContext);
        searchContext.addRewrite(parentFilter);

        if (filterName != null) {
            parseContext.addNamedFilter(filterName, parentFilter);
        }
        return parentFilter;
    }

(startLine=52 endLine=132 srcPath=/root/NewExperiment/elasticsearchFilter/00801/src/main/java/org/elasticsearch/index/query/HasChildFilterParser.java)
    public Filter parse(QueryParseContext parseContext) throws IOException, QueryParsingException {
        XContentParser parser = parseContext.parser();

        Query query = null;
        boolean queryFound = false;
        String childType = null;

        String filterName = null;
        String currentFieldName = null;
        XContentParser.Token token;
        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
            if (token == XContentParser.Token.FIELD_NAME) {
                currentFieldName = parser.currentName();
            } else if (token == XContentParser.Token.START_OBJECT) {
                if ("query".equals(currentFieldName)) {
                    // TODO we need to set the type, but, `query` can come before `type`...
                    // since we switch types, make sure we change the context
                    String[] origTypes = QueryParseContext.setTypesWithPrevious(childType == null ? null : new String[]{childType});
                    try {
                        query = parseContext.parseInnerQuery();
                        queryFound = true;
                    } finally {
                        QueryParseContext.setTypes(origTypes);
                    }
                } else if ("filter".equals(currentFieldName)) {
                    // TODO handle `filter` element before `type` element...
                    String[] origTypes = QueryParseContext.setTypesWithPrevious(childType == null ? null : new String[]{childType});
                    try {
                        Filter innerFilter = parseContext.parseInnerFilter();
                        query = new XConstantScoreQuery(innerFilter);
                        queryFound = true;
                    } finally {
                        QueryParseContext.setTypes(origTypes);
                    }
                } else {
                    throw new QueryParsingException(parseContext.index(), "[has_child] filter does not support [" + currentFieldName + "]");
                }
            } else if (token.isValue()) {
                if ("type".equals(currentFieldName) || "child_type".equals(currentFieldName) || "childType".equals(currentFieldName)) {
                    childType = parser.text();
                } else if ("_scope".equals(currentFieldName)) {
                    throw new QueryParsingException(parseContext.index(), "the [_scope] support in [has_child] filter has been removed, use a filter as a facet_filter in the relevant global facet");
                } else if ("_name".equals(currentFieldName)) {
                    filterName = parser.text();
                } else {
                    throw new QueryParsingException(parseContext.index(), "[has_child] filter does not support [" + currentFieldName + "]");
                }
            }
        }
        if (!queryFound) {
            throw new QueryParsingException(parseContext.index(), "[child] filter requires 'query' field");
        }
        if (query == null) {
            return null;
        }
        if (childType == null) {
            throw new QueryParsingException(parseContext.index(), "[child] filter requires 'type' field");
        }

        DocumentMapper childDocMapper = parseContext.mapperService().documentMapper(childType);
        if (childDocMapper == null) {
            throw new QueryParsingException(parseContext.index(), "No mapping for for type [" + childType + "]");
        }
        if (childDocMapper.parentFieldMapper() == null) {
            throw new QueryParsingException(parseContext.index(), "Type [" + childType + "] does not have parent mapping");
        }
        String parentType = childDocMapper.parentFieldMapper().type();

        // wrap the query with type query
        query = new XFilteredQuery(query, parseContext.cacheFilter(childDocMapper.typeFilter(), null));

        SearchContext searchContext = SearchContext.current();

        HasChildFilter childFilter = HasChildFilter.create(query, parentType, childType, searchContext);
        searchContext.addRewrite(childFilter);

        if (filterName != null) {
            parseContext.addNamedFilter(filterName, childFilter);
        }
        return childFilter;
    }

commonMethod: 
(startLine=170 endLine=170 srcPath=/root/NewExperiment/elasticsearchFilter/00802/src/main/java/org/elasticsearch/common/xcontent/XContentParser.java)
    boolean booleanValue() throws IOException;


, Instance #
frags: 
(startLine=51 endLine=137 srcPath=/root/NewExperiment/elasticsearchFilter/00828/src/test/java/org/elasticsearch/test/integration/recovery/RecoveryWhileUnderLoadTests.java)
    public void recoverWhileUnderLoadAllocateBackupsTest() throws Exception {
        logger.info("--> starting [node1] ...");
        startNode("node1");

        logger.info("--> creating test index ...");
        client("node1").admin().indices().prepareCreate("test").execute().actionGet();

        final AtomicLong idGenerator = new AtomicLong();
        final AtomicLong indexCounter = new AtomicLong();
        final AtomicBoolean stop = new AtomicBoolean(false);
        Thread[] writers = new Thread[5];
        final CountDownLatch stopLatch = new CountDownLatch(writers.length);

        logger.info("--> starting {} indexing threads", writers.length);
        for (int i = 0; i < writers.length; i++) {
            final int indexerId = i;
            writers[i] = new Thread() {
                @Override
                public void run() {
                    try {
                        logger.info("**** starting indexing thread {}", indexerId);
                        while (!stop.get()) {
                            long id = idGenerator.incrementAndGet();
                            if (id % 1000 == 0) {
                                client("node1").admin().indices().prepareFlush().execute().actionGet();
                            }
                            client("node1").prepareIndex("test", "type1", Long.toString(id))
                                    .setSource(MapBuilder.<String, Object>newMapBuilder().put("test", "value" + id).map()).execute().actionGet();
                            indexCounter.incrementAndGet();
                        }
                        logger.info("**** done indexing thread {}", indexerId);
                    } catch (Exception e) {
                        logger.warn("**** failed indexing thread {}", e, indexerId);
                    } finally {
                        stopLatch.countDown();
                    }
                }
            };
            writers[i].start();
        }

        logger.info("--> waiting for 2000 docs to be indexed ...");
        while (client("node1").prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 2000) {
            Thread.sleep(100);
            client("node1").admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 2000 docs indexed");

        logger.info("--> flushing the index ....");
        // now flush, just to make sure we have some data in the index, not just translog
        client("node1").admin().indices().prepareFlush().execute().actionGet();


        logger.info("--> waiting for 4000 docs to be indexed ...");
        while (client("node1").prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 4000) {
            Thread.sleep(100);
            client("node1").admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 4000 docs indexed");

        logger.info("--> starting [node2] ...");
        // now start another node, while we index
        startNode("node2");

        logger.info("--> waiting for GREEN health status ...");
        // make sure the cluster state is green, and all has been recovered
        assertThat(client("node1").admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setTimeout("1m").setWaitForGreenStatus().setWaitForNodes("2").execute().actionGet().isTimedOut(), equalTo(false));

        logger.info("--> waiting for 10000 docs to be indexed ...");
        while (client("node1").prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 10000) {
            Thread.sleep(100);
            client("node1").admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 10000 docs indexed");

        logger.info("--> marking and waiting for indexing threads to stop ...");
        stop.set(true);
        stopLatch.await();
        logger.info("--> indexing threads stopped");

        logger.info("--> refreshing the index");
        client("node1").admin().indices().prepareRefresh().execute().actionGet();
        logger.info("--> verifying indexed content");
        for (int i = 0; i < 10; i++) {
            assertThat(client("node1").prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount(), equalTo(indexCounter.get()));
        }
    }

(startLine=140 endLine=228 srcPath=/root/NewExperiment/elasticsearchFilter/00828/src/test/java/org/elasticsearch/test/integration/recovery/RecoveryWhileUnderLoadTests.java)
    public void recoverWhileUnderLoadAllocateBackupsRelocatePrimariesTest() throws Exception {
        logger.info("--> starting [node1] ...");
        startNode("node1");

        logger.info("--> creating test index ...");
        client("node1").admin().indices().prepareCreate("test").execute().actionGet();

        final AtomicLong idGenerator = new AtomicLong();
        final AtomicLong indexCounter = new AtomicLong();
        final AtomicBoolean stop = new AtomicBoolean(false);
        Thread[] writers = new Thread[5];
        logger.info("--> starting {} indexing threads", writers.length);
        final CountDownLatch stopLatch = new CountDownLatch(writers.length);
        for (int i = 0; i < writers.length; i++) {
            final int indexerId = i;
            writers[i] = new Thread() {
                @Override
                public void run() {
                    try {
                        logger.info("**** starting indexing thread {}", indexerId);
                        while (!stop.get()) {
                            long id = idGenerator.incrementAndGet();
                            client("node1").prepareIndex("test", "type1", Long.toString(id))
                                    .setSource(MapBuilder.<String, Object>newMapBuilder().put("test", "value" + id).map()).execute().actionGet();
                            indexCounter.incrementAndGet();
                        }
                        logger.info("**** done indexing thread {}", indexerId);
                    } catch (Exception e) {
                        logger.warn("**** failed indexing thread {}", e, indexerId);
                    } finally {
                        stopLatch.countDown();
                    }
                }
            };
            writers[i].start();
        }

        logger.info("--> waiting for 2000 docs to be indexed ...");
        while (client("node1").prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 2000) {
            Thread.sleep(100);
            client("node1").admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 2000 docs indexed");

        logger.info("--> flushing the index ....");
        // now flush, just to make sure we have some data in the index, not just translog
        client("node1").admin().indices().prepareFlush().execute().actionGet();


        logger.info("--> waiting for 4000 docs to be indexed ...");
        while (client("node1").prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 4000) {
            Thread.sleep(100);
            client("node1").admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 4000 docs indexed");

        logger.info("--> starting [node2] ...");
        startNode("node2");
        logger.info("--> starting [node3] ...");
        startNode("node3");
        logger.info("--> starting [node4] ...");
        startNode("node4");

        logger.info("--> waiting for GREEN health status ...");
        assertThat(client("node1").admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setTimeout("1m").setWaitForGreenStatus().setWaitForNodes("4").execute().actionGet().isTimedOut(), equalTo(false));


        logger.info("--> waiting for 15000 docs to be indexed ...");
        while (client("node1").prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 15000) {
            Thread.sleep(100);
            client("node1").admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 15000 docs indexed");

        stop.set(true);
        stopLatch.await();

        logger.info("--> marking and waiting for indexing threads to stop ...");
        stop.set(true);
        stopLatch.await();
        logger.info("--> indexing threads stopped");

        logger.info("--> refreshing the index");
        client("node1").admin().indices().prepareRefresh().execute().actionGet();
        logger.info("--> verifying indexed content");
        for (int i = 0; i < 10; i++) {
            assertThat(client("node1").prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount(), equalTo(indexCounter.get()));
        }
    }

commonMethod: 
(startLine=208 endLine=218 srcPath=/root/NewExperiment/elasticsearchFilter/00829/src/test/java/org/elasticsearch/test/integration/AbstractSharedClusterTest.java)
    public void allowNodes(String index, int numNodes) {
        cluster().ensureAtLeastNumNodes(numNodes);
        ImmutableSettings.Builder builder = ImmutableSettings.builder();
        if (numNodes > 0) {
            getExcludeSettings(index, numNodes, builder);
        }
        Settings build = builder.build();
        if (!build.getAsMap().isEmpty()) {
            client().admin().indices().prepareUpdateSettings(index).setSettings(build).execute().actionGet();
        }
    }


, Instance #
frags: 
(startLine=65 endLine=90 srcPath=/root/NewExperiment/elasticsearchFilter/00828/src/test/java/org/elasticsearch/test/integration/recovery/RecoveryWhileUnderLoadTests.java)
        for (int i = 0; i < writers.length; i++) {
            final int indexerId = i;
            writers[i] = new Thread() {
                @Override
                public void run() {
                    try {
                        logger.info("**** starting indexing thread {}", indexerId);
                        while (!stop.get()) {
                            long id = idGenerator.incrementAndGet();
                            if (id % 1000 == 0) {
                                client("node1").admin().indices().prepareFlush().execute().actionGet();
                            }
                            client("node1").prepareIndex("test", "type1", Long.toString(id))
                                    .setSource(MapBuilder.<String, Object>newMapBuilder().put("test", "value" + id).map()).execute().actionGet();
                            indexCounter.incrementAndGet();
                        }
                        logger.info("**** done indexing thread {}", indexerId);
                    } catch (Exception e) {
                        logger.warn("**** failed indexing thread {}", e, indexerId);
                    } finally {
                        stopLatch.countDown();
                    }
                }
            };
            writers[i].start();
        }

(startLine=153 endLine=175 srcPath=/root/NewExperiment/elasticsearchFilter/00828/src/test/java/org/elasticsearch/test/integration/recovery/RecoveryWhileUnderLoadTests.java)
        for (int i = 0; i < writers.length; i++) {
            final int indexerId = i;
            writers[i] = new Thread() {
                @Override
                public void run() {
                    try {
                        logger.info("**** starting indexing thread {}", indexerId);
                        while (!stop.get()) {
                            long id = idGenerator.incrementAndGet();
                            client("node1").prepareIndex("test", "type1", Long.toString(id))
                                    .setSource(MapBuilder.<String, Object>newMapBuilder().put("test", "value" + id).map()).execute().actionGet();
                            indexCounter.incrementAndGet();
                        }
                        logger.info("**** done indexing thread {}", indexerId);
                    } catch (Exception e) {
                        logger.warn("**** failed indexing thread {}", e, indexerId);
                    } finally {
                        stopLatch.countDown();
                    }
                }
            };
            writers[i].start();
        }

(startLine=246 endLine=268 srcPath=/root/NewExperiment/elasticsearchFilter/00828/src/test/java/org/elasticsearch/test/integration/recovery/RecoveryWhileUnderLoadTests.java)
        for (int i = 0; i < writers.length; i++) {
            final int indexerId = i;
            writers[i] = new Thread() {
                @Override
                public void run() {
                    try {
                        logger.info("**** starting indexing thread {}", indexerId);
                        while (!stop.get()) {
                            long id = idGenerator.incrementAndGet();
                            client("node2").prepareIndex("test", "type1", Long.toString(id))
                                    .setSource(MapBuilder.<String, Object>newMapBuilder().put("test", "value" + id).map()).execute().actionGet();
                            indexCounter.incrementAndGet();
                        }
                        logger.info("**** done indexing thread {}", indexerId);
                    } catch (Exception e) {
                        logger.warn("**** failed indexing thread {}", e, indexerId);
                    } finally {
                        stopLatch.countDown();
                    }
                }
            };
            writers[i].start();
        }

commonMethod: 
(startLine=208 endLine=218 srcPath=/root/NewExperiment/elasticsearchFilter/00829/src/test/java/org/elasticsearch/test/integration/AbstractSharedClusterTest.java)
    public void allowNodes(String index, int numNodes) {
        cluster().ensureAtLeastNumNodes(numNodes);
        ImmutableSettings.Builder builder = ImmutableSettings.builder();
        if (numNodes > 0) {
            getExcludeSettings(index, numNodes, builder);
        }
        Settings build = builder.build();
        if (!build.getAsMap().isEmpty()) {
            client().admin().indices().prepareUpdateSettings(index).setSettings(build).execute().actionGet();
        }
    }


, Instance #
frags: 
(startLine=975 endLine=1011 srcPath=/root/NewExperiment/elasticsearchFilter/00840/src/test/java/org/elasticsearch/test/integration/search/highlight/HighlighterSearchTests.java)
    public void testMultiMapperNoVectorWithStore() throws Exception {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 2))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("title").field("type", "multi_field").startObject("fields")
                        .startObject("title").field("type", "string").field("store", "yes").field("term_vector", "no").endObject()
                        .startObject("key").field("type", "string").field("store", "yes").field("term_vector", "no").field("analyzer", "whitespace").endObject()
                        .endObject().endObject()
                        .endObject().endObject().endObject())
                .execute().actionGet();

        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();

        client().prepareIndex("test", "type1", "1").setSource("title", "this is a test").execute().actionGet();
        client().admin().indices().prepareRefresh().execute().actionGet();

        // simple search on body with standard analyzer with a simple field query
        SearchResponse search = client().prepareSearch()
                .setQuery(fieldQuery("title", "this is a test"))
                .setHighlighterEncoder("html")
                .addHighlightedField("title", 50, 1)
                .execute().actionGet();
        assertThat(Arrays.toString(search.getShardFailures()), search.getFailedShards(), equalTo(0));

        SearchHit hit = search.getHits().getAt(0);
        assertThat(hit.highlightFields().get("title").fragments()[0].string(), equalTo("this is a <em>test</em>"));

        // search on title.key and highlight on title
        search = client().prepareSearch()
                .setQuery(fieldQuery("title.key", "this is a test"))
                .setHighlighterEncoder("html")
                .addHighlightedField("title.key", 50, 1)
                .execute().actionGet();
        assertThat(Arrays.toString(search.getShardFailures()), search.getFailedShards(), equalTo(0));

        hit = search.getHits().getAt(0);
        assertThat(hit.highlightFields().get("title.key").fragments()[0].string(), equalTo("<em>this</em> <em>is</em> <em>a</em> <em>test</em>"));
    }

(startLine=1014 endLine=1050 srcPath=/root/NewExperiment/elasticsearchFilter/00840/src/test/java/org/elasticsearch/test/integration/search/highlight/HighlighterSearchTests.java)
    public void testMultiMapperNoVectorFromSource() throws Exception {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 2))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("title").field("type", "multi_field").startObject("fields")
                        .startObject("title").field("type", "string").field("store", "no").field("term_vector", "no").endObject()
                        .startObject("key").field("type", "string").field("store", "no").field("term_vector", "no").field("analyzer", "whitespace").endObject()
                        .endObject().endObject()
                        .endObject().endObject().endObject())
                .execute().actionGet();

        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();

        client().prepareIndex("test", "type1", "1").setSource("title", "this is a test").execute().actionGet();
        client().admin().indices().prepareRefresh().execute().actionGet();

        // simple search on body with standard analyzer with a simple field query
        SearchResponse search = client().prepareSearch()
                .setQuery(fieldQuery("title", "this is a test"))
                .setHighlighterEncoder("html")
                .addHighlightedField("title", 50, 1)
                .execute().actionGet();
        assertThat(Arrays.toString(search.getShardFailures()), search.getFailedShards(), equalTo(0));

        SearchHit hit = search.getHits().getAt(0);
        assertThat(hit.highlightFields().get("title").fragments()[0].string(), equalTo("this is a <em>test</em>"));

        // search on title.key and highlight on title.key
        search = client().prepareSearch()
                .setQuery(fieldQuery("title.key", "this is a test"))
                .setHighlighterEncoder("html")
                .addHighlightedField("title.key", 50, 1)
                .execute().actionGet();
        assertThat(Arrays.toString(search.getShardFailures()), search.getFailedShards(), equalTo(0));

        hit = search.getHits().getAt(0);
        assertThat(hit.highlightFields().get("title.key").fragments()[0].string(), equalTo("<em>this</em> <em>is</em> <em>a</em> <em>test</em>"));
    }

commonMethod: 
(startLine=276 endLine=282 srcPath=/root/NewExperiment/elasticsearchFilter/00841/src/test/java/org/elasticsearch/test/integration/AbstractSharedClusterTest.java)
    public ClusterHealthStatus ensureGreen() {
        ClusterHealthResponse actionGet = client().admin().cluster()
                .health(Requests.clusterHealthRequest().waitForGreenStatus().waitForEvents(Priority.LANGUID).waitForRelocatingShards(0)).actionGet();
        assertThat(actionGet.isTimedOut(), equalTo(false));
        assertThat(actionGet.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        return actionGet.getStatus();
    }


, Instance #
frags: 
(startLine=975 endLine=1011 srcPath=/root/NewExperiment/elasticsearchFilter/00840/src/test/java/org/elasticsearch/test/integration/search/highlight/HighlighterSearchTests.java)
    public void testMultiMapperNoVectorWithStore() throws Exception {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 2))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("title").field("type", "multi_field").startObject("fields")
                        .startObject("title").field("type", "string").field("store", "yes").field("term_vector", "no").endObject()
                        .startObject("key").field("type", "string").field("store", "yes").field("term_vector", "no").field("analyzer", "whitespace").endObject()
                        .endObject().endObject()
                        .endObject().endObject().endObject())
                .execute().actionGet();

        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();

        client().prepareIndex("test", "type1", "1").setSource("title", "this is a test").execute().actionGet();
        client().admin().indices().prepareRefresh().execute().actionGet();

        // simple search on body with standard analyzer with a simple field query
        SearchResponse search = client().prepareSearch()
                .setQuery(fieldQuery("title", "this is a test"))
                .setHighlighterEncoder("html")
                .addHighlightedField("title", 50, 1)
                .execute().actionGet();
        assertThat(Arrays.toString(search.getShardFailures()), search.getFailedShards(), equalTo(0));

        SearchHit hit = search.getHits().getAt(0);
        assertThat(hit.highlightFields().get("title").fragments()[0].string(), equalTo("this is a <em>test</em>"));

        // search on title.key and highlight on title
        search = client().prepareSearch()
                .setQuery(fieldQuery("title.key", "this is a test"))
                .setHighlighterEncoder("html")
                .addHighlightedField("title.key", 50, 1)
                .execute().actionGet();
        assertThat(Arrays.toString(search.getShardFailures()), search.getFailedShards(), equalTo(0));

        hit = search.getHits().getAt(0);
        assertThat(hit.highlightFields().get("title.key").fragments()[0].string(), equalTo("<em>this</em> <em>is</em> <em>a</em> <em>test</em>"));
    }

(startLine=1014 endLine=1050 srcPath=/root/NewExperiment/elasticsearchFilter/00840/src/test/java/org/elasticsearch/test/integration/search/highlight/HighlighterSearchTests.java)
    public void testMultiMapperNoVectorFromSource() throws Exception {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 2))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("title").field("type", "multi_field").startObject("fields")
                        .startObject("title").field("type", "string").field("store", "no").field("term_vector", "no").endObject()
                        .startObject("key").field("type", "string").field("store", "no").field("term_vector", "no").field("analyzer", "whitespace").endObject()
                        .endObject().endObject()
                        .endObject().endObject().endObject())
                .execute().actionGet();

        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();

        client().prepareIndex("test", "type1", "1").setSource("title", "this is a test").execute().actionGet();
        client().admin().indices().prepareRefresh().execute().actionGet();

        // simple search on body with standard analyzer with a simple field query
        SearchResponse search = client().prepareSearch()
                .setQuery(fieldQuery("title", "this is a test"))
                .setHighlighterEncoder("html")
                .addHighlightedField("title", 50, 1)
                .execute().actionGet();
        assertThat(Arrays.toString(search.getShardFailures()), search.getFailedShards(), equalTo(0));

        SearchHit hit = search.getHits().getAt(0);
        assertThat(hit.highlightFields().get("title").fragments()[0].string(), equalTo("this is a <em>test</em>"));

        // search on title.key and highlight on title.key
        search = client().prepareSearch()
                .setQuery(fieldQuery("title.key", "this is a test"))
                .setHighlighterEncoder("html")
                .addHighlightedField("title.key", 50, 1)
                .execute().actionGet();
        assertThat(Arrays.toString(search.getShardFailures()), search.getFailedShards(), equalTo(0));

        hit = search.getHits().getAt(0);
        assertThat(hit.highlightFields().get("title.key").fragments()[0].string(), equalTo("<em>this</em> <em>is</em> <em>a</em> <em>test</em>"));
    }

commonMethod: 
(startLine=326 endLine=332 srcPath=/root/NewExperiment/elasticsearchFilter/00841/src/test/java/org/elasticsearch/test/integration/AbstractSharedClusterTest.java)
    protected RefreshResponse refresh() {
        waitForRelocation();
        // TODO RANDOMIZE with flush?
        RefreshResponse actionGet = client().admin().indices().prepareRefresh().execute().actionGet();
        assertNoFailures(actionGet);
        return actionGet;
    }


, Instance #
frags: 
(startLine=55 endLine=103 srcPath=/root/NewExperiment/elasticsearchFilter/00840/src/test/java/org/elasticsearch/test/integration/search/geo/GeoShapeIntegrationTests.java)
    public void testIndexPointsFilterRectangle() throws Exception {
        client().admin().indices().prepareDelete().execute().actionGet();

        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type1")
                .startObject("properties").startObject("location")
                .field("type", "geo_shape")
                .field("tree", "quadtree")
                .endObject().endObject()
                .endObject().endObject().string();
        client().admin().indices().prepareCreate("test").addMapping("type1", mapping).execute().actionGet();
        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().execute().actionGet();

        client().prepareIndex("test", "type1", "1").setSource(jsonBuilder().startObject()
                .field("name", "Document 1")
                .startObject("location")
                .field("type", "point")
                .startArray("coordinates").value(-30).value(-30).endArray()
                .endObject()
                .endObject()).execute().actionGet();

        client().prepareIndex("test", "type1", "2").setSource(jsonBuilder().startObject()
                .field("name", "Document 2")
                .startObject("location")
                .field("type", "point")
                .startArray("coordinates").value(-45).value(-50).endArray()
                .endObject()
                .endObject()).execute().actionGet();

        client().admin().indices().prepareRefresh().execute().actionGet();

        Shape shape = newRectangle().topLeft(-45, 45).bottomRight(45, -45).build();

        SearchResponse searchResponse = client().prepareSearch()
                .setQuery(filteredQuery(matchAllQuery(),
                        geoIntersectionFilter("location", shape)))
                .execute().actionGet();

        assertThat(searchResponse.getHits().getTotalHits(), equalTo(1l));
        assertThat(searchResponse.getHits().hits().length, equalTo(1));
        assertThat(searchResponse.getHits().getAt(0).id(), equalTo("1"));

        searchResponse = client().prepareSearch()
                .setQuery(geoShapeQuery("location", shape))
                .execute().actionGet();

        assertThat(searchResponse.getHits().getTotalHits(), equalTo(1l));
        assertThat(searchResponse.getHits().hits().length, equalTo(1));
        assertThat(searchResponse.getHits().getAt(0).id(), equalTo("1"));
    }

(startLine=148 endLine=197 srcPath=/root/NewExperiment/elasticsearchFilter/00840/src/test/java/org/elasticsearch/test/integration/search/geo/GeoShapeIntegrationTests.java)
    public void testIndexedShapeReference() throws Exception {
        client().admin().indices().prepareDelete().execute().actionGet();

        String mapping = XContentFactory.jsonBuilder().startObject().startObject("type1")
                .startObject("properties").startObject("location")
                .field("type", "geo_shape")
                .field("tree", "quadtree")
                .endObject().endObject()
                .endObject().endObject().string();
        client().admin().indices().prepareCreate("test").addMapping("type1", mapping).execute().actionGet();
        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().execute().actionGet();

        client().prepareIndex("test", "type1", "1").setSource(jsonBuilder().startObject()
                .field("name", "Document 1")
                .startObject("location")
                .field("type", "point")
                .startArray("coordinates").value(-30).value(-30).endArray()
                .endObject()
                .endObject()).execute().actionGet();

        client().admin().indices().prepareRefresh("test").execute().actionGet();

        Shape shape = newRectangle().topLeft(-45, 45).bottomRight(45, -45).build();
        XContentBuilder shapeContent = jsonBuilder().startObject()
                .startObject("shape");
        GeoJSONShapeSerializer.serialize(shape, shapeContent);
        shapeContent.endObject();

        client().prepareIndex("shapes", "shape_type", "Big_Rectangle").setSource(shapeContent).execute().actionGet();
        client().admin().indices().prepareRefresh().execute().actionGet();

        client().admin().indices().prepareRefresh("shapes").execute().actionGet();

        SearchResponse searchResponse = client().prepareSearch("test")
                .setQuery(filteredQuery(matchAllQuery(),
                        geoIntersectionFilter("location", "Big_Rectangle", "shape_type")))
                .execute().actionGet();

        assertThat(searchResponse.getHits().getTotalHits(), equalTo(1l));
        assertThat(searchResponse.getHits().hits().length, equalTo(1));
        assertThat(searchResponse.getHits().getAt(0).id(), equalTo("1"));

        searchResponse = client().prepareSearch()
                .setQuery(geoShapeQuery("location", "Big_Rectangle", "shape_type"))
                .execute().actionGet();

        assertThat(searchResponse.getHits().getTotalHits(), equalTo(1l));
        assertThat(searchResponse.getHits().hits().length, equalTo(1));
        assertThat(searchResponse.getHits().getAt(0).id(), equalTo("1"));
    }

commonMethod: 
(startLine=276 endLine=282 srcPath=/root/NewExperiment/elasticsearchFilter/00841/src/test/java/org/elasticsearch/test/integration/AbstractSharedClusterTest.java)
    public ClusterHealthStatus ensureGreen() {
        ClusterHealthResponse actionGet = client().admin().cluster()
                .health(Requests.clusterHealthRequest().waitForGreenStatus().waitForEvents(Priority.LANGUID).waitForRelocatingShards(0)).actionGet();
        assertThat(actionGet.isTimedOut(), equalTo(false));
        assertThat(actionGet.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        return actionGet.getStatus();
    }


, Instance #
frags: 
(startLine=392 endLine=423 srcPath=/root/NewExperiment/elasticsearchFilter/00842/src/main/java/org/elasticsearch/index/mapper/geo/GeoPointFieldMapper.java)
    private void parseLatLon(ParseContext context, double lat, double lon) throws IOException {
        if (normalizeLat || normalizeLon) {
            GeoPoint point = new GeoPoint(lat, lon);
            GeoUtils.normalizePoint(point, normalizeLat, normalizeLon);
            lat = point.lat();
            lon = point.lon();
        }

        if (validateLat) {
            if (lat > 90.0 || lat < -90.0) {
                throw new ElasticSearchIllegalArgumentException("illegal latitude value [" + lat + "] for " + name);
            }
        }
        if (validateLon) {
            if (lon > 180.0 || lon < -180) {
                throw new ElasticSearchIllegalArgumentException("illegal longitude value [" + lon + "] for " + name);
            }
        }

        context.externalValue(Double.toString(lat) + ',' + Double.toString(lon));
        geoStringMapper.parse(context);
        if (enableGeoHash) {
            context.externalValue(GeoHashUtils.encode(lat, lon, precision));
            geohashMapper.parse(context);
        }
        if (enableLatLon) {
            context.externalValue(lat);
            latMapper.parse(context);
            context.externalValue(lon);
            lonMapper.parse(context);
        }
    }

(startLine=425 endLine=455 srcPath=/root/NewExperiment/elasticsearchFilter/00842/src/main/java/org/elasticsearch/index/mapper/geo/GeoPointFieldMapper.java)
    private void parseGeohash(ParseContext context, String geohash) throws IOException {
        GeoPoint point = GeoHashUtils.decode(geohash);

        if (normalizeLat || normalizeLon) {
            GeoUtils.normalizePoint(point, normalizeLat, normalizeLon);
        }

        if (validateLat) {
            if (point.lat() > 90.0 || point.lat() < -90.0) {
                throw new ElasticSearchIllegalArgumentException("illegal latitude value [" + point.lat() + "] for " + name);
            }
        }
        if (validateLon) {
            if (point.lon() > 180.0 || point.lon() < -180) {
                throw new ElasticSearchIllegalArgumentException("illegal longitude value [" + point.lon() + "] for " + name);
            }
        }

        context.externalValue(Double.toString(point.lat()) + ',' + Double.toString(point.lon()));
        geoStringMapper.parse(context);
        if (enableGeoHash) {
            context.externalValue(geohash);
            geohashMapper.parse(context);
        }
        if (enableLatLon) {
            context.externalValue(point.lat());
            latMapper.parse(context);
            context.externalValue(point.lon());
            lonMapper.parse(context);
        }
    }

commonMethod: 
(startLine=416 endLine=424 srcPath=/root/NewExperiment/elasticsearchFilter/00843/src/main/java/org/elasticsearch/index/mapper/geo/GeoPointFieldMapper.java)
    private void parseGeohashField(ParseContext context, String geohash) throws IOException {
        int len = enableGeohashPrefix ?Math.min(precision, geohash.length()) :1;
        
        for (int i = 0; i < len; i++) {
            context.externalValue(geohash.substring(0, geohash.length() - i));
            // side effect of this call is adding the field
            geohashMapper.parse(context);
        }
    }


, Instance #
frags: 
(startLine=86 endLine=138 srcPath=/root/NewExperiment/elasticsearchFilter/00848/src/main/java/org/elasticsearch/index/fielddata/plain/DoubleArrayIndexFieldData.java)
    public DoubleArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {

        AtomicReader reader = context.reader();
        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return DoubleArrayAtomicFieldData.EMPTY;
        }
        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TDoubleArrayList values = new TDoubleArrayList();

        values.add(0); // first "t" indicates null value
        OrdinalsBuilder builder = new OrdinalsBuilder(terms, reader.maxDoc());
        try {
            final BytesRefIterator iter = builder.buildFromTerms(builder.wrapNumeric64Bit(terms.iterator(null)), reader.getLiveDocs());
            BytesRef term;
            while ((term = iter.next()) != null) {
                values.add(NumericUtils.sortableLongToDouble(NumericUtils.prefixCodedToLong(term)));
            }
            Ordinals build = builder.build(fieldDataType.getSettings());
            if (!build.isMultiValued() && CommonSettings.removeOrdsOnSingleValue(fieldDataType)) {
                Docs ordinals = build.ordinals();
                final FixedBitSet set = builder.buildDocsWithValuesSet();

                // there's sweatspot where due to low unique value count, using ordinals will consume less memory
                long singleValuesArraySize = reader.maxDoc() * RamUsage.NUM_BYTES_DOUBLE + (set == null ? 0 : set.getBits().length * RamUsage.NUM_BYTES_LONG + RamUsage.NUM_BYTES_INT);
                long uniqueValuesArraySize = values.size() * RamUsage.NUM_BYTES_DOUBLE;
                long ordinalsSize = build.getMemorySizeInBytes();
                if (uniqueValuesArraySize + ordinalsSize < singleValuesArraySize) {
                    return new DoubleArrayAtomicFieldData.WithOrdinals(values.toArray(new double[values.size()]), reader.maxDoc(), build);
                }

                double[] sValues = new double[reader.maxDoc()];
                int maxDoc = reader.maxDoc();
                for (int i = 0; i < maxDoc; i++) {
                    sValues[i] = values.get(ordinals.getOrd(i));
                }

                if (set == null) {
                    return new DoubleArrayAtomicFieldData.Single(sValues, reader.maxDoc());
                } else {
                    return new DoubleArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
                }
            } else {
                return new DoubleArrayAtomicFieldData.WithOrdinals(
                        values.toArray(new double[values.size()]),
                        reader.maxDoc(),
                        build);
            }
        } finally {
            builder.close();
        }

    }

(startLine=86 endLine=137 srcPath=/root/NewExperiment/elasticsearchFilter/00848/src/main/java/org/elasticsearch/index/fielddata/plain/FloatArrayIndexFieldData.java)
    public FloatArrayAtomicFieldData loadDirect(AtomicReaderContext context) throws Exception {
        AtomicReader reader = context.reader();
        Terms terms = reader.terms(getFieldNames().indexName());
        if (terms == null) {
            return FloatArrayAtomicFieldData.EMPTY;
        }
        // TODO: how can we guess the number of terms? numerics end up creating more terms per value...
        final TFloatArrayList values = new TFloatArrayList();

        values.add(0); // first "t" indicates null value

        OrdinalsBuilder builder = new OrdinalsBuilder(terms, reader.maxDoc());
        try {
            BytesRefIterator iter = builder.buildFromTerms(builder.wrapNumeric32Bit(terms.iterator(null)), reader.getLiveDocs());
            BytesRef term;
            while ((term = iter.next()) != null) {
                values.add(NumericUtils.sortableIntToFloat(NumericUtils.prefixCodedToInt(term)));
            }
            Ordinals build = builder.build(fieldDataType.getSettings());
            if (!build.isMultiValued() && CommonSettings.removeOrdsOnSingleValue(fieldDataType)) {
                Docs ordinals = build.ordinals();
                final FixedBitSet set = builder.buildDocsWithValuesSet();

                // there's sweatspot where due to low unique value count, using ordinals will consume less memory
                long singleValuesArraySize = reader.maxDoc() * RamUsage.NUM_BYTES_FLOAT + (set == null ? 0 : set.getBits().length * RamUsage.NUM_BYTES_LONG + RamUsage.NUM_BYTES_INT);
                long uniqueValuesArraySize = values.size() * RamUsage.NUM_BYTES_FLOAT;
                long ordinalsSize = build.getMemorySizeInBytes();
                if (uniqueValuesArraySize + ordinalsSize < singleValuesArraySize) {
                    return new FloatArrayAtomicFieldData.WithOrdinals(values.toArray(new float[values.size()]), reader.maxDoc(), build);
                }

                float[] sValues = new float[reader.maxDoc()];
                int maxDoc = reader.maxDoc();
                for (int i = 0; i < maxDoc; i++) {
                    sValues[i] = values.get(ordinals.getOrd(i));
                }
                if (set == null) {
                    return new FloatArrayAtomicFieldData.Single(sValues, reader.maxDoc());
                } else {
                    return new FloatArrayAtomicFieldData.SingleFixedSet(sValues, reader.maxDoc(), set);
                }
            } else {
                return new FloatArrayAtomicFieldData.WithOrdinals(
                        values.toArray(new float[values.size()]),
                        reader.maxDoc(),
                        build);
            }
        } finally {
            builder.close();
        }

    }

commonMethod: 
(startLine=106 endLine=110 srcPath=/root/NewExperiment/elasticsearchFilter/00849/src/main/java/org/elasticsearch/common/settings/Settings.java)
    /**
     * Returns the setting value (as float) associated with the setting key. If it does not exists,
     * returns the default value provided.
     */
    Float getAsFloat(String setting, Float defaultValue) throws SettingsException;


, Instance #
frags: 
(startLine=724 endLine=779 srcPath=/root/NewExperiment/elasticsearchFilter/00849/src/main/java/org/elasticsearch/common/xcontent/XContentBuilder.java)
    public XContentBuilder field(String name, Object value) throws IOException {
        if (value == null) {
            nullField(name);
            return this;
        }
        Class type = value.getClass();
        if (type == String.class) {
            field(name, (String) value);
        } else if (type == Float.class) {
            field(name, ((Float) value).floatValue());
        } else if (type == Double.class) {
            field(name, ((Double) value).doubleValue());
        } else if (type == Integer.class) {
            field(name, ((Integer) value).intValue());
        } else if (type == Long.class) {
            field(name, ((Long) value).longValue());
        } else if (type == Short.class) {
            field(name, ((Short) value).shortValue());
        } else if (type == Byte.class) {
            field(name, ((Byte) value).byteValue());
        } else if (type == Boolean.class) {
            field(name, ((Boolean) value).booleanValue());
        } else if (value instanceof Date) {
            field(name, (Date) value);
        } else if (value instanceof Calendar) {
            field(name, convertCalendar((Calendar) value));
        } else if (type == byte[].class) {
            field(name, (byte[]) value);
        } else if (value instanceof ReadableInstant) {
            field(name, (ReadableInstant) value);
        } else if (value instanceof Map) {
            //noinspection unchecked
            field(name, (Map<String, Object>) value);
        } else if (value instanceof Iterable) {
            field(name, (Iterable) value);
        } else if (value instanceof Object[]) {
            field(name, (Object[]) value);
        } else if (value instanceof int[]) {
            field(name, (int[]) value);
        } else if (value instanceof long[]) {
            field(name, (long[]) value);
        } else if (value instanceof float[]) {
            field(name, (float[]) value);
        } else if (value instanceof double[]) {
            field(name, (double[]) value);
        } else if (value instanceof BytesReference) {
            field(name, (BytesReference) value);
        } else if (value instanceof Text) {
            field(name, (Text) value);
        } else if (value instanceof ToXContent) {
            field(name, (ToXContent) value);
        } else {
            field(name, value.toString());
        }
        return this;
    }

(startLine=781 endLine=832 srcPath=/root/NewExperiment/elasticsearchFilter/00849/src/main/java/org/elasticsearch/common/xcontent/XContentBuilder.java)
    public XContentBuilder field(XContentBuilderString name, Object value) throws IOException {
        if (value == null) {
            nullField(name);
            return this;
        }
        Class type = value.getClass();
        if (type == String.class) {
            field(name, (String) value);
        } else if (type == Float.class) {
            field(name, ((Float) value).floatValue());
        } else if (type == Double.class) {
            field(name, ((Double) value).doubleValue());
        } else if (type == Integer.class) {
            field(name, ((Integer) value).intValue());
        } else if (type == Long.class) {
            field(name, ((Long) value).longValue());
        } else if (type == Short.class) {
            field(name, ((Short) value).shortValue());
        } else if (type == Byte.class) {
            field(name, ((Byte) value).byteValue());
        } else if (type == Boolean.class) {
            field(name, ((Boolean) value).booleanValue());
        } else if (value instanceof Date) {
            field(name, (Date) value);
        } else if (type == byte[].class) {
            field(name, (byte[]) value);
        } else if (value instanceof ReadableInstant) {
            field(name, (ReadableInstant) value);
        } else if (value instanceof Map) {
            //noinspection unchecked
            field(name, (Map<String, Object>) value);
        } else if (value instanceof Iterable) {
            field(name, (Iterable) value);
        } else if (value instanceof Object[]) {
            field(name, (Object[]) value);
        } else if (value instanceof int[]) {
            field(name, (int[]) value);
        } else if (value instanceof long[]) {
            field(name, (long[]) value);
        } else if (value instanceof float[]) {
            field(name, (float[]) value);
        } else if (value instanceof double[]) {
            field(name, (double[]) value);
        } else if (value instanceof BytesReference) {
            field(name, (BytesReference) value);
        } else if (value instanceof Text) {
            field(name, (Text) value);
        } else {
            field(name, value.toString());
        }
        return this;
    }

commonMethod: 
(startLine=1077 endLine=1171 srcPath=/root/NewExperiment/elasticsearchFilter/00850/src/main/java/org/elasticsearch/common/xcontent/XContentBuilder.java)
    private void writeValue(Object value) throws IOException {
        if (value == null) {
            generator.writeNull();
            return;
        }
        Class type = value.getClass();
        if (type == String.class) {
            generator.writeString((String) value);
        } else if (type == Integer.class) {
            generator.writeNumber(((Integer) value).intValue());
        } else if (type == Long.class) {
            generator.writeNumber(((Long) value).longValue());
        } else if (type == Float.class) {
            generator.writeNumber(((Float) value).floatValue());
        } else if (type == Double.class) {
            generator.writeNumber(((Double) value).doubleValue());
        } else if (type == Short.class) {
            generator.writeNumber(((Short) value).shortValue());
        } else if (type == Boolean.class) {
            generator.writeBoolean(((Boolean) value).booleanValue());
        } else if (value instanceof Map) {
            writeMap((Map) value);
        } else if (value instanceof Iterable) {
            generator.writeStartArray();
            for (Object v : (Iterable) value) {
                writeValue(v);
            }
            generator.writeEndArray();
        } else if (value instanceof Object[]) {
            generator.writeStartArray();
            for (Object v : (Object[]) value) {
                writeValue(v);
            }
            generator.writeEndArray();
        } else if (type == byte[].class) {
            generator.writeBinary((byte[]) value);
        } else if (value instanceof Date) {
            generator.writeString(XContentBuilder.defaultDatePrinter.print(((Date) value).getTime()));
        } else if (value instanceof Calendar) {
            generator.writeString(XContentBuilder.defaultDatePrinter.print((((Calendar) value)).getTimeInMillis()));
        } else if (value instanceof BytesReference) {
            BytesReference bytes = (BytesReference) value;
            if (!bytes.hasArray()) {
                bytes = bytes.toBytesArray();
            }
            generator.writeBinary(bytes.array(), bytes.arrayOffset(), bytes.length());
        } else if (value instanceof Text) {
            Text text = (Text) value;
            if (text.hasBytes() && text.bytes().hasArray()) {
                generator.writeUTF8String(text.bytes().array(), text.bytes().arrayOffset(), text.bytes().length());
            } else if (text.hasString()) {
                generator.writeString(text.string());
            } else {
                BytesArray bytesArray = text.bytes().toBytesArray();
                generator.writeUTF8String(bytesArray.array(), bytesArray.arrayOffset(), bytesArray.length());
            }
        } else if (value instanceof ToXContent) {
            ((ToXContent) value).toXContent(this, ToXContent.EMPTY_PARAMS);
        } else if (value instanceof double[]) {
            generator.writeStartArray();
            for (double v : (double[]) value) {
                generator.writeNumber(v);
            }
            generator.writeEndArray();
        } else if (value instanceof long[]) {
            generator.writeStartArray();
            for (long v : (long[]) value) {
                generator.writeNumber(v);
            }
            generator.writeEndArray();
        } else if (value instanceof int[]) {
            generator.writeStartArray();
            for (int v : (int[]) value) {
                generator.writeNumber(v);
            }
            generator.writeEndArray();
        } else if (value instanceof float[]) {
            generator.writeStartArray();
            for (float v : (float[]) value) {
                generator.writeNumber(v);
            }
            generator.writeEndArray();
        } else if (value instanceof short[]) {
            generator.writeStartArray();
            for (float v : (short[]) value) {
                generator.writeNumber(v);
            }
            generator.writeEndArray();
        } else {
            // if this is a "value" object, like enum, DistanceUnit, ..., just toString it
            // yea, it can be misleading when toString a Java class, but really, jackson should be used in that case
            generator.writeString(value.toString());
            //throw new ElasticSearchIllegalArgumentException("type not supported for generic value conversion: " + type);
        }
    }


, Instance #
frags: 
(startLine=433 endLine=450 srcPath=/root/NewExperiment/elasticsearchFilter/00849/src/test/java/org/elasticsearch/test/integration/update/UpdateTests.java)
    public void testUpdateRequestWithBothScriptAndDoc() throws Exception {
        createIndex();
        ClusterHealthResponse clusterHealth = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().execute().actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        try {
            client().prepareUpdate("test", "type1", "1")
                    .setDoc(XContentFactory.jsonBuilder().startObject().field("field", 1).endObject())
                    .setScript("ctx._source.field += 1")
                    .execute().actionGet();
            fail("Should have thrown ActionRequestValidationException");
        } catch (ActionRequestValidationException e) {
            assertThat(e.validationErrors().size(), equalTo(1));
            assertThat(e.validationErrors().get(0), containsString("can't provide both script and doc"));
            assertThat(e.getMessage(), containsString("can't provide both script and doc"));
        }
    }

(startLine=453 endLine=469 srcPath=/root/NewExperiment/elasticsearchFilter/00849/src/test/java/org/elasticsearch/test/integration/update/UpdateTests.java)
    public void testUpdateRequestWithScriptAndShouldUpsertDoc() throws Exception {
        createIndex();
        ClusterHealthResponse clusterHealth = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().execute().actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        try {
            client().prepareUpdate("test", "type1", "1")
                    .setScript("ctx._source.field += 1")
                    .setDocAsUpsert(true)
                    .execute().actionGet();
            fail("Should have thrown ActionRequestValidationException");
        } catch (ActionRequestValidationException e) {
            assertThat(e.validationErrors().size(), equalTo(1));
            assertThat(e.validationErrors().get(0), containsString("can't say to upsert doc without providing doc"));
            assertThat(e.getMessage(), containsString("can't say to upsert doc without providing doc"));
        }
    }

commonMethod: 
(startLine=275 endLine=281 srcPath=/root/NewExperiment/elasticsearchFilter/00850/src/test/java/org/elasticsearch/test/integration/AbstractSharedClusterTest.java)
    public ClusterHealthStatus ensureGreen() {
        ClusterHealthResponse actionGet = client().admin().cluster()
                .health(Requests.clusterHealthRequest().waitForGreenStatus().waitForEvents(Priority.LANGUID).waitForRelocatingShards(0)).actionGet();
        assertThat(actionGet.isTimedOut(), equalTo(false));
        assertThat(actionGet.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        return actionGet.getStatus();
    }


, Instance #
frags: 
(startLine=1507 endLine=1616 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
         BiFun<? super K, ? super V, ? extends V> mf) {
        if (k == null || mf == null)
            throw new NullPointerException();
        int h = spread(k.hashCode());
        V val = null;
        int delta = 0;
        int len = 0;
        for (Node<V>[] tab = table;;) {
            Node<V> f; int i, fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (onlyIfPresent)
                    break;
                Node<V> node = new Node<V>(h, k, null, null);
                synchronized (node) {
                    if (casTabAt(tab, i, null, node)) {
                        try {
                            len = 1;
                            if ((val = mf.apply(k, null)) != null) {
                                node.val = val;
                                delta = 1;
                            }
                        } finally {
                            if (delta == 0)
                                setTabAt(tab, i, null);
                        }
                    }
                }
                if (len != 0)
                    break;
            }
            else if ((fh = f.hash) < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            if (p == null && onlyIfPresent)
                                break;
                            V pv = (p == null) ? null : p.val;
                            if ((val = mf.apply(k, pv)) != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    len = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0)
                        break;
                }
                else
                    tab = (Node<V>[])fk;
            }
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f, pred = null;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(k, ev);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                if (!onlyIfPresent &&
                                    (val = mf.apply(k, null)) != null) {
                                    pred.next = new Node<V>(h, k, val, null);
                                    delta = 1;
                                    if (len >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                }
                if (len != 0)
                    break;
            }
        }
        if (delta != 0)
            addCount((long)delta, len);
        return val;
    }

(startLine=1620 endLine=1711 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        (K k, V v, BiFun<? super V, ? super V, ? extends V> mf) {
        if (k == null || v == null || mf == null)
            throw new NullPointerException();
        int h = spread(k.hashCode());
        V val = null;
        int delta = 0;
        int len = 0;
        for (Node<V>[] tab = table;;) {
            int i; Node<V> f; Object fk; V fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node<V>(h, k, v, null))) {
                    delta = 1;
                    val = v;
                    break;
                }
            }
            else if (f.hash < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            val = (p == null) ? v : mf.apply(p.val, v);
                            if (val != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    len = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0)
                        break;
                }
                else
                    tab = (Node<V>[])fk;
            }
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f, pred = null;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(ev, v);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                val = v;
                                pred.next = new Node<V>(h, k, val, null);
                                delta = 1;
                                if (len >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                }
                if (len != 0)
                    break;
            }
        }
        if (delta != 0)
            addCount((long)delta, len);
        return val;
    }

(startLine=1404 endLine=1502 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        (K k, Fun<? super K, ? extends V> mf) {
        if (k == null || mf == null)
            throw new NullPointerException();
        int h = spread(k.hashCode());
        V val = null;
        int len = 0;
        for (Node<V>[] tab = table;;) {
            Node<V> f; int i; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                Node<V> node = new Node<V>(h, k, null, null);
                synchronized (node) {
                    if (casTabAt(tab, i, null, node)) {
                        len = 1;
                        try {
                            if ((val = mf.apply(k)) != null)
                                node.val = val;
                        } finally {
                            if (val == null)
                                setTabAt(tab, i, null);
                        }
                    }
                }
                if (len != 0)
                    break;
            }
            else if (f.hash < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    boolean added = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            if (p != null)
                                val = p.val;
                            else if ((val = mf.apply(k)) != null) {
                                added = true;
                                len = 2;
                                t.putTreeNode(h, k, val);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0) {
                        if (!added)
                            return val;
                        break;
                    }
                }
                else
                    tab = (Node<V>[])fk;
            }
            else {
                for (Node<V> e = f; e != null; e = e.next) { // prescan
                    Object ek; V ev;
                    if (e.hash == h && (ev = e.val) != null &&
                        ((ek = e.key) == k || k.equals(ek)))
                        return ev;
                }
                boolean added = false;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = ev;
                                break;
                            }
                            Node<V> last = e;
                            if ((e = e.next) == null) {
                                if ((val = mf.apply(k)) != null) {
                                    added = true;
                                    last.next = new Node<V>(h, k, val, null);
                                    if (len >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                }
                if (len != 0) {
                    if (!added)
                        return val;
                    break;
                }
            }
        }
        if (val != null)
            addCount(1L, len);
        return val;
    }

commonMethod: 
(startLine=2764 endLine=2868 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Removes the given node, that must be present before this
         * call.  This is messier than typical red-black deletion code
         * because we cannot swap the contents of an interior node
         * with a leaf successor that is pinned by "next" pointers
         * that are accessible independently of lock. So instead we
         * swap the tree linkages.
         *
         * @return true if now too small, so should be untreeified
         */
        final boolean removeTreeNode(TreeNode<K,V> p) {
            TreeNode<K,V> next = (TreeNode<K,V>)p.next;
            TreeNode<K,V> pred = p.prev;  // unlink traversal pointers
            TreeNode<K,V> r, rl;
            if (pred == null)
                first = next;
            else
                pred.next = next;
            if (next != null)
                next.prev = pred;
            if (first == null) {
                root = null;
                return true;
            }
            if ((r = root) == null || r.right == null || // too small
                (rl = r.left) == null || rl.left == null)
                return true;
            lockRoot();
            try {
                TreeNode<K,V> replacement;
                TreeNode<K,V> pl = p.left;
                TreeNode<K,V> pr = p.right;
                if (pl != null && pr != null) {
                    TreeNode<K,V> s = pr, sl;
                    while ((sl = s.left) != null) // find successor
                        s = sl;
                    boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                    TreeNode<K,V> sr = s.right;
                    TreeNode<K,V> pp = p.parent;
                    if (s == pr) { // p was s's direct parent
                        p.parent = s;
                        s.right = p;
                    }
                    else {
                        TreeNode<K,V> sp = s.parent;
                        if ((p.parent = sp) != null) {
                            if (s == sp.left)
                                sp.left = p;
                            else
                                sp.right = p;
                        }
                        if ((s.right = pr) != null)
                            pr.parent = s;
                    }
                    p.left = null;
                    if ((p.right = sr) != null)
                        sr.parent = p;
                    if ((s.left = pl) != null)
                        pl.parent = s;
                    if ((s.parent = pp) == null)
                        r = s;
                    else if (p == pp.left)
                        pp.left = s;
                    else
                        pp.right = s;
                    if (sr != null)
                        replacement = sr;
                    else
                        replacement = p;
                }
                else if (pl != null)
                    replacement = pl;
                else if (pr != null)
                    replacement = pr;
                else
                    replacement = p;
                if (replacement != p) {
                    TreeNode<K,V> pp = replacement.parent = p.parent;
                    if (pp == null)
                        r = replacement;
                    else if (p == pp.left)
                        pp.left = replacement;
                    else
                        pp.right = replacement;
                    p.left = p.right = p.parent = null;
                }

                root = (p.red) ? r : balanceDeletion(r, replacement);

                if (p == replacement) {  // detach pointers
                    TreeNode<K,V> pp;
                    if ((pp = p.parent) != null) {
                        if (p == pp.left)
                            pp.left = null;
                        else if (p == pp.right)
                            pp.right = null;
                        p.parent = null;
                    }
                }
            } finally {
                unlockRoot();
            }
            assert checkInvariants(root);
            return false;
        }


, Instance #
frags: 
(startLine=1507 endLine=1616 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
         BiFun<? super K, ? super V, ? extends V> mf) {
        if (k == null || mf == null)
            throw new NullPointerException();
        int h = spread(k.hashCode());
        V val = null;
        int delta = 0;
        int len = 0;
        for (Node<V>[] tab = table;;) {
            Node<V> f; int i, fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (onlyIfPresent)
                    break;
                Node<V> node = new Node<V>(h, k, null, null);
                synchronized (node) {
                    if (casTabAt(tab, i, null, node)) {
                        try {
                            len = 1;
                            if ((val = mf.apply(k, null)) != null) {
                                node.val = val;
                                delta = 1;
                            }
                        } finally {
                            if (delta == 0)
                                setTabAt(tab, i, null);
                        }
                    }
                }
                if (len != 0)
                    break;
            }
            else if ((fh = f.hash) < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            if (p == null && onlyIfPresent)
                                break;
                            V pv = (p == null) ? null : p.val;
                            if ((val = mf.apply(k, pv)) != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    len = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0)
                        break;
                }
                else
                    tab = (Node<V>[])fk;
            }
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f, pred = null;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(k, ev);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                if (!onlyIfPresent &&
                                    (val = mf.apply(k, null)) != null) {
                                    pred.next = new Node<V>(h, k, val, null);
                                    delta = 1;
                                    if (len >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                }
                if (len != 0)
                    break;
            }
        }
        if (delta != 0)
            addCount((long)delta, len);
        return val;
    }

(startLine=1620 endLine=1711 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        (K k, V v, BiFun<? super V, ? super V, ? extends V> mf) {
        if (k == null || v == null || mf == null)
            throw new NullPointerException();
        int h = spread(k.hashCode());
        V val = null;
        int delta = 0;
        int len = 0;
        for (Node<V>[] tab = table;;) {
            int i; Node<V> f; Object fk; V fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node<V>(h, k, v, null))) {
                    delta = 1;
                    val = v;
                    break;
                }
            }
            else if (f.hash < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            val = (p == null) ? v : mf.apply(p.val, v);
                            if (val != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    len = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0)
                        break;
                }
                else
                    tab = (Node<V>[])fk;
            }
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f, pred = null;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(ev, v);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                val = v;
                                pred.next = new Node<V>(h, k, val, null);
                                delta = 1;
                                if (len >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                }
                if (len != 0)
                    break;
            }
        }
        if (delta != 0)
            addCount((long)delta, len);
        return val;
    }

(startLine=1404 endLine=1502 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        (K k, Fun<? super K, ? extends V> mf) {
        if (k == null || mf == null)
            throw new NullPointerException();
        int h = spread(k.hashCode());
        V val = null;
        int len = 0;
        for (Node<V>[] tab = table;;) {
            Node<V> f; int i; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                Node<V> node = new Node<V>(h, k, null, null);
                synchronized (node) {
                    if (casTabAt(tab, i, null, node)) {
                        len = 1;
                        try {
                            if ((val = mf.apply(k)) != null)
                                node.val = val;
                        } finally {
                            if (val == null)
                                setTabAt(tab, i, null);
                        }
                    }
                }
                if (len != 0)
                    break;
            }
            else if (f.hash < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    boolean added = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            if (p != null)
                                val = p.val;
                            else if ((val = mf.apply(k)) != null) {
                                added = true;
                                len = 2;
                                t.putTreeNode(h, k, val);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0) {
                        if (!added)
                            return val;
                        break;
                    }
                }
                else
                    tab = (Node<V>[])fk;
            }
            else {
                for (Node<V> e = f; e != null; e = e.next) { // prescan
                    Object ek; V ev;
                    if (e.hash == h && (ev = e.val) != null &&
                        ((ek = e.key) == k || k.equals(ek)))
                        return ev;
                }
                boolean added = false;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = ev;
                                break;
                            }
                            Node<V> last = e;
                            if ((e = e.next) == null) {
                                if ((val = mf.apply(k)) != null) {
                                    added = true;
                                    last.next = new Node<V>(h, k, val, null);
                                    if (len >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                }
                if (len != 0) {
                    if (!added)
                        return val;
                    break;
                }
            }
        }
        if (val != null)
            addCount(1L, len);
        return val;
    }

commonMethod: 
(startLine=2533 endLine=2565 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Returns the TreeNode (or null if not found) for the given key
         * starting at given root.
         */
        final TreeNode<K,V> findTreeNode(int h, Object k, Class<?> kc) {
            if (k != null) {
                TreeNode<K,V> p = this;
                do  {
                    int ph, dir; K pk; TreeNode<K,V> q;
                    TreeNode<K,V> pl = p.left, pr = p.right;
                    if ((ph = p.hash) > h)
                        p = pl;
                    else if (ph < h)
                        p = pr;
                    else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                        return p;
                    else if (pl == null && pr == null)
                        break;
                    else if ((kc != null ||
                              (kc = comparableClassFor(k)) != null) &&
                             (dir = compareComparables(kc, k, pk)) != 0)
                        p = (dir < 0) ? pl : pr;
                    else if (pl == null)
                        p = pr;
                    else if (pr == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        p = pl;
                    else
                        return q;
                } while (p != null);
            }
            return null;
        }


, Instance #
frags: 
(startLine=1507 endLine=1616 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
         BiFun<? super K, ? super V, ? extends V> mf) {
        if (k == null || mf == null)
            throw new NullPointerException();
        int h = spread(k.hashCode());
        V val = null;
        int delta = 0;
        int len = 0;
        for (Node<V>[] tab = table;;) {
            Node<V> f; int i, fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (onlyIfPresent)
                    break;
                Node<V> node = new Node<V>(h, k, null, null);
                synchronized (node) {
                    if (casTabAt(tab, i, null, node)) {
                        try {
                            len = 1;
                            if ((val = mf.apply(k, null)) != null) {
                                node.val = val;
                                delta = 1;
                            }
                        } finally {
                            if (delta == 0)
                                setTabAt(tab, i, null);
                        }
                    }
                }
                if (len != 0)
                    break;
            }
            else if ((fh = f.hash) < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            if (p == null && onlyIfPresent)
                                break;
                            V pv = (p == null) ? null : p.val;
                            if ((val = mf.apply(k, pv)) != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    len = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0)
                        break;
                }
                else
                    tab = (Node<V>[])fk;
            }
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f, pred = null;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(k, ev);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                if (!onlyIfPresent &&
                                    (val = mf.apply(k, null)) != null) {
                                    pred.next = new Node<V>(h, k, val, null);
                                    delta = 1;
                                    if (len >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                }
                if (len != 0)
                    break;
            }
        }
        if (delta != 0)
            addCount((long)delta, len);
        return val;
    }

(startLine=1620 endLine=1711 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        (K k, V v, BiFun<? super V, ? super V, ? extends V> mf) {
        if (k == null || v == null || mf == null)
            throw new NullPointerException();
        int h = spread(k.hashCode());
        V val = null;
        int delta = 0;
        int len = 0;
        for (Node<V>[] tab = table;;) {
            int i; Node<V> f; Object fk; V fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node<V>(h, k, v, null))) {
                    delta = 1;
                    val = v;
                    break;
                }
            }
            else if (f.hash < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            val = (p == null) ? v : mf.apply(p.val, v);
                            if (val != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    len = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0)
                        break;
                }
                else
                    tab = (Node<V>[])fk;
            }
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f, pred = null;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(ev, v);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                val = v;
                                pred.next = new Node<V>(h, k, val, null);
                                delta = 1;
                                if (len >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                }
                if (len != 0)
                    break;
            }
        }
        if (delta != 0)
            addCount((long)delta, len);
        return val;
    }

(startLine=1404 endLine=1502 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        (K k, Fun<? super K, ? extends V> mf) {
        if (k == null || mf == null)
            throw new NullPointerException();
        int h = spread(k.hashCode());
        V val = null;
        int len = 0;
        for (Node<V>[] tab = table;;) {
            Node<V> f; int i; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                Node<V> node = new Node<V>(h, k, null, null);
                synchronized (node) {
                    if (casTabAt(tab, i, null, node)) {
                        len = 1;
                        try {
                            if ((val = mf.apply(k)) != null)
                                node.val = val;
                        } finally {
                            if (val == null)
                                setTabAt(tab, i, null);
                        }
                    }
                }
                if (len != 0)
                    break;
            }
            else if (f.hash < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    boolean added = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            if (p != null)
                                val = p.val;
                            else if ((val = mf.apply(k)) != null) {
                                added = true;
                                len = 2;
                                t.putTreeNode(h, k, val);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0) {
                        if (!added)
                            return val;
                        break;
                    }
                }
                else
                    tab = (Node<V>[])fk;
            }
            else {
                for (Node<V> e = f; e != null; e = e.next) { // prescan
                    Object ek; V ev;
                    if (e.hash == h && (ev = e.val) != null &&
                        ((ek = e.key) == k || k.equals(ek)))
                        return ev;
                }
                boolean added = false;
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = ev;
                                break;
                            }
                            Node<V> last = e;
                            if ((e = e.next) == null) {
                                if ((val = mf.apply(k)) != null) {
                                    added = true;
                                    last.next = new Node<V>(h, k, val, null);
                                    if (len >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                }
                if (len != 0) {
                    if (!added)
                        return val;
                    break;
                }
            }
        }
        if (val != null)
            addCount(1L, len);
        return val;
    }

commonMethod: 
(startLine=2708 endLine=2762 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Finds or adds a node.
         * @return null if added
         */
        final TreeNode<K,V> putTreeVal(int h, K k, V v) {
            Class<?> kc = null;
            for (TreeNode<K,V> p = root;;) {
                int dir, ph; K pk; TreeNode<K,V> q, pr;
                if (p == null) {
                    first = root = new TreeNode<K,V>(h, k, v, null, null);
                    break;
                }
                else if ((ph = p.hash) > h)
                    dir = -1;
                else if (ph < h)
                    dir = 1;
                else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                    return p;
                else if ((kc == null &&
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0) {
                    if (p.left == null)
                        dir = 1;
                    else if ((pr = p.right) == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        dir = -1;
                    else
                        return q;
                }
                TreeNode<K,V> xp = p;
                if ((p = (dir < 0) ? p.left : p.right) == null) {
                    TreeNode<K,V> x, f = first;
                    first = x = new TreeNode<K,V>(h, k, v, f, xp);
                    if (f != null)
                        f.prev = x;
                    if (dir < 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    if (!xp.red)
                        x.red = true;
                    else {
                        lockRoot();
                        try {
                            root = balanceInsertion(root, x);
                        } finally {
                            unlockRoot();
                        }
                    }
                    break;
                }
            }
            assert checkInvariants(root);
            return null;
        }


, Instance #
frags: 
(startLine=1414 endLine=1430 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                Node<V> node = new Node<V>(h, k, null, null);
                synchronized (node) {
                    if (casTabAt(tab, i, null, node)) {
                        len = 1;
                        try {
                            if ((val = mf.apply(k)) != null)
                                node.val = val;
                        } finally {
                            if (val == null)
                                setTabAt(tab, i, null);
                        }
                    }
                }
                if (len != 0)
                    break;
            }

(startLine=1518 endLine=1538 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (onlyIfPresent)
                    break;
                Node<V> node = new Node<V>(h, k, null, null);
                synchronized (node) {
                    if (casTabAt(tab, i, null, node)) {
                        try {
                            len = 1;
                            if ((val = mf.apply(k, null)) != null) {
                                node.val = val;
                                delta = 1;
                            }
                        } finally {
                            if (delta == 0)
                                setTabAt(tab, i, null);
                        }
                    }
                }
                if (len != 0)
                    break;
            }

commonMethod: 
(startLine=2533 endLine=2565 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Returns the TreeNode (or null if not found) for the given key
         * starting at given root.
         */
        final TreeNode<K,V> findTreeNode(int h, Object k, Class<?> kc) {
            if (k != null) {
                TreeNode<K,V> p = this;
                do  {
                    int ph, dir; K pk; TreeNode<K,V> q;
                    TreeNode<K,V> pl = p.left, pr = p.right;
                    if ((ph = p.hash) > h)
                        p = pl;
                    else if (ph < h)
                        p = pr;
                    else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                        return p;
                    else if (pl == null && pr == null)
                        break;
                    else if ((kc != null ||
                              (kc = comparableClassFor(k)) != null) &&
                             (dir = compareComparables(kc, k, pk)) != 0)
                        p = (dir < 0) ? pl : pr;
                    else if (pl == null)
                        p = pr;
                    else if (pr == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        p = pl;
                    else
                        return q;
                } while (p != null);
            }
            return null;
        }


, Instance #
frags: 
(startLine=1414 endLine=1430 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                Node<V> node = new Node<V>(h, k, null, null);
                synchronized (node) {
                    if (casTabAt(tab, i, null, node)) {
                        len = 1;
                        try {
                            if ((val = mf.apply(k)) != null)
                                node.val = val;
                        } finally {
                            if (val == null)
                                setTabAt(tab, i, null);
                        }
                    }
                }
                if (len != 0)
                    break;
            }

(startLine=1518 endLine=1538 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (onlyIfPresent)
                    break;
                Node<V> node = new Node<V>(h, k, null, null);
                synchronized (node) {
                    if (casTabAt(tab, i, null, node)) {
                        try {
                            len = 1;
                            if ((val = mf.apply(k, null)) != null) {
                                node.val = val;
                                delta = 1;
                            }
                        } finally {
                            if (delta == 0)
                                setTabAt(tab, i, null);
                        }
                    }
                }
                if (len != 0)
                    break;
            }

commonMethod: 
(startLine=2708 endLine=2762 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Finds or adds a node.
         * @return null if added
         */
        final TreeNode<K,V> putTreeVal(int h, K k, V v) {
            Class<?> kc = null;
            for (TreeNode<K,V> p = root;;) {
                int dir, ph; K pk; TreeNode<K,V> q, pr;
                if (p == null) {
                    first = root = new TreeNode<K,V>(h, k, v, null, null);
                    break;
                }
                else if ((ph = p.hash) > h)
                    dir = -1;
                else if (ph < h)
                    dir = 1;
                else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                    return p;
                else if ((kc == null &&
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0) {
                    if (p.left == null)
                        dir = 1;
                    else if ((pr = p.right) == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        dir = -1;
                    else
                        return q;
                }
                TreeNode<K,V> xp = p;
                if ((p = (dir < 0) ? p.left : p.right) == null) {
                    TreeNode<K,V> x, f = first;
                    first = x = new TreeNode<K,V>(h, k, v, f, xp);
                    if (f != null)
                        f.prev = x;
                    if (dir < 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    if (!xp.red)
                        x.red = true;
                    else {
                        lockRoot();
                        try {
                            root = balanceInsertion(root, x);
                        } finally {
                            unlockRoot();
                        }
                    }
                    break;
                }
            }
            assert checkInvariants(root);
            return null;
        }


, Instance #
frags: 
(startLine=932 endLine=953 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                    if (xp == xppl) {
                        TreeNode<V> y = xpp.right;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.right) {
                                rotateLeft(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateRight(xpp);
                                }
                            }
                        }
                    }

(startLine=954 endLine=975 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                    else {
                        TreeNode<V> y = xppl;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.left) {
                                rotateRight(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateLeft(xpp);
                                }
                            }
                        }
                    }

commonMethod: 
(startLine=2764 endLine=2868 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Removes the given node, that must be present before this
         * call.  This is messier than typical red-black deletion code
         * because we cannot swap the contents of an interior node
         * with a leaf successor that is pinned by "next" pointers
         * that are accessible independently of lock. So instead we
         * swap the tree linkages.
         *
         * @return true if now too small, so should be untreeified
         */
        final boolean removeTreeNode(TreeNode<K,V> p) {
            TreeNode<K,V> next = (TreeNode<K,V>)p.next;
            TreeNode<K,V> pred = p.prev;  // unlink traversal pointers
            TreeNode<K,V> r, rl;
            if (pred == null)
                first = next;
            else
                pred.next = next;
            if (next != null)
                next.prev = pred;
            if (first == null) {
                root = null;
                return true;
            }
            if ((r = root) == null || r.right == null || // too small
                (rl = r.left) == null || rl.left == null)
                return true;
            lockRoot();
            try {
                TreeNode<K,V> replacement;
                TreeNode<K,V> pl = p.left;
                TreeNode<K,V> pr = p.right;
                if (pl != null && pr != null) {
                    TreeNode<K,V> s = pr, sl;
                    while ((sl = s.left) != null) // find successor
                        s = sl;
                    boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                    TreeNode<K,V> sr = s.right;
                    TreeNode<K,V> pp = p.parent;
                    if (s == pr) { // p was s's direct parent
                        p.parent = s;
                        s.right = p;
                    }
                    else {
                        TreeNode<K,V> sp = s.parent;
                        if ((p.parent = sp) != null) {
                            if (s == sp.left)
                                sp.left = p;
                            else
                                sp.right = p;
                        }
                        if ((s.right = pr) != null)
                            pr.parent = s;
                    }
                    p.left = null;
                    if ((p.right = sr) != null)
                        sr.parent = p;
                    if ((s.left = pl) != null)
                        pl.parent = s;
                    if ((s.parent = pp) == null)
                        r = s;
                    else if (p == pp.left)
                        pp.left = s;
                    else
                        pp.right = s;
                    if (sr != null)
                        replacement = sr;
                    else
                        replacement = p;
                }
                else if (pl != null)
                    replacement = pl;
                else if (pr != null)
                    replacement = pr;
                else
                    replacement = p;
                if (replacement != p) {
                    TreeNode<K,V> pp = replacement.parent = p.parent;
                    if (pp == null)
                        r = replacement;
                    else if (p == pp.left)
                        pp.left = replacement;
                    else
                        pp.right = replacement;
                    p.left = p.right = p.parent = null;
                }

                root = (p.red) ? r : balanceDeletion(r, replacement);

                if (p == replacement) {  // detach pointers
                    TreeNode<K,V> pp;
                    if ((pp = p.parent) != null) {
                        if (p == pp.left)
                            pp.left = null;
                        else if (p == pp.right)
                            pp.right = null;
                        p.parent = null;
                    }
                }
            } finally {
                unlockRoot();
            }
            assert checkInvariants(root);
            return false;
        }


, Instance #
frags: 
(startLine=932 endLine=953 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                    if (xp == xppl) {
                        TreeNode<V> y = xpp.right;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.right) {
                                rotateLeft(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateRight(xpp);
                                }
                            }
                        }
                    }

(startLine=954 endLine=975 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                    else {
                        TreeNode<V> y = xppl;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.left) {
                                rotateRight(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateLeft(xpp);
                                }
                            }
                        }
                    }

commonMethod: 
(startLine=2533 endLine=2565 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Returns the TreeNode (or null if not found) for the given key
         * starting at given root.
         */
        final TreeNode<K,V> findTreeNode(int h, Object k, Class<?> kc) {
            if (k != null) {
                TreeNode<K,V> p = this;
                do  {
                    int ph, dir; K pk; TreeNode<K,V> q;
                    TreeNode<K,V> pl = p.left, pr = p.right;
                    if ((ph = p.hash) > h)
                        p = pl;
                    else if (ph < h)
                        p = pr;
                    else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                        return p;
                    else if (pl == null && pr == null)
                        break;
                    else if ((kc != null ||
                              (kc = comparableClassFor(k)) != null) &&
                             (dir = compareComparables(kc, k, pk)) != 0)
                        p = (dir < 0) ? pl : pr;
                    else if (pl == null)
                        p = pr;
                    else if (pr == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        p = pl;
                    else
                        return q;
                } while (p != null);
            }
            return null;
        }


, Instance #
frags: 
(startLine=940 endLine=952 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                        else {
                            if (x == xp.right) {
                                rotateLeft(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateRight(xpp);
                                }
                            }
                        }

(startLine=962 endLine=974 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                        else {
                            if (x == xp.left) {
                                rotateRight(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateLeft(xpp);
                                }
                            }
                        }

commonMethod: 
(startLine=2533 endLine=2565 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Returns the TreeNode (or null if not found) for the given key
         * starting at given root.
         */
        final TreeNode<K,V> findTreeNode(int h, Object k, Class<?> kc) {
            if (k != null) {
                TreeNode<K,V> p = this;
                do  {
                    int ph, dir; K pk; TreeNode<K,V> q;
                    TreeNode<K,V> pl = p.left, pr = p.right;
                    if ((ph = p.hash) > h)
                        p = pl;
                    else if (ph < h)
                        p = pr;
                    else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                        return p;
                    else if (pl == null && pr == null)
                        break;
                    else if ((kc != null ||
                              (kc = comparableClassFor(k)) != null) &&
                             (dir = compareComparables(kc, k, pk)) != 0)
                        p = (dir < 0) ? pl : pr;
                    else if (pl == null)
                        p = pr;
                    else if (pr == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        p = pl;
                    else
                        return q;
                } while (p != null);
            }
            return null;
        }


, Instance #
frags: 
(startLine=1431 endLine=1459 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else if (f.hash < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    boolean added = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            if (p != null)
                                val = p.val;
                            else if ((val = mf.apply(k)) != null) {
                                added = true;
                                len = 2;
                                t.putTreeNode(h, k, val);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0) {
                        if (!added)
                            return val;
                        break;
                    }
                }
                else
                    tab = (Node<V>[])fk;
            }

(startLine=1539 endLine=1572 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else if ((fh = f.hash) < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            if (p == null && onlyIfPresent)
                                break;
                            V pv = (p == null) ? null : p.val;
                            if ((val = mf.apply(k, pv)) != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    len = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0)
                        break;
                }
                else
                    tab = (Node<V>[])fk;
            }

(startLine=1638 endLine=1669 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else if (f.hash < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            val = (p == null) ? v : mf.apply(p.val, v);
                            if (val != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    len = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0)
                        break;
                }
                else
                    tab = (Node<V>[])fk;
            }

commonMethod: 
(startLine=2533 endLine=2565 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Returns the TreeNode (or null if not found) for the given key
         * starting at given root.
         */
        final TreeNode<K,V> findTreeNode(int h, Object k, Class<?> kc) {
            if (k != null) {
                TreeNode<K,V> p = this;
                do  {
                    int ph, dir; K pk; TreeNode<K,V> q;
                    TreeNode<K,V> pl = p.left, pr = p.right;
                    if ((ph = p.hash) > h)
                        p = pl;
                    else if (ph < h)
                        p = pr;
                    else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                        return p;
                    else if (pl == null && pr == null)
                        break;
                    else if ((kc != null ||
                              (kc = comparableClassFor(k)) != null) &&
                             (dir = compareComparables(kc, k, pk)) != 0)
                        p = (dir < 0) ? pl : pr;
                    else if (pl == null)
                        p = pr;
                    else if (pr == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        p = pl;
                    else
                        return q;
                } while (p != null);
            }
            return null;
        }


, Instance #
frags: 
(startLine=1431 endLine=1459 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else if (f.hash < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    boolean added = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            if (p != null)
                                val = p.val;
                            else if ((val = mf.apply(k)) != null) {
                                added = true;
                                len = 2;
                                t.putTreeNode(h, k, val);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0) {
                        if (!added)
                            return val;
                        break;
                    }
                }
                else
                    tab = (Node<V>[])fk;
            }

(startLine=1539 endLine=1572 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else if ((fh = f.hash) < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            if (p == null && onlyIfPresent)
                                break;
                            V pv = (p == null) ? null : p.val;
                            if ((val = mf.apply(k, pv)) != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    len = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0)
                        break;
                }
                else
                    tab = (Node<V>[])fk;
            }

(startLine=1638 endLine=1669 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else if (f.hash < 0) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin<V> t = (TreeBin<V>)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            len = 1;
                            TreeNode<V> p = t.getTreeNode(h, k, t.root);
                            val = (p == null) ? v : mf.apply(p.val, v);
                            if (val != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    len = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (len != 0)
                        break;
                }
                else
                    tab = (Node<V>[])fk;
            }

commonMethod: 
(startLine=2708 endLine=2762 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Finds or adds a node.
         * @return null if added
         */
        final TreeNode<K,V> putTreeVal(int h, K k, V v) {
            Class<?> kc = null;
            for (TreeNode<K,V> p = root;;) {
                int dir, ph; K pk; TreeNode<K,V> q, pr;
                if (p == null) {
                    first = root = new TreeNode<K,V>(h, k, v, null, null);
                    break;
                }
                else if ((ph = p.hash) > h)
                    dir = -1;
                else if (ph < h)
                    dir = 1;
                else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                    return p;
                else if ((kc == null &&
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0) {
                    if (p.left == null)
                        dir = 1;
                    else if ((pr = p.right) == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        dir = -1;
                    else
                        return q;
                }
                TreeNode<K,V> xp = p;
                if ((p = (dir < 0) ? p.left : p.right) == null) {
                    TreeNode<K,V> x, f = first;
                    first = x = new TreeNode<K,V>(h, k, v, f, xp);
                    if (f != null)
                        f.prev = x;
                    if (dir < 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    if (!xp.red)
                        x.red = true;
                    else {
                        lockRoot();
                        try {
                            root = balanceInsertion(root, x);
                        } finally {
                            unlockRoot();
                        }
                    }
                    break;
                }
            }
            assert checkInvariants(root);
            return null;
        }


, Instance #
frags: 
(startLine=1573 endLine=1611 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f, pred = null;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(k, ev);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                if (!onlyIfPresent &&
                                    (val = mf.apply(k, null)) != null) {
                                    pred.next = new Node<V>(h, k, val, null);
                                    delta = 1;
                                    if (len >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                }
                if (len != 0)
                    break;
            }

(startLine=1670 endLine=1706 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f, pred = null;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(ev, v);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                val = v;
                                pred.next = new Node<V>(h, k, val, null);
                                delta = 1;
                                if (len >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                }
                if (len != 0)
                    break;
            }

commonMethod: 
(startLine=2533 endLine=2565 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Returns the TreeNode (or null if not found) for the given key
         * starting at given root.
         */
        final TreeNode<K,V> findTreeNode(int h, Object k, Class<?> kc) {
            if (k != null) {
                TreeNode<K,V> p = this;
                do  {
                    int ph, dir; K pk; TreeNode<K,V> q;
                    TreeNode<K,V> pl = p.left, pr = p.right;
                    if ((ph = p.hash) > h)
                        p = pl;
                    else if (ph < h)
                        p = pr;
                    else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                        return p;
                    else if (pl == null && pr == null)
                        break;
                    else if ((kc != null ||
                              (kc = comparableClassFor(k)) != null) &&
                             (dir = compareComparables(kc, k, pk)) != 0)
                        p = (dir < 0) ? pl : pr;
                    else if (pl == null)
                        p = pr;
                    else if (pr == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        p = pl;
                    else
                        return q;
                } while (p != null);
            }
            return null;
        }


, Instance #
frags: 
(startLine=1573 endLine=1611 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f, pred = null;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(k, ev);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                if (!onlyIfPresent &&
                                    (val = mf.apply(k, null)) != null) {
                                    pred.next = new Node<V>(h, k, val, null);
                                    delta = 1;
                                    if (len >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                }
                if (len != 0)
                    break;
            }

(startLine=1670 endLine=1706 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
            else {
                synchronized (f) {
                    if (tabAt(tab, i) == f) {
                        len = 1;
                        for (Node<V> e = f, pred = null;; ++len) {
                            Object ek; V ev;
                            if (e.hash == h &&
                                (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(ev, v);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                val = v;
                                pred.next = new Node<V>(h, k, val, null);
                                delta = 1;
                                if (len >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                }
                if (len != 0)
                    break;
            }

commonMethod: 
(startLine=2708 endLine=2762 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Finds or adds a node.
         * @return null if added
         */
        final TreeNode<K,V> putTreeVal(int h, K k, V v) {
            Class<?> kc = null;
            for (TreeNode<K,V> p = root;;) {
                int dir, ph; K pk; TreeNode<K,V> q, pr;
                if (p == null) {
                    first = root = new TreeNode<K,V>(h, k, v, null, null);
                    break;
                }
                else if ((ph = p.hash) > h)
                    dir = -1;
                else if (ph < h)
                    dir = 1;
                else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                    return p;
                else if ((kc == null &&
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0) {
                    if (p.left == null)
                        dir = 1;
                    else if ((pr = p.right) == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        dir = -1;
                    else
                        return q;
                }
                TreeNode<K,V> xp = p;
                if ((p = (dir < 0) ? p.left : p.right) == null) {
                    TreeNode<K,V> x, f = first;
                    first = x = new TreeNode<K,V>(h, k, v, f, xp);
                    if (f != null)
                        f.prev = x;
                    if (dir < 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    if (!xp.red)
                        x.red = true;
                    else {
                        lockRoot();
                        try {
                            root = balanceInsertion(root, x);
                        } finally {
                            unlockRoot();
                        }
                    }
                    break;
                }
            }
            assert checkInvariants(root);
            return null;
        }


, Instance #
frags: 
(startLine=1581 endLine=1594 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(k, ev);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }

(startLine=1678 endLine=1691 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(ev, v);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }

commonMethod: 
(startLine=2533 endLine=2565 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Returns the TreeNode (or null if not found) for the given key
         * starting at given root.
         */
        final TreeNode<K,V> findTreeNode(int h, Object k, Class<?> kc) {
            if (k != null) {
                TreeNode<K,V> p = this;
                do  {
                    int ph, dir; K pk; TreeNode<K,V> q;
                    TreeNode<K,V> pl = p.left, pr = p.right;
                    if ((ph = p.hash) > h)
                        p = pl;
                    else if (ph < h)
                        p = pr;
                    else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                        return p;
                    else if (pl == null && pr == null)
                        break;
                    else if ((kc != null ||
                              (kc = comparableClassFor(k)) != null) &&
                             (dir = compareComparables(kc, k, pk)) != 0)
                        p = (dir < 0) ? pl : pr;
                    else if (pl == null)
                        p = pr;
                    else if (pr == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        p = pl;
                    else
                        return q;
                } while (p != null);
            }
            return null;
        }


, Instance #
frags: 
(startLine=1581 endLine=1594 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(k, ev);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }

(startLine=1678 endLine=1691 srcPath=/root/NewExperiment/elasticsearchFilter/00855/src/main/java/jsr166e/ConcurrentHashMapV8.java)
                                ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(ev, v);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node<V> en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }

commonMethod: 
(startLine=2708 endLine=2762 srcPath=/root/NewExperiment/elasticsearchFilter/00856/src/main/java/jsr166e/ConcurrentHashMapV8.java)
        /**
         * Finds or adds a node.
         * @return null if added
         */
        final TreeNode<K,V> putTreeVal(int h, K k, V v) {
            Class<?> kc = null;
            for (TreeNode<K,V> p = root;;) {
                int dir, ph; K pk; TreeNode<K,V> q, pr;
                if (p == null) {
                    first = root = new TreeNode<K,V>(h, k, v, null, null);
                    break;
                }
                else if ((ph = p.hash) > h)
                    dir = -1;
                else if (ph < h)
                    dir = 1;
                else if ((pk = p.key) == k || (pk != null && k.equals(pk)))
                    return p;
                else if ((kc == null &&
                          (kc = comparableClassFor(k)) == null) ||
                         (dir = compareComparables(kc, k, pk)) == 0) {
                    if (p.left == null)
                        dir = 1;
                    else if ((pr = p.right) == null ||
                             (q = pr.findTreeNode(h, k, kc)) == null)
                        dir = -1;
                    else
                        return q;
                }
                TreeNode<K,V> xp = p;
                if ((p = (dir < 0) ? p.left : p.right) == null) {
                    TreeNode<K,V> x, f = first;
                    first = x = new TreeNode<K,V>(h, k, v, f, xp);
                    if (f != null)
                        f.prev = x;
                    if (dir < 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    if (!xp.red)
                        x.red = true;
                    else {
                        lockRoot();
                        try {
                            root = balanceInsertion(root, x);
                        } finally {
                            unlockRoot();
                        }
                    }
                    break;
                }
            }
            assert checkInvariants(root);
            return null;
        }


, Instance #
frags: 
(startLine=223 endLine=230 srcPath=/root/NewExperiment/elasticsearchFilter/00864/src/main/java/org/elasticsearch/index/percolator/PercolatorService.java)
                    for (IndexService indexService : indicesService) {
                        // only load queries for "this" index percolator service
                        if (indexService.index().equals(index())) {
                            logger.debug("loading percolator queries for index [{}]...", indexService.index().name());
                            loadQueries(indexService.index().name());
                            logger.trace("done loading percolator queries for index [{}]", indexService.index().name());
                        }
                    }

(startLine=250 endLine=259 srcPath=/root/NewExperiment/elasticsearchFilter/00864/src/main/java/org/elasticsearch/index/percolator/PercolatorService.java)
            synchronized (mutex) {
                if (initialQueriesFetchDone) {
                    return;
                }
                // we load queries for this index
                logger.debug("loading percolator queries for index [{}]...", indexService.index().name());
                loadQueries(index.name());
                logger.trace("done loading percolator queries for index [{}]", indexService.index().name());
                initialQueriesFetchDone = true;
            }

commonMethod: 
(startLine=253 endLine=259 srcPath=/root/NewExperiment/elasticsearchFilter/00865/src/main/java/org/elasticsearch/index/query/IndexQueryParserService.java)
    public ParsedQuery parse(XContentParser parser) {
        try {
            return parse(cache.get(), parser);
        } catch (IOException e) {
            throw new QueryParsingException(index, "Failed to parse", e);
        }
    }


, Instance #
frags: 
(startLine=223 endLine=230 srcPath=/root/NewExperiment/elasticsearchFilter/00864/src/main/java/org/elasticsearch/index/percolator/PercolatorService.java)
                    for (IndexService indexService : indicesService) {
                        // only load queries for "this" index percolator service
                        if (indexService.index().equals(index())) {
                            logger.debug("loading percolator queries for index [{}]...", indexService.index().name());
                            loadQueries(indexService.index().name());
                            logger.trace("done loading percolator queries for index [{}]", indexService.index().name());
                        }
                    }

(startLine=250 endLine=259 srcPath=/root/NewExperiment/elasticsearchFilter/00864/src/main/java/org/elasticsearch/index/percolator/PercolatorService.java)
            synchronized (mutex) {
                if (initialQueriesFetchDone) {
                    return;
                }
                // we load queries for this index
                logger.debug("loading percolator queries for index [{}]...", indexService.index().name());
                loadQueries(index.name());
                logger.trace("done loading percolator queries for index [{}]", indexService.index().name());
                initialQueriesFetchDone = true;
            }

commonMethod: 
(startLine=261 endLine=266 srcPath=/root/NewExperiment/elasticsearchFilter/00865/src/main/java/org/elasticsearch/index/query/IndexQueryParserService.java)
    @Nullable
    public Filter parseInnerFilter(XContentParser parser) throws IOException {
        QueryParseContext context = cache.get();
        context.reset(parser);
        return context.parseInnerFilter();
    }


, Instance #
frags: 
(startLine=213 endLine=238 srcPath=/root/NewExperiment/elasticsearchFilter/00900/src/main/java/org/elasticsearch/action/admin/indices/status/IndicesStatusResponse.java)
                    if (shardStatus.getPeerRecoveryStatus() != null) {
                        PeerRecoveryStatus peerRecoveryStatus = shardStatus.getPeerRecoveryStatus();
                        builder.startObject(Fields.PEER_RECOVERY);
                        builder.field(Fields.STAGE, peerRecoveryStatus.getStage());
                        builder.field(Fields.START_TIME_IN_MILLIS, peerRecoveryStatus.getStartTime());
                        builder.field(Fields.TIME, peerRecoveryStatus.getTime());
                        builder.field(Fields.TIME_IN_MILLIS, peerRecoveryStatus.getTime().millis());

                        builder.startObject(Fields.INDEX);
                        builder.field(Fields.PROGRESS, peerRecoveryStatus.getIndexRecoveryProgress());
                        builder.field(Fields.SIZE, peerRecoveryStatus.getIndexSize());
                        builder.field(Fields.SIZE_IN_BYTES, peerRecoveryStatus.getIndexSize().bytes());
                        builder.field(Fields.REUSED_SIZE, peerRecoveryStatus.getReusedIndexSize());
                        builder.field(Fields.REUSED_SIZE_IN_BYTES, peerRecoveryStatus.getReusedIndexSize().bytes());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE, peerRecoveryStatus.getExpectedRecoveredIndexSize());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE_IN_BYTES, peerRecoveryStatus.getExpectedRecoveredIndexSize().bytes());
                        builder.field(Fields.RECOVERED_SIZE, peerRecoveryStatus.getRecoveredIndexSize());
                        builder.field(Fields.RECOVERED_SIZE_IN_BYTES, peerRecoveryStatus.getRecoveredIndexSize().bytes());
                        builder.endObject();

                        builder.startObject(Fields.TRANSLOG);
                        builder.field(Fields.RECOVERED, peerRecoveryStatus.getRecoveredTranslogOperations());
                        builder.endObject();

                        builder.endObject();
                    }

(startLine=240 endLine=265 srcPath=/root/NewExperiment/elasticsearchFilter/00900/src/main/java/org/elasticsearch/action/admin/indices/status/IndicesStatusResponse.java)
                    if (shardStatus.getGatewayRecoveryStatus() != null) {
                        GatewayRecoveryStatus gatewayRecoveryStatus = shardStatus.getGatewayRecoveryStatus();
                        builder.startObject(Fields.GATEWAY_RECOVERY);
                        builder.field(Fields.STAGE, gatewayRecoveryStatus.getStage());
                        builder.field(Fields.START_TIME_IN_MILLIS, gatewayRecoveryStatus.getStartTime());
                        builder.field(Fields.TIME, gatewayRecoveryStatus.getTime());
                        builder.field(Fields.TIME_IN_MILLIS, gatewayRecoveryStatus.getTime().millis());

                        builder.startObject(Fields.INDEX);
                        builder.field(Fields.PROGRESS, gatewayRecoveryStatus.getIndexRecoveryProgress());
                        builder.field(Fields.SIZE, gatewayRecoveryStatus.getIndexSize());
                        builder.field(Fields.SIZE_IN_BYTES, gatewayRecoveryStatus.getIndexSize().bytes());
                        builder.field(Fields.REUSED_SIZE, gatewayRecoveryStatus.getReusedIndexSize());
                        builder.field(Fields.REUSED_SIZE_IN_BYTES, gatewayRecoveryStatus.getReusedIndexSize().bytes());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE, gatewayRecoveryStatus.getExpectedRecoveredIndexSize());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE_IN_BYTES, gatewayRecoveryStatus.getExpectedRecoveredIndexSize().bytes());
                        builder.field(Fields.RECOVERED_SIZE, gatewayRecoveryStatus.getRecoveredIndexSize());
                        builder.field(Fields.RECOVERED_SIZE_IN_BYTES, gatewayRecoveryStatus.getRecoveredIndexSize().bytes());
                        builder.endObject();

                        builder.startObject(Fields.TRANSLOG);
                        builder.field(Fields.RECOVERED, gatewayRecoveryStatus.getRecoveredTranslogOperations());
                        builder.endObject();

                        builder.endObject();
                    }

commonMethod: 
(startLine=839 endLine=845 srcPath=/root/NewExperiment/elasticsearchFilter/00901/src/main/java/org/elasticsearch/common/xcontent/XContentBuilder.java)
    public XContentBuilder timeValueField(XContentBuilderString rawFieldName, XContentBuilderString readableFieldName, TimeValue timeValue) throws IOException {
        if (readableFormat) {
            field(readableFieldName, timeValue.toString());
        }
        field(rawFieldName, timeValue.millis());
        return this;
    }


, Instance #
frags: 
(startLine=213 endLine=238 srcPath=/root/NewExperiment/elasticsearchFilter/00900/src/main/java/org/elasticsearch/action/admin/indices/status/IndicesStatusResponse.java)
                    if (shardStatus.getPeerRecoveryStatus() != null) {
                        PeerRecoveryStatus peerRecoveryStatus = shardStatus.getPeerRecoveryStatus();
                        builder.startObject(Fields.PEER_RECOVERY);
                        builder.field(Fields.STAGE, peerRecoveryStatus.getStage());
                        builder.field(Fields.START_TIME_IN_MILLIS, peerRecoveryStatus.getStartTime());
                        builder.field(Fields.TIME, peerRecoveryStatus.getTime());
                        builder.field(Fields.TIME_IN_MILLIS, peerRecoveryStatus.getTime().millis());

                        builder.startObject(Fields.INDEX);
                        builder.field(Fields.PROGRESS, peerRecoveryStatus.getIndexRecoveryProgress());
                        builder.field(Fields.SIZE, peerRecoveryStatus.getIndexSize());
                        builder.field(Fields.SIZE_IN_BYTES, peerRecoveryStatus.getIndexSize().bytes());
                        builder.field(Fields.REUSED_SIZE, peerRecoveryStatus.getReusedIndexSize());
                        builder.field(Fields.REUSED_SIZE_IN_BYTES, peerRecoveryStatus.getReusedIndexSize().bytes());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE, peerRecoveryStatus.getExpectedRecoveredIndexSize());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE_IN_BYTES, peerRecoveryStatus.getExpectedRecoveredIndexSize().bytes());
                        builder.field(Fields.RECOVERED_SIZE, peerRecoveryStatus.getRecoveredIndexSize());
                        builder.field(Fields.RECOVERED_SIZE_IN_BYTES, peerRecoveryStatus.getRecoveredIndexSize().bytes());
                        builder.endObject();

                        builder.startObject(Fields.TRANSLOG);
                        builder.field(Fields.RECOVERED, peerRecoveryStatus.getRecoveredTranslogOperations());
                        builder.endObject();

                        builder.endObject();
                    }

(startLine=240 endLine=265 srcPath=/root/NewExperiment/elasticsearchFilter/00900/src/main/java/org/elasticsearch/action/admin/indices/status/IndicesStatusResponse.java)
                    if (shardStatus.getGatewayRecoveryStatus() != null) {
                        GatewayRecoveryStatus gatewayRecoveryStatus = shardStatus.getGatewayRecoveryStatus();
                        builder.startObject(Fields.GATEWAY_RECOVERY);
                        builder.field(Fields.STAGE, gatewayRecoveryStatus.getStage());
                        builder.field(Fields.START_TIME_IN_MILLIS, gatewayRecoveryStatus.getStartTime());
                        builder.field(Fields.TIME, gatewayRecoveryStatus.getTime());
                        builder.field(Fields.TIME_IN_MILLIS, gatewayRecoveryStatus.getTime().millis());

                        builder.startObject(Fields.INDEX);
                        builder.field(Fields.PROGRESS, gatewayRecoveryStatus.getIndexRecoveryProgress());
                        builder.field(Fields.SIZE, gatewayRecoveryStatus.getIndexSize());
                        builder.field(Fields.SIZE_IN_BYTES, gatewayRecoveryStatus.getIndexSize().bytes());
                        builder.field(Fields.REUSED_SIZE, gatewayRecoveryStatus.getReusedIndexSize());
                        builder.field(Fields.REUSED_SIZE_IN_BYTES, gatewayRecoveryStatus.getReusedIndexSize().bytes());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE, gatewayRecoveryStatus.getExpectedRecoveredIndexSize());
                        builder.field(Fields.EXPECTED_RECOVERED_SIZE_IN_BYTES, gatewayRecoveryStatus.getExpectedRecoveredIndexSize().bytes());
                        builder.field(Fields.RECOVERED_SIZE, gatewayRecoveryStatus.getRecoveredIndexSize());
                        builder.field(Fields.RECOVERED_SIZE_IN_BYTES, gatewayRecoveryStatus.getRecoveredIndexSize().bytes());
                        builder.endObject();

                        builder.startObject(Fields.TRANSLOG);
                        builder.field(Fields.RECOVERED, gatewayRecoveryStatus.getRecoveredTranslogOperations());
                        builder.endObject();

                        builder.endObject();
                    }

commonMethod: 
(startLine=855 endLine=861 srcPath=/root/NewExperiment/elasticsearchFilter/00901/src/main/java/org/elasticsearch/common/xcontent/XContentBuilder.java)
    public XContentBuilder byteSizeField(XContentBuilderString rawFieldName, XContentBuilderString readableFieldName, ByteSizeValue byteSizeValue) throws IOException {
        if (readableFormat) {
            field(readableFieldName, byteSizeValue.toString());
        }
        field(rawFieldName, byteSizeValue.bytes());
        return this;
    }


, Instance #
frags: 
(startLine=87 endLine=121 srcPath=/root/NewExperiment/elasticsearchFilter/00904/src/main/java/org/elasticsearch/percolator/PercolatorService.java)
    public PercolateShardResponse matchPercolate(final PercolateShardRequest request) {
        return innerPercolate(request, new PercolateAction() {
            @Override
            public PercolateShardResponse doPercolateAction(PercolateContext context) {
                List<Text> matches = new ArrayList<Text>();
                if (context.query == null) {
                    Lucene.ExistsCollector collector = new Lucene.ExistsCollector();
                    for (Map.Entry<Text, Query> entry : context.percolateQueries.entrySet()) {
                        collector.reset();
                        try {
                            context.searcher.search(entry.getValue(), collector);
                        } catch (IOException e) {
                            logger.warn("[" + entry.getKey() + "] failed to execute query", e);
                        }

                        if (collector.exists()) {
                            matches.add(entry.getKey());
                        }
                    }
                } else {
                    Engine.Searcher percolatorSearcher = context.indexShard.searcher();
                    try {
                        percolatorSearcher.searcher().search(
                                context.query, match(logger, context.percolateQueries, context.searcher, context.fieldDataService, matches)
                        );
                    } catch (IOException e) {
                        logger.warn("failed to execute", e);
                    } finally {
                        percolatorSearcher.release();
                    }
                }
                return new PercolateShardResponse(matches.toArray(new Text[matches.size()]), request.index(), request.shardId());
            }
        });
    }

(startLine=123 endLine=157 srcPath=/root/NewExperiment/elasticsearchFilter/00904/src/main/java/org/elasticsearch/percolator/PercolatorService.java)
    public PercolateShardResponse countPercolate(final PercolateShardRequest request) {
        return innerPercolate(request, new PercolateAction() {
            @Override
            public PercolateShardResponse doPercolateAction(PercolateContext context) {
                long count = 0;
                if (context.query == null) {
                    Lucene.ExistsCollector collector = new Lucene.ExistsCollector();
                    for (Map.Entry<Text, Query> entry : context.percolateQueries.entrySet()) {
                        collector.reset();
                        try {
                            context.searcher.search(entry.getValue(), collector);
                        } catch (IOException e) {
                            logger.warn("[" + entry.getKey() + "] failed to execute query", e);
                        }

                        if (collector.exists()) {
                            count++;
                        }
                    }
                } else {
                    Engine.Searcher percolatorSearcher = context.indexShard.searcher();
                    try {
                        Count countCollector = count(logger, context.percolateQueries, context.searcher, context.fieldDataService);
                        percolatorSearcher.searcher().search(context.query, countCollector);
                        count = countCollector.counter();
                    } catch (IOException e) {
                        logger.warn("failed to execute", e);
                    } finally {
                        percolatorSearcher.release();
                    }
                }
                return new PercolateShardResponse(count, request.index(), request.shardId());
            }
        });
    }

commonMethod: 
(startLine=166 endLine=233 srcPath=/root/NewExperiment/elasticsearchFilter/00905/src/main/java/org/elasticsearch/percolator/PercolatorService.java)
    private PercolateShardResponse preparePercolate(PercolateShardRequest request, PercolateAction action) {
        IndexService percolateIndexService = indicesService.indexServiceSafe(request.index());
        IndexShard indexShard = percolateIndexService.shardSafe(request.shardId());

        ShardPercolateService shardPercolateService = indexShard.shardPercolateService();
        shardPercolateService.prePercolate();
        long startTime = System.nanoTime();
        try {
            ConcurrentMap<Text, Query> percolateQueries = indexShard.percolateRegistry().percolateQueries();
            if (percolateQueries.isEmpty()) {
                return new PercolateShardResponse(request.index(), request.shardId());
            }

            final PercolateContext context = new PercolateContext();
            context.percolateQueries = percolateQueries;
            context.indexShard = indexShard;
            ParsedDocument parsedDocument = parsePercolate(percolateIndexService, request, context);
            if (request.docSource() != null && request.docSource().length() != 0) {
                parsedDocument = parseFetchedDoc(request.docSource(), percolateIndexService, request.documentType());
            } else if (parsedDocument == null) {
                throw new ElasticSearchParseException("No doc to percolate in the request");
            }

            if (context.size < 0) {
                context.size = 0;
            }

            // first, parse the source doc into a MemoryIndex
            final MemoryIndex memoryIndex = cache.get();
            try {
                // TODO: This means percolation does not support nested docs...
                // So look into: ByteBufferDirectory
                for (IndexableField field : parsedDocument.rootDoc().getFields()) {
                    if (!field.fieldType().indexed()) {
                        continue;
                    }
                    // no need to index the UID field
                    if (field.name().equals(UidFieldMapper.NAME)) {
                        continue;
                    }
                    TokenStream tokenStream;
                    try {
                        tokenStream = field.tokenStream(parsedDocument.analyzer());
                        if (tokenStream != null) {
                            memoryIndex.addField(field.name(), tokenStream, field.boost());
                        }
                    } catch (IOException e) {
                        throw new ElasticSearchException("Failed to create token stream", e);
                    }
                }

                context.docSearcher = memoryIndex.createSearcher();
                context.fieldDataService = percolateIndexService.fieldData();
                IndexCache indexCache = percolateIndexService.cache();
                try {
                    return action.doPercolateAction(context);
                } finally {
                    // explicitly clear the reader, since we can only register on callback on SegmentReader
                    indexCache.clear(context.docSearcher.getIndexReader());
                    context.fieldDataService.clear(context.docSearcher.getIndexReader());
                }
            } finally {
                memoryIndex.reset();
            }
        } finally {
            shardPercolateService.postPercolate(System.nanoTime() - startTime);
        }
    }


, Instance #
frags: 
(startLine=64 endLine=222 srcPath=/root/NewExperiment/elasticsearchFilter/00905/src/test/java/org/elasticsearch/test/integration/indexlifecycle/IndexLifecycleActionTests.java)
    public void testIndexLifecycleActionsWith11Shards1Backup() throws Exception {
        Settings settings = settingsBuilder()
                .put(SETTING_NUMBER_OF_SHARDS, 11)
                .put(SETTING_NUMBER_OF_REPLICAS, 1)
                .put("cluster.routing.schedule", "20ms") // reroute every 20ms so we identify new nodes fast
                .build();

        // start one server
        logger.info("Starting sever1");
        startNode("server1", settings);

        ClusterService clusterService1 = ((InternalNode) node("server1")).injector().getInstance(ClusterService.class);
        String node1 = clusterService1.state().nodes().localNodeId();

        wipeIndices(client());

        logger.info("Creating index [test]");
        CreateIndexResponse createIndexResponse = client("server1").admin().indices().create(createIndexRequest("test")).actionGet();
        assertThat(createIndexResponse.isAcknowledged(), equalTo(true));

        logger.info("Running Cluster Health");
        ClusterHealthResponse clusterHealth = client("server1").admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.YELLOW));

        ClusterState clusterState = client().admin().cluster().prepareState().get().getState();
        RoutingNode routingNodeEntry1 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node1);
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), equalTo(11));

        logger.info("Starting server2");
        // start another server
        startNode("server2", settings);

        // first wait for 2 nodes in the cluster
        logger.info("Running Cluster Health");
        clusterHealth = client("server1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        ClusterService clusterService2 = ((InternalNode) node("server2")).injector().getInstance(ClusterService.class);
        String node2 = clusterService2.state().nodes().localNodeId();

        // explicitly call reroute, so shards will get relocated to the new node (we delay it in ES in case other nodes join)
        client("server1").admin().cluster().prepareReroute().execute().actionGet();

        clusterHealth = client("server1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2").waitForRelocatingShards(0)).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getNumberOfDataNodes(), equalTo(2));
        assertThat(clusterHealth.getInitializingShards(), equalTo(0));
        assertThat(clusterHealth.getUnassignedShards(), equalTo(0));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(22));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));


        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes().nodesToShards(), node1, node2);
        routingNodeEntry1 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node1);
        assertThat(routingNodeEntry1.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), equalTo(11));
        RoutingNode routingNodeEntry2 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node2);
        assertThat(routingNodeEntry2.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), equalTo(11));

        logger.info("Starting server3");
        // start another server
        startNode("server3", settings);

        // first wait for 3 nodes in the cluster
        clusterHealth = client("server1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3")).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));


        ClusterService clusterService3 = ((InternalNode) node("server3")).injector().getInstance(ClusterService.class);
        String node3 = clusterService3.state().nodes().localNodeId();

        // explicitly call reroute, so shards will get relocated to the new node (we delay it in ES in case other nodes join)
        client("server1").admin().cluster().prepareReroute().execute().actionGet();

        clusterHealth = client("server1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3").waitForRelocatingShards(0)).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getNumberOfDataNodes(), equalTo(3));
        assertThat(clusterHealth.getInitializingShards(), equalTo(0));
        assertThat(clusterHealth.getUnassignedShards(), equalTo(0));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(22));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));


        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes().nodesToShards(), node1, node2, node3);

        routingNodeEntry1 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node1);
        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node2);
        RoutingNode routingNodeEntry3 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node3);

        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED) + routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(22));

        assertThat(routingNodeEntry1.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), anyOf(equalTo(7), equalTo(8)));

        assertThat(routingNodeEntry2.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), anyOf(equalTo(7), equalTo(8)));

        assertThat(routingNodeEntry3.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(7));


        logger.info("Closing server1");
        // kill the first server
        closeNode("server1");
        // verify health
        logger.info("Running Cluster Health");
        clusterHealth = client("server2").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        client().admin().cluster().prepareReroute().get();

        clusterHealth = client("server2").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForRelocatingShards(0).waitForNodes("2")).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(22));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));

        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes().nodesToShards(), node3, node2);
        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node2);
        routingNodeEntry3 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node3);

        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(22));

        assertThat(routingNodeEntry2.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), equalTo(11));

        assertThat(routingNodeEntry3.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(11));


        logger.info("Deleting index [test]");
        // last, lets delete the index
        DeleteIndexResponse deleteIndexResponse = client("server2").admin().indices().prepareDelete("test").execute().actionGet();
        assertThat(deleteIndexResponse.isAcknowledged(), equalTo(true));

        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes().nodesToShards(), node3, node2);
        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node2);
        assertThat(routingNodeEntry2.shards().isEmpty(), equalTo(true));

        routingNodeEntry3 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node3);
        assertThat(routingNodeEntry3.shards().isEmpty(), equalTo(true));
    }

(startLine=226 endLine=390 srcPath=/root/NewExperiment/elasticsearchFilter/00905/src/test/java/org/elasticsearch/test/integration/indexlifecycle/IndexLifecycleActionTests.java)
    public void testIndexLifecycleActionsWith11Shards0Backup() throws Exception {

        Settings settings = settingsBuilder()
                .put(SETTING_NUMBER_OF_SHARDS, 11)
                .put(SETTING_NUMBER_OF_REPLICAS, 0)
                .put("cluster.routing.schedule", "20ms") // reroute every 20ms so we identify new nodes fast
                .build();

        // start one server
        logger.info("Starting server1");
        startNode("server1", settings);

        ClusterService clusterService1 = ((InternalNode) node("server1")).injector().getInstance(ClusterService.class);
        String node1 = clusterService1.state().nodes().localNodeId();

        wipeIndices(client());

        logger.info("Creating index [test]");
        CreateIndexResponse createIndexResponse = client("server1").admin().indices().create(createIndexRequest("test")).actionGet();
        assertThat(createIndexResponse.isAcknowledged(), equalTo(true));

        logger.info("Running Cluster Health");
        ClusterHealthResponse clusterHealth = client("server1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus()).actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(11));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));

        ClusterState clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes().nodesToShards(), node1);
        RoutingNode routingNodeEntry1 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node1);
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), equalTo(11));

        // start another server
        logger.info("Starting server2");
        startNode("server2", settings);

        // first wait for 2 nodes in the cluster
        clusterHealth = client("server1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        ClusterService clusterService2 = ((InternalNode) node("server2")).injector().getInstance(ClusterService.class);
        String node2 = clusterService2.state().nodes().localNodeId();

        // explicitly call reroute, so shards will get relocated to the new node (we delay it in ES in case other nodes join)
        client("server1").admin().cluster().prepareReroute().execute().actionGet();

        clusterHealth = client("server1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForRelocatingShards(0).waitForNodes("2")).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getNumberOfDataNodes(), equalTo(2));
        assertThat(clusterHealth.getInitializingShards(), equalTo(0));
        assertThat(clusterHealth.getUnassignedShards(), equalTo(0));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(11));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));


        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes().nodesToShards(), node1, node2);
        routingNodeEntry1 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node1);
        assertThat(routingNodeEntry1.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), anyOf(equalTo(6), equalTo(5)));
        RoutingNode routingNodeEntry2 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node2);
        assertThat(routingNodeEntry2.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), anyOf(equalTo(5), equalTo(6)));

        // start another server
        logger.info("Starting server3");
        startNode("server3");

        // first wait for 3 nodes in the cluster
        clusterHealth = client("server1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3")).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        ClusterService clusterService3 = ((InternalNode) node("server3")).injector().getInstance(ClusterService.class);
        String node3 = clusterService3.state().nodes().localNodeId();

        // explicitly call reroute, so shards will get relocated to the new node (we delay it in ES in case other nodes join)
        client("server1").admin().cluster().prepareReroute().execute().actionGet();

        clusterHealth = client("server1").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3").waitForRelocatingShards(0)).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getNumberOfDataNodes(), equalTo(3));
        assertThat(clusterHealth.getInitializingShards(), equalTo(0));
        assertThat(clusterHealth.getUnassignedShards(), equalTo(0));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(11));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));


        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes().nodesToShards(), node1, node2, node3);
        routingNodeEntry1 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node1);
        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node2);
        RoutingNode routingNodeEntry3 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node3);

        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED) + routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(11));

        assertThat(routingNodeEntry1.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), anyOf(equalTo(5), equalTo(4), equalTo(3)));

        assertThat(routingNodeEntry2.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), anyOf(equalTo(5), equalTo(4), equalTo(3)));

        assertThat(routingNodeEntry3.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(3));


        logger.info("Closing server1");
        // kill the first server
        closeNode("server1");

        logger.info("Running Cluster Health");
        clusterHealth = client("server3").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        client().admin().cluster().prepareReroute().get();

        logger.info("Running Cluster Health");
        clusterHealth = client("server3").admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2").waitForRelocatingShards(0)).actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(11));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));

        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes().nodesToShards(), node3, node2);

        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node2);
        routingNodeEntry3 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node3);

        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(11));

        assertThat(routingNodeEntry2.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), anyOf(equalTo(5), equalTo(6)));

        assertThat(routingNodeEntry3.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry3.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry3.numberOfShardsWithState(STARTED), anyOf(equalTo(5), equalTo(6)));

        logger.info("Deleting index [test]");
        // last, lets delete the index
        DeleteIndexResponse deleteIndexResponse = client("server2").admin().indices().delete(deleteIndexRequest("test")).actionGet();
        assertThat(deleteIndexResponse.isAcknowledged(), equalTo(true));

        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes().nodesToShards(), node3, node2);

        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node2);
        assertThat(routingNodeEntry2.shards().isEmpty(), equalTo(true));

        routingNodeEntry3 = clusterState.readOnlyRoutingNodes().nodesToShards().get(node3);
        assertThat(routingNodeEntry3.shards().isEmpty(), equalTo(true));
    }

commonMethod: 
(startLine=223 endLine=229 srcPath=/root/NewExperiment/elasticsearchFilter/00906/src/test/java/org/elasticsearch/test/integration/indexlifecycle/IndexLifecycleActionTests.java)
    private String getLocalNodeId(String name) {
        assert node(name) != null : "no node for name: " + name;
        Discovery discovery = ((InternalNode) node(name)).injector().getInstance(Discovery.class);
        String nodeId = discovery.localNode().getId();
        assertThat(nodeId, not(nullValue()));
        return nodeId;
    }


, Instance #
frags: 
(startLine=91 endLine=115 srcPath=/root/NewExperiment/elasticsearchFilter/00914/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            BytesRef uid = values.getValue(doc);
            if (uid == null) {
                return;
            }
            Text id = new BytesText(Uid.idFromUid(uid));
            Query query = queries.get(id);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                searcher.search(query, collector);
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(id);
                    }
                    counter++;
                }
            } catch (IOException e) {
                logger.warn("[" + id + "] failed to execute query", e);
            }
        }

(startLine=138 endLine=159 srcPath=/root/NewExperiment/elasticsearchFilter/00914/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            BytesRef uid = values.getValue(doc);
            if (uid == null) {
                return;
            }
            Text id = new BytesText(Uid.idFromUid(uid));
            Query query = queries.get(id);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                searcher.search(query, collector);
                if (collector.exists()) {
                    topDocsCollector.collect(doc);
                }
            } catch (IOException e) {
                logger.warn("[" + id + "] failed to execute query", e);
            }
        }

(startLine=196 endLine=221 srcPath=/root/NewExperiment/elasticsearchFilter/00914/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            BytesRef uid = values.getValue(doc);
            if (uid == null) {
                return;
            }
            Text id = new BytesText(Uid.idFromUid(uid));
            Query query = queries.get(id);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                searcher.search(query, collector);
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(id);
                        scores.add(scorer.score());
                    }
                    counter++;
                }
            } catch (IOException e) {
                logger.warn("[" + id + "] failed to execute query", e);
            }
        }

(startLine=250 endLine=271 srcPath=/root/NewExperiment/elasticsearchFilter/00914/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            BytesRef uid = values.getValue(doc);
            if (uid == null) {
                return;
            }
            Text id = new BytesText(Uid.idFromUid(uid));
            Query query = queries.get(id);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                searcher.search(query, collector);
                if (collector.exists()) {
                    counter++;
                }
            } catch (IOException e) {
                logger.warn("[" + id + "] failed to execute query", e);
            }
        }

commonMethod: 
(startLine=78 endLine=84 srcPath=/root/NewExperiment/elasticsearchFilter/00915/src/main/java/org/elasticsearch/index/fielddata/BytesValues.java)
    /**
     * Fills the given spare for the given doc ID and returns the hashcode of the reference as defined by
     * {@link BytesRef#hashCode()}
     */
    public int getValueHashed(int docId, BytesRef spare) {
        return getValueScratch(docId, spare).hashCode();
    }


, Instance #
frags: 
(startLine=91 endLine=115 srcPath=/root/NewExperiment/elasticsearchFilter/00914/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            BytesRef uid = values.getValue(doc);
            if (uid == null) {
                return;
            }
            Text id = new BytesText(Uid.idFromUid(uid));
            Query query = queries.get(id);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                searcher.search(query, collector);
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(id);
                    }
                    counter++;
                }
            } catch (IOException e) {
                logger.warn("[" + id + "] failed to execute query", e);
            }
        }

(startLine=196 endLine=221 srcPath=/root/NewExperiment/elasticsearchFilter/00914/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            BytesRef uid = values.getValue(doc);
            if (uid == null) {
                return;
            }
            Text id = new BytesText(Uid.idFromUid(uid));
            Query query = queries.get(id);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                searcher.search(query, collector);
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(id);
                        scores.add(scorer.score());
                    }
                    counter++;
                }
            } catch (IOException e) {
                logger.warn("[" + id + "] failed to execute query", e);
            }
        }

commonMethod: 
(startLine=51 endLine=58 srcPath=/root/NewExperiment/elasticsearchFilter/00915/src/main/java/org/elasticsearch/index/fielddata/BytesValues.java)
    /**
     * Converts the provided bytes to "safe" ones from a "non" safe call made (if needed). Note,
     * this calls makes the bytes safe for *reads*, not writes (into the same BytesRef). For example,
     * it makes it safe to be placed in a map.
     */
    public BytesRef makeSafe(BytesRef bytes) {
        return BytesRef.deepCopyOf(bytes);
    }


, Instance #
frags: 
(startLine=162 endLine=215 srcPath=/root/NewExperiment/elasticsearchFilter/00917/src/main/java/org/elasticsearch/search/facet/datehistogram/InternalFullDateHistogramFacet.java)
    public Facet reduce(ReduceContext context) {
        List<Facet> facets = context.facets();
        if (facets.size() == 1) {
            // we need to sort it
            InternalFullDateHistogramFacet internalFacet = (InternalFullDateHistogramFacet) facets.get(0);
            List<FullEntry> entries = internalFacet.getEntries();
            CollectionUtil.timSort(entries, comparatorType.comparator());
            internalFacet.releaseCache();
            return internalFacet;
        }

        ExtTLongObjectHashMap<FullEntry> map = context.cacheRecycler().popLongObjectMap();

        for (Facet facet : facets) {
            InternalFullDateHistogramFacet histoFacet = (InternalFullDateHistogramFacet) facet;
            for (FullEntry fullEntry : histoFacet.entries) {
                FullEntry current = map.get(fullEntry.time);
                if (current != null) {
                    current.count += fullEntry.count;
                    current.total += fullEntry.total;
                    current.totalCount += fullEntry.totalCount;
                    if (fullEntry.min < current.min) {
                        current.min = fullEntry.min;
                    }
                    if (fullEntry.max > current.max) {
                        current.max = fullEntry.max;
                    }
                } else {
                    map.put(fullEntry.time, fullEntry);
                }
            }
            histoFacet.releaseCache();
        }

        // sort
        Object[] values = map.internalValues();
        Arrays.sort(values, (Comparator) comparatorType.comparator());
        List<FullEntry> ordered = new ArrayList<FullEntry>(map.size());
        for (int i = 0; i < map.size(); i++) {
            FullEntry value = (FullEntry) values[i];
            if (value == null) {
                break;
            }
            ordered.add(value);
        }

        context.cacheRecycler().pushLongObjectMap(map);

        // just initialize it as already ordered facet
        InternalFullDateHistogramFacet ret = new InternalFullDateHistogramFacet(getName());
        ret.comparatorType = comparatorType;
        ret.entries = ordered;
        return ret;
    }

(startLine=159 endLine=212 srcPath=/root/NewExperiment/elasticsearchFilter/00917/src/main/java/org/elasticsearch/search/facet/histogram/InternalFullHistogramFacet.java)
    public Facet reduce(ReduceContext context) {
        List<Facet> facets = context.facets();
        if (facets.size() == 1) {
            // we need to sort it
            InternalFullHistogramFacet internalFacet = (InternalFullHistogramFacet) facets.get(0);
            List<FullEntry> entries = internalFacet.getEntries();
            CollectionUtil.timSort(entries, comparatorType.comparator());
            internalFacet.releaseCache();
            return internalFacet;
        }

        ExtTLongObjectHashMap<FullEntry> map = context.cacheRecycler().popLongObjectMap();

        for (Facet facet : facets) {
            InternalFullHistogramFacet histoFacet = (InternalFullHistogramFacet) facet;
            for (FullEntry fullEntry : histoFacet.entries) {
                FullEntry current = map.get(fullEntry.key);
                if (current != null) {
                    current.count += fullEntry.count;
                    current.total += fullEntry.total;
                    current.totalCount += fullEntry.totalCount;
                    if (fullEntry.min < current.min) {
                        current.min = fullEntry.min;
                    }
                    if (fullEntry.max > current.max) {
                        current.max = fullEntry.max;
                    }
                } else {
                    map.put(fullEntry.key, fullEntry);
                }
            }
            histoFacet.releaseCache();
        }

        // sort
        Object[] values = map.internalValues();
        Arrays.sort(values, (Comparator) comparatorType.comparator());
        List<FullEntry> ordered = new ArrayList<FullEntry>(map.size());
        for (int i = 0; i < map.size(); i++) {
            FullEntry value = (FullEntry) values[i];
            if (value == null) {
                break;
            }
            ordered.add(value);
        }

        context.cacheRecycler().pushLongObjectMap(map);

        // just initialize it as already ordered facet
        InternalFullHistogramFacet ret = new InternalFullHistogramFacet(getName());
        ret.comparatorType = comparatorType;
        ret.entries = ordered;
        return ret;
    }

commonMethod: 
(startLine=220 endLine=222 srcPath=/root/NewExperiment/elasticsearchFilter/00918/src/main/java/org/elasticsearch/cache/recycler/CacheRecycler.java)
    public <T> Recycler.V<ExtTLongObjectHashMap<T>> longObjectMap(int sizing) {
        return (Recycler.V) longObjectMap.obtain(sizing);
    }


, Instance #
frags: 
(startLine=175 endLine=194 srcPath=/root/NewExperiment/elasticsearchFilter/00917/src/main/java/org/elasticsearch/search/facet/datehistogram/InternalFullDateHistogramFacet.java)
        for (Facet facet : facets) {
            InternalFullDateHistogramFacet histoFacet = (InternalFullDateHistogramFacet) facet;
            for (FullEntry fullEntry : histoFacet.entries) {
                FullEntry current = map.get(fullEntry.time);
                if (current != null) {
                    current.count += fullEntry.count;
                    current.total += fullEntry.total;
                    current.totalCount += fullEntry.totalCount;
                    if (fullEntry.min < current.min) {
                        current.min = fullEntry.min;
                    }
                    if (fullEntry.max > current.max) {
                        current.max = fullEntry.max;
                    }
                } else {
                    map.put(fullEntry.time, fullEntry);
                }
            }
            histoFacet.releaseCache();
        }

(startLine=172 endLine=191 srcPath=/root/NewExperiment/elasticsearchFilter/00917/src/main/java/org/elasticsearch/search/facet/histogram/InternalFullHistogramFacet.java)
        for (Facet facet : facets) {
            InternalFullHistogramFacet histoFacet = (InternalFullHistogramFacet) facet;
            for (FullEntry fullEntry : histoFacet.entries) {
                FullEntry current = map.get(fullEntry.key);
                if (current != null) {
                    current.count += fullEntry.count;
                    current.total += fullEntry.total;
                    current.totalCount += fullEntry.totalCount;
                    if (fullEntry.min < current.min) {
                        current.min = fullEntry.min;
                    }
                    if (fullEntry.max > current.max) {
                        current.max = fullEntry.max;
                    }
                } else {
                    map.put(fullEntry.key, fullEntry);
                }
            }
            histoFacet.releaseCache();
        }

commonMethod: 
(startLine=220 endLine=222 srcPath=/root/NewExperiment/elasticsearchFilter/00918/src/main/java/org/elasticsearch/cache/recycler/CacheRecycler.java)
    public <T> Recycler.V<ExtTLongObjectHashMap<T>> longObjectMap(int sizing) {
        return (Recycler.V) longObjectMap.obtain(sizing);
    }


, Instance #
frags: 
(startLine=153 endLine=166 srcPath=/root/NewExperiment/elasticsearchFilter/00917/src/main/java/org/elasticsearch/search/facet/datehistogram/InternalCountDateHistogramFacet.java)
        if (facets.size() == 1) {
            InternalCountDateHistogramFacet histoFacet = (InternalCountDateHistogramFacet) facets.get(0);
            if (histoFacet.entries == null) {
                histoFacet.entries = new CountEntry[histoFacet.counts.size()];
                int i = 0;
                for (TLongLongIterator it = histoFacet.counts.iterator(); it.hasNext(); ) {
                    it.advance();
                    histoFacet.entries[i++] = new CountEntry(it.key(), it.value());
                }
            }
            Arrays.sort(histoFacet.entries, histoFacet.comparatorType.comparator());
            histoFacet.releaseCache();
            return facets.get(0);
        }

(startLine=153 endLine=167 srcPath=/root/NewExperiment/elasticsearchFilter/00917/src/main/java/org/elasticsearch/search/facet/histogram/InternalCountHistogramFacet.java)
        if (facets.size() == 1) {
            // need to sort here...
            InternalCountHistogramFacet histoFacet = (InternalCountHistogramFacet) facets.get(0);
            if (histoFacet.entries == null) {
                histoFacet.entries = new CountEntry[histoFacet.counts.size()];
                int i = 0;
                for (TLongLongIterator it = histoFacet.counts.iterator(); it.hasNext(); ) {
                    it.advance();
                    histoFacet.entries[i++] = new CountEntry(it.key(), it.value());
                }
            }
            Arrays.sort(histoFacet.entries, histoFacet.comparatorType.comparator());
            histoFacet.releaseCache();
            return facets.get(0);
        }

commonMethod: 
(startLine=224 endLine=226 srcPath=/root/NewExperiment/elasticsearchFilter/00918/src/main/java/org/elasticsearch/cache/recycler/CacheRecycler.java)
    public Recycler.V<TLongLongHashMap> longLongMap(int sizing) {
        return longLongMap.obtain(sizing);
    }


, Instance #
frags: 
(startLine=155 endLine=162 srcPath=/root/NewExperiment/elasticsearchFilter/00917/src/main/java/org/elasticsearch/search/facet/datehistogram/InternalCountDateHistogramFacet.java)
            if (histoFacet.entries == null) {
                histoFacet.entries = new CountEntry[histoFacet.counts.size()];
                int i = 0;
                for (TLongLongIterator it = histoFacet.counts.iterator(); it.hasNext(); ) {
                    it.advance();
                    histoFacet.entries[i++] = new CountEntry(it.key(), it.value());
                }
            }

(startLine=156 endLine=163 srcPath=/root/NewExperiment/elasticsearchFilter/00917/src/main/java/org/elasticsearch/search/facet/histogram/InternalCountHistogramFacet.java)
            if (histoFacet.entries == null) {
                histoFacet.entries = new CountEntry[histoFacet.counts.size()];
                int i = 0;
                for (TLongLongIterator it = histoFacet.counts.iterator(); it.hasNext(); ) {
                    it.advance();
                    histoFacet.entries[i++] = new CountEntry(it.key(), it.value());
                }
            }

commonMethod: 
(startLine=224 endLine=226 srcPath=/root/NewExperiment/elasticsearchFilter/00918/src/main/java/org/elasticsearch/cache/recycler/CacheRecycler.java)
    public Recycler.V<TLongLongHashMap> longLongMap(int sizing) {
        return longLongMap.obtain(sizing);
    }


, Instance #
frags: 
(startLine=169 endLine=182 srcPath=/root/NewExperiment/elasticsearchFilter/00917/src/main/java/org/elasticsearch/search/facet/datehistogram/InternalCountDateHistogramFacet.java)
        for (Facet facet : facets) {
            InternalCountDateHistogramFacet histoFacet = (InternalCountDateHistogramFacet) facet;
            if (histoFacet.entries != null) {
                for (CountEntry entry : histoFacet.entries) {
                    counts.adjustOrPutValue(entry.getTime(), entry.getCount(), entry.getCount());
                }
            } else {
                for (TLongLongIterator it = histoFacet.counts.iterator(); it.hasNext(); ) {
                    it.advance();
                    counts.adjustOrPutValue(it.key(), it.value(), it.value());
                }
            }
            histoFacet.releaseCache();
        }

(startLine=170 endLine=183 srcPath=/root/NewExperiment/elasticsearchFilter/00917/src/main/java/org/elasticsearch/search/facet/histogram/InternalCountHistogramFacet.java)
        for (Facet facet : facets) {
            InternalCountHistogramFacet histoFacet = (InternalCountHistogramFacet) facet;
            if (histoFacet.entries != null) {
                for (Entry entry : histoFacet.entries) {
                    counts.adjustOrPutValue(entry.getKey(), entry.getCount(), entry.getCount());
                }
            } else {
                for (TLongLongIterator it = histoFacet.counts.iterator(); it.hasNext(); ) {
                    it.advance();
                    counts.adjustOrPutValue(it.key(), it.value(), it.value());
                }
            }
            histoFacet.releaseCache();
        }

commonMethod: 
(startLine=224 endLine=226 srcPath=/root/NewExperiment/elasticsearchFilter/00918/src/main/java/org/elasticsearch/cache/recycler/CacheRecycler.java)
    public Recycler.V<TLongLongHashMap> longLongMap(int sizing) {
        return longLongMap.obtain(sizing);
    }


, Instance #
frags: 
(startLine=49 endLine=133 srcPath=/root/NewExperiment/elasticsearchFilter/00930/src/test/java/org/elasticsearch/test/integration/recovery/RecoveryWhileUnderLoadTests.java)
    public void recoverWhileUnderLoadAllocateBackupsTest() throws Exception {
        logger.info("--> creating test index ...");
        prepareCreate("test", 1);

        final AtomicLong idGenerator = new AtomicLong();
        final AtomicLong indexCounter = new AtomicLong();
        final AtomicBoolean stop = new AtomicBoolean(false);
        Thread[] writers = new Thread[5];
        final CountDownLatch stopLatch = new CountDownLatch(writers.length);

        logger.info("--> starting {} indexing threads", writers.length);
        for (int i = 0; i < writers.length; i++) {
            final int indexerId = i;
            final Client client = client();
            writers[i] = new Thread() {
                @Override
                public void run() {
                    try {
                        logger.info("**** starting indexing thread {}", indexerId);
                        while (!stop.get()) {
                            long id = idGenerator.incrementAndGet();
                            if (id % 1000 == 0) {
                                client.admin().indices().prepareFlush().execute().actionGet();
                            }
                            client.prepareIndex("test", "type1", Long.toString(id))
                                    .setSource(MapBuilder.<String, Object>newMapBuilder().put("test", "value" + id).map()).execute().actionGet();
                            indexCounter.incrementAndGet();
                        }
                        logger.info("**** done indexing thread {}", indexerId);
                    } catch (Exception e) {
                        logger.warn("**** failed indexing thread {}", e, indexerId);
                    } finally {
                        stopLatch.countDown();
                    }
                }
            };
            writers[i].start();
        }

        logger.info("--> waiting for 2000 docs to be indexed ...");
        while (client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 2000) {
            Thread.sleep(100);
            client().admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 2000 docs indexed");

        logger.info("--> flushing the index ....");
        // now flush, just to make sure we have some data in the index, not just translog
        client().admin().indices().prepareFlush().execute().actionGet();


        logger.info("--> waiting for 4000 docs to be indexed ...");
        while (client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 4000) {
            Thread.sleep(100);
            client().admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 4000 docs indexed");

        logger.info("--> allow 2 nodes for index [test] ...");
        // now start another node, while we index
        allowNodes("test", 2);

        logger.info("--> waiting for GREEN health status ...");
        // make sure the cluster state is green, and all has been recovered
        assertThat(client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setTimeout("1m").setWaitForGreenStatus().setWaitForNodes(">=2").execute().actionGet().isTimedOut(), equalTo(false));

        logger.info("--> waiting for 10000 docs to be indexed ...");
        while (client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 10000) {
            Thread.sleep(100);
            client().admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 10000 docs indexed");

        logger.info("--> marking and waiting for indexing threads to stop ...");
        stop.set(true);
        stopLatch.await();
        logger.info("--> indexing threads stopped");

        logger.info("--> refreshing the index");
        refreshAndAssert();
        logger.info("--> verifying indexed content");
        for (int i = 0; i < 10; i++) {
            assertThat("iteration: " + i + " failed", client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount(), equalTo(indexCounter.get()));
        }
    }

(startLine=137 endLine=218 srcPath=/root/NewExperiment/elasticsearchFilter/00930/src/test/java/org/elasticsearch/test/integration/recovery/RecoveryWhileUnderLoadTests.java)
    public void recoverWhileUnderLoadAllocateBackupsRelocatePrimariesTest() throws Exception {
        logger.info("--> creating test index ...");
        prepareCreate("test", 1);

        final AtomicLong idGenerator = new AtomicLong();
        final AtomicLong indexCounter = new AtomicLong();
        final AtomicBoolean stop = new AtomicBoolean(false);
        Thread[] writers = new Thread[5];
        logger.info("--> starting {} indexing threads", writers.length);
        final CountDownLatch stopLatch = new CountDownLatch(writers.length);
        for (int i = 0; i < writers.length; i++) {
            final int indexerId = i;
            final Client client = client();
            writers[i] = new Thread() {
                @Override
                public void run() {
                    try {
                        logger.info("**** starting indexing thread {}", indexerId);
                        while (!stop.get()) {
                            long id = idGenerator.incrementAndGet();
                            client.prepareIndex("test", "type1", Long.toString(id))
                                    .setSource(MapBuilder.<String, Object>newMapBuilder().put("test", "value" + id).map()).execute().actionGet();
                            indexCounter.incrementAndGet();
                        }
                        logger.info("**** done indexing thread {}", indexerId);
                    } catch (Exception e) {
                        logger.warn("**** failed indexing thread {}", e, indexerId);
                    } finally {
                        stopLatch.countDown();
                    }
                }
            };
            writers[i].start();
        }

        logger.info("--> waiting for 2000 docs to be indexed ...");
        while (client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 2000) {
            Thread.sleep(100);
            client().admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 2000 docs indexed");

        logger.info("--> flushing the index ....");
        // now flush, just to make sure we have some data in the index, not just translog
        client().admin().indices().prepareFlush().execute().actionGet();


        logger.info("--> waiting for 4000 docs to be indexed ...");
        while (client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 4000) {
            Thread.sleep(100);
            client().admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 4000 docs indexed");
        logger.info("--> allow 4 nodes for index [test] ...");
        allowNodes("test", 4);

        logger.info("--> waiting for GREEN health status ...");
        assertThat(client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setTimeout("1m").setWaitForGreenStatus().setWaitForNodes(">=4").execute().actionGet().isTimedOut(), equalTo(false));


        logger.info("--> waiting for 15000 docs to be indexed ...");
        while (client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() < 15000) {
            Thread.sleep(100);
            client().admin().indices().prepareRefresh().execute().actionGet();
        }
        logger.info("--> 15000 docs indexed");

        stop.set(true);
        stopLatch.await();

        logger.info("--> marking and waiting for indexing threads to stop ...");
        stop.set(true);
        stopLatch.await();
        logger.info("--> indexing threads stopped");

        logger.info("--> refreshing the index");
        refreshAndAssert();
        logger.info("--> verifying indexed content");
        for (int i = 0; i < 10; i++) {
            assertThat("iteration: " + i + " failed", client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount(), equalTo(indexCounter.get()));
        }
    }

commonMethod: 
(startLine=312 endLine=319 srcPath=/root/NewExperiment/elasticsearchFilter/00931/src/test/java/org/elasticsearch/test/integration/recovery/RecoveryWhileUnderLoadTests.java)
    private void waitForDocs(final long numDocs) throws InterruptedException {
        awaitBusy(new Predicate<Object>() {
            public boolean apply(Object o) {
                return client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount() > numDocs;
            }
        }, 5, TimeUnit.MINUTES); // not really relevant here we just have to wait some time
        assertThat(client().prepareCount().setQuery(matchAllQuery()).execute().actionGet().getCount(), greaterThan(numDocs));
    }


, Instance #
frags: 
(startLine=52 endLine=129 srcPath=/root/NewExperiment/elasticsearchFilter/00937/src/test/java/org/elasticsearch/test/integration/recovery/RecoveryWhileUnderLoadTests.java)
    public void recoverWhileUnderLoadAllocateBackupsTest() throws Exception {
        logger.info("--> creating test index ...");
        prepareCreate("test", 1);

        final AtomicLong idGenerator = new AtomicLong();
        final AtomicLong indexCounter = new AtomicLong();
        final AtomicBoolean stop = new AtomicBoolean(false);
        Thread[] writers = new Thread[5];
        final CountDownLatch stopLatch = new CountDownLatch(writers.length);

        logger.info("--> starting {} indexing threads", writers.length);
        for (int i = 0; i < writers.length; i++) {
            final int indexerId = i;
            final Client client = client();
            writers[i] = new Thread() {
                @Override
                public void run() {
                    try {
                        logger.info("**** starting indexing thread {}", indexerId);
                        while (!stop.get()) {
                            long id = idGenerator.incrementAndGet();
                            if (id % 1000 == 0) {
                                client.admin().indices().prepareFlush().execute().actionGet();
                            }
                            client.prepareIndex("test", "type1", Long.toString(id))
                                    .setSource(MapBuilder.<String, Object>newMapBuilder().put("test", "value" + id).map()).execute().actionGet();
                            indexCounter.incrementAndGet();
                        }
                        logger.info("**** done indexing thread {}", indexerId);
                    } catch (Throwable e) {
                        logger.warn("**** failed indexing thread {}", e, indexerId);
                    } finally {
                        stopLatch.countDown();
                    }
                }
            };
            writers[i].start();
        }

        logger.info("--> waiting for 2000 docs to be indexed ...");
        waitForDocs(2000);
        logger.info("--> 2000 docs indexed");

        logger.info("--> flushing the index ....");
        // now flush, just to make sure we have some data in the index, not just translog
        client().admin().indices().prepareFlush().execute().actionGet();


        logger.info("--> waiting for 4000 docs to be indexed ...");
        waitForDocs(4000);
        logger.info("--> 4000 docs indexed");

        logger.info("--> allow 2 nodes for index [test] ...");
        // now start another node, while we index
        allowNodes("test", 2);

        logger.info("--> waiting for GREEN health status ...");
        // make sure the cluster state is green, and all has been recovered
        assertThat(client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setTimeout("1m").setWaitForGreenStatus().setWaitForNodes(">=2").execute().actionGet().isTimedOut(), equalTo(false));

        logger.info("--> waiting for 10000 docs to be indexed ...");
        waitForDocs(15000);
        logger.info("--> 10000 docs indexed");

        logger.info("--> marking and waiting for indexing threads to stop ...");
        stop.set(true);
        stopLatch.await();
        logger.info("--> indexing threads stopped");

        logger.info("--> refreshing the index");
        refreshAndAssert();
        logger.info("--> verifying indexed content");
        for (int i = 0; i < 10; i++) {
            CountResponse actionGet = client().prepareCount().setQuery(matchAllQuery()).execute().actionGet();
            assertNoFailures(actionGet);
            assertThat("iteration: " + i + " failed", actionGet.getCount(), equalTo(indexCounter.get()));
        }
    }

(startLine=133 endLine=207 srcPath=/root/NewExperiment/elasticsearchFilter/00937/src/test/java/org/elasticsearch/test/integration/recovery/RecoveryWhileUnderLoadTests.java)
    public void recoverWhileUnderLoadAllocateBackupsRelocatePrimariesTest() throws Exception {
        logger.info("--> creating test index ...");
        prepareCreate("test", 1);

        final AtomicLong idGenerator = new AtomicLong();
        final AtomicLong indexCounter = new AtomicLong();
        final AtomicBoolean stop = new AtomicBoolean(false);
        Thread[] writers = new Thread[5];
        logger.info("--> starting {} indexing threads", writers.length);
        final CountDownLatch stopLatch = new CountDownLatch(writers.length);
        for (int i = 0; i < writers.length; i++) {
            final int indexerId = i;
            final Client client = client();
            writers[i] = new Thread() {
                @Override
                public void run() {
                    try {
                        logger.info("**** starting indexing thread {}", indexerId);
                        while (!stop.get()) {
                            long id = idGenerator.incrementAndGet();
                            client.prepareIndex("test", "type1", Long.toString(id))
                                    .setSource(MapBuilder.<String, Object>newMapBuilder().put("test", "value" + id).map()).execute().actionGet();
                            indexCounter.incrementAndGet();
                        }
                        logger.info("**** done indexing thread {}", indexerId);
                    } catch (Throwable e) {
                        logger.warn("**** failed indexing thread {}", e, indexerId);
                    } finally {
                        stopLatch.countDown();
                    }
                }
            };
            writers[i].start();
        }

        logger.info("--> waiting for 2000 docs to be indexed ...");
        waitForDocs(2000);
        logger.info("--> 2000 docs indexed");

        logger.info("--> flushing the index ....");
        // now flush, just to make sure we have some data in the index, not just translog
        client().admin().indices().prepareFlush().execute().actionGet();


        logger.info("--> waiting for 4000 docs to be indexed ...");
        waitForDocs(4000);
        logger.info("--> 4000 docs indexed");
        logger.info("--> allow 4 nodes for index [test] ...");
        allowNodes("test", 4);

        logger.info("--> waiting for GREEN health status ...");
        assertThat(client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setTimeout("1m").setWaitForGreenStatus().setWaitForNodes(">=4").execute().actionGet().isTimedOut(), equalTo(false));


        logger.info("--> waiting for 15000 docs to be indexed ...");
        waitForDocs(15000);
        logger.info("--> 15000 docs indexed");

        stop.set(true);
        stopLatch.await();

        logger.info("--> marking and waiting for indexing threads to stop ...");
        stop.set(true);
        stopLatch.await();
        logger.info("--> indexing threads stopped");

        logger.info("--> refreshing the index");
        refreshAndAssert();
        logger.info("--> verifying indexed content");
        for (int i = 0; i < 10; i++) {
            CountResponse actionGet = client().prepareCount().setQuery(matchAllQuery()).execute().actionGet();
            assertNoFailures(actionGet);
            assertThat("iteration: " + i + " failed", actionGet.getCount(), equalTo(indexCounter.get()));
        }
    }

commonMethod: 
(startLine=294 endLine=317 srcPath=/root/NewExperiment/elasticsearchFilter/00938/src/test/java/org/elasticsearch/test/integration/recovery/RecoveryWhileUnderLoadTests.java)
    private void iterateAssertCount(final int numberOfShards, final long numberOfDocs, int iterations) {

        CountResponse[] iterationResults = new CountResponse[iterations];

        for (int i = 0; i < iterations; i++) {
            CountResponse countResponse = client().prepareCount().setQuery(matchAllQuery()).execute().actionGet();
            iterationResults[i] = countResponse;
            logger.info("iteration [{}] - successful shards: {} (expected {})", i, countResponse.getSuccessfulShards(), numberOfShards);
            logger.info("iteration [{}] - failed shards: {} (expected 0)", i, countResponse.getFailedShards());
            if (countResponse.getShardFailures() != null && countResponse.getShardFailures().length > 1) {
                logger.info("iteration [{}] - shard failures: {}", i, Arrays.toString(countResponse.getShardFailures()));
            }
            logger.info("iteration [{}] - returned documents: {} (expected {})", i, countResponse.getCount(), numberOfDocs);
        }

        for (int i = 0; i < iterations; i++) {
            CountResponse actionGet = iterationResults[i];
            assertNoFailures(actionGet);
            //checking that we are not missing any shard
            assertThat(actionGet.getSuccessfulShards(), equalTo(numberOfShards));
            //if it fails here it means that some shard is missing documents (not refreshed?)
            assertThat("iteration: " + i + " failed", actionGet.getCount(), equalTo(numberOfDocs));
        }
    }


, Instance #
frags: 
(startLine=207 endLine=214 srcPath=/root/NewExperiment/elasticsearchFilter/00947/src/test/java/org/elasticsearch/test/integration/search/suggest/SuggestSearchTests.java)
        {
            SearchRequestBuilder suggestBuilder = client().prepareSearch().setSearchType(SearchType.COUNT);
            suggestBuilder.setSuggestText("tetsting sugestion");
            suggestBuilder.addSuggestion(phraseSuggestion("did_you_mean").field("nosuchField")
                    .addCandidateGenerator(PhraseSuggestionBuilder.candidateGenerator("name").prefixLength(0).minWordLength(0).suggestMode("always").maxEdits(2))
                    .gramSize(3));
            assertThrows(suggestBuilder, SearchPhaseExecutionException.class);
        }

(startLine=215 endLine=222 srcPath=/root/NewExperiment/elasticsearchFilter/00947/src/test/java/org/elasticsearch/test/integration/search/suggest/SuggestSearchTests.java)
        {
            SearchRequestBuilder suggestBuilder = client().prepareSearch().setSearchType(SearchType.COUNT);
            suggestBuilder.setSuggestText("tetsting sugestion");
            suggestBuilder.addSuggestion(phraseSuggestion("did_you_mean").field("nosuchField")
                    .addCandidateGenerator(PhraseSuggestionBuilder.candidateGenerator("name").prefixLength(0).minWordLength(0).suggestMode("always").maxEdits(2))
                    .gramSize(3));
            assertThrows(suggestBuilder, SearchPhaseExecutionException.class);
        }

commonMethod: 
(startLine=359 endLine=365 srcPath=/root/NewExperiment/elasticsearchFilter/00948/src/test/java/org/elasticsearch/test/integration/AbstractSharedClusterTest.java)
    protected RefreshResponse refresh() {
        waitForRelocation();
        // TODO RANDOMIZE with flush?
        RefreshResponse actionGet = client().admin().indices().prepareRefresh().execute().actionGet();
        assertNoFailures(actionGet);
        return actionGet;
    }


, Instance #
frags: 
(startLine=207 endLine=214 srcPath=/root/NewExperiment/elasticsearchFilter/00947/src/test/java/org/elasticsearch/test/integration/search/suggest/SuggestSearchTests.java)
        {
            SearchRequestBuilder suggestBuilder = client().prepareSearch().setSearchType(SearchType.COUNT);
            suggestBuilder.setSuggestText("tetsting sugestion");
            suggestBuilder.addSuggestion(phraseSuggestion("did_you_mean").field("nosuchField")
                    .addCandidateGenerator(PhraseSuggestionBuilder.candidateGenerator("name").prefixLength(0).minWordLength(0).suggestMode("always").maxEdits(2))
                    .gramSize(3));
            assertThrows(suggestBuilder, SearchPhaseExecutionException.class);
        }

(startLine=215 endLine=222 srcPath=/root/NewExperiment/elasticsearchFilter/00947/src/test/java/org/elasticsearch/test/integration/search/suggest/SuggestSearchTests.java)
        {
            SearchRequestBuilder suggestBuilder = client().prepareSearch().setSearchType(SearchType.COUNT);
            suggestBuilder.setSuggestText("tetsting sugestion");
            suggestBuilder.addSuggestion(phraseSuggestion("did_you_mean").field("nosuchField")
                    .addCandidateGenerator(PhraseSuggestionBuilder.candidateGenerator("name").prefixLength(0).minWordLength(0).suggestMode("always").maxEdits(2))
                    .gramSize(3));
            assertThrows(suggestBuilder, SearchPhaseExecutionException.class);
        }

commonMethod: 
(startLine=296 endLine=302 srcPath=/root/NewExperiment/elasticsearchFilter/00948/src/test/java/org/elasticsearch/test/integration/AbstractSharedClusterTest.java)
    public ClusterHealthStatus ensureGreen() {
        ClusterHealthResponse actionGet = client().admin().cluster()
                .health(Requests.clusterHealthRequest().waitForGreenStatus().waitForEvents(Priority.LANGUID).waitForRelocatingShards(0)).actionGet();
        assertThat(actionGet.isTimedOut(), equalTo(false));
        assertThat(actionGet.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        return actionGet.getStatus();
    }


, Instance #
frags: 
(startLine=166 endLine=177 srcPath=/root/NewExperiment/elasticsearchFilter/00952/src/main/java/org/elasticsearch/plugins/PluginManager.java)
                        if (!downloaded) {
                            pluginUrl = new URL("https://oss.sonatype.org/service/local/repositories/releases/content/" + userName.replace('.', '/') + "/" + repoName + "/" + version + "/" + repoName + "-" + version + ".zip");
                            System.out.println("Trying " + pluginUrl.toExternalForm() + "...");
                            try {
                                downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                                downloaded = true;
                            } catch (Exception e) {
                                if (verbose) {
                                    System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e));
                                }
                            }
                        }

(startLine=193 endLine=206 srcPath=/root/NewExperiment/elasticsearchFilter/00952/src/main/java/org/elasticsearch/plugins/PluginManager.java)
                } else {
                    // assume site plugin, download master....
                    URL pluginUrl = new URL("https://github.com/" + userName + "/" + repoName + "/archive/master.zip");
                    System.out.println("Trying " + pluginUrl.toExternalForm() + "... (assuming site plugin)");
                    try {
                        downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                        downloaded = true;
                    } catch (Exception e2) {
                        // ignore
                        if (verbose) {
                            System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e2));
                        }
                    }
                }

commonMethod: 
(startLine=450 endLine=452 srcPath=/root/NewExperiment/elasticsearchFilter/00953/src/main/java/org/elasticsearch/plugins/PluginManager.java)
        File distroFile(Environment env) {
            return new File(env.pluginsFile(), name + ".zip");
        }


, Instance #
frags: 
(startLine=166 endLine=177 srcPath=/root/NewExperiment/elasticsearchFilter/00952/src/main/java/org/elasticsearch/plugins/PluginManager.java)
                        if (!downloaded) {
                            pluginUrl = new URL("https://oss.sonatype.org/service/local/repositories/releases/content/" + userName.replace('.', '/') + "/" + repoName + "/" + version + "/" + repoName + "-" + version + ".zip");
                            System.out.println("Trying " + pluginUrl.toExternalForm() + "...");
                            try {
                                downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                                downloaded = true;
                            } catch (Exception e) {
                                if (verbose) {
                                    System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e));
                                }
                            }
                        }

(startLine=193 endLine=206 srcPath=/root/NewExperiment/elasticsearchFilter/00952/src/main/java/org/elasticsearch/plugins/PluginManager.java)
                } else {
                    // assume site plugin, download master....
                    URL pluginUrl = new URL("https://github.com/" + userName + "/" + repoName + "/archive/master.zip");
                    System.out.println("Trying " + pluginUrl.toExternalForm() + "... (assuming site plugin)");
                    try {
                        downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                        downloaded = true;
                    } catch (Exception e2) {
                        // ignore
                        if (verbose) {
                            System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e2));
                        }
                    }
                }

commonMethod: 
(startLine=462 endLine=493 srcPath=/root/NewExperiment/elasticsearchFilter/00953/src/main/java/org/elasticsearch/plugins/PluginManager.java)
        static PluginHandle parse(String name) {
            String[] elements = name.split("/");
            // We first consider the simplest form: pluginname
            String repo = elements[0];
            String user = null;
            String version = null;

            // We consider the form: username/pluginname
            if (elements.length > 1) {
                user = elements[0];
                repo = elements[1];

                // We consider the form: username/pluginname/version
                if (elements.length > 2) {
                    version = elements[2];
                }
            }

            if (repo.startsWith("elasticsearch-")) {
                // remove elasticsearch- prefix
                String endname = repo.substring("elasticsearch-".length());
                return new PluginHandle(endname, version, user, repo);
            }

            if (name.startsWith("es-")) {
                // remove es- prefix
                String endname = repo.substring("es-".length());
                return new PluginHandle(endname, version, user, repo);
            }

            return new PluginHandle(repo, version, user, repo);
        }


, Instance #
frags: 
(startLine=166 endLine=177 srcPath=/root/NewExperiment/elasticsearchFilter/00952/src/main/java/org/elasticsearch/plugins/PluginManager.java)
                        if (!downloaded) {
                            pluginUrl = new URL("https://oss.sonatype.org/service/local/repositories/releases/content/" + userName.replace('.', '/') + "/" + repoName + "/" + version + "/" + repoName + "-" + version + ".zip");
                            System.out.println("Trying " + pluginUrl.toExternalForm() + "...");
                            try {
                                downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                                downloaded = true;
                            } catch (Exception e) {
                                if (verbose) {
                                    System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e));
                                }
                            }
                        }

(startLine=193 endLine=206 srcPath=/root/NewExperiment/elasticsearchFilter/00952/src/main/java/org/elasticsearch/plugins/PluginManager.java)
                } else {
                    // assume site plugin, download master....
                    URL pluginUrl = new URL("https://github.com/" + userName + "/" + repoName + "/archive/master.zip");
                    System.out.println("Trying " + pluginUrl.toExternalForm() + "... (assuming site plugin)");
                    try {
                        downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                        downloaded = true;
                    } catch (Exception e2) {
                        // ignore
                        if (verbose) {
                            System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e2));
                        }
                    }
                }

commonMethod: 
(startLine=458 endLine=460 srcPath=/root/NewExperiment/elasticsearchFilter/00953/src/main/java/org/elasticsearch/plugins/PluginManager.java)
        File binDir(Environment env) {
            return new File(new File(env.homeFile(), "bin"), name);
        }


, Instance #
frags: 
(startLine=166 endLine=177 srcPath=/root/NewExperiment/elasticsearchFilter/00952/src/main/java/org/elasticsearch/plugins/PluginManager.java)
                        if (!downloaded) {
                            pluginUrl = new URL("https://oss.sonatype.org/service/local/repositories/releases/content/" + userName.replace('.', '/') + "/" + repoName + "/" + version + "/" + repoName + "-" + version + ".zip");
                            System.out.println("Trying " + pluginUrl.toExternalForm() + "...");
                            try {
                                downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                                downloaded = true;
                            } catch (Exception e) {
                                if (verbose) {
                                    System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e));
                                }
                            }
                        }

(startLine=193 endLine=206 srcPath=/root/NewExperiment/elasticsearchFilter/00952/src/main/java/org/elasticsearch/plugins/PluginManager.java)
                } else {
                    // assume site plugin, download master....
                    URL pluginUrl = new URL("https://github.com/" + userName + "/" + repoName + "/archive/master.zip");
                    System.out.println("Trying " + pluginUrl.toExternalForm() + "... (assuming site plugin)");
                    try {
                        downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                        downloaded = true;
                    } catch (Exception e2) {
                        // ignore
                        if (verbose) {
                            System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e2));
                        }
                    }
                }

commonMethod: 
(startLine=454 endLine=456 srcPath=/root/NewExperiment/elasticsearchFilter/00953/src/main/java/org/elasticsearch/plugins/PluginManager.java)
        File extractedDir(Environment env) {
            return new File(env.pluginsFile(), name);
        }


, Instance #
frags: 
(startLine=166 endLine=177 srcPath=/root/NewExperiment/elasticsearchFilter/00952/src/main/java/org/elasticsearch/plugins/PluginManager.java)
                        if (!downloaded) {
                            pluginUrl = new URL("https://oss.sonatype.org/service/local/repositories/releases/content/" + userName.replace('.', '/') + "/" + repoName + "/" + version + "/" + repoName + "-" + version + ".zip");
                            System.out.println("Trying " + pluginUrl.toExternalForm() + "...");
                            try {
                                downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                                downloaded = true;
                            } catch (Exception e) {
                                if (verbose) {
                                    System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e));
                                }
                            }
                        }

(startLine=193 endLine=206 srcPath=/root/NewExperiment/elasticsearchFilter/00952/src/main/java/org/elasticsearch/plugins/PluginManager.java)
                } else {
                    // assume site plugin, download master....
                    URL pluginUrl = new URL("https://github.com/" + userName + "/" + repoName + "/archive/master.zip");
                    System.out.println("Trying " + pluginUrl.toExternalForm() + "... (assuming site plugin)");
                    try {
                        downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                        downloaded = true;
                    } catch (Exception e2) {
                        // ignore
                        if (verbose) {
                            System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e2));
                        }
                    }
                }

commonMethod: 
(startLine=424 endLine=439 srcPath=/root/NewExperiment/elasticsearchFilter/00953/src/main/java/org/elasticsearch/plugins/PluginManager.java)
        List<URL> urls() {
            List<URL> urls = new ArrayList<URL>();
            if (version != null) {
                // Elasticsearch download service
                addUrl(urls, "http://download.elasticsearch.org/" + user + "/" + repo + "/" + repo + "-" + version + ".zip");
                // Maven central repository
                addUrl(urls, "http://search.maven.org/remotecontent?filepath=" + user.replace('.', '/') + "/" + repo + "/" + version + "/" + repo + "-" + version + ".zip");
                // Sonatype repository
                addUrl(urls, "https://oss.sonatype.org/service/local/repositories/releases/content/" + user.replace('.', '/') + "/" + repo + "/" + version + "/" + repo + "-" + version + ".zip");
                // Github repository
                addUrl(urls, "https://github.com/" + user + "/" + repo + "/archive/v" + version + ".zip");
            }
            // Github repository for master branch (assume site)
            addUrl(urls, "https://github.com/" + user + "/" + repo + "/archive/master.zip");
            return urls;
        }


, Instance #
frags: 
(startLine=110 endLine=122 srcPath=/root/NewExperiment/elasticsearchFilter/00953/src/main/java/org/elasticsearch/plugins/PluginManager.java)
        if (url != null) {
            URL pluginUrl = new URL(url);
            System.out.println("Trying " + pluginUrl.toExternalForm() + "...");
            try {
                downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                downloaded = true;
            } catch (IOException e) {
                // ignore
                if (verbose) {
                    System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e));
                }
            }
        }

(startLine=124 endLine=138 srcPath=/root/NewExperiment/elasticsearchFilter/00953/src/main/java/org/elasticsearch/plugins/PluginManager.java)
        if (!downloaded) {
            // We try all possible locations
            for (URL url: pluginHandle.urls()) {
                System.out.println("Trying " + url.toExternalForm() + "...");
                try {
                    downloadHelper.download(url, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                    downloaded = true;
                    break;
                } catch (Exception e) {
                    if (verbose) {
                        System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e));
                    }
                }
            }
        }

commonMethod: 
(startLine=420 endLine=422 srcPath=/root/NewExperiment/elasticsearchFilter/00954/src/main/java/org/elasticsearch/plugins/PluginManager.java)
    private void debug(String line) {
        if (outputMode == OutputMode.VERBOSE) System.out.println(line);
    }


, Instance #
frags: 
(startLine=110 endLine=122 srcPath=/root/NewExperiment/elasticsearchFilter/00953/src/main/java/org/elasticsearch/plugins/PluginManager.java)
        if (url != null) {
            URL pluginUrl = new URL(url);
            System.out.println("Trying " + pluginUrl.toExternalForm() + "...");
            try {
                downloadHelper.download(pluginUrl, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                downloaded = true;
            } catch (IOException e) {
                // ignore
                if (verbose) {
                    System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e));
                }
            }
        }

(startLine=124 endLine=138 srcPath=/root/NewExperiment/elasticsearchFilter/00953/src/main/java/org/elasticsearch/plugins/PluginManager.java)
        if (!downloaded) {
            // We try all possible locations
            for (URL url: pluginHandle.urls()) {
                System.out.println("Trying " + url.toExternalForm() + "...");
                try {
                    downloadHelper.download(url, pluginFile, new HttpDownloadHelper.VerboseProgress(System.out));
                    downloaded = true;
                    break;
                } catch (Exception e) {
                    if (verbose) {
                        System.out.println("Failed: " + ExceptionsHelper.detailedMessage(e));
                    }
                }
            }
        }

commonMethod: 
(startLine=424 endLine=426 srcPath=/root/NewExperiment/elasticsearchFilter/00954/src/main/java/org/elasticsearch/plugins/PluginManager.java)
    private void log(String line) {
        if (outputMode != OutputMode.SILENT) System.out.println(line);
    }


, Instance #
frags: 
(startLine=41 endLine=100 srcPath=/root/NewExperiment/elasticsearchFilter/00958/src/test/java/org/elasticsearch/search/matchedqueries/MatchedQueriesTests.java)
    public void simpleMatchedQueryFromFilteredQuery() throws Exception {

        client().admin().indices().prepareCreate("test").execute().actionGet();
        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().execute().actionGet();

        client().prepareIndex("test", "type1", "1").setSource(jsonBuilder().startObject()
                .field("name", "test1")
                .field("number", 1)
                .endObject()).execute().actionGet();

        client().prepareIndex("test", "type1", "2").setSource(jsonBuilder().startObject()
                .field("name", "test2")
                .field("number", 2)
                .endObject()).execute().actionGet();

        client().prepareIndex("test", "type1", "3").setSource(jsonBuilder().startObject()
                .field("name", "test3")
                .field("number", 3)
                .endObject()).execute().actionGet();

        client().admin().indices().prepareRefresh().execute().actionGet();

        SearchResponse searchResponse = client().prepareSearch()
                .setQuery(filteredQuery(matchAllQuery(), orFilter(rangeFilter("number").lte(2).filterName("test1"), rangeFilter("number").gt(2).filterName("test2"))))
                .execute().actionGet();


        assertNoFailures(searchResponse);
        assertThat(searchResponse.getHits().totalHits(), equalTo(3l));
        for (SearchHit hit : searchResponse.getHits()) {
            if (hit.id().equals("1") || hit.id().equals("2")) {
                assertThat(hit.matchedQueries().length, equalTo(1));
                assertThat(hit.matchedQueries(), hasItemInArray("test1"));
            } else if (hit.id().equals("3")) {
                assertThat(hit.matchedQueries().length, equalTo(1));
                assertThat(hit.matchedQueries(), hasItemInArray("test2"));
            } else {
                fail("Unexpected document returned with id " + hit.id());
            }
        }

        searchResponse = client().prepareSearch()
                .setQuery(boolQuery().should(rangeQuery("number").lte(2).queryName("test1")).should(rangeQuery("number").gt(2).queryName("test2")))
                .execute().actionGet();


        assertNoFailures(searchResponse);
        assertThat(searchResponse.getHits().totalHits(), equalTo(3l));
        for (SearchHit hit : searchResponse.getHits()) {
            if (hit.id().equals("1") || hit.id().equals("2")) {
                assertThat(hit.matchedQueries().length, equalTo(1));
                assertThat(hit.matchedQueries(), hasItemInArray("test1"));
            } else if (hit.id().equals("3")) {
                assertThat(hit.matchedQueries().length, equalTo(1));
                assertThat(hit.matchedQueries(), hasItemInArray("test2"));
            } else {
                fail("Unexpected document returned with id " + hit.id());
            }
        }
    }

(startLine=103 endLine=168 srcPath=/root/NewExperiment/elasticsearchFilter/00958/src/test/java/org/elasticsearch/search/matchedqueries/MatchedQueriesTests.java)
    public void simpleMatchedQueryFromTopLevelFilter() throws Exception {

        client().admin().indices().prepareCreate("test").execute().actionGet();
        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().execute().actionGet();

        client().prepareIndex("test", "type1", "1").setSource(jsonBuilder().startObject()
                .field("name", "test")
                .field("title", "title1")
                .endObject()).execute().actionGet();

        client().prepareIndex("test", "type1", "2").setSource(jsonBuilder().startObject()
                .field("name", "test")
                .endObject()).execute().actionGet();

        client().prepareIndex("test", "type1", "3").setSource(jsonBuilder().startObject()
                .field("name", "test")
                .endObject()).execute().actionGet();

        client().admin().indices().prepareRefresh().execute().actionGet();

        SearchResponse searchResponse = client().prepareSearch()
                .setQuery(matchAllQuery())
                .setFilter(orFilter(
                        termFilter("name", "test").filterName("name"),
                        termFilter("title", "title1").filterName("title")))
                .execute().actionGet();

        assertNoFailures(searchResponse);
        assertThat(searchResponse.getHits().totalHits(), equalTo(3l));

        for (SearchHit hit : searchResponse.getHits()) {
            if (hit.id().equals("1")) {
                assertThat(hit.matchedQueries().length, equalTo(2));
                assertThat(hit.matchedQueries(), hasItemInArray("name"));
                assertThat(hit.matchedQueries(), hasItemInArray("title"));
            } else if (hit.id().equals("2") || hit.id().equals("3")) {
                assertThat(hit.matchedQueries().length, equalTo(1));
                assertThat(hit.matchedQueries(), hasItemInArray("name"));
            } else {
                fail("Unexpected document returned with id " + hit.id());
            }
        }

        searchResponse = client().prepareSearch()
                .setQuery(matchAllQuery())
                .setFilter(queryFilter(boolQuery()
                        .should(termQuery("name", "test").queryName("name"))
                        .should(termQuery("title", "title1").queryName("title"))))
                .execute().actionGet();

        assertNoFailures(searchResponse);
        assertThat(searchResponse.getHits().totalHits(), equalTo(3l));

        for (SearchHit hit : searchResponse.getHits()) {
            if (hit.id().equals("1")) {
                assertThat(hit.matchedQueries().length, equalTo(2));
                assertThat(hit.matchedQueries(), hasItemInArray("name"));
                assertThat(hit.matchedQueries(), hasItemInArray("title"));
            } else if (hit.id().equals("2") || hit.id().equals("3")) {
                assertThat(hit.matchedQueries().length, equalTo(1));
                assertThat(hit.matchedQueries(), hasItemInArray("name"));
            } else {
                fail("Unexpected document returned with id " + hit.id());
            }
        }
    }

(startLine=171 endLine=228 srcPath=/root/NewExperiment/elasticsearchFilter/00958/src/test/java/org/elasticsearch/search/matchedqueries/MatchedQueriesTests.java)
    public void simpleMatchedQueryFromTopLevelFilterAndFilteredQuery() throws Exception {

        client().admin().indices().prepareCreate("test").execute().actionGet();
        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForGreenStatus().execute().actionGet();

        client().prepareIndex("test", "type1", "1").setSource(jsonBuilder().startObject()
                .field("name", "test")
                .field("title", "title1")
                .endObject()).execute().actionGet();

        client().prepareIndex("test", "type1", "2").setSource(jsonBuilder().startObject()
                .field("name", "test")
                .field("title", "title2")
                .endObject()).execute().actionGet();

        client().prepareIndex("test", "type1", "3").setSource(jsonBuilder().startObject()
                .field("name", "test")
                .field("title", "title3")
                .endObject()).execute().actionGet();

        client().admin().indices().prepareRefresh().execute().actionGet();

        SearchResponse searchResponse = client().prepareSearch()
                .setQuery(filteredQuery(matchAllQuery(), termsFilter("title", "title1", "title2", "title3").filterName("title")))
                        .setFilter(termFilter("name", "test").filterName("name"))
                        .execute().actionGet();

        assertNoFailures(searchResponse);
        assertThat(searchResponse.getHits().totalHits(), equalTo(3l));

        for (SearchHit hit : searchResponse.getHits()) {
            if (hit.id().equals("1") || hit.id().equals("2") || hit.id().equals("3")) {
                assertThat(hit.matchedQueries().length, equalTo(2));
                assertThat(hit.matchedQueries(), hasItemInArray("name"));
                assertThat(hit.matchedQueries(), hasItemInArray("title"));
            } else {
                fail("Unexpected document returned with id " + hit.id());
            }
        }

        searchResponse = client().prepareSearch()
                .setQuery(termsQuery("title", "title1", "title2", "title3").queryName("title"))
                .setFilter(queryFilter(matchQuery("name", "test").queryName("name")))
                .execute().actionGet();

        assertNoFailures(searchResponse);
        assertThat(searchResponse.getHits().totalHits(), equalTo(3l));

        for (SearchHit hit : searchResponse.getHits()) {
            if (hit.id().equals("1") || hit.id().equals("2") || hit.id().equals("3")) {
                assertThat(hit.matchedQueries().length, equalTo(2));
                assertThat(hit.matchedQueries(), hasItemInArray("name"));
                assertThat(hit.matchedQueries(), hasItemInArray("title"));
            } else {
                fail("Unexpected document returned with id " + hit.id());
            }
        }
    }

commonMethod: 
(startLine=251 endLine=257 srcPath=/root/NewExperiment/elasticsearchFilter/00959/src/test/java/org/elasticsearch/AbstractSharedClusterTest.java)
    public ClusterHealthStatus ensureGreen() {
        ClusterHealthResponse actionGet = client().admin().cluster()
                .health(Requests.clusterHealthRequest().waitForGreenStatus().waitForEvents(Priority.LANGUID).waitForRelocatingShards(0)).actionGet();
        assertThat(actionGet.isTimedOut(), equalTo(false));
        assertThat(actionGet.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        return actionGet.getStatus();
    }


, Instance #
frags: 
(startLine=451 endLine=469 srcPath=/root/NewExperiment/elasticsearchFilter/00963/src/test/java/org/elasticsearch/aliases/IndexAliasesTests.java)
    public void testWaitForAliasCreationMultipleShards() throws Exception {
        // delete all indices
        client().admin().indices().prepareDelete().execute().actionGet();

        logger.info("--> creating index [test]");
        client().admin().indices().create(createIndexRequest("test")).actionGet();

        logger.info("--> running cluster_health");
        ClusterHealthResponse clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus()).actionGet();
        logger.info("--> done cluster_health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        for (int i = 0; i < 10; i++) {
            assertThat(client().admin().indices().prepareAliases().addAlias("test", "alias" + i).execute().actionGet().isAcknowledged(), equalTo(true));
            client().index(indexRequest("alias" + i).type("type1").id("1").source(source("1", "test")).refresh(true)).actionGet();
        }

    }

(startLine=472 endLine=489 srcPath=/root/NewExperiment/elasticsearchFilter/00963/src/test/java/org/elasticsearch/aliases/IndexAliasesTests.java)
    public void testWaitForAliasCreationSingleShard() throws Exception {
        // delete all indices
        client().admin().indices().prepareDelete().execute().actionGet();

        logger.info("--> creating index [test]");
        client().admin().indices().create(createIndexRequest("test").settings(settingsBuilder().put("index.numberOfReplicas", 0).put("index.numberOfShards", 1))).actionGet();

        logger.info("--> running cluster_health");
        ClusterHealthResponse clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus()).actionGet();
        logger.info("--> done cluster_health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        for (int i = 0; i < 10; i++) {
            assertThat(client().admin().indices().prepareAliases().addAlias("test", "alias" + i).execute().actionGet().isAcknowledged(), equalTo(true));
            client().index(indexRequest("alias" + i).type("type1").id("1").source(source("1", "test")).refresh(true)).actionGet();
        }
    }

commonMethod: 
(startLine=264 endLine=273 srcPath=/root/NewExperiment/elasticsearchFilter/00964/src/test/java/org/elasticsearch/AbstractSharedClusterTest.java)
    public ClusterHealthStatus ensureGreen() {
        ClusterHealthResponse actionGet = client().admin().cluster()
                .health(Requests.clusterHealthRequest().waitForGreenStatus().waitForEvents(Priority.LANGUID).waitForRelocatingShards(0)).actionGet();
        if (actionGet.isTimedOut()) {
            logger.info("ensureGreen timed out, cluster state:\n{}\n{}", client().admin().cluster().prepareState().get().getState().prettyPrint(), client().admin().cluster().preparePendingClusterTasks().get().prettyPrint());
            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false));
        }
        assertThat(actionGet.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        return actionGet.getStatus();
    }


, Instance #
frags: 
(startLine=563 endLine=590 srcPath=/root/NewExperiment/elasticsearchFilter/00973/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java)
    private void updateMappingOnMaster(final String index, final String type) {
        try {
            MapperService mapperService = indicesService.indexServiceSafe(index).mapperService();
            final DocumentMapper documentMapper = mapperService.documentMapper(type);
            if (documentMapper == null) { // should not happen
                return;
            }
            documentMapper.refreshSource();

            mappingUpdatedAction.execute(new MappingUpdatedAction.MappingUpdatedRequest(index, type, documentMapper.mappingSource()), new ActionListener<MappingUpdatedAction.MappingUpdatedResponse>() {
                @Override
                public void onResponse(MappingUpdatedAction.MappingUpdatedResponse mappingUpdatedResponse) {
                    // all is well
                }

                @Override
                public void onFailure(Throwable e) {
                    try {
                        logger.warn("failed to update master on updated mapping for index [{}], type [{}] and source [{}]", e, index, type, documentMapper.mappingSource().string());
                    } catch (IOException e1) {
                        // ignore
                    }
                }
            });
        } catch (Throwable e) {
            logger.warn("failed to update master on updated mapping for index [{}], type [{}]", e, index, type);
        }
    }

(startLine=264 endLine=289 srcPath=/root/NewExperiment/elasticsearchFilter/00973/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java)
        try {
            MapperService mapperService = indicesService.indexServiceSafe(request.index()).mapperService();
            final DocumentMapper documentMapper = mapperService.documentMapper(request.type());
            if (documentMapper == null) { // should not happen
                return;
            }
            documentMapper.refreshSource();
            logger.trace("Sending mapping updated to master: index [{}] type [{}]", request.index(), request.type());
            mappingUpdatedAction.execute(new MappingUpdatedAction.MappingUpdatedRequest(request.index(), request.type(), documentMapper.mappingSource()), new ActionListener<MappingUpdatedAction.MappingUpdatedResponse>() {
                @Override
                public void onResponse(MappingUpdatedAction.MappingUpdatedResponse mappingUpdatedResponse) {
                    // all is well
                    latch.countDown();
                }

                @Override
                public void onFailure(Throwable e) {
                    latch.countDown();
                    try {
                        logger.warn("Failed to update master on updated mapping for index [" + request.index() + "], type [" + request.type() + "] and source [" + documentMapper.mappingSource().string() + "]", e);
                    } catch (IOException e1) {
                        // ignore
                    }
                }
            });
        } catch (Exception e) {

commonMethod: 
(startLine=222 endLine=224 srcPath=/root/NewExperiment/elasticsearchFilter/00974/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java)
    public String uuid() {
        return settings.get(SETTING_UUID, INDEX_UUID_NA_VALUE);
    }


, Instance #
frags: 
(startLine=563 endLine=590 srcPath=/root/NewExperiment/elasticsearchFilter/00973/src/main/java/org/elasticsearch/action/bulk/TransportShardBulkAction.java)
    private void updateMappingOnMaster(final String index, final String type) {
        try {
            MapperService mapperService = indicesService.indexServiceSafe(index).mapperService();
            final DocumentMapper documentMapper = mapperService.documentMapper(type);
            if (documentMapper == null) { // should not happen
                return;
            }
            documentMapper.refreshSource();

            mappingUpdatedAction.execute(new MappingUpdatedAction.MappingUpdatedRequest(index, type, documentMapper.mappingSource()), new ActionListener<MappingUpdatedAction.MappingUpdatedResponse>() {
                @Override
                public void onResponse(MappingUpdatedAction.MappingUpdatedResponse mappingUpdatedResponse) {
                    // all is well
                }

                @Override
                public void onFailure(Throwable e) {
                    try {
                        logger.warn("failed to update master on updated mapping for index [{}], type [{}] and source [{}]", e, index, type, documentMapper.mappingSource().string());
                    } catch (IOException e1) {
                        // ignore
                    }
                }
            });
        } catch (Throwable e) {
            logger.warn("failed to update master on updated mapping for index [{}], type [{}]", e, index, type);
        }
    }

(startLine=264 endLine=289 srcPath=/root/NewExperiment/elasticsearchFilter/00973/src/main/java/org/elasticsearch/action/index/TransportIndexAction.java)
        try {
            MapperService mapperService = indicesService.indexServiceSafe(request.index()).mapperService();
            final DocumentMapper documentMapper = mapperService.documentMapper(request.type());
            if (documentMapper == null) { // should not happen
                return;
            }
            documentMapper.refreshSource();
            logger.trace("Sending mapping updated to master: index [{}] type [{}]", request.index(), request.type());
            mappingUpdatedAction.execute(new MappingUpdatedAction.MappingUpdatedRequest(request.index(), request.type(), documentMapper.mappingSource()), new ActionListener<MappingUpdatedAction.MappingUpdatedResponse>() {
                @Override
                public void onResponse(MappingUpdatedAction.MappingUpdatedResponse mappingUpdatedResponse) {
                    // all is well
                    latch.countDown();
                }

                @Override
                public void onFailure(Throwable e) {
                    latch.countDown();
                    try {
                        logger.warn("Failed to update master on updated mapping for index [" + request.index() + "], type [" + request.type() + "] and source [" + documentMapper.mappingSource().string() + "]", e);
                    } catch (IOException e1) {
                        // ignore
                    }
                }
            });
        } catch (Exception e) {

commonMethod: 
(startLine=235 endLine=240 srcPath=/root/NewExperiment/elasticsearchFilter/00974/src/main/java/org/elasticsearch/cluster/metadata/IndexMetaData.java)
        assert uuid() != null;
        if (INDEX_UUID_NA_VALUE.equals(otherUUID) || INDEX_UUID_NA_VALUE.equals(uuid())) {
            return true;
        }
        return otherUUID.equals(getUUID());
    }


, Instance #
frags: 
(startLine=311 endLine=317 srcPath=/root/NewExperiment/elasticsearchFilter/00984/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java)
    public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        long now = context == null ? System.currentTimeMillis() : context.nowInMillis();
        return NumericRangeQuery.newLongRange(names.indexName(), precisionStep,
                lowerTerm == null ? null : dateMathParser.parse(convertToString(lowerTerm), now),
                upperTerm == null ? null : (includeUpper && parseUpperInclusive) ? dateMathParser.parseUpperInclusive(convertToString(upperTerm), now) : dateMathParser.parse(convertToString(upperTerm), now),
                includeLower, includeUpper);
    }

(startLine=320 endLine=326 srcPath=/root/NewExperiment/elasticsearchFilter/00984/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java)
    public Filter rangeFilter(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        long now = context == null ? System.currentTimeMillis() : context.nowInMillis();
        return NumericRangeFilter.newLongRange(names.indexName(), precisionStep,
                lowerTerm == null ? null : dateMathParser.parse(convertToString(lowerTerm), now),
                upperTerm == null ? null : (includeUpper && parseUpperInclusive) ? dateMathParser.parseUpperInclusive(convertToString(upperTerm), now) : dateMathParser.parse(convertToString(upperTerm), now),
                includeLower, includeUpper);
    }

(startLine=329 endLine=335 srcPath=/root/NewExperiment/elasticsearchFilter/00984/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java)
    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        long now = context == null ? System.currentTimeMillis() : context.nowInMillis();
        return NumericRangeFieldDataFilter.newLongRange((IndexNumericFieldData<?>) fieldData.getForField(this),
                lowerTerm == null ? null : dateMathParser.parse(convertToString(lowerTerm), now),
                upperTerm == null ? null : (includeUpper && parseUpperInclusive) ? dateMathParser.parseUpperInclusive(convertToString(upperTerm), now) : dateMathParser.parse(convertToString(upperTerm), now),
                includeLower, includeUpper);
    }

commonMethod: 
(startLine=302 endLine=304 srcPath=/root/NewExperiment/elasticsearchFilter/00985/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java)
    public long parseToMilliseconds(Object value, @Nullable QueryParseContext context) {
        return parseToMilliseconds(value, context, false);
    }


, Instance #
frags: 
(startLine=311 endLine=317 srcPath=/root/NewExperiment/elasticsearchFilter/00984/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java)
    public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        long now = context == null ? System.currentTimeMillis() : context.nowInMillis();
        return NumericRangeQuery.newLongRange(names.indexName(), precisionStep,
                lowerTerm == null ? null : dateMathParser.parse(convertToString(lowerTerm), now),
                upperTerm == null ? null : (includeUpper && parseUpperInclusive) ? dateMathParser.parseUpperInclusive(convertToString(upperTerm), now) : dateMathParser.parse(convertToString(upperTerm), now),
                includeLower, includeUpper);
    }

(startLine=320 endLine=326 srcPath=/root/NewExperiment/elasticsearchFilter/00984/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java)
    public Filter rangeFilter(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        long now = context == null ? System.currentTimeMillis() : context.nowInMillis();
        return NumericRangeFilter.newLongRange(names.indexName(), precisionStep,
                lowerTerm == null ? null : dateMathParser.parse(convertToString(lowerTerm), now),
                upperTerm == null ? null : (includeUpper && parseUpperInclusive) ? dateMathParser.parseUpperInclusive(convertToString(upperTerm), now) : dateMathParser.parse(convertToString(upperTerm), now),
                includeLower, includeUpper);
    }

(startLine=329 endLine=335 srcPath=/root/NewExperiment/elasticsearchFilter/00984/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java)
    public Filter rangeFilter(IndexFieldDataService fieldData, Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, @Nullable QueryParseContext context) {
        long now = context == null ? System.currentTimeMillis() : context.nowInMillis();
        return NumericRangeFieldDataFilter.newLongRange((IndexNumericFieldData<?>) fieldData.getForField(this),
                lowerTerm == null ? null : dateMathParser.parse(convertToString(lowerTerm), now),
                upperTerm == null ? null : (includeUpper && parseUpperInclusive) ? dateMathParser.parseUpperInclusive(convertToString(upperTerm), now) : dateMathParser.parse(convertToString(upperTerm), now),
                includeLower, includeUpper);
    }

commonMethod: 
(startLine=306 endLine=309 srcPath=/root/NewExperiment/elasticsearchFilter/00985/src/main/java/org/elasticsearch/index/mapper/core/DateFieldMapper.java)
    public long parseToMilliseconds(Object value, @Nullable QueryParseContext context, boolean includeUpper) {
        long now = context == null ? System.currentTimeMillis() : context.nowInMillis();
        return includeUpper ? dateMathParser.parseUpperInclusive(convertToString(value), now) : dateMathParser.parse(convertToString(value), now);
    }


, Instance #
frags: 
(startLine=289 endLine=300 srcPath=/root/NewExperiment/elasticsearchFilter/00991/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexStateService.java)
        public void onIndexStateUpdated(NodeIndicesStateUpdatedAction.NodeIndexStateUpdatedResponse response) {
            if (version <= response.version()) {
                logger.trace("Received NodeIndexStateUpdatedResponse with version [{}] from [{}]", response.version(), response.nodeId());
                if (countDown.decrementAndGet() == 0) {
                    indicesStateUpdatedAction.remove(this);
                    if (notified.compareAndSet(false, true)) {
                        logger.trace("NodeIndexStateUpdated was acknowledged by all expected nodes, returning");
                        listener.onResponse(new Response(true));
                    }
                }
            }
        }

(startLine=258 endLine=269 srcPath=/root/NewExperiment/elasticsearchFilter/00991/src/main/java/org/elasticsearch/cluster/metadata/MetaDataIndexAliasesService.java)
        public void onAliasesUpdated(NodeAliasesUpdatedAction.NodeAliasesUpdatedResponse response) {
            if (version <= response.version()) {
                logger.trace("Received NodeAliasesUpdatedResponse with version [{}] from [{}]", response.version(), response.nodeId());
                if (countDown.decrementAndGet() == 0) {
                    aliasOperationPerformedAction.remove(this);
                    if (notified.compareAndSet(false, true)) {
                        logger.trace("NodeAliasUpdated was acknowledged by all expected nodes, returning");
                        listener.onResponse(new Response(true));
                    }
                }
            }
        }

commonMethod: 
(startLine=45 endLine=61 srcPath=/root/NewExperiment/elasticsearchFilter/00992/src/main/java/org/elasticsearch/common/util/concurrent/CountDown.java)
    /**
     * Decrements the count-down and returns <code>true</code> iff this call
     * reached zero otherwise <code>false</code>
     */
    public boolean countDown() {
        assert originalCount > 0;
        for (;;) {
            final int current = countDown.get();
            assert current >= 0;
            if (current == 0) {
                return false;
            }
            if (countDown.compareAndSet(current, current - 1)) {
                return current == 1;
            }
        }
    }


, Instance #
frags: 
(startLine=97 endLine=120 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/search/geo/InMemoryGeoBoundingBoxFilter.java)
        protected boolean matchDoc(int doc) {
            if (!values.hasValue(doc)) {
                return false;
            }

            if (values.isMultiValued()) {
                GeoPointValues.Iter iter = values.getIter(doc);
                while (iter.hasNext()) {
                    GeoPoint point = iter.next();
                    if (((topLeft.lon() <= point.lon() || bottomRight.lon() >= point.lon())) &&
                            (topLeft.lat() >= point.lat() && bottomRight.lat() <= point.lat())) {
                        return true;
                    }
                }
            } else {
                GeoPoint point = values.getValue(doc);

                if (((topLeft.lon() <= point.lon() || bottomRight.lon() >= point.lon())) &&
                        (topLeft.lat() >= point.lat() && bottomRight.lat() <= point.lat())) {
                    return true;
                }
            }
            return false;
        }

(startLine=141 endLine=163 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/search/geo/InMemoryGeoBoundingBoxFilter.java)
        protected boolean matchDoc(int doc) {
            if (!values.hasValue(doc)) {
                return false;
            }

            if (values.isMultiValued()) {
                GeoPointValues.Iter iter = values.getIter(doc);
                while (iter.hasNext()) {
                    GeoPoint point = iter.next();
                    if (topLeft.lon() <= point.lon() && bottomRight.lon() >= point.lon()
                            && topLeft.lat() >= point.lat() && bottomRight.lat() <= point.lat()) {
                        return true;
                    }
                }
            } else {
                GeoPoint point = values.getValue(doc);
                if (topLeft.lon() <= point.lon() && bottomRight.lon() >= point.lon()
                        && topLeft.lat() >= point.lat() && bottomRight.lat() <= point.lat()) {
                    return true;
                }
            }
            return false;
        }

commonMethod: 
(startLine=90 endLine=103 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/GeoPointValues.java)
    /**
     * Returns the next value for the current docID set to {@link #setDocument(int)}.
     * This method should only be called <tt>N</tt> times where <tt>N</tt> is the number
     * returned from {@link #setDocument(int)}. If called more than <tt>N</tt> times the behavior
     * is undefined.
     *
     * Note: the returned {@link GeoPoint} might be shared across invocations.
     *
     * @return the next value for the current docID set to {@link #setDocument(int)}.
     */
    public GeoPoint nextValue() {
        assert docId != -1;
        return getValue(docId);
    }


, Instance #
frags: 
(startLine=50 endLine=94 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
        if (isFloat) {
            final DoubleValues values = getDoubleValues();
            return new BytesValues(values.isMultiValued()) {

                @Override
                public boolean hasValue(int docId) {
                    return values.hasValue(docId);
                }

                @Override
                public BytesRef getValueScratch(int docId, BytesRef ret) {
                    if (values.hasValue(docId)) {
                        ret.copyChars(Double.toString(values.getValue(docId)));
                    } else {
                        ret.length = 0;
                    }
                    return ret;
                }

                @Override
                public Iter getIter(int docId) {
                    final DoubleValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Double.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }
            };
        } else {

(startLine=94 endLine=138 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
        } else {
            final LongValues values = getLongValues();
            return new BytesValues(values.isMultiValued()) {

                @Override
                public boolean hasValue(int docId) {
                    return values.hasValue(docId);
                }

                @Override
                public BytesRef getValueScratch(int docId, BytesRef ret) {
                    if (values.hasValue(docId)) {
                        ret.copyChars(Long.toString(values.getValue(docId)));
                    } else {
                        ret.length = 0;
                    }
                    return ret;
                }

                @Override
                public Iter getIter(int docId) {
                    final LongValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Long.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }
            };
        }

commonMethod: 
(startLine=98 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/DoubleValues.java)
    /**
     * Sets iteration to the specified docID and returns the number of
     * values for this document ID,
     * @param docId document ID
     *
     * @see #nextValue()
     */
    public int setDocument(int docId) {
        this.docId = docId;
        return hasValue(docId) ?  1 : 0;
    }


, Instance #
frags: 
(startLine=50 endLine=94 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
        if (isFloat) {
            final DoubleValues values = getDoubleValues();
            return new BytesValues(values.isMultiValued()) {

                @Override
                public boolean hasValue(int docId) {
                    return values.hasValue(docId);
                }

                @Override
                public BytesRef getValueScratch(int docId, BytesRef ret) {
                    if (values.hasValue(docId)) {
                        ret.copyChars(Double.toString(values.getValue(docId)));
                    } else {
                        ret.length = 0;
                    }
                    return ret;
                }

                @Override
                public Iter getIter(int docId) {
                    final DoubleValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Double.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }
            };
        } else {

(startLine=94 endLine=138 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
        } else {
            final LongValues values = getLongValues();
            return new BytesValues(values.isMultiValued()) {

                @Override
                public boolean hasValue(int docId) {
                    return values.hasValue(docId);
                }

                @Override
                public BytesRef getValueScratch(int docId, BytesRef ret) {
                    if (values.hasValue(docId)) {
                        ret.copyChars(Long.toString(values.getValue(docId)));
                    } else {
                        ret.length = 0;
                    }
                    return ret;
                }

                @Override
                public Iter getIter(int docId) {
                    final LongValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Long.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }
            };
        }

commonMethod: 
(startLine=163 endLine=167 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/DoubleValues.java)
        @Override
        public int setDocument(int docId) {
            this.docId = docId;
            return ordinals.setDocument(docId);
        }


, Instance #
frags: 
(startLine=50 endLine=94 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
        if (isFloat) {
            final DoubleValues values = getDoubleValues();
            return new BytesValues(values.isMultiValued()) {

                @Override
                public boolean hasValue(int docId) {
                    return values.hasValue(docId);
                }

                @Override
                public BytesRef getValueScratch(int docId, BytesRef ret) {
                    if (values.hasValue(docId)) {
                        ret.copyChars(Double.toString(values.getValue(docId)));
                    } else {
                        ret.length = 0;
                    }
                    return ret;
                }

                @Override
                public Iter getIter(int docId) {
                    final DoubleValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Double.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }
            };
        } else {

(startLine=94 endLine=138 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
        } else {
            final LongValues values = getLongValues();
            return new BytesValues(values.isMultiValued()) {

                @Override
                public boolean hasValue(int docId) {
                    return values.hasValue(docId);
                }

                @Override
                public BytesRef getValueScratch(int docId, BytesRef ret) {
                    if (values.hasValue(docId)) {
                        ret.copyChars(Long.toString(values.getValue(docId)));
                    } else {
                        ret.length = 0;
                    }
                    return ret;
                }

                @Override
                public Iter getIter(int docId) {
                    final LongValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Long.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }
            };
        }

commonMethod: 
(startLine=98 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/LongValues.java)
    /**
     * Sets iteration to the specified docID and returns the number of
     * values for this document ID,
     * @param docId document ID
     *
     * @see #nextValue()
     */
    public int setDocument(int docId) {
        this.docId = docId;
        return hasValue(docId) ?  1 : 0;
    }


, Instance #
frags: 
(startLine=50 endLine=94 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
        if (isFloat) {
            final DoubleValues values = getDoubleValues();
            return new BytesValues(values.isMultiValued()) {

                @Override
                public boolean hasValue(int docId) {
                    return values.hasValue(docId);
                }

                @Override
                public BytesRef getValueScratch(int docId, BytesRef ret) {
                    if (values.hasValue(docId)) {
                        ret.copyChars(Double.toString(values.getValue(docId)));
                    } else {
                        ret.length = 0;
                    }
                    return ret;
                }

                @Override
                public Iter getIter(int docId) {
                    final DoubleValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Double.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }
            };
        } else {

(startLine=94 endLine=138 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
        } else {
            final LongValues values = getLongValues();
            return new BytesValues(values.isMultiValued()) {

                @Override
                public boolean hasValue(int docId) {
                    return values.hasValue(docId);
                }

                @Override
                public BytesRef getValueScratch(int docId, BytesRef ret) {
                    if (values.hasValue(docId)) {
                        ret.copyChars(Long.toString(values.getValue(docId)));
                    } else {
                        ret.length = 0;
                    }
                    return ret;
                }

                @Override
                public Iter getIter(int docId) {
                    final LongValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Long.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }
            };
        }

commonMethod: 
(startLine=163 endLine=167 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/LongValues.java)
        @Override
        public int setDocument(int docId) {
            this.docId = docId;
            return ordinals.setDocument(docId);
        }


, Instance #
frags: 
(startLine=184 endLine=196 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceFilter.java)
            if (values.isMultiValued()) {
                GeoPointValues.Iter iter = values.getIter(doc);
                while (iter.hasNext()) {
                    GeoPoint point = iter.next();
                    if (distanceBoundingCheck.isWithin(point.lat(), point.lon())) {
                        double d = fixedSourceDistance.calculate(point.lat(), point.lon());
                        if (d < distance) {
                            return true;
                        }
                    }
                }
                return false;
            } else {

(startLine=202 endLine=214 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceRangeFilter.java)
            if (values.isMultiValued()) {
                GeoPointValues.Iter iter = values.getIter(doc);
                while (iter.hasNext()) {
                    GeoPoint point = iter.next();
                    if (distanceBoundingCheck.isWithin(point.lat(), point.lon())) {
                        double d = fixedSourceDistance.calculate(point.lat(), point.lon());
                        if (d >= inclusiveLowerPoint && d <= inclusiveUpperPoint) {
                            return true;
                        }
                    }
                }
                return false;
            } else {

commonMethod: 
(startLine=79 endLine=89 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/GeoPointValues.java)
    /**
     * Sets iteration to the specified docID and returns the number of
     * values for this document ID,
     * @param docId document ID
     *
     * @see #nextValue()
     */
    public int setDocument(int docId) {
        this.docId = docId;
        return hasValue(docId) ? 1 : 0;
    }


, Instance #
frags: 
(startLine=184 endLine=196 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceFilter.java)
            if (values.isMultiValued()) {
                GeoPointValues.Iter iter = values.getIter(doc);
                while (iter.hasNext()) {
                    GeoPoint point = iter.next();
                    if (distanceBoundingCheck.isWithin(point.lat(), point.lon())) {
                        double d = fixedSourceDistance.calculate(point.lat(), point.lon());
                        if (d < distance) {
                            return true;
                        }
                    }
                }
                return false;
            } else {

(startLine=202 endLine=214 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/search/geo/GeoDistanceRangeFilter.java)
            if (values.isMultiValued()) {
                GeoPointValues.Iter iter = values.getIter(doc);
                while (iter.hasNext()) {
                    GeoPoint point = iter.next();
                    if (distanceBoundingCheck.isWithin(point.lat(), point.lon())) {
                        double d = fixedSourceDistance.calculate(point.lat(), point.lon());
                        if (d >= inclusiveLowerPoint && d <= inclusiveUpperPoint) {
                            return true;
                        }
                    }
                }
                return false;
            } else {

commonMethod: 
(startLine=90 endLine=103 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/GeoPointValues.java)
    /**
     * Returns the next value for the current docID set to {@link #setDocument(int)}.
     * This method should only be called <tt>N</tt> times where <tt>N</tt> is the number
     * returned from {@link #setDocument(int)}. If called more than <tt>N</tt> times the behavior
     * is undefined.
     *
     * Note: the returned {@link GeoPoint} might be shared across invocations.
     *
     * @return the next value for the current docID set to {@link #setDocument(int)}.
     */
    public GeoPoint nextValue() {
        assert docId != -1;
        return getValue(docId);
    }


, Instance #
frags: 
(startLine=102 endLine=111 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/search/geo/InMemoryGeoBoundingBoxFilter.java)
            if (values.isMultiValued()) {
                GeoPointValues.Iter iter = values.getIter(doc);
                while (iter.hasNext()) {
                    GeoPoint point = iter.next();
                    if (((topLeft.lon() <= point.lon() || bottomRight.lon() >= point.lon())) &&
                            (topLeft.lat() >= point.lat() && bottomRight.lat() <= point.lat())) {
                        return true;
                    }
                }
            } else {

(startLine=146 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/search/geo/InMemoryGeoBoundingBoxFilter.java)
            if (values.isMultiValued()) {
                GeoPointValues.Iter iter = values.getIter(doc);
                while (iter.hasNext()) {
                    GeoPoint point = iter.next();
                    if (topLeft.lon() <= point.lon() && bottomRight.lon() >= point.lon()
                            && topLeft.lat() >= point.lat() && bottomRight.lat() <= point.lat()) {
                        return true;
                    }
                }
            } else {

commonMethod: 
(startLine=79 endLine=89 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/GeoPointValues.java)
    /**
     * Sets iteration to the specified docID and returns the number of
     * values for this document ID,
     * @param docId document ID
     *
     * @see #nextValue()
     */
    public int setDocument(int docId) {
        this.docId = docId;
        return hasValue(docId) ? 1 : 0;
    }


, Instance #
frags: 
(startLine=102 endLine=111 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/search/geo/InMemoryGeoBoundingBoxFilter.java)
            if (values.isMultiValued()) {
                GeoPointValues.Iter iter = values.getIter(doc);
                while (iter.hasNext()) {
                    GeoPoint point = iter.next();
                    if (((topLeft.lon() <= point.lon() || bottomRight.lon() >= point.lon())) &&
                            (topLeft.lat() >= point.lat() && bottomRight.lat() <= point.lat())) {
                        return true;
                    }
                }
            } else {

(startLine=146 endLine=155 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/search/geo/InMemoryGeoBoundingBoxFilter.java)
            if (values.isMultiValued()) {
                GeoPointValues.Iter iter = values.getIter(doc);
                while (iter.hasNext()) {
                    GeoPoint point = iter.next();
                    if (topLeft.lon() <= point.lon() && bottomRight.lon() >= point.lon()
                            && topLeft.lat() >= point.lat() && bottomRight.lat() <= point.lat()) {
                        return true;
                    }
                }
            } else {

commonMethod: 
(startLine=90 endLine=103 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/GeoPointValues.java)
    /**
     * Returns the next value for the current docID set to {@link #setDocument(int)}.
     * This method should only be called <tt>N</tt> times where <tt>N</tt> is the number
     * returned from {@link #setDocument(int)}. If called more than <tt>N</tt> times the behavior
     * is undefined.
     *
     * Note: the returned {@link GeoPoint} might be shared across invocations.
     *
     * @return the next value for the current docID set to {@link #setDocument(int)}.
     */
    public GeoPoint nextValue() {
        assert docId != -1;
        return getValue(docId);
    }


, Instance #
frags: 
(startLine=70 endLine=92 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
                public Iter getIter(int docId) {
                    final DoubleValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Double.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }

(startLine=114 endLine=136 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
                public Iter getIter(int docId) {
                    final LongValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Long.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }

commonMethod: 
(startLine=98 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/LongValues.java)
    /**
     * Sets iteration to the specified docID and returns the number of
     * values for this document ID,
     * @param docId document ID
     *
     * @see #nextValue()
     */
    public int setDocument(int docId) {
        this.docId = docId;
        return hasValue(docId) ?  1 : 0;
    }


, Instance #
frags: 
(startLine=70 endLine=92 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
                public Iter getIter(int docId) {
                    final DoubleValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Double.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }

(startLine=114 endLine=136 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
                public Iter getIter(int docId) {
                    final LongValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Long.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }

commonMethod: 
(startLine=163 endLine=167 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/LongValues.java)
        @Override
        public int setDocument(int docId) {
            this.docId = docId;
            return ordinals.setDocument(docId);
        }


, Instance #
frags: 
(startLine=70 endLine=92 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
                public Iter getIter(int docId) {
                    final DoubleValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Double.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }

(startLine=114 endLine=136 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
                public Iter getIter(int docId) {
                    final LongValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Long.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }

commonMethod: 
(startLine=110 endLine=120 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/LongValues.java)
    /**
     * Returns the next value for the current docID set to {@link #setDocument(int)}.
     * This method should only be called <tt>N</tt> times where <tt>N</tt> is the number
     * returned from {@link #setDocument(int)}. If called more than <tt>N</tt> times the behavior
     * is undefined.
     *
     * @return the next value for the current docID set to {@link #setDocument(int)}.
     */
    public long nextValue() {
        return getValue(docId);
    }


, Instance #
frags: 
(startLine=70 endLine=92 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
                public Iter getIter(int docId) {
                    final DoubleValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Double.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }

(startLine=114 endLine=136 srcPath=/root/NewExperiment/elasticsearchFilter/00994/src/main/java/org/elasticsearch/index/fielddata/AbstractAtomicNumericFieldData.java)
                public Iter getIter(int docId) {
                    final LongValues.Iter iter = values.getIter(docId);
                    return new BytesValues.Iter() {
                        private final BytesRef spare = new BytesRef();

                        @Override
                        public boolean hasNext() {
                            return iter.hasNext();
                        }

                        @Override
                        public BytesRef next() {
                            spare.copyChars(Long.toString(iter.next()));
                            return spare;
                        }

                        @Override
                        public int hash() {
                            return spare.hashCode();
                        }

                    };
                }

commonMethod: 
(startLine=169 endLine=172 srcPath=/root/NewExperiment/elasticsearchFilter/00995/src/main/java/org/elasticsearch/index/fielddata/LongValues.java)
        @Override
        public long nextValue() {
            return getValueByOrd(ordinals.nextOrd());
        }


]