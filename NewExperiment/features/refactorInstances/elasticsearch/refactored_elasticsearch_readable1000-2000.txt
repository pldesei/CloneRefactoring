[Instance #
frags: 
(startLine=154 endLine=186 srcPath=/root/NewExperiment/elasticsearchFilter/01006/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            spare.reset(values.getValue(doc), values.currentValueHash());
            Query query = queries.get(spare);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                if (context.highlight() != null) {
                    context.parsedQuery(new ParsedQuery(query, ImmutableMap.<String, Filter>of()));
                    context.hitContext().cache().clear();
                }

                searcher.search(query, collector);
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(values.copyShared());
                        if (context.highlight() != null) {
                            highlightPhase.hitExecute(context, context.hitContext());
                            hls.add(context.hitContext().hit().getHighlightFields());
                        }
                    }
                    counter++;
                    if (facetCollector != null) {
                        facetCollector.collect(doc);
                    }
                }
            } catch (IOException e) {
                logger.warn("[" + spare.bytes.utf8ToString() + "] failed to execute query", e);
            }
        }

(startLine=275 endLine=307 srcPath=/root/NewExperiment/elasticsearchFilter/01006/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            spare.reset(values.getValue(doc), values.currentValueHash());
            Query query = queries.get(spare);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                if (context.highlight() != null) {
                    context.parsedQuery(new ParsedQuery(query, ImmutableMap.<String, Filter>of()));
                    context.hitContext().cache().clear();
                }
                searcher.search(query, collector);
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(values.copyShared());
                        scores.add(scorer.score());
                        if (context.highlight() != null) {
                            highlightPhase.hitExecute(context, context.hitContext());
                            hls.add(context.hitContext().hit().getHighlightFields());
                        }
                    }
                    counter++;
                    if (facetCollector != null) {
                        facetCollector.collect(doc);
                    }
                }
            } catch (IOException e) {
                logger.warn("[" + spare.bytes.utf8ToString() + "] failed to execute query", e);
            }
        }

commonMethod: 
(startLine=135 endLine=143 srcPath=/root/NewExperiment/elasticsearchFilter/01007/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
    protected final Query getQuery(int doc) {
        final int numValues = values.setDocument(doc);
        if (numValues == 0) {
            return null;
        }
        assert numValues == 1;
        spare.reset(values.nextValue(), values.currentValueHash());
        return queries.get(spare);
    }


, Instance #
frags: 
(startLine=212 endLine=232 srcPath=/root/NewExperiment/elasticsearchFilter/01006/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            spare.reset(values.getValue(doc), values.currentValueHash());
            Query query = queries.get(spare);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                searcher.search(query, collector);
                if (collector.exists()) {
                    topDocsCollector.collect(doc);
                    if (facetCollector != null) {
                        facetCollector.collect(doc);
                    }
                }
            } catch (IOException e) {
                logger.warn("[" + spare.bytes.utf8ToString() + "] failed to execute query", e);
            }
        }

(startLine=340 endLine=360 srcPath=/root/NewExperiment/elasticsearchFilter/01006/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            spare.reset(values.getValue(doc), values.currentValueHash());
            Query query = queries.get(spare);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                searcher.search(query, collector);
                if (collector.exists()) {
                    counter++;
                    if (facetCollector != null) {
                        facetCollector.collect(doc);
                    }
                }
            } catch (IOException e) {
                logger.warn("[" + spare.bytes.utf8ToString() + "] failed to execute query", e);
            }
        }

commonMethod: 
(startLine=135 endLine=143 srcPath=/root/NewExperiment/elasticsearchFilter/01007/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
    protected final Query getQuery(int doc) {
        final int numValues = values.setDocument(doc);
        if (numValues == 0) {
            return null;
        }
        assert numValues == 1;
        spare.reset(values.nextValue(), values.currentValueHash());
        return queries.get(spare);
    }


, Instance #
frags: 
(startLine=433 endLine=480 srcPath=/root/NewExperiment/elasticsearchFilter/01024/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java)
    public void testSourceLookupHighlightingUsingPlainHighlighter() throws Exception {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 2))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        // we don't store title and don't use term vector, now lets see if it works...
                        .startObject("title").field("type", "string").field("store", "no").field("term_vector", "no").endObject()
                        .startObject("attachments").startObject("properties").startObject("body").field("type", "string").field("store", "no").field("term_vector", "no").endObject().endObject().endObject()
                        .endObject().endObject().endObject())
                .execute().actionGet();
        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();

        for (int i = 0; i < 5; i++) {
            client().prepareIndex("test", "type1", Integer.toString(i))
                    .setSource(XContentFactory.jsonBuilder().startObject()
                            .field("title", "This is a test on the highlighting bug present in elasticsearch")
                            .startArray("attachments").startObject().field("body", "attachment 1").endObject().startObject().field("body", "attachment 2").endObject().endArray()
                            .endObject())
                    .setRefresh(true).execute().actionGet();
        }

        SearchResponse search = client().prepareSearch()
                .setQuery(fieldQuery("title", "bug"))
                .addHighlightedField("title", -1, 0)
                .execute().actionGet();

        assertNoFailures(search);

        assertThat(search.getHits().totalHits(), equalTo(5l));
        assertThat(search.getHits().hits().length, equalTo(5));

        for (SearchHit hit : search.getHits()) {
            assertThat(hit.highlightFields().get("title").fragments()[0].string(), equalTo("This is a test on the highlighting <em>bug</em> present in elasticsearch"));
        }

        search = client().prepareSearch()
                .setQuery(fieldQuery("attachments.body", "attachment"))
                .addHighlightedField("attachments.body", -1, 0)
                .execute().actionGet();

        assertNoFailures(search);

        assertThat(search.getHits().totalHits(), equalTo(5l));
        assertThat(search.getHits().hits().length, equalTo(5));

        for (SearchHit hit : search.getHits()) {
            assertThat(hit.highlightFields().get("attachments.body").fragments()[0].string(), equalTo("<em>attachment</em> 1"));
            assertThat(hit.highlightFields().get("attachments.body").fragments()[1].string(), equalTo("<em>attachment</em> 2"));
        }
    }

(startLine=483 endLine=530 srcPath=/root/NewExperiment/elasticsearchFilter/01024/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java)
    public void testSourceLookupHighlightingUsingFastVectorHighlighter() throws Exception {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 2))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        // we don't store title, now lets see if it works...
                        .startObject("title").field("type", "string").field("store", "no").field("term_vector", "with_positions_offsets").endObject()
                        .startObject("attachments").startObject("properties").startObject("body").field("type", "string").field("store", "no").field("term_vector", "with_positions_offsets").endObject().endObject().endObject()
                        .endObject().endObject().endObject())
                .execute().actionGet();
        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();

        for (int i = 0; i < 5; i++) {
            client().prepareIndex("test", "type1", Integer.toString(i))
                    .setSource(XContentFactory.jsonBuilder().startObject()
                            .field("title", "This is a test on the highlighting bug present in elasticsearch")
                            .startArray("attachments").startObject().field("body", "attachment 1").endObject().startObject().field("body", "attachment 2").endObject().endArray()
                            .endObject())
                    .setRefresh(true).execute().actionGet();
        }

        SearchResponse search = client().prepareSearch()
                .setQuery(fieldQuery("title", "bug"))
                .addHighlightedField("title", -1, 0)
                .execute().actionGet();

        assertNoFailures(search);

        assertThat(search.getHits().totalHits(), equalTo(5l));
        assertThat(search.getHits().hits().length, equalTo(5));

        for (SearchHit hit : search.getHits()) {
            assertThat(hit.highlightFields().get("title").fragments()[0].string(), equalTo("This is a test on the highlighting <em>bug</em> present in elasticsearch"));
        }

        search = client().prepareSearch()
                .setQuery(fieldQuery("attachments.body", "attachment"))
                .addHighlightedField("attachments.body", -1, 2)
                .execute().actionGet();

        assertNoFailures(search);

        assertThat(search.getHits().totalHits(), equalTo(5l));
        assertThat(search.getHits().hits().length, equalTo(5));

        for (SearchHit hit : search.getHits()) {
            assertThat(hit.highlightFields().get("attachments.body").fragments()[0].string(), equalTo("<em>attachment</em> 1"));
            assertThat(hit.highlightFields().get("attachments.body").fragments()[1].string(), equalTo("<em>attachment</em> 2"));
        }
    }

commonMethod: 
(startLine=384 endLine=392 srcPath=/root/NewExperiment/elasticsearchFilter/01025/src/test/java/org/elasticsearch/test/AbstractIntegrationTest.java)
    public ClusterHealthStatus ensureYellow() {
        ClusterHealthResponse actionGet = client().admin().cluster()
                .health(Requests.clusterHealthRequest().waitForRelocatingShards(0).waitForYellowStatus().waitForEvents(Priority.LANGUID)).actionGet();
        if (actionGet.isTimedOut()) {
            logger.info("ensureYellow timed out, cluster state:\n{}\n{}", client().admin().cluster().prepareState().get().getState().prettyPrint(), client().admin().cluster().preparePendingClusterTasks().get().prettyPrint());
            assertThat("timed out waiting for yellow", actionGet.isTimedOut(), equalTo(false));
        }
        return actionGet.getStatus();
    }


, Instance #
frags: 
(startLine=443 endLine=450 srcPath=/root/NewExperiment/elasticsearchFilter/01024/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java)
        for (int i = 0; i < 5; i++) {
            client().prepareIndex("test", "type1", Integer.toString(i))
                    .setSource(XContentFactory.jsonBuilder().startObject()
                            .field("title", "This is a test on the highlighting bug present in elasticsearch")
                            .startArray("attachments").startObject().field("body", "attachment 1").endObject().startObject().field("body", "attachment 2").endObject().endArray()
                            .endObject())
                    .setRefresh(true).execute().actionGet();
        }

(startLine=493 endLine=500 srcPath=/root/NewExperiment/elasticsearchFilter/01024/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java)
        for (int i = 0; i < 5; i++) {
            client().prepareIndex("test", "type1", Integer.toString(i))
                    .setSource(XContentFactory.jsonBuilder().startObject()
                            .field("title", "This is a test on the highlighting bug present in elasticsearch")
                            .startArray("attachments").startObject().field("body", "attachment 1").endObject().startObject().field("body", "attachment 2").endObject().endArray()
                            .endObject())
                    .setRefresh(true).execute().actionGet();
        }

commonMethod: 
(startLine=384 endLine=392 srcPath=/root/NewExperiment/elasticsearchFilter/01025/src/test/java/org/elasticsearch/test/AbstractIntegrationTest.java)
    public ClusterHealthStatus ensureYellow() {
        ClusterHealthResponse actionGet = client().admin().cluster()
                .health(Requests.clusterHealthRequest().waitForRelocatingShards(0).waitForYellowStatus().waitForEvents(Priority.LANGUID)).actionGet();
        if (actionGet.isTimedOut()) {
            logger.info("ensureYellow timed out, cluster state:\n{}\n{}", client().admin().cluster().prepareState().get().getState().prettyPrint(), client().admin().cluster().preparePendingClusterTasks().get().prettyPrint());
            assertThat("timed out waiting for yellow", actionGet.isTimedOut(), equalTo(false));
        }
        return actionGet.getStatus();
    }


, Instance #
frags: 
(startLine=923 endLine=949 srcPath=/root/NewExperiment/elasticsearchFilter/01024/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java)
    public void testSameContent() throws Exception {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 2))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("title").field("type", "string").field("store", "yes").field("term_vector", "with_positions_offsets").endObject()
                        .endObject().endObject().endObject())
                .execute().actionGet();
        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();

        for (int i = 0; i < 5; i++) {
            client().prepareIndex("test", "type1", Integer.toString(i))
                    .setSource("title", "This is a test on the highlighting bug present in elasticsearch").setRefresh(true).execute().actionGet();
        }

        SearchResponse search = client().prepareSearch()
                .setQuery(fieldQuery("title", "bug"))
                .addHighlightedField("title", -1, 0)
                .execute().actionGet();

        assertThat(search.getHits().totalHits(), equalTo(5l));
        assertThat(search.getHits().hits().length, equalTo(5));
        assertThat(search.getFailedShards(), equalTo(0));

        for (SearchHit hit : search.getHits()) {
            // LUCENE 3.1 UPGRADE: Caused adding the space at the end...
            assertThat(hit.highlightFields().get("title").fragments()[0].string(), equalTo("This is a test on the highlighting <em>bug</em> present in elasticsearch"));
        }
    }

(startLine=952 endLine=979 srcPath=/root/NewExperiment/elasticsearchFilter/01024/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java)
    public void testFastVectorHighlighterOffsetParameter() throws Exception {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 2))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("title").field("type", "string").field("store", "yes").field("term_vector", "with_positions_offsets").endObject()
                        .endObject().endObject().endObject())
                .execute().actionGet();
        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();

        for (int i = 0; i < 5; i++) {
            client().prepareIndex("test", "type1", Integer.toString(i))
                    .setSource("title", "This is a test on the highlighting bug present in elasticsearch").setRefresh(true).execute().actionGet();
        }

        SearchResponse search = client().prepareSearch()
                .setQuery(fieldQuery("title", "bug"))
                .addHighlightedField("title", 30, 1, 10)
                .execute().actionGet();

        assertNoFailures(search);

        assertThat(search.getHits().totalHits(), equalTo(5l));
        assertThat(search.getHits().hits().length, equalTo(5));

        for (SearchHit hit : search.getHits()) {
            // LUCENE 3.1 UPGRADE: Caused adding the space at the end...
            assertThat(hit.highlightFields().get("title").fragments()[0].string(), equalTo("highlighting <em>bug</em> present in elasticsearch"));
        }
    }

(startLine=982 endLine=1011 srcPath=/root/NewExperiment/elasticsearchFilter/01024/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java)
    public void testEscapeHtml() throws Exception {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 2))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("title").field("type", "string").field("store", "yes")
                        .endObject().endObject().endObject())
                .execute().actionGet();
        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();

        for (int i = 0; i < 5; i++) {
            client().prepareIndex("test", "type1", Integer.toString(i))
                    .setSource("title", "This is a html escaping highlighting test for *&? elasticsearch").setRefresh(true).execute().actionGet();
        }

        SearchResponse search = client().prepareSearch()
                .setQuery(fieldQuery("title", "test"))
                .setHighlighterEncoder("html")
                .addHighlightedField("title", 50, 1, 10)
                .execute().actionGet();

        assertNoFailures(search);


        assertThat(search.getHits().totalHits(), equalTo(5l));
        assertThat(search.getHits().hits().length, equalTo(5));

        for (SearchHit hit : search.getHits()) {
            // LUCENE 3.1 UPGRADE: Caused adding the space at the end...
            assertThat(hit.highlightFields().get("title").fragments()[0].string(), equalTo("This is a html escaping highlighting <em>test</em> for *&amp;? elasticsearch"));
        }
    }

(startLine=1014 endLine=1042 srcPath=/root/NewExperiment/elasticsearchFilter/01024/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java)
    public void testEscapeHtml_vector() throws Exception {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 2))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("title").field("type", "string").field("store", "yes").field("term_vector", "with_positions_offsets").endObject()
                        .endObject().endObject().endObject())
                .execute().actionGet();
        client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();

        for (int i = 0; i < 5; i++) {
            client().prepareIndex("test", "type1", Integer.toString(i))
                    .setSource("title", "This is a html escaping highlighting test for *&? elasticsearch").setRefresh(true).execute().actionGet();
        }

        SearchResponse search = client().prepareSearch()
                .setQuery(fieldQuery("title", "test"))
                .setHighlighterEncoder("html")
                .addHighlightedField("title", 30, 1, 10)
                .execute().actionGet();


        assertNoFailures(search);

        assertThat(search.getHits().totalHits(), equalTo(5l));
        assertThat(search.getHits().hits().length, equalTo(5));

        for (SearchHit hit : search.getHits()) {
            assertThat(hit.highlightFields().get("title").fragments()[0].string(), equalTo("highlighting <em>test</em> for *&amp;? elasticsearch"));
        }
    }

commonMethod: 
(startLine=384 endLine=392 srcPath=/root/NewExperiment/elasticsearchFilter/01025/src/test/java/org/elasticsearch/test/AbstractIntegrationTest.java)
    public ClusterHealthStatus ensureYellow() {
        ClusterHealthResponse actionGet = client().admin().cluster()
                .health(Requests.clusterHealthRequest().waitForRelocatingShards(0).waitForYellowStatus().waitForEvents(Priority.LANGUID)).actionGet();
        if (actionGet.isTimedOut()) {
            logger.info("ensureYellow timed out, cluster state:\n{}\n{}", client().admin().cluster().prepareState().get().getState().prettyPrint(), client().admin().cluster().preparePendingClusterTasks().get().prettyPrint());
            assertThat("timed out waiting for yellow", actionGet.isTimedOut(), equalTo(false));
        }
        return actionGet.getStatus();
    }


, Instance #
frags: 
(startLine=564 endLine=569 srcPath=/root/NewExperiment/elasticsearchFilter/01024/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java)
        for (SearchHit hit : search.getHits()) {
            Text[] fragments = hit.highlightFields().get("title").fragments();
            assertThat(fragments.length, equalTo(2));
            assertThat(fragments[0].string(), equalTo("This is a test on the highlighting <em>bug</em> present in elasticsearch. Hopefully it works."));
            assertThat(fragments[1].string(), equalTo("This is the second <em>bug</em> to perform highlighting on."));
        }

(startLine=582 endLine=587 srcPath=/root/NewExperiment/elasticsearchFilter/01024/src/test/java/org/elasticsearch/search/highlight/HighlighterSearchTests.java)
        for (SearchHit hit : search.getHits()) {
            Text[] fragments = hit.highlightFields().get("title").fragments();
            assertThat(fragments.length, equalTo(2));
            assertThat(fragments[0].string(), equalTo("This is a test on the highlighting <em>bug</em> present in elasticsearch."));
            assertThat(fragments[1].string(), equalTo("This is the second <em>bug</em> to perform highlighting on."));
        }

commonMethod: 
(startLine=384 endLine=392 srcPath=/root/NewExperiment/elasticsearchFilter/01025/src/test/java/org/elasticsearch/test/AbstractIntegrationTest.java)
    public ClusterHealthStatus ensureYellow() {
        ClusterHealthResponse actionGet = client().admin().cluster()
                .health(Requests.clusterHealthRequest().waitForRelocatingShards(0).waitForYellowStatus().waitForEvents(Priority.LANGUID)).actionGet();
        if (actionGet.isTimedOut()) {
            logger.info("ensureYellow timed out, cluster state:\n{}\n{}", client().admin().cluster().prepareState().get().getState().prettyPrint(), client().admin().cluster().preparePendingClusterTasks().get().prettyPrint());
            assertThat("timed out waiting for yellow", actionGet.isTimedOut(), equalTo(false));
        }
        return actionGet.getStatus();
    }


, Instance #
frags: 
(startLine=483 endLine=516 srcPath=/root/NewExperiment/elasticsearchFilter/01052/src/test/java/org/elasticsearch/count/query/SimpleQueryTests.java)
    public void testMatchQueryZeroTermsQuery() throws IOException {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 1))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("field1").field("type", "string").field("analyzer", "classic").endObject()
                        .startObject("field2").field("type", "string").field("analyzer", "classic").endObject()
                        .endObject().endObject().endObject())
                .execute().actionGet();
        client().prepareIndex("test", "type1", "1").setSource("field1", "value1").execute().actionGet();
        client().prepareIndex("test", "type1", "2").setSource("field1", "value2").execute().actionGet();
        client().admin().indices().prepareRefresh("test").execute().actionGet();

        BoolQueryBuilder boolQuery = boolQuery()
                .must(matchQuery("field1", "a").zeroTermsQuery(MatchQueryBuilder.ZeroTermsQuery.NONE))
                .must(matchQuery("field1", "value1").zeroTermsQuery(MatchQueryBuilder.ZeroTermsQuery.NONE));
        CountResponse countResponse = client().prepareCount()
                .setQuery(boolQuery)
                .execute().actionGet();
        assertHitCount(countResponse, 0l);

        boolQuery = boolQuery()
                .must(matchQuery("field1", "a").zeroTermsQuery(MatchQueryBuilder.ZeroTermsQuery.ALL))
                .must(matchQuery("field1", "value1").zeroTermsQuery(MatchQueryBuilder.ZeroTermsQuery.ALL));
        countResponse = client().prepareCount()
                .setQuery(boolQuery)
                .execute().actionGet();
        assertHitCount(countResponse, 1l);

        boolQuery = boolQuery()
                .must(matchQuery("field1", "a").zeroTermsQuery(MatchQueryBuilder.ZeroTermsQuery.ALL));
        countResponse = client().prepareCount()
                .setQuery(boolQuery)
                .execute().actionGet();
        assertHitCount(countResponse, 2l);
    }

(startLine=519 endLine=552 srcPath=/root/NewExperiment/elasticsearchFilter/01052/src/test/java/org/elasticsearch/count/query/SimpleQueryTests.java)
    public void testMultiMatchQueryZeroTermsQuery() throws IOException {
        client().admin().indices().prepareCreate("test").setSettings(ImmutableSettings.settingsBuilder().put("index.number_of_shards", 1))
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("field1").field("type", "string").field("analyzer", "classic").endObject()
                        .startObject("field2").field("type", "string").field("analyzer", "classic").endObject()
                        .endObject().endObject().endObject())
                .execute().actionGet();
        client().prepareIndex("test", "type1", "1").setSource("field1", "value1", "field2", "value2").execute().actionGet();
        client().prepareIndex("test", "type1", "2").setSource("field1", "value3", "field2", "value4").execute().actionGet();
        client().admin().indices().prepareRefresh("test").execute().actionGet();

        BoolQueryBuilder boolQuery = boolQuery()
                .must(multiMatchQuery("a", "field1", "field2").zeroTermsQuery(MatchQueryBuilder.ZeroTermsQuery.NONE))
                .must(multiMatchQuery("value1", "field1", "field2").zeroTermsQuery(MatchQueryBuilder.ZeroTermsQuery.NONE)); // Fields are ORed together
        CountResponse countResponse = client().prepareCount()
                .setQuery(boolQuery)
                .execute().actionGet();
        assertHitCount(countResponse, 0l);

        boolQuery = boolQuery()
                .must(multiMatchQuery("a", "field1", "field2").zeroTermsQuery(MatchQueryBuilder.ZeroTermsQuery.ALL))
                .must(multiMatchQuery("value4", "field1", "field2").zeroTermsQuery(MatchQueryBuilder.ZeroTermsQuery.ALL));
        countResponse = client().prepareCount()
                .setQuery(boolQuery)
                .execute().actionGet();
        assertHitCount(countResponse, 1l);

        boolQuery = boolQuery()
                .must(multiMatchQuery("a", "field1").zeroTermsQuery(MatchQueryBuilder.ZeroTermsQuery.ALL));
        countResponse = client().prepareCount()
                .setQuery(boolQuery)
                .execute().actionGet();
        assertHitCount(countResponse, 2l);
    }

commonMethod: 
(startLine=530 endLine=540 srcPath=/root/NewExperiment/elasticsearchFilter/01053/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java)
    /**
     * Waits for relocations and refreshes all indices in the cluster.
     * @see #waitForRelocation()
     */
    protected final RefreshResponse refresh() {
        waitForRelocation();
        // TODO RANDOMIZE with flush?
        RefreshResponse actionGet = client().admin().indices().prepareRefresh().execute().actionGet();
        assertNoFailures(actionGet);
        return actionGet;
    }


, Instance #
frags: 
(startLine=1803 endLine=1849 srcPath=/root/NewExperiment/elasticsearchFilter/01052/src/test/java/org/elasticsearch/search/query/SimpleQueryTests.java)
    public void testMatchQueryWithSynonyms() throws IOException {
        CreateIndexRequestBuilder builder = prepareCreate("test").setSettings(settingsBuilder()
                .put(SETTING_NUMBER_OF_SHARDS, 1)
                .put(SETTING_NUMBER_OF_REPLICAS, 0)
                .put("index.analysis.analyzer.index.type", "custom")
                .put("index.analysis.analyzer.index.tokenizer", "standard")
                .put("index.analysis.analyzer.index.filter", "lowercase")
                .put("index.analysis.analyzer.search.type", "custom")
                .put("index.analysis.analyzer.search.tokenizer", "standard")

                .putArray("index.analysis.analyzer.search.filter", "lowercase", "synonym")
                .put("index.analysis.filter.synonym.type", "synonym")
                .putArray("index.analysis.filter.synonym.synonyms", "fast, quick"));

        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("test")
                .startObject("properties")
                .startObject("text")
                .field("type", "string")
                .field("index_analyzer", "index")
                .field("search_analyzer", "search")
                .endObject()
                .endObject()
                .endObject().endObject();
        assertAcked(builder.addMapping("test", mapping));
        ensureGreen();
        client().prepareIndex("test", "test", "1").setSource(jsonBuilder().startObject()
                .field("text", "quick brown fox")
                .endObject())
                .execute().actionGet();
        client().admin().indices().prepareRefresh().execute().actionGet();
        SearchResponse searchResponse = client().prepareSearch("test").setQuery(QueryBuilders.matchQuery("text", "quick").operator(MatchQueryBuilder.Operator.AND)).get();
        assertHitCount(searchResponse, 1);
        searchResponse = client().prepareSearch("test").setQuery(QueryBuilders.matchQuery("text", "quick brown").operator(MatchQueryBuilder.Operator.AND)).get();
        assertHitCount(searchResponse, 1);
        searchResponse = client().prepareSearch("test").setQuery(QueryBuilders.matchQuery("text", "fast").operator(MatchQueryBuilder.Operator.AND)).get();
        assertHitCount(searchResponse, 1);

        client().prepareIndex("test", "test", "2").setSource(jsonBuilder().startObject()
                .field("text", "fast brown fox")
                .endObject())
                .execute().actionGet();
        client().admin().indices().prepareRefresh().execute().actionGet();
        searchResponse = client().prepareSearch("test").setQuery(QueryBuilders.matchQuery("text", "quick").operator(MatchQueryBuilder.Operator.AND)).get();
        assertHitCount(searchResponse, 2);
        searchResponse = client().prepareSearch("test").setQuery(QueryBuilders.matchQuery("text", "quick brown").operator(MatchQueryBuilder.Operator.AND)).get();
        assertHitCount(searchResponse, 2);
    }

(startLine=1894 endLine=1940 srcPath=/root/NewExperiment/elasticsearchFilter/01052/src/test/java/org/elasticsearch/search/query/SimpleQueryTests.java)
    public void testQueryStringWithSynonyms() throws IOException {
        CreateIndexRequestBuilder builder = prepareCreate("test").setSettings(settingsBuilder()
                .put(SETTING_NUMBER_OF_SHARDS, 1)
                .put(SETTING_NUMBER_OF_REPLICAS, 0)
                .put("index.analysis.analyzer.index.type", "custom")
                .put("index.analysis.analyzer.index.tokenizer", "standard")
                .put("index.analysis.analyzer.index.filter", "lowercase")
                .put("index.analysis.analyzer.search.type", "custom")
                .put("index.analysis.analyzer.search.tokenizer", "standard")

                .putArray("index.analysis.analyzer.search.filter", "lowercase", "synonym")
                .put("index.analysis.filter.synonym.type", "synonym")
                .putArray("index.analysis.filter.synonym.synonyms", "fast, quick"));

        XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("test")
                .startObject("properties")
                .startObject("text")
                .field("type", "string")
                .field("index_analyzer", "index")
                .field("search_analyzer", "search")
                .endObject()
                .endObject()
                .endObject().endObject();
        assertAcked(builder.addMapping("test", mapping));
        ensureGreen();
        client().prepareIndex("test", "test", "1").setSource(jsonBuilder().startObject()
                .field("text", "quick brown fox")
                .endObject())
                .execute().actionGet();
        client().admin().indices().prepareRefresh().execute().actionGet();
        SearchResponse searchResponse = client().prepareSearch("test").setQuery(QueryBuilders.queryString("quick").defaultField("text").defaultOperator(QueryStringQueryBuilder.Operator.AND)).get();
        assertHitCount(searchResponse, 1);
        searchResponse = client().prepareSearch("test").setQuery(QueryBuilders.queryString("quick brown").defaultField("text").defaultOperator(QueryStringQueryBuilder.Operator.AND)).get();
        assertHitCount(searchResponse, 1);
        searchResponse = client().prepareSearch().setQuery(QueryBuilders.queryString("fast").defaultField("text").defaultOperator(QueryStringQueryBuilder.Operator.AND)).get();
        assertHitCount(searchResponse, 1);

        client().prepareIndex("test", "test", "2").setSource(jsonBuilder().startObject()
                .field("text", "fast brown fox")
                .endObject())
                .execute().actionGet();
        client().admin().indices().prepareRefresh().execute().actionGet();
        searchResponse = client().prepareSearch("test").setQuery(QueryBuilders.queryString("quick").defaultField("text").defaultOperator(QueryStringQueryBuilder.Operator.AND)).get();
        assertHitCount(searchResponse, 2);
        searchResponse = client().prepareSearch("test").setQuery(QueryBuilders.queryString("quick brown").defaultField("text").defaultOperator(QueryStringQueryBuilder.Operator.AND)).get();
        assertHitCount(searchResponse, 2);
    }

commonMethod: 
(startLine=530 endLine=540 srcPath=/root/NewExperiment/elasticsearchFilter/01053/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java)
    /**
     * Waits for relocations and refreshes all indices in the cluster.
     * @see #waitForRelocation()
     */
    protected final RefreshResponse refresh() {
        waitForRelocation();
        // TODO RANDOMIZE with flush?
        RefreshResponse actionGet = client().admin().indices().prepareRefresh().execute().actionGet();
        assertNoFailures(actionGet);
        return actionGet;
    }


, Instance #
frags: 
(startLine=282 endLine=294 srcPath=/root/NewExperiment/elasticsearchFilter/01060/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java)
                if (nextShard != null) {
                    // trace log this exception
                    if (logger.isTraceEnabled()) {
                        if (t != null) {
                            if (shard != null) {
                                logger.trace(shard.shortSummary() + ": Failed to execute [" + request + "]", t);
                            } else {
                                logger.trace(shardIt.shardId() + ": Failed to execute [" + request + "]", t);
                            }
                        }
                    }
                    performFirstPhase(shardIndex, shardIt, nextShard);
                } else {

(startLine=294 endLine=305 srcPath=/root/NewExperiment/elasticsearchFilter/01060/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java)
                } else {
                    // no more shards active, add a failure
                    if (logger.isDebugEnabled()) {
                        if (t != null && !TransportActions.isShardNotAvailableException(t)) {
                            if (shard != null) {
                                logger.debug(shard.shortSummary() + ": Failed to execute [" + request + "]", t);
                            } else {
                                logger.debug(shardIt.shardId() + ": Failed to execute [" + request + "]", t);
                            }
                        }
                    }
                }

commonMethod: 
(startLine=300 endLine=306 srcPath=/root/NewExperiment/elasticsearchFilter/01061/src/main/java/org/elasticsearch/action/search/type/TransportSearchTypeAction.java)
        private String executionFailureMsg(@Nullable ShardRouting shard, final ShardIterator shardIt, SearchRequest request, boolean lastShard) {
            if (shard != null) {
                return shard.shortSummary() + ": Failed to execute [" + request + "] lastShard [" + lastShard + "]";
            } else {
                return shardIt.shardId() + ": Failed to execute [" + request + "] lastShard [" + lastShard + "]";
            }
        }


, Instance #
frags: 
(startLine=426 endLine=464 srcPath=/root/NewExperiment/elasticsearchFilter/01065/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java)
            if (failedShard.state() == INITIALIZING) {
                // the shard is initializing and recovering from another node
                boolean dirty = false;
                // first, we need to cancel the current node that is being initialized
                RoutingNode initializingNode = routingNodes.node(failedShard.currentNodeId());
                if (initializingNode != null) {
                    for (Iterator<MutableShardRouting> it = initializingNode.iterator(); it.hasNext(); ) {
                        MutableShardRouting shardRouting = it.next();
                        if (shardRouting.equals(failedShard)) {
                            dirty = true;
                            it.remove();

                            routingNodes.deassignShard( shardRouting );

                            if (addToIgnoreList) {
                                // make sure we ignore this shard on the relevant node
                                allocation.addIgnoreShardForNode(failedShard.shardId(), failedShard.currentNodeId());
                            }

                            break;
                        }
                    }
                }
                if (dirty) {
                    // now, find the node that we are relocating *from*, and cancel its relocation
                    RoutingNode relocatingFromNode = routingNodes.node(failedShard.relocatingNodeId());
                    if (relocatingFromNode != null) {
                        for (Iterator<MutableShardRouting> it = relocatingFromNode.iterator(); it.hasNext(); ) {
                            MutableShardRouting shardRouting = it.next();
                            if (shardRouting.shardId().equals(failedShard.shardId()) && shardRouting.state() == RELOCATING) {
                                dirty = true;
                                routingNodes.cancelRelocationForShard( shardRouting );
                                break;
                            }
                        }
                    }
                }
                return dirty;
            } else if (failedShard.state() == RELOCATING) {

(startLine=464 endLine=504 srcPath=/root/NewExperiment/elasticsearchFilter/01065/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java)
            } else if (failedShard.state() == RELOCATING) {
                boolean dirty = false;
                // the shard is relocating, meaning its the source the shard is relocating from
                // first, we need to cancel the current relocation from the current node
                // now, find the node that we are recovering from, cancel the relocation, remove it from the node
                // and add it to the unassigned shards list...
                RoutingNode relocatingFromNode = routingNodes.node(failedShard.currentNodeId());
                if (relocatingFromNode != null) {
                    for (Iterator<MutableShardRouting> it = relocatingFromNode.iterator(); it.hasNext(); ) {
                        MutableShardRouting shardRouting = it.next();
                        if (shardRouting.equals(failedShard)) {
                            dirty = true;
                            routingNodes.cancelRelocationForShard( shardRouting );
                            it.remove();
                            if (addToIgnoreList) {
                                // make sure we ignore this shard on the relevant node
                                allocation.addIgnoreShardForNode(failedShard.shardId(), failedShard.currentNodeId());
                            }

                            routingNodes.unassigned().add(new MutableShardRouting(failedShard.index(), failedShard.id(),
                                    null, failedShard.primary(), ShardRoutingState.UNASSIGNED, failedShard.version() + 1));
                            break;
                        }
                    }
                }
                if (dirty) {
                    // next, we need to find the target initializing shard that is recovering from, and remove it...
                    RoutingNode initializingNode = routingNodes.node(failedShard.relocatingNodeId());
                    if (initializingNode != null) {
                        for (Iterator<MutableShardRouting> it = initializingNode.iterator(); it.hasNext(); ) {
                            MutableShardRouting shardRouting = it.next();
                            if (shardRouting.shardId().equals(failedShard.shardId()) && shardRouting.state() == INITIALIZING) {
                                dirty = true;
                                routingNodes.deassignShard( shardRouting );
                                it.remove();
                            }
                        }
                    }
                }
                return dirty;
            } else {

commonMethod: 
(startLine=382 endLine=388 srcPath=/root/NewExperiment/elasticsearchFilter/01066/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java)
    /**
     * Cancels a relocation of a shard that shard must relocating.
     */
    public void cancelRelocation(MutableShardRouting shard) {
        relocatingShards--;
        shard.cancelRelocation();
    }


, Instance #
frags: 
(startLine=426 endLine=464 srcPath=/root/NewExperiment/elasticsearchFilter/01065/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java)
            if (failedShard.state() == INITIALIZING) {
                // the shard is initializing and recovering from another node
                boolean dirty = false;
                // first, we need to cancel the current node that is being initialized
                RoutingNode initializingNode = routingNodes.node(failedShard.currentNodeId());
                if (initializingNode != null) {
                    for (Iterator<MutableShardRouting> it = initializingNode.iterator(); it.hasNext(); ) {
                        MutableShardRouting shardRouting = it.next();
                        if (shardRouting.equals(failedShard)) {
                            dirty = true;
                            it.remove();

                            routingNodes.deassignShard( shardRouting );

                            if (addToIgnoreList) {
                                // make sure we ignore this shard on the relevant node
                                allocation.addIgnoreShardForNode(failedShard.shardId(), failedShard.currentNodeId());
                            }

                            break;
                        }
                    }
                }
                if (dirty) {
                    // now, find the node that we are relocating *from*, and cancel its relocation
                    RoutingNode relocatingFromNode = routingNodes.node(failedShard.relocatingNodeId());
                    if (relocatingFromNode != null) {
                        for (Iterator<MutableShardRouting> it = relocatingFromNode.iterator(); it.hasNext(); ) {
                            MutableShardRouting shardRouting = it.next();
                            if (shardRouting.shardId().equals(failedShard.shardId()) && shardRouting.state() == RELOCATING) {
                                dirty = true;
                                routingNodes.cancelRelocationForShard( shardRouting );
                                break;
                            }
                        }
                    }
                }
                return dirty;
            } else if (failedShard.state() == RELOCATING) {

(startLine=464 endLine=504 srcPath=/root/NewExperiment/elasticsearchFilter/01065/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java)
            } else if (failedShard.state() == RELOCATING) {
                boolean dirty = false;
                // the shard is relocating, meaning its the source the shard is relocating from
                // first, we need to cancel the current relocation from the current node
                // now, find the node that we are recovering from, cancel the relocation, remove it from the node
                // and add it to the unassigned shards list...
                RoutingNode relocatingFromNode = routingNodes.node(failedShard.currentNodeId());
                if (relocatingFromNode != null) {
                    for (Iterator<MutableShardRouting> it = relocatingFromNode.iterator(); it.hasNext(); ) {
                        MutableShardRouting shardRouting = it.next();
                        if (shardRouting.equals(failedShard)) {
                            dirty = true;
                            routingNodes.cancelRelocationForShard( shardRouting );
                            it.remove();
                            if (addToIgnoreList) {
                                // make sure we ignore this shard on the relevant node
                                allocation.addIgnoreShardForNode(failedShard.shardId(), failedShard.currentNodeId());
                            }

                            routingNodes.unassigned().add(new MutableShardRouting(failedShard.index(), failedShard.id(),
                                    null, failedShard.primary(), ShardRoutingState.UNASSIGNED, failedShard.version() + 1));
                            break;
                        }
                    }
                }
                if (dirty) {
                    // next, we need to find the target initializing shard that is recovering from, and remove it...
                    RoutingNode initializingNode = routingNodes.node(failedShard.relocatingNodeId());
                    if (initializingNode != null) {
                        for (Iterator<MutableShardRouting> it = initializingNode.iterator(); it.hasNext(); ) {
                            MutableShardRouting shardRouting = it.next();
                            if (shardRouting.shardId().equals(failedShard.shardId()) && shardRouting.state() == INITIALIZING) {
                                dirty = true;
                                routingNodes.deassignShard( shardRouting );
                                it.remove();
                            }
                        }
                    }
                }
                return dirty;
            } else {

commonMethod: 
(startLine=475 endLine=482 srcPath=/root/NewExperiment/elasticsearchFilter/01066/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java)
    public RoutingNodeIterator routingNodeIter(String nodeId) {
        final RoutingNode routingNode = nodesToShards.get(nodeId);
        if (routingNode == null) {
            return null;
        }
        assert assertShardStats(this);
        return new RoutingNodeIterator(routingNode);
    }


, Instance #
frags: 
(startLine=449 endLine=462 srcPath=/root/NewExperiment/elasticsearchFilter/01065/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java)
                if (dirty) {
                    // now, find the node that we are relocating *from*, and cancel its relocation
                    RoutingNode relocatingFromNode = routingNodes.node(failedShard.relocatingNodeId());
                    if (relocatingFromNode != null) {
                        for (Iterator<MutableShardRouting> it = relocatingFromNode.iterator(); it.hasNext(); ) {
                            MutableShardRouting shardRouting = it.next();
                            if (shardRouting.shardId().equals(failedShard.shardId()) && shardRouting.state() == RELOCATING) {
                                dirty = true;
                                routingNodes.cancelRelocationForShard( shardRouting );
                                break;
                            }
                        }
                    }
                }

(startLine=489 endLine=502 srcPath=/root/NewExperiment/elasticsearchFilter/01065/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java)
                if (dirty) {
                    // next, we need to find the target initializing shard that is recovering from, and remove it...
                    RoutingNode initializingNode = routingNodes.node(failedShard.relocatingNodeId());
                    if (initializingNode != null) {
                        for (Iterator<MutableShardRouting> it = initializingNode.iterator(); it.hasNext(); ) {
                            MutableShardRouting shardRouting = it.next();
                            if (shardRouting.shardId().equals(failedShard.shardId()) && shardRouting.state() == INITIALIZING) {
                                dirty = true;
                                routingNodes.deassignShard( shardRouting );
                                it.remove();
                            }
                        }
                    }
                }

commonMethod: 
(startLine=382 endLine=388 srcPath=/root/NewExperiment/elasticsearchFilter/01066/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java)
    /**
     * Cancels a relocation of a shard that shard must relocating.
     */
    public void cancelRelocation(MutableShardRouting shard) {
        relocatingShards--;
        shard.cancelRelocation();
    }


, Instance #
frags: 
(startLine=449 endLine=462 srcPath=/root/NewExperiment/elasticsearchFilter/01065/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java)
                if (dirty) {
                    // now, find the node that we are relocating *from*, and cancel its relocation
                    RoutingNode relocatingFromNode = routingNodes.node(failedShard.relocatingNodeId());
                    if (relocatingFromNode != null) {
                        for (Iterator<MutableShardRouting> it = relocatingFromNode.iterator(); it.hasNext(); ) {
                            MutableShardRouting shardRouting = it.next();
                            if (shardRouting.shardId().equals(failedShard.shardId()) && shardRouting.state() == RELOCATING) {
                                dirty = true;
                                routingNodes.cancelRelocationForShard( shardRouting );
                                break;
                            }
                        }
                    }
                }

(startLine=489 endLine=502 srcPath=/root/NewExperiment/elasticsearchFilter/01065/src/main/java/org/elasticsearch/cluster/routing/allocation/AllocationService.java)
                if (dirty) {
                    // next, we need to find the target initializing shard that is recovering from, and remove it...
                    RoutingNode initializingNode = routingNodes.node(failedShard.relocatingNodeId());
                    if (initializingNode != null) {
                        for (Iterator<MutableShardRouting> it = initializingNode.iterator(); it.hasNext(); ) {
                            MutableShardRouting shardRouting = it.next();
                            if (shardRouting.shardId().equals(failedShard.shardId()) && shardRouting.state() == INITIALIZING) {
                                dirty = true;
                                routingNodes.deassignShard( shardRouting );
                                it.remove();
                            }
                        }
                    }
                }

commonMethod: 
(startLine=475 endLine=482 srcPath=/root/NewExperiment/elasticsearchFilter/01066/src/main/java/org/elasticsearch/cluster/routing/RoutingNodes.java)
    public RoutingNodeIterator routingNodeIter(String nodeId) {
        final RoutingNode routingNode = nodesToShards.get(nodeId);
        if (routingNode == null) {
            return null;
        }
        assert assertShardStats(this);
        return new RoutingNodeIterator(routingNode);
    }


, Instance #
frags: 
(startLine=88 endLine=98 srcPath=/root/NewExperiment/elasticsearchFilter/01078/src/main/java/org/elasticsearch/rest/action/support/RestTable.java)
        if (verbose) {
            // print the headers
            for (int i = 0; i < width.length; i++) {
                String headerName = table.getHeaders().get(i).value.toString();
                if (displayHeaders.contains(headerName)) {
                    pad(table.getHeaders().get(i), width[i], request, out);
                    out.append(" ");
                }
            }
            out.append("\n");
        }

(startLine=99 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/01078/src/main/java/org/elasticsearch/rest/action/support/RestTable.java)
        for (List<Table.Cell> row : table.getRows()) {
            for (int i = 0; i < width.length; i++) {
                String headerName = table.getHeaders().get(i).value.toString();
                if (displayHeaders.contains(headerName)) {
                    pad(row.get(i), width[i], request, out);
                    out.append(" ");
                }
            }
            out.append("\n");
        }

commonMethod: 
(startLine=150 endLine=160 srcPath=/root/NewExperiment/elasticsearchFilter/01079/src/main/java/org/elasticsearch/common/Table.java)
    public List<Cell> getHeadersFromNames(List<String> headerNames) {
        List<Cell> hdrs = new ArrayList<Cell>();
        for (String hdrToFind : headerNames) {
            for (Cell header : headers) {
                if (((String) header.value).equalsIgnoreCase(hdrToFind)) {
                    hdrs.add(header);
                }
            }
        }
        return hdrs;
    }


, Instance #
frags: 
(startLine=149 endLine=165 srcPath=/root/NewExperiment/elasticsearchFilter/01086/src/main/java/org/elasticsearch/index/query/IndicesFilterParser.java)
    protected boolean matchesIndices(String currentIndex, String... indices) {
        final String[] concreteIndices;
        try {
            concreteIndices = clusterService.state().metaData().concreteIndices(indices, IgnoreIndices.MISSING, true);
        } catch(IndexMissingException e) {
            //Although we use IgnoreIndices.MISSING, according to MetaData#concreteIndices contract,
            // we get IndexMissing either when we have a single index that is missing or when all indices are missing
            return false;
        }

        for (String index : concreteIndices) {
            if (Regex.simpleMatch(index, currentIndex)) {
                return true;
            }
        }
        return false;
    }

(startLine=147 endLine=163 srcPath=/root/NewExperiment/elasticsearchFilter/01086/src/main/java/org/elasticsearch/index/query/IndicesQueryParser.java)
    protected boolean matchesIndices(String currentIndex, String... indices) {
        final String[] concreteIndices;
        try {
            concreteIndices = clusterService.state().metaData().concreteIndices(indices, IgnoreIndices.MISSING, true);
        } catch(IndexMissingException e) {
            //Although we use IgnoreIndices.MISSING, according to MetaData#concreteIndices contract,
            // we get IndexMissing either when we have a single index that is missing or when all indices are missing
            return false;
        }

        for (String index : concreteIndices) {
            if (Regex.simpleMatch(index, currentIndex)) {
                return true;
            }
        }
        return false;
    }

commonMethod: 
(startLine=614 endLine=619 srcPath=/root/NewExperiment/elasticsearchFilter/01087/src/main/java/org/elasticsearch/cluster/metadata/MetaData.java)
    /**
     * Translates the provided indices (possibly aliased) into actual indices.
     */
    public String[] concreteIndicesIgnoreMissing(String[] indices) {
        return concreteIndices(indices, IndicesOptions.fromOptions(true, true, true, false));
    }


, Instance #
frags: 
(startLine=428 endLine=453 srcPath=/root/NewExperiment/elasticsearchFilter/01089/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java)
    private AttributesRoutings getActiveAttribute(AttributesKey key, DiscoveryNodes nodes) {
        AttributesRoutings shardRoutings = activeShardsByAttributes.get(key);
        if (shardRoutings == null) {
            synchronized (shardsByAttributeMutex) {
                ArrayList<ShardRouting> from = new ArrayList<ShardRouting>(activeShards);
                ArrayList<ShardRouting> to = new ArrayList<ShardRouting>();
                for (String attribute : key.attributes) {
                    String localAttributeValue = nodes.localNode().attributes().get(attribute);
                    if (localAttributeValue == null) {
                        continue;
                    }
                    for (Iterator<ShardRouting> iterator = from.iterator(); iterator.hasNext(); ) {
                        ShardRouting fromShard = iterator.next();
                        if (localAttributeValue.equals(nodes.get(fromShard.currentNodeId()).attributes().get(attribute))) {
                            iterator.remove();
                            to.add(fromShard);
                        }
                    }
                }

                shardRoutings = new AttributesRoutings(ImmutableList.copyOf(to), ImmutableList.copyOf(from));
                activeShardsByAttributes = MapBuilder.newMapBuilder(activeShardsByAttributes).put(key, shardRoutings).immutableMap();
            }
        }
        return shardRoutings;
    }

(startLine=455 endLine=480 srcPath=/root/NewExperiment/elasticsearchFilter/01089/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java)
    private AttributesRoutings getInitializingAttribute(AttributesKey key, DiscoveryNodes nodes) {
        AttributesRoutings shardRoutings = initializingShardsByAttributes.get(key);
        if (shardRoutings == null) {
            synchronized (shardsByAttributeMutex) {
                ArrayList<ShardRouting> from = new ArrayList<ShardRouting>(allInitializingShards);
                ArrayList<ShardRouting> to = new ArrayList<ShardRouting>();
                for (String attribute : key.attributes) {
                    String localAttributeValue = nodes.localNode().attributes().get(attribute);
                    if (localAttributeValue == null) {
                        continue;
                    }
                    for (Iterator<ShardRouting> iterator = from.iterator(); iterator.hasNext(); ) {
                        ShardRouting fromShard = iterator.next();
                        if (localAttributeValue.equals(nodes.get(fromShard.currentNodeId()).attributes().get(attribute))) {
                            iterator.remove();
                            to.add(fromShard);
                        }
                    }
                }

                shardRoutings = new AttributesRoutings(ImmutableList.copyOf(to), ImmutableList.copyOf(from));
                initializingShardsByAttributes = MapBuilder.newMapBuilder(initializingShardsByAttributes).put(key, shardRoutings).immutableMap();
            }
        }
        return shardRoutings;
    }

commonMethod: 
(startLine=456 endLine=474 srcPath=/root/NewExperiment/elasticsearchFilter/01090/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java)
    private static ImmutableList<ShardRouting> collectAttributeShards(AttributesKey key, DiscoveryNodes nodes, ArrayList<ShardRouting> from) {
        final ArrayList<ShardRouting> to = new ArrayList<ShardRouting>();
        for (final String attribute : key.attributes) {
            final String localAttributeValue = nodes.localNode().attributes().get(attribute);
            if (localAttributeValue != null) {
                for (Iterator<ShardRouting> iterator = from.iterator(); iterator.hasNext(); ) {
                    ShardRouting fromShard = iterator.next();
                    final DiscoveryNode discoveryNode = nodes.get(fromShard.currentNodeId());
                    if (discoveryNode == null) {
                        iterator.remove(); // node is not present anymore - ignore shard
                    } else if (localAttributeValue.equals(discoveryNode.attributes().get(attribute))) {
                        iterator.remove();
                        to.add(fromShard);
                    }
                }
            }
        }
        return ImmutableList.copyOf(to);
    }


, Instance #
frags: 
(startLine=428 endLine=453 srcPath=/root/NewExperiment/elasticsearchFilter/01089/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java)
    private AttributesRoutings getActiveAttribute(AttributesKey key, DiscoveryNodes nodes) {
        AttributesRoutings shardRoutings = activeShardsByAttributes.get(key);
        if (shardRoutings == null) {
            synchronized (shardsByAttributeMutex) {
                ArrayList<ShardRouting> from = new ArrayList<ShardRouting>(activeShards);
                ArrayList<ShardRouting> to = new ArrayList<ShardRouting>();
                for (String attribute : key.attributes) {
                    String localAttributeValue = nodes.localNode().attributes().get(attribute);
                    if (localAttributeValue == null) {
                        continue;
                    }
                    for (Iterator<ShardRouting> iterator = from.iterator(); iterator.hasNext(); ) {
                        ShardRouting fromShard = iterator.next();
                        if (localAttributeValue.equals(nodes.get(fromShard.currentNodeId()).attributes().get(attribute))) {
                            iterator.remove();
                            to.add(fromShard);
                        }
                    }
                }

                shardRoutings = new AttributesRoutings(ImmutableList.copyOf(to), ImmutableList.copyOf(from));
                activeShardsByAttributes = MapBuilder.newMapBuilder(activeShardsByAttributes).put(key, shardRoutings).immutableMap();
            }
        }
        return shardRoutings;
    }

(startLine=455 endLine=480 srcPath=/root/NewExperiment/elasticsearchFilter/01089/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java)
    private AttributesRoutings getInitializingAttribute(AttributesKey key, DiscoveryNodes nodes) {
        AttributesRoutings shardRoutings = initializingShardsByAttributes.get(key);
        if (shardRoutings == null) {
            synchronized (shardsByAttributeMutex) {
                ArrayList<ShardRouting> from = new ArrayList<ShardRouting>(allInitializingShards);
                ArrayList<ShardRouting> to = new ArrayList<ShardRouting>();
                for (String attribute : key.attributes) {
                    String localAttributeValue = nodes.localNode().attributes().get(attribute);
                    if (localAttributeValue == null) {
                        continue;
                    }
                    for (Iterator<ShardRouting> iterator = from.iterator(); iterator.hasNext(); ) {
                        ShardRouting fromShard = iterator.next();
                        if (localAttributeValue.equals(nodes.get(fromShard.currentNodeId()).attributes().get(attribute))) {
                            iterator.remove();
                            to.add(fromShard);
                        }
                    }
                }

                shardRoutings = new AttributesRoutings(ImmutableList.copyOf(to), ImmutableList.copyOf(from));
                initializingShardsByAttributes = MapBuilder.newMapBuilder(initializingShardsByAttributes).put(key, shardRoutings).immutableMap();
            }
        }
        return shardRoutings;
    }

commonMethod: 
(startLine=456 endLine=474 srcPath=/root/NewExperiment/elasticsearchFilter/01090/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java)
    private static ImmutableList<ShardRouting> collectAttributeShards(AttributesKey key, DiscoveryNodes nodes, ArrayList<ShardRouting> from) {
        final ArrayList<ShardRouting> to = new ArrayList<ShardRouting>();
        for (final String attribute : key.attributes) {
            final String localAttributeValue = nodes.localNode().attributes().get(attribute);
            if (localAttributeValue != null) {
                for (Iterator<ShardRouting> iterator = from.iterator(); iterator.hasNext(); ) {
                    ShardRouting fromShard = iterator.next();
                    final DiscoveryNode discoveryNode = nodes.get(fromShard.currentNodeId());
                    if (discoveryNode == null) {
                        iterator.remove(); // node is not present anymore - ignore shard
                    } else if (localAttributeValue.equals(discoveryNode.attributes().get(attribute))) {
                        iterator.remove();
                        to.add(fromShard);
                    }
                }
            }
        }
        return ImmutableList.copyOf(to);
    }


, Instance #
frags: 
(startLine=434 endLine=446 srcPath=/root/NewExperiment/elasticsearchFilter/01089/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java)
                for (String attribute : key.attributes) {
                    String localAttributeValue = nodes.localNode().attributes().get(attribute);
                    if (localAttributeValue == null) {
                        continue;
                    }
                    for (Iterator<ShardRouting> iterator = from.iterator(); iterator.hasNext(); ) {
                        ShardRouting fromShard = iterator.next();
                        if (localAttributeValue.equals(nodes.get(fromShard.currentNodeId()).attributes().get(attribute))) {
                            iterator.remove();
                            to.add(fromShard);
                        }
                    }
                }

(startLine=461 endLine=473 srcPath=/root/NewExperiment/elasticsearchFilter/01089/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java)
                for (String attribute : key.attributes) {
                    String localAttributeValue = nodes.localNode().attributes().get(attribute);
                    if (localAttributeValue == null) {
                        continue;
                    }
                    for (Iterator<ShardRouting> iterator = from.iterator(); iterator.hasNext(); ) {
                        ShardRouting fromShard = iterator.next();
                        if (localAttributeValue.equals(nodes.get(fromShard.currentNodeId()).attributes().get(attribute))) {
                            iterator.remove();
                            to.add(fromShard);
                        }
                    }
                }

commonMethod: 
(startLine=456 endLine=474 srcPath=/root/NewExperiment/elasticsearchFilter/01090/src/main/java/org/elasticsearch/cluster/routing/IndexShardRoutingTable.java)
    private static ImmutableList<ShardRouting> collectAttributeShards(AttributesKey key, DiscoveryNodes nodes, ArrayList<ShardRouting> from) {
        final ArrayList<ShardRouting> to = new ArrayList<ShardRouting>();
        for (final String attribute : key.attributes) {
            final String localAttributeValue = nodes.localNode().attributes().get(attribute);
            if (localAttributeValue != null) {
                for (Iterator<ShardRouting> iterator = from.iterator(); iterator.hasNext(); ) {
                    ShardRouting fromShard = iterator.next();
                    final DiscoveryNode discoveryNode = nodes.get(fromShard.currentNodeId());
                    if (discoveryNode == null) {
                        iterator.remove(); // node is not present anymore - ignore shard
                    } else if (localAttributeValue.equals(discoveryNode.attributes().get(attribute))) {
                        iterator.remove();
                        to.add(fromShard);
                    }
                }
            }
        }
        return ImmutableList.copyOf(to);
    }


, Instance #
frags: 
(startLine=275 endLine=284 srcPath=/root/NewExperiment/elasticsearchFilter/01091/src/main/java/org/elasticsearch/index/get/ShardGetService.java)
                                    if (value != null && x != null) {
                                        if (value instanceof List) {
                                            List list = (List) value;
                                            for (int i = 0; i < list.size(); i++) {
                                                list.set(i, x.valueForSearch(list.get(i)));
                                            }
                                        } else {
                                            value = x.valueForSearch(value);
                                        }
                                    }

(startLine=400 endLine=409 srcPath=/root/NewExperiment/elasticsearchFilter/01091/src/main/java/org/elasticsearch/index/get/ShardGetService.java)
                        if (value != null && x != null) {
                            if (value instanceof List) {
                                List list = (List) value;
                                for (int i = 0; i < list.size(); i++) {
                                    list.set(i, x.mapper().valueForSearch(list.get(i)));
                                }
                            } else {
                                value = x.mapper().valueForSearch(value);
                            }
                        }

commonMethod: 
(startLine=137 endLine=143 srcPath=/root/NewExperiment/elasticsearchFilter/01092/src/main/java/org/elasticsearch/search/lookup/SourceLookup.java)
    /**
     * Returns the values associated with the path. Those are "low" level values, and it can
     * handle path expression where an array/list is navigated within.
     */
    public List<Object> extractRawValues(String path) {
        return XContentMapValues.extractRawValues(path, loadSourceIfNeeded());
    }


, Instance #
frags: 
(startLine=77 endLine=90 srcPath=/root/NewExperiment/elasticsearchFilter/01111/src/main/java/org/elasticsearch/action/admin/indices/close/TransportCloseIndexAction.java)
    protected void doExecute(CloseIndexRequest request, ActionListener<CloseIndexResponse> listener) {
        ClusterState state = clusterService.state();
        String[] indicesOrAliases = request.indices();
        request.indices(state.metaData().concreteIndices(indicesOrAliases, request.indicesOptions()));

        if (disableCloseAllIndices) {
            if (state.metaData().isExplicitAllIndices(indicesOrAliases) ||
                    state.metaData().isPatternMatchingAllIndices(indicesOrAliases, request.indices())) {
                throw new ElasticsearchIllegalArgumentException("closing all indices is disabled");
            }
        }

        super.doExecute(request, listener);
    }

(startLine=80 endLine=93 srcPath=/root/NewExperiment/elasticsearchFilter/01111/src/main/java/org/elasticsearch/action/admin/indices/delete/TransportDeleteIndexAction.java)
    protected void doExecute(DeleteIndexRequest request, ActionListener<DeleteIndexResponse> listener) {
        ClusterState state = clusterService.state();
        String[] indicesOrAliases = request.indices();

        request.indices(state.metaData().concreteIndices(request.indices(), request.indicesOptions()));

        if (disableDeleteAllIndices) {
            if (state.metaData().isAllIndices(indicesOrAliases) ||
                    state.metaData().isPatternMatchingAllIndices(indicesOrAliases, request.indices())) {
                throw new ElasticsearchIllegalArgumentException("deleting all indices is disabled");
            }
        }
        super.doExecute(request, listener);
    }

commonMethod: 
(startLine=49 endLine=70 srcPath=/root/NewExperiment/elasticsearchFilter/01112/src/main/java/org/elasticsearch/action/support/DestructiveOperations.java)
    /**
     * Fail if there is wildcard usage in indices and the named is required for destructive operations.
     */
    public void failDestructive(String[] aliasesOrIndices) {
        if (!destructiveRequiresName) {
            return;
        }

        if (aliasesOrIndices == null || aliasesOrIndices.length == 0) {
            throw new ElasticsearchIllegalArgumentException("Wildcard expressions or all indices are not allowed");
        } else if (aliasesOrIndices.length == 1) {
            if (hasWildcardUsage(aliasesOrIndices[0])) {
                throw new ElasticsearchIllegalArgumentException("Wildcard expressions or all indices are not allowed");
            }
        } else {
            for (String aliasesOrIndex : aliasesOrIndices) {
                if (hasWildcardUsage(aliasesOrIndex)) {
                    throw new ElasticsearchIllegalArgumentException("Wildcard expressions or all indices are not allowed");
                }
            }
        }
    }


, Instance #
frags: 
(startLine=383 endLine=439 srcPath=/root/NewExperiment/elasticsearchFilter/01126/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java)
    public RestoreSnapshotRequest source(Map source) {
        boolean ignoreUnavailable = IndicesOptions.lenient().ignoreUnavailable();
        boolean allowNoIndices = IndicesOptions.lenient().allowNoIndices();
        boolean expandWildcardsOpen = IndicesOptions.lenient().expandWildcardsOpen();
        boolean expandWildcardsClosed = IndicesOptions.lenient().expandWildcardsClosed();

        for (Map.Entry<String, Object> entry : ((Map<String, Object>) source).entrySet()) {
            String name = entry.getKey();
            if (name.equals("indices")) {
                if (entry.getValue() instanceof String) {
                    indices(Strings.splitStringByCommaToArray((String) entry.getValue()));
                } else if (entry.getValue() instanceof ArrayList) {
                    indices((ArrayList<String>) entry.getValue());
                } else {
                    throw new ElasticsearchIllegalArgumentException("malformed indices section, should be an array of strings");
                }
            } else if (name.equals("ignore_unavailable") || name.equals("ignoreUnavailable")) {
                assert entry.getValue() instanceof String;
                ignoreUnavailable = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("allow_no_indices") || name.equals("allowNoIndices")) {
                assert entry.getValue() instanceof String;
                allowNoIndices = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("expand_wildcards_open") || name.equals("expandWildcardsOpen")) {
                assert entry.getValue() instanceof String;
                expandWildcardsOpen = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("expand_wildcards_closed") || name.equals("expandWildcardsClosed")) {
                assert entry.getValue() instanceof String;
                expandWildcardsClosed = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("settings")) {
                if (!(entry.getValue() instanceof Map)) {
                    throw new ElasticsearchIllegalArgumentException("malformed settings section, should indices an inner object");
                }
                settings((Map<String, Object>) entry.getValue());
            } else if (name.equals("include_global_state")) {
                if (!(entry.getValue() instanceof Boolean)) {
                    throw new ElasticsearchIllegalArgumentException("malformed include_global_state, should be boolean");
                }
                includeGlobalState((Boolean) entry.getValue());
            } else if (name.equals("rename_pattern")) {
                if (entry.getValue() instanceof String) {
                    renamePattern((String) entry.getValue());
                } else {
                    throw new ElasticsearchIllegalArgumentException("malformed rename_pattern");
                }
            } else if (name.equals("rename_replacement")) {
                if (entry.getValue() instanceof String) {
                    renameReplacement((String) entry.getValue());
                } else {
                    throw new ElasticsearchIllegalArgumentException("malformed rename_replacement");
                }
            } else {
                throw new ElasticsearchIllegalArgumentException("Unknown parameter " + name);
            }
        }
        indicesOptions(IndicesOptions.fromOptions(ignoreUnavailable, allowNoIndices, expandWildcardsOpen, expandWildcardsClosed));
        return this;
    }

(startLine=340 endLine=381 srcPath=/root/NewExperiment/elasticsearchFilter/01126/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java)
    public CreateSnapshotRequest source(Map source) {
        boolean ignoreUnavailable = IndicesOptions.lenient().ignoreUnavailable();
        boolean allowNoIndices = IndicesOptions.lenient().allowNoIndices();
        boolean expandWildcardsOpen = IndicesOptions.lenient().expandWildcardsOpen();
        boolean expandWildcardsClosed = IndicesOptions.lenient().expandWildcardsClosed();
        for (Map.Entry<String, Object> entry : ((Map<String, Object>) source).entrySet()) {
            String name = entry.getKey();
            if (name.equals("indices")) {
                if (entry.getValue() instanceof String) {
                    indices(Strings.splitStringByCommaToArray((String) entry.getValue()));
                } else if (entry.getValue() instanceof ArrayList) {
                    indices((ArrayList<String>) entry.getValue());
                } else {
                    throw new ElasticsearchIllegalArgumentException("malformed indices section, should be an array of strings");
                }
            } else if (name.equals("ignore_unavailable") || name.equals("ignoreUnavailable")) {
                assert entry.getValue() instanceof String;
                ignoreUnavailable = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("allow_no_indices") || name.equals("allowNoIndices")) {
                assert entry.getValue() instanceof String;
                allowNoIndices = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("expand_wildcards_open") || name.equals("expandWildcardsOpen")) {
                assert entry.getValue() instanceof String;
                expandWildcardsOpen = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("expand_wildcards_closed") || name.equals("expandWildcardsClosed")) {
                assert entry.getValue() instanceof String;
                expandWildcardsClosed = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("settings")) {
                if (!(entry.getValue() instanceof Map)) {
                    throw new ElasticsearchIllegalArgumentException("malformed settings section, should indices an inner object");
                }
                settings((Map<String, Object>) entry.getValue());
            } else if (name.equals("include_global_state")) {
                if (!(entry.getValue() instanceof Boolean)) {
                    throw new ElasticsearchIllegalArgumentException("malformed include_global_state, should be boolean");
                }
                includeGlobalState((Boolean) entry.getValue());
            }
        }
        indicesOptions(IndicesOptions.fromOptions(ignoreUnavailable, allowNoIndices, expandWildcardsOpen, expandWildcardsClosed));
        return this;
    }

commonMethod: 
(startLine=92 endLine=95 srcPath=/root/NewExperiment/elasticsearchFilter/01127/src/main/java/org/elasticsearch/action/support/IndicesOptions.java)
    public static IndicesOptions fromOptions(boolean ignoreUnavailable, boolean allowNoIndices, boolean expandToOpenIndices, boolean expandToClosedIndices) {
        byte id = toByte(ignoreUnavailable, allowNoIndices, expandToOpenIndices, expandToClosedIndices);
        return VALUES[id];
    }


, Instance #
frags: 
(startLine=383 endLine=439 srcPath=/root/NewExperiment/elasticsearchFilter/01126/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/restore/RestoreSnapshotRequest.java)
    public RestoreSnapshotRequest source(Map source) {
        boolean ignoreUnavailable = IndicesOptions.lenient().ignoreUnavailable();
        boolean allowNoIndices = IndicesOptions.lenient().allowNoIndices();
        boolean expandWildcardsOpen = IndicesOptions.lenient().expandWildcardsOpen();
        boolean expandWildcardsClosed = IndicesOptions.lenient().expandWildcardsClosed();

        for (Map.Entry<String, Object> entry : ((Map<String, Object>) source).entrySet()) {
            String name = entry.getKey();
            if (name.equals("indices")) {
                if (entry.getValue() instanceof String) {
                    indices(Strings.splitStringByCommaToArray((String) entry.getValue()));
                } else if (entry.getValue() instanceof ArrayList) {
                    indices((ArrayList<String>) entry.getValue());
                } else {
                    throw new ElasticsearchIllegalArgumentException("malformed indices section, should be an array of strings");
                }
            } else if (name.equals("ignore_unavailable") || name.equals("ignoreUnavailable")) {
                assert entry.getValue() instanceof String;
                ignoreUnavailable = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("allow_no_indices") || name.equals("allowNoIndices")) {
                assert entry.getValue() instanceof String;
                allowNoIndices = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("expand_wildcards_open") || name.equals("expandWildcardsOpen")) {
                assert entry.getValue() instanceof String;
                expandWildcardsOpen = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("expand_wildcards_closed") || name.equals("expandWildcardsClosed")) {
                assert entry.getValue() instanceof String;
                expandWildcardsClosed = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("settings")) {
                if (!(entry.getValue() instanceof Map)) {
                    throw new ElasticsearchIllegalArgumentException("malformed settings section, should indices an inner object");
                }
                settings((Map<String, Object>) entry.getValue());
            } else if (name.equals("include_global_state")) {
                if (!(entry.getValue() instanceof Boolean)) {
                    throw new ElasticsearchIllegalArgumentException("malformed include_global_state, should be boolean");
                }
                includeGlobalState((Boolean) entry.getValue());
            } else if (name.equals("rename_pattern")) {
                if (entry.getValue() instanceof String) {
                    renamePattern((String) entry.getValue());
                } else {
                    throw new ElasticsearchIllegalArgumentException("malformed rename_pattern");
                }
            } else if (name.equals("rename_replacement")) {
                if (entry.getValue() instanceof String) {
                    renameReplacement((String) entry.getValue());
                } else {
                    throw new ElasticsearchIllegalArgumentException("malformed rename_replacement");
                }
            } else {
                throw new ElasticsearchIllegalArgumentException("Unknown parameter " + name);
            }
        }
        indicesOptions(IndicesOptions.fromOptions(ignoreUnavailable, allowNoIndices, expandWildcardsOpen, expandWildcardsClosed));
        return this;
    }

(startLine=340 endLine=381 srcPath=/root/NewExperiment/elasticsearchFilter/01126/src/main/java/org/elasticsearch/action/admin/cluster/snapshots/create/CreateSnapshotRequest.java)
    public CreateSnapshotRequest source(Map source) {
        boolean ignoreUnavailable = IndicesOptions.lenient().ignoreUnavailable();
        boolean allowNoIndices = IndicesOptions.lenient().allowNoIndices();
        boolean expandWildcardsOpen = IndicesOptions.lenient().expandWildcardsOpen();
        boolean expandWildcardsClosed = IndicesOptions.lenient().expandWildcardsClosed();
        for (Map.Entry<String, Object> entry : ((Map<String, Object>) source).entrySet()) {
            String name = entry.getKey();
            if (name.equals("indices")) {
                if (entry.getValue() instanceof String) {
                    indices(Strings.splitStringByCommaToArray((String) entry.getValue()));
                } else if (entry.getValue() instanceof ArrayList) {
                    indices((ArrayList<String>) entry.getValue());
                } else {
                    throw new ElasticsearchIllegalArgumentException("malformed indices section, should be an array of strings");
                }
            } else if (name.equals("ignore_unavailable") || name.equals("ignoreUnavailable")) {
                assert entry.getValue() instanceof String;
                ignoreUnavailable = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("allow_no_indices") || name.equals("allowNoIndices")) {
                assert entry.getValue() instanceof String;
                allowNoIndices = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("expand_wildcards_open") || name.equals("expandWildcardsOpen")) {
                assert entry.getValue() instanceof String;
                expandWildcardsOpen = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("expand_wildcards_closed") || name.equals("expandWildcardsClosed")) {
                assert entry.getValue() instanceof String;
                expandWildcardsClosed = Boolean.valueOf(entry.getValue().toString());
            } else if (name.equals("settings")) {
                if (!(entry.getValue() instanceof Map)) {
                    throw new ElasticsearchIllegalArgumentException("malformed settings section, should indices an inner object");
                }
                settings((Map<String, Object>) entry.getValue());
            } else if (name.equals("include_global_state")) {
                if (!(entry.getValue() instanceof Boolean)) {
                    throw new ElasticsearchIllegalArgumentException("malformed include_global_state, should be boolean");
                }
                includeGlobalState((Boolean) entry.getValue());
            }
        }
        indicesOptions(IndicesOptions.fromOptions(ignoreUnavailable, allowNoIndices, expandWildcardsOpen, expandWildcardsClosed));
        return this;
    }

commonMethod: 
(startLine=1012 endLine=1014 srcPath=/root/NewExperiment/elasticsearchFilter/01127/src/main/java/org/elasticsearch/common/Strings.java)
    public static String[] splitStringByCommaToArray(final String s) {
        return splitStringToArray(s, ',');
    }


, Instance #
frags: 
(startLine=64 endLine=77 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/bucket/geogrid/GeoHashGridAggregator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert owningBucketOrdinal == 0;
        final LongValues values = valuesSource.longValues();
        final int valuesCount = values.setDocument(doc);

        for (int i = 0; i < valuesCount; ++i) {
            final long val = values.nextValue();
            long bucketOrdinal = bucketOrds.add(val);
            if (bucketOrdinal < 0) { // already seen
                bucketOrdinal = - 1 - bucketOrdinal;
            }
            collectBucket(doc, bucketOrdinal);
        }
    }

(startLine=65 endLine=78 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongTermsAggregator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert owningBucketOrdinal == 0;
        final LongValues values = valuesSource.longValues();
        final int valuesCount = values.setDocument(doc);

        for (int i = 0; i < valuesCount; ++i) {
            final long val = values.nextValue();
            long bucketOrdinal = bucketOrds.add(val);
            if (bucketOrdinal < 0) { // already seen
                bucketOrdinal = - 1 - bucketOrdinal;
            }
            collectBucket(doc, bucketOrdinal);
        }
    }

commonMethod: 
(startLine=57 endLine=59 srcPath=/root/NewExperiment/elasticsearchFilter/01135/src/main/java/org/elasticsearch/search/aggregations/support/numeric/NumericValuesSource.java)
    public LongValues longValues() {
        return source.longValues();
    }


, Instance #
frags: 
(startLine=69 endLine=102 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/StatsAggegator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

(startLine=71 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/extended/ExtendedStatsAggregator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            sumOfSqrs = BigArrays.resize(sumOfSqrs, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double sumOfSqr = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            sumOfSqr += value * value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        sumOfSqrs.increment(owningBucketOrdinal, sumOfSqr);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

commonMethod: 
(startLine=61 endLine=63 srcPath=/root/NewExperiment/elasticsearchFilter/01135/src/main/java/org/elasticsearch/search/aggregations/support/numeric/NumericValuesSource.java)
    public DoubleValues doubleValues() {
        return source.doubleValues();
    }


, Instance #
frags: 
(startLine=69 endLine=102 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/StatsAggegator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

(startLine=71 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/extended/ExtendedStatsAggregator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            sumOfSqrs = BigArrays.resize(sumOfSqrs, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double sumOfSqr = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            sumOfSqr += value * value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        sumOfSqrs.increment(owningBucketOrdinal, sumOfSqr);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

commonMethod: 
(startLine=126 endLine=130 srcPath=/root/NewExperiment/elasticsearchFilter/01135/src/main/java/org/elasticsearch/index/fielddata/DoubleValues.java)
        @Override
        public int setDocument(int docId) {
            this.docId = docId;
            return ordinals.setDocument(docId);
        }


, Instance #
frags: 
(startLine=69 endLine=102 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/StatsAggegator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

(startLine=71 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/extended/ExtendedStatsAggregator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            sumOfSqrs = BigArrays.resize(sumOfSqrs, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double sumOfSqr = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            sumOfSqr += value * value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        sumOfSqrs.increment(owningBucketOrdinal, sumOfSqr);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

commonMethod: 
(startLine=146 endLine=149 srcPath=/root/NewExperiment/elasticsearchFilter/01135/src/main/java/org/elasticsearch/index/fielddata/DoubleValues.java)
        @Override
        public int setDocument(int docId) {
            return 0;
        }


, Instance #
frags: 
(startLine=69 endLine=102 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/StatsAggegator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

(startLine=71 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/extended/ExtendedStatsAggregator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            sumOfSqrs = BigArrays.resize(sumOfSqrs, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double sumOfSqr = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            sumOfSqr += value * value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        sumOfSqrs.increment(owningBucketOrdinal, sumOfSqr);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

commonMethod: 
(startLine=161 endLine=164 srcPath=/root/NewExperiment/elasticsearchFilter/01135/src/main/java/org/elasticsearch/index/fielddata/DoubleValues.java)
            @Override
            public int setDocument(int docId) {
                return values.setDocument(docId);
            }


, Instance #
frags: 
(startLine=69 endLine=102 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/StatsAggegator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

(startLine=71 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/extended/ExtendedStatsAggregator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            sumOfSqrs = BigArrays.resize(sumOfSqrs, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double sumOfSqr = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            sumOfSqr += value * value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        sumOfSqrs.increment(owningBucketOrdinal, sumOfSqr);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

commonMethod: 
(startLine=132 endLine=135 srcPath=/root/NewExperiment/elasticsearchFilter/01135/src/main/java/org/elasticsearch/index/fielddata/DoubleValues.java)
        @Override
        public double nextValue() {
            return getValueByOrd(ordinals.nextOrd());
        }


, Instance #
frags: 
(startLine=69 endLine=102 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/StatsAggegator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

(startLine=71 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/01134/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/extended/ExtendedStatsAggregator.java)
    public void collect(int doc, long owningBucketOrdinal) throws IOException {
        assert valuesSource != null : "collect must only be called if #shouldCollect returns true";

        DoubleValues values = valuesSource.doubleValues();
        if (values == null) {
            return;
        }

        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = BigArrays.resize(counts, overSize);
            sums = BigArrays.resize(sums, overSize);
            mins = BigArrays.resize(mins, overSize);
            maxes = BigArrays.resize(maxes, overSize);
            sumOfSqrs = BigArrays.resize(sumOfSqrs, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

        final int valuesCount = values.setDocument(doc);
        counts.increment(owningBucketOrdinal, valuesCount);
        double sum = 0;
        double sumOfSqr = 0;
        double min = mins.get(owningBucketOrdinal);
        double max = maxes.get(owningBucketOrdinal);
        for (int i = 0; i < valuesCount; i++) {
            double value = values.nextValue();
            sum += value;
            sumOfSqr += value * value;
            min = Math.min(min, value);
            max = Math.max(max, value);
        }
        sums.increment(owningBucketOrdinal, sum);
        sumOfSqrs.increment(owningBucketOrdinal, sumOfSqr);
        mins.set(owningBucketOrdinal, min);
        maxes.set(owningBucketOrdinal, max);
    }

commonMethod: 
(startLine=166 endLine=169 srcPath=/root/NewExperiment/elasticsearchFilter/01135/src/main/java/org/elasticsearch/index/fielddata/DoubleValues.java)
            @Override
            public double nextValue() {
                return (double) values.nextValue();
            }


, Instance #
frags: 
(startLine=185 endLine=202 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 1; j <= QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName)
                    .setQuery(
                            filteredQuery(
                                    matchAllQuery(),
                                    hasChildFilter("child", matchAllQuery())
                            )
                    )
                    .execute().actionGet();
            if (searchResponse.getFailedShards() > 0) {
                System.err.println("Search Failures " + Arrays.toString(searchResponse.getShardFailures()));
            }
            long expected = (COUNT / BATCH) * BATCH;
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("--> mismatch on hits [" + j + "], got [" + searchResponse.getHits().totalHits() + "], expected [" + expected + "]");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

(startLine=146 endLine=161 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_WARMUP; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName)
                    .setQuery(
                            filteredQuery(
                                    matchAllQuery(),
                                    hasChildFilter("child", termQuery("tag", "tag1"))
                            )
                    )
                    .execute().actionGet();
            if (searchResponse.getFailedShards() > 0) {
                System.err.println("Search Failures " + Arrays.toString(searchResponse.getShardFailures()));
            }
            if (searchResponse.getHits().totalHits() != COUNT) {
                System.err.println("--> mismatch on hits [" + j + "], got [" + searchResponse.getHits().totalHits() + "], expected [" + COUNT + "]");
            }
        }

(startLine=232 endLine=247 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_WARMUP; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName)
                    .setQuery(
                            filteredQuery(
                                    matchAllQuery(),
                                    hasParentFilter("parent", termQuery("name", "test1"))
                            )
                    )
                    .execute().actionGet();
            if (searchResponse.getFailedShards() > 0) {
                System.err.println("Search Failures " + Arrays.toString(searchResponse.getShardFailures()));
            }
            if (searchResponse.getHits().totalHits() != CHILD_COUNT) {
                System.err.println("--> mismatch on hits [" + j + "], got [" + searchResponse.getHits().totalHits() + "], expected [" + CHILD_COUNT + "]");
            }
        }

commonMethod: 
(startLine=103 endLine=105 srcPath=/root/NewExperiment/elasticsearchFilter/01141/src/test/java/org/elasticsearch/benchmark/search/child/ParentChildIndexGenerator.java)
    public String getQueryValue() {
        return "value" + RANDOM.nextInt(numChildrenPerParent / queryValueRatio);
    }


, Instance #
frags: 
(startLine=355 endLine=362 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery("child", matchAllQuery()).scoreType("max")).execute().actionGet();
            long expected = (COUNT / BATCH) * BATCH;
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

(startLine=206 endLine=215 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(
                    filteredQuery(matchAllQuery(), hasChildFilter("child", termQuery("id", Integer.toString(j + 1))))
            ).execute().actionGet();
            long expected = 1;
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

(startLine=366 endLine=373 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery("child", termQuery("id", Integer.toString(j + 1))).scoreType("max")).execute().actionGet();
            long expected = 1;
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

commonMethod: 
(startLine=103 endLine=105 srcPath=/root/NewExperiment/elasticsearchFilter/01141/src/test/java/org/elasticsearch/benchmark/search/child/ParentChildIndexGenerator.java)
    public String getQueryValue() {
        return "value" + RANDOM.nextInt(numChildrenPerParent / queryValueRatio);
    }


, Instance #
frags: 
(startLine=206 endLine=215 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(
                    filteredQuery(matchAllQuery(), hasChildFilter("child", termQuery("id", Integer.toString(j + 1))))
            ).execute().actionGet();
            long expected = 1;
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

(startLine=366 endLine=373 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery("child", termQuery("id", Integer.toString(j + 1))).scoreType("max")).execute().actionGet();
            long expected = 1;
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

commonMethod: 
(startLine=50 endLine=101 srcPath=/root/NewExperiment/elasticsearchFilter/01141/src/test/java/org/elasticsearch/benchmark/search/child/ParentChildIndexGenerator.java)
    public void index() {
        // Memory intensive...
        ObjectOpenHashSet<String> usedParentIds = ObjectOpenHashSet.newInstanceWithCapacity(numParents, 0.5f);
        ObjectArrayList<ParentDocument> parents = ObjectArrayList.newInstanceWithCapacity(numParents);

        for (int i = 0; i < numParents; i++) {
            String parentId;
            do {
                parentId = RandomStrings.randomAsciiOfLength(RANDOM, 10);
            } while (!usedParentIds.add(parentId));
            String[] queryValues = new String[numChildrenPerParent];
            for (int j = 0; j < numChildrenPerParent; j++) {
                queryValues[j] = getQueryValue();
            }
            parents.add(new ParentDocument(parentId, queryValues));
        }

        int indexCounter = 0;
        int childIdCounter = 0;
        while (!parents.isEmpty()) {
            BulkRequestBuilder request = client.prepareBulk();
            for (int i = 0; !parents.isEmpty() && i < 100; i++) {
                int index = RANDOM.nextInt(parents.size());
                ParentDocument parentDocument = parents.get(index);

                if (parentDocument.indexCounter == -1) {
                    request.add(Requests.indexRequest("test").type("parent")
                            .id(parentDocument.parentId)
                            .source("field1", getQueryValue()));
                } else {
                    request.add(Requests.indexRequest("test").type("child")
                            .parent(parentDocument.parentId)
                            .id(String.valueOf(++childIdCounter))
                            .source("field2", parentDocument.queryValues[parentDocument.indexCounter]));
                }

                if (++parentDocument.indexCounter == parentDocument.queryValues.length) {
                    parents.remove(index);
                }
            }

            BulkResponse response = request.execute().actionGet();
            if (response.hasFailures()) {
                System.err.println("--> failures...");
            }

            indexCounter += response.getItems().length;
            if (indexCounter % 100000 == 0) {
                System.out.println("--> Indexed " + indexCounter + " documents");
            }
        }
    }


, Instance #
frags: 
(startLine=206 endLine=215 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(
                    filteredQuery(matchAllQuery(), hasChildFilter("child", termQuery("id", Integer.toString(j + 1))))
            ).execute().actionGet();
            long expected = 1;
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

(startLine=345 endLine=351 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery("child", termQuery("tag", "tag1")).scoreType("max")).execute().actionGet();
            if (searchResponse.getHits().totalHits() != COUNT) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

(startLine=355 endLine=362 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery("child", matchAllQuery()).scoreType("max")).execute().actionGet();
            long expected = (COUNT / BATCH) * BATCH;
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

(startLine=366 endLine=373 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery("child", termQuery("id", Integer.toString(j + 1))).scoreType("max")).execute().actionGet();
            long expected = 1;
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

commonMethod: 
(startLine=103 endLine=105 srcPath=/root/NewExperiment/elasticsearchFilter/01141/src/test/java/org/elasticsearch/benchmark/search/child/ParentChildIndexGenerator.java)
    public String getQueryValue() {
        return "value" + RANDOM.nextInt(numChildrenPerParent / queryValueRatio);
    }


, Instance #
frags: 
(startLine=206 endLine=215 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(
                    filteredQuery(matchAllQuery(), hasChildFilter("child", termQuery("id", Integer.toString(j + 1))))
            ).execute().actionGet();
            long expected = 1;
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

(startLine=345 endLine=351 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery("child", termQuery("tag", "tag1")).scoreType("max")).execute().actionGet();
            if (searchResponse.getHits().totalHits() != COUNT) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

(startLine=366 endLine=373 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery("child", termQuery("id", Integer.toString(j + 1))).scoreType("max")).execute().actionGet();
            long expected = 1;
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits");
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

commonMethod: 
(startLine=50 endLine=101 srcPath=/root/NewExperiment/elasticsearchFilter/01141/src/test/java/org/elasticsearch/benchmark/search/child/ParentChildIndexGenerator.java)
    public void index() {
        // Memory intensive...
        ObjectOpenHashSet<String> usedParentIds = ObjectOpenHashSet.newInstanceWithCapacity(numParents, 0.5f);
        ObjectArrayList<ParentDocument> parents = ObjectArrayList.newInstanceWithCapacity(numParents);

        for (int i = 0; i < numParents; i++) {
            String parentId;
            do {
                parentId = RandomStrings.randomAsciiOfLength(RANDOM, 10);
            } while (!usedParentIds.add(parentId));
            String[] queryValues = new String[numChildrenPerParent];
            for (int j = 0; j < numChildrenPerParent; j++) {
                queryValues[j] = getQueryValue();
            }
            parents.add(new ParentDocument(parentId, queryValues));
        }

        int indexCounter = 0;
        int childIdCounter = 0;
        while (!parents.isEmpty()) {
            BulkRequestBuilder request = client.prepareBulk();
            for (int i = 0; !parents.isEmpty() && i < 100; i++) {
                int index = RANDOM.nextInt(parents.size());
                ParentDocument parentDocument = parents.get(index);

                if (parentDocument.indexCounter == -1) {
                    request.add(Requests.indexRequest("test").type("parent")
                            .id(parentDocument.parentId)
                            .source("field1", getQueryValue()));
                } else {
                    request.add(Requests.indexRequest("test").type("child")
                            .parent(parentDocument.parentId)
                            .id(String.valueOf(++childIdCounter))
                            .source("field2", parentDocument.queryValues[parentDocument.indexCounter]));
                }

                if (++parentDocument.indexCounter == parentDocument.queryValues.length) {
                    parents.remove(index);
                }
            }

            BulkResponse response = request.execute().actionGet();
            if (response.hasFailures()) {
                System.err.println("--> failures...");
            }

            indexCounter += response.getItems().length;
            if (indexCounter % 100000 == 0) {
                System.out.println("--> Indexed " + indexCounter + " documents");
            }
        }
    }


, Instance #
frags: 
(startLine=73 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        try {
            client.admin().indices().create(createIndexRequest(indexName)).actionGet();
            client.admin().indices().preparePutMapping(indexName).setType("child").setSource(XContentFactory.jsonBuilder().startObject().startObject("child")
                    .startObject("_parent").field("type", "parent").endObject()
                    .endObject().endObject()).execute().actionGet();
            Thread.sleep(5000);

            StopWatch stopWatch = new StopWatch().start();

            System.out.println("--> Indexing [" + COUNT + "] parent document and [" + (COUNT * CHILD_COUNT) + " child documents");
            long ITERS = COUNT / BATCH;
            long i = 1;
            int counter = 0;
            for (; i <= ITERS; i++) {
                BulkRequestBuilder request = client.prepareBulk();
                for (int j = 0; j < BATCH; j++) {
                    counter++;
                    request.add(Requests.indexRequest(indexName).type("parent").id(Integer.toString(counter))
                            .source(parentSource(counter, "test" + counter)));
                    for (int k = 0; k < CHILD_COUNT; k++) {
                        request.add(Requests.indexRequest(indexName).type("child").id(Integer.toString(counter) + "_" + k)
                                .parent(Integer.toString(counter))
                                .source(childSource(counter, "tag" + k)));
                    }
                }
                BulkResponse response = request.execute().actionGet();
                if (response.hasFailures()) {
                    System.err.println("--> failures...");
                }
                if (((i * BATCH) % 10000) == 0) {
                    System.out.println("--> Indexed " + (i * BATCH) * (1 + CHILD_COUNT) + " took " + stopWatch.stop().lastTaskTime());
                    stopWatch.start();
                }
            }
            System.out.println("--> Indexing took " + stopWatch.totalTime() + ", TPS " + (((double) (COUNT * (1 + CHILD_COUNT))) / stopWatch.totalTime().secondsFrac()));
        } catch (Exception e) {

(startLine=75 endLine=110 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchAndIndexingBenchmark.java)
        try {
            client.admin().indices().create(createIndexRequest(indexName)).actionGet();
            client.admin().indices().preparePutMapping(indexName).setType("child").setSource(XContentFactory.jsonBuilder().startObject().startObject("child")
                    .startObject("_parent").field("type", "parent").endObject()
                    .endObject().endObject()).execute().actionGet();
            Thread.sleep(5000);

            StopWatch stopWatch = new StopWatch().start();

            System.out.println("--> Indexing [" + COUNT + "] parent document and [" + (COUNT * CHILD_COUNT) + " child documents");
            long ITERS = COUNT / BATCH;
            long i = 1;
            int counter = 0;
            for (; i <= ITERS; i++) {
                BulkRequestBuilder request = client.prepareBulk();
                for (int j = 0; j < BATCH; j++) {
                    counter++;
                    request.add(Requests.indexRequest(indexName).type("parent").id(Integer.toString(counter))
                            .source(parentSource(Integer.toString(counter), "test" + counter)));
                    for (int k = 0; k < CHILD_COUNT; k++) {
                        request.add(Requests.indexRequest(indexName).type("child").id(Integer.toString(counter) + "_" + k)
                                .parent(Integer.toString(counter))
                                .source(childSource(Integer.toString(counter), "tag" + k)));
                    }
                }
                BulkResponse response = request.execute().actionGet();
                if (response.hasFailures()) {
                    System.err.println("--> failures...");
                }
                if (((i * BATCH) % 10000) == 0) {
                    System.out.println("--> Indexed " + (i * BATCH) * (1 + CHILD_COUNT) + " took " + stopWatch.stop().lastTaskTime());
                    stopWatch.start();
                }
            }
            System.out.println("--> Indexing took " + stopWatch.totalTime() + ", TPS " + (((double) (COUNT * (1 + CHILD_COUNT))) / stopWatch.totalTime().secondsFrac()));
        } catch (Exception e) {

commonMethod: 
(startLine=50 endLine=101 srcPath=/root/NewExperiment/elasticsearchFilter/01141/src/test/java/org/elasticsearch/benchmark/search/child/ParentChildIndexGenerator.java)
    public void index() {
        // Memory intensive...
        ObjectOpenHashSet<String> usedParentIds = ObjectOpenHashSet.newInstanceWithCapacity(numParents, 0.5f);
        ObjectArrayList<ParentDocument> parents = ObjectArrayList.newInstanceWithCapacity(numParents);

        for (int i = 0; i < numParents; i++) {
            String parentId;
            do {
                parentId = RandomStrings.randomAsciiOfLength(RANDOM, 10);
            } while (!usedParentIds.add(parentId));
            String[] queryValues = new String[numChildrenPerParent];
            for (int j = 0; j < numChildrenPerParent; j++) {
                queryValues[j] = getQueryValue();
            }
            parents.add(new ParentDocument(parentId, queryValues));
        }

        int indexCounter = 0;
        int childIdCounter = 0;
        while (!parents.isEmpty()) {
            BulkRequestBuilder request = client.prepareBulk();
            for (int i = 0; !parents.isEmpty() && i < 100; i++) {
                int index = RANDOM.nextInt(parents.size());
                ParentDocument parentDocument = parents.get(index);

                if (parentDocument.indexCounter == -1) {
                    request.add(Requests.indexRequest("test").type("parent")
                            .id(parentDocument.parentId)
                            .source("field1", getQueryValue()));
                } else {
                    request.add(Requests.indexRequest("test").type("child")
                            .parent(parentDocument.parentId)
                            .id(String.valueOf(++childIdCounter))
                            .source("field2", parentDocument.queryValues[parentDocument.indexCounter]));
                }

                if (++parentDocument.indexCounter == parentDocument.queryValues.length) {
                    parents.remove(index);
                }
            }

            BulkResponse response = request.execute().actionGet();
            if (response.hasFailures()) {
                System.err.println("--> failures...");
            }

            indexCounter += response.getItems().length;
            if (indexCounter % 100000 == 0) {
                System.out.println("--> Indexed " + indexCounter + " documents");
            }
        }
    }


, Instance #
frags: 
(startLine=219 endLine=228 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            double expected = Math.pow((j + 1), 3) * CHILD_COUNT;
            SearchResponse searchResponse = client.prepareSearch(indexName)
                    .setQuery(filteredQuery(matchAllQuery(), hasChildFilter("child", constantScoreQuery(rangeFilter("num").lte(expected)))))
                    .execute().actionGet();
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits: " + searchResponse.getHits().totalHits() + " != " + expected);
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

(startLine=377 endLine=384 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            double expected = Math.pow((j + 1), 3) * CHILD_COUNT;
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery("child", constantScoreQuery(rangeFilter("num").lte(expected))).scoreType("max")).execute().actionGet();
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits: " + searchResponse.getHits().totalHits() + " != " + expected);
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

commonMethod: 
(startLine=103 endLine=105 srcPath=/root/NewExperiment/elasticsearchFilter/01141/src/test/java/org/elasticsearch/benchmark/search/child/ParentChildIndexGenerator.java)
    public String getQueryValue() {
        return "value" + RANDOM.nextInt(numChildrenPerParent / queryValueRatio);
    }


, Instance #
frags: 
(startLine=219 endLine=228 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            double expected = Math.pow((j + 1), 3) * CHILD_COUNT;
            SearchResponse searchResponse = client.prepareSearch(indexName)
                    .setQuery(filteredQuery(matchAllQuery(), hasChildFilter("child", constantScoreQuery(rangeFilter("num").lte(expected)))))
                    .execute().actionGet();
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits: " + searchResponse.getHits().totalHits() + " != " + expected);
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

(startLine=377 endLine=384 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
        for (int j = 0; j < QUERY_COUNT; j++) {
            double expected = Math.pow((j + 1), 3) * CHILD_COUNT;
            SearchResponse searchResponse = client.prepareSearch(indexName).setQuery(hasChildQuery("child", constantScoreQuery(rangeFilter("num").lte(expected))).scoreType("max")).execute().actionGet();
            if (searchResponse.getHits().totalHits() != expected) {
                System.err.println("mismatch on hits: " + searchResponse.getHits().totalHits() + " != " + expected);
            }
            totalQueryTime += searchResponse.getTookInMillis();
        }

commonMethod: 
(startLine=50 endLine=101 srcPath=/root/NewExperiment/elasticsearchFilter/01141/src/test/java/org/elasticsearch/benchmark/search/child/ParentChildIndexGenerator.java)
    public void index() {
        // Memory intensive...
        ObjectOpenHashSet<String> usedParentIds = ObjectOpenHashSet.newInstanceWithCapacity(numParents, 0.5f);
        ObjectArrayList<ParentDocument> parents = ObjectArrayList.newInstanceWithCapacity(numParents);

        for (int i = 0; i < numParents; i++) {
            String parentId;
            do {
                parentId = RandomStrings.randomAsciiOfLength(RANDOM, 10);
            } while (!usedParentIds.add(parentId));
            String[] queryValues = new String[numChildrenPerParent];
            for (int j = 0; j < numChildrenPerParent; j++) {
                queryValues[j] = getQueryValue();
            }
            parents.add(new ParentDocument(parentId, queryValues));
        }

        int indexCounter = 0;
        int childIdCounter = 0;
        while (!parents.isEmpty()) {
            BulkRequestBuilder request = client.prepareBulk();
            for (int i = 0; !parents.isEmpty() && i < 100; i++) {
                int index = RANDOM.nextInt(parents.size());
                ParentDocument parentDocument = parents.get(index);

                if (parentDocument.indexCounter == -1) {
                    request.add(Requests.indexRequest("test").type("parent")
                            .id(parentDocument.parentId)
                            .source("field1", getQueryValue()));
                } else {
                    request.add(Requests.indexRequest("test").type("child")
                            .parent(parentDocument.parentId)
                            .id(String.valueOf(++childIdCounter))
                            .source("field2", parentDocument.queryValues[parentDocument.indexCounter]));
                }

                if (++parentDocument.indexCounter == parentDocument.queryValues.length) {
                    parents.remove(index);
                }
            }

            BulkResponse response = request.execute().actionGet();
            if (response.hasFailures()) {
                System.err.println("--> failures...");
            }

            indexCounter += response.getItems().length;
            if (indexCounter % 100000 == 0) {
                System.out.println("--> Indexed " + indexCounter + " documents");
            }
        }
    }


, Instance #
frags: 
(startLine=86 endLine=106 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
            for (; i <= ITERS; i++) {
                BulkRequestBuilder request = client.prepareBulk();
                for (int j = 0; j < BATCH; j++) {
                    counter++;
                    request.add(Requests.indexRequest(indexName).type("parent").id(Integer.toString(counter))
                            .source(parentSource(counter, "test" + counter)));
                    for (int k = 0; k < CHILD_COUNT; k++) {
                        request.add(Requests.indexRequest(indexName).type("child").id(Integer.toString(counter) + "_" + k)
                                .parent(Integer.toString(counter))
                                .source(childSource(counter, "tag" + k)));
                    }
                }
                BulkResponse response = request.execute().actionGet();
                if (response.hasFailures()) {
                    System.err.println("--> failures...");
                }
                if (((i * BATCH) % 10000) == 0) {
                    System.out.println("--> Indexed " + (i * BATCH) * (1 + CHILD_COUNT) + " took " + stopWatch.stop().lastTaskTime());
                    stopWatch.start();
                }
            }

(startLine=88 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchAndIndexingBenchmark.java)
            for (; i <= ITERS; i++) {
                BulkRequestBuilder request = client.prepareBulk();
                for (int j = 0; j < BATCH; j++) {
                    counter++;
                    request.add(Requests.indexRequest(indexName).type("parent").id(Integer.toString(counter))
                            .source(parentSource(Integer.toString(counter), "test" + counter)));
                    for (int k = 0; k < CHILD_COUNT; k++) {
                        request.add(Requests.indexRequest(indexName).type("child").id(Integer.toString(counter) + "_" + k)
                                .parent(Integer.toString(counter))
                                .source(childSource(Integer.toString(counter), "tag" + k)));
                    }
                }
                BulkResponse response = request.execute().actionGet();
                if (response.hasFailures()) {
                    System.err.println("--> failures...");
                }
                if (((i * BATCH) % 10000) == 0) {
                    System.out.println("--> Indexed " + (i * BATCH) * (1 + CHILD_COUNT) + " took " + stopWatch.stop().lastTaskTime());
                    stopWatch.start();
                }
            }

commonMethod: 
(startLine=50 endLine=101 srcPath=/root/NewExperiment/elasticsearchFilter/01141/src/test/java/org/elasticsearch/benchmark/search/child/ParentChildIndexGenerator.java)
    public void index() {
        // Memory intensive...
        ObjectOpenHashSet<String> usedParentIds = ObjectOpenHashSet.newInstanceWithCapacity(numParents, 0.5f);
        ObjectArrayList<ParentDocument> parents = ObjectArrayList.newInstanceWithCapacity(numParents);

        for (int i = 0; i < numParents; i++) {
            String parentId;
            do {
                parentId = RandomStrings.randomAsciiOfLength(RANDOM, 10);
            } while (!usedParentIds.add(parentId));
            String[] queryValues = new String[numChildrenPerParent];
            for (int j = 0; j < numChildrenPerParent; j++) {
                queryValues[j] = getQueryValue();
            }
            parents.add(new ParentDocument(parentId, queryValues));
        }

        int indexCounter = 0;
        int childIdCounter = 0;
        while (!parents.isEmpty()) {
            BulkRequestBuilder request = client.prepareBulk();
            for (int i = 0; !parents.isEmpty() && i < 100; i++) {
                int index = RANDOM.nextInt(parents.size());
                ParentDocument parentDocument = parents.get(index);

                if (parentDocument.indexCounter == -1) {
                    request.add(Requests.indexRequest("test").type("parent")
                            .id(parentDocument.parentId)
                            .source("field1", getQueryValue()));
                } else {
                    request.add(Requests.indexRequest("test").type("child")
                            .parent(parentDocument.parentId)
                            .id(String.valueOf(++childIdCounter))
                            .source("field2", parentDocument.queryValues[parentDocument.indexCounter]));
                }

                if (++parentDocument.indexCounter == parentDocument.queryValues.length) {
                    parents.remove(index);
                }
            }

            BulkResponse response = request.execute().actionGet();
            if (response.hasFailures()) {
                System.err.println("--> failures...");
            }

            indexCounter += response.getItems().length;
            if (indexCounter % 100000 == 0) {
                System.out.println("--> Indexed " + indexCounter + " documents");
            }
        }
    }


, Instance #
frags: 
(startLine=88 endLine=97 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchBenchmark.java)
                for (int j = 0; j < BATCH; j++) {
                    counter++;
                    request.add(Requests.indexRequest(indexName).type("parent").id(Integer.toString(counter))
                            .source(parentSource(counter, "test" + counter)));
                    for (int k = 0; k < CHILD_COUNT; k++) {
                        request.add(Requests.indexRequest(indexName).type("child").id(Integer.toString(counter) + "_" + k)
                                .parent(Integer.toString(counter))
                                .source(childSource(counter, "tag" + k)));
                    }
                }

(startLine=90 endLine=99 srcPath=/root/NewExperiment/elasticsearchFilter/01140/src/test/java/org/elasticsearch/benchmark/search/child/ChildSearchAndIndexingBenchmark.java)
                for (int j = 0; j < BATCH; j++) {
                    counter++;
                    request.add(Requests.indexRequest(indexName).type("parent").id(Integer.toString(counter))
                            .source(parentSource(Integer.toString(counter), "test" + counter)));
                    for (int k = 0; k < CHILD_COUNT; k++) {
                        request.add(Requests.indexRequest(indexName).type("child").id(Integer.toString(counter) + "_" + k)
                                .parent(Integer.toString(counter))
                                .source(childSource(Integer.toString(counter), "tag" + k)));
                    }
                }

commonMethod: 
(startLine=50 endLine=101 srcPath=/root/NewExperiment/elasticsearchFilter/01141/src/test/java/org/elasticsearch/benchmark/search/child/ParentChildIndexGenerator.java)
    public void index() {
        // Memory intensive...
        ObjectOpenHashSet<String> usedParentIds = ObjectOpenHashSet.newInstanceWithCapacity(numParents, 0.5f);
        ObjectArrayList<ParentDocument> parents = ObjectArrayList.newInstanceWithCapacity(numParents);

        for (int i = 0; i < numParents; i++) {
            String parentId;
            do {
                parentId = RandomStrings.randomAsciiOfLength(RANDOM, 10);
            } while (!usedParentIds.add(parentId));
            String[] queryValues = new String[numChildrenPerParent];
            for (int j = 0; j < numChildrenPerParent; j++) {
                queryValues[j] = getQueryValue();
            }
            parents.add(new ParentDocument(parentId, queryValues));
        }

        int indexCounter = 0;
        int childIdCounter = 0;
        while (!parents.isEmpty()) {
            BulkRequestBuilder request = client.prepareBulk();
            for (int i = 0; !parents.isEmpty() && i < 100; i++) {
                int index = RANDOM.nextInt(parents.size());
                ParentDocument parentDocument = parents.get(index);

                if (parentDocument.indexCounter == -1) {
                    request.add(Requests.indexRequest("test").type("parent")
                            .id(parentDocument.parentId)
                            .source("field1", getQueryValue()));
                } else {
                    request.add(Requests.indexRequest("test").type("child")
                            .parent(parentDocument.parentId)
                            .id(String.valueOf(++childIdCounter))
                            .source("field2", parentDocument.queryValues[parentDocument.indexCounter]));
                }

                if (++parentDocument.indexCounter == parentDocument.queryValues.length) {
                    parents.remove(index);
                }
            }

            BulkResponse response = request.execute().actionGet();
            if (response.hasFailures()) {
                System.err.println("--> failures...");
            }

            indexCounter += response.getItems().length;
            if (indexCounter % 100000 == 0) {
                System.out.println("--> Indexed " + indexCounter + " documents");
            }
        }
    }


, Instance #
frags: 
(startLine=327 endLine=356 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
        } else if (type == Type.PHRASE_PREFIX) {
            MultiPhrasePrefixQuery mpq = new MultiPhrasePrefixQuery();
            mpq.setSlop(phraseSlop);
            mpq.setMaxExpansions(maxExpansions);
            List<Term> multiTerms = new ArrayList<Term>();
            int position = -1;
            for (int i = 0; i < numTokens; i++) {
                int positionIncrement = 1;
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                positionIncrement = posIncrAtt.getPositionIncrement();

                if (positionIncrement > 0 && multiTerms.size() > 0) {
                    if (enablePositionIncrements) {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                    } else {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                    }
                    multiTerms.clear();
                }
                position += positionIncrement;
                multiTerms.add(new Term(field, termToByteRef(termAtt)));
            }
            if (enablePositionIncrements) {
                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
            } else {
                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
            }
            return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);
        }

(startLine=278 endLine=307 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
            if (severalTokensAtSamePosition) {
                final MultiPhraseQuery mpq = new MultiPhraseQuery();
                mpq.setSlop(phraseSlop);
                final List<Term> multiTerms = new ArrayList<Term>();
                int position = -1;
                for (int i = 0; i < numTokens; i++) {
                    int positionIncrement = 1;
                    boolean hasNext = buffer.incrementToken();
                    assert hasNext == true;
                    positionIncrement = posIncrAtt.getPositionIncrement();

                    if (positionIncrement > 0 && multiTerms.size() > 0) {
                        if (enablePositionIncrements) {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                        } else {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                        }
                        multiTerms.clear();
                    }
                    position += positionIncrement;
                    //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8 
                    multiTerms.add(new Term(field, termToByteRef(termAtt)));
                }
                if (enablePositionIncrements) {
                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                } else {
                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                }
                return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);
            } else {

commonMethod: 
(startLine=87 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/01152/src/main/java/org/elasticsearch/common/lucene/search/MultiPhrasePrefixQuery.java)
    /**
     * Allows to specify the relative position of terms within the phrase.
     *
     * @param terms
     * @param position
     * @see org.apache.lucene.search.PhraseQuery#add(Term, int)
     */
    public void add(Term[] terms, int position) {
        if (termArrays.size() == 0)
            field = terms[0].field();

        for (int i = 0; i < terms.length; i++) {
            if (terms[i].field() != field) {
                throw new IllegalArgumentException(
                        "All phrase terms must be in the same field (" + field + "): "
                                + terms[i]);
            }
        }

        termArrays.add(terms);
        positions.add(Integer.valueOf(position));
    }


, Instance #
frags: 
(startLine=327 endLine=356 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
        } else if (type == Type.PHRASE_PREFIX) {
            MultiPhrasePrefixQuery mpq = new MultiPhrasePrefixQuery();
            mpq.setSlop(phraseSlop);
            mpq.setMaxExpansions(maxExpansions);
            List<Term> multiTerms = new ArrayList<Term>();
            int position = -1;
            for (int i = 0; i < numTokens; i++) {
                int positionIncrement = 1;
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                positionIncrement = posIncrAtt.getPositionIncrement();

                if (positionIncrement > 0 && multiTerms.size() > 0) {
                    if (enablePositionIncrements) {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                    } else {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                    }
                    multiTerms.clear();
                }
                position += positionIncrement;
                multiTerms.add(new Term(field, termToByteRef(termAtt)));
            }
            if (enablePositionIncrements) {
                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
            } else {
                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
            }
            return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);
        }

(startLine=278 endLine=307 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
            if (severalTokensAtSamePosition) {
                final MultiPhraseQuery mpq = new MultiPhraseQuery();
                mpq.setSlop(phraseSlop);
                final List<Term> multiTerms = new ArrayList<Term>();
                int position = -1;
                for (int i = 0; i < numTokens; i++) {
                    int positionIncrement = 1;
                    boolean hasNext = buffer.incrementToken();
                    assert hasNext == true;
                    positionIncrement = posIncrAtt.getPositionIncrement();

                    if (positionIncrement > 0 && multiTerms.size() > 0) {
                        if (enablePositionIncrements) {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                        } else {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                        }
                        multiTerms.clear();
                    }
                    position += positionIncrement;
                    //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8 
                    multiTerms.add(new Term(field, termToByteRef(termAtt)));
                }
                if (enablePositionIncrements) {
                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                } else {
                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                }
                return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);
            } else {

commonMethod: 
(startLine=67 endLine=71 srcPath=/root/NewExperiment/elasticsearchFilter/01152/src/main/java/org/elasticsearch/index/query/QueryParseContext.java)
    public static String[] setTypesWithPrevious(String[] types) {
        String[] old = typesContext.get();
        setTypes(types);
        return old;
    }


, Instance #
frags: 
(startLine=327 endLine=356 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
        } else if (type == Type.PHRASE_PREFIX) {
            MultiPhrasePrefixQuery mpq = new MultiPhrasePrefixQuery();
            mpq.setSlop(phraseSlop);
            mpq.setMaxExpansions(maxExpansions);
            List<Term> multiTerms = new ArrayList<Term>();
            int position = -1;
            for (int i = 0; i < numTokens; i++) {
                int positionIncrement = 1;
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                positionIncrement = posIncrAtt.getPositionIncrement();

                if (positionIncrement > 0 && multiTerms.size() > 0) {
                    if (enablePositionIncrements) {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                    } else {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                    }
                    multiTerms.clear();
                }
                position += positionIncrement;
                multiTerms.add(new Term(field, termToByteRef(termAtt)));
            }
            if (enablePositionIncrements) {
                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
            } else {
                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
            }
            return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);
        }

(startLine=278 endLine=307 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
            if (severalTokensAtSamePosition) {
                final MultiPhraseQuery mpq = new MultiPhraseQuery();
                mpq.setSlop(phraseSlop);
                final List<Term> multiTerms = new ArrayList<Term>();
                int position = -1;
                for (int i = 0; i < numTokens; i++) {
                    int positionIncrement = 1;
                    boolean hasNext = buffer.incrementToken();
                    assert hasNext == true;
                    positionIncrement = posIncrAtt.getPositionIncrement();

                    if (positionIncrement > 0 && multiTerms.size() > 0) {
                        if (enablePositionIncrements) {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                        } else {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                        }
                        multiTerms.clear();
                    }
                    position += positionIncrement;
                    //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8 
                    multiTerms.add(new Term(field, termToByteRef(termAtt)));
                }
                if (enablePositionIncrements) {
                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                } else {
                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                }
                return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);
            } else {

commonMethod: 
(startLine=279 endLine=294 srcPath=/root/NewExperiment/elasticsearchFilter/01152/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
        public Query createCommonTermsQuery(String field, String queryText, Occur highFreqOccur, Occur lowFreqOccur, float maxTermFrequency) {
            Query booleanQuery = createBooleanQuery(field, queryText, Occur.SHOULD);
            if (booleanQuery != null && booleanQuery instanceof BooleanQuery) {
                BooleanQuery bq = (BooleanQuery) booleanQuery;
                ExtendedCommonTermsQuery query = new ExtendedCommonTermsQuery(highFreqOccur, lowFreqOccur, maxTermFrequency, ((BooleanQuery)booleanQuery).isCoordDisabled());
                for (BooleanClause clause : bq.clauses()) {
                    if (!(clause.getQuery() instanceof TermQuery)) {
                        return booleanQuery;
                    }
                    query.add(((TermQuery) clause.getQuery()).getTerm());
                }
                return query;
            }
            return booleanQuery;

        }


, Instance #
frags: 
(startLine=327 endLine=356 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
        } else if (type == Type.PHRASE_PREFIX) {
            MultiPhrasePrefixQuery mpq = new MultiPhrasePrefixQuery();
            mpq.setSlop(phraseSlop);
            mpq.setMaxExpansions(maxExpansions);
            List<Term> multiTerms = new ArrayList<Term>();
            int position = -1;
            for (int i = 0; i < numTokens; i++) {
                int positionIncrement = 1;
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                positionIncrement = posIncrAtt.getPositionIncrement();

                if (positionIncrement > 0 && multiTerms.size() > 0) {
                    if (enablePositionIncrements) {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                    } else {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                    }
                    multiTerms.clear();
                }
                position += positionIncrement;
                multiTerms.add(new Term(field, termToByteRef(termAtt)));
            }
            if (enablePositionIncrements) {
                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
            } else {
                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
            }
            return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);
        }

(startLine=278 endLine=307 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
            if (severalTokensAtSamePosition) {
                final MultiPhraseQuery mpq = new MultiPhraseQuery();
                mpq.setSlop(phraseSlop);
                final List<Term> multiTerms = new ArrayList<Term>();
                int position = -1;
                for (int i = 0; i < numTokens; i++) {
                    int positionIncrement = 1;
                    boolean hasNext = buffer.incrementToken();
                    assert hasNext == true;
                    positionIncrement = posIncrAtt.getPositionIncrement();

                    if (positionIncrement > 0 && multiTerms.size() > 0) {
                        if (enablePositionIncrements) {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                        } else {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                        }
                        multiTerms.clear();
                    }
                    position += positionIncrement;
                    //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8 
                    multiTerms.add(new Term(field, termToByteRef(termAtt)));
                }
                if (enablePositionIncrements) {
                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                } else {
                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                }
                return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);
            } else {

commonMethod: 
(startLine=253 endLine=277 srcPath=/root/NewExperiment/elasticsearchFilter/01152/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
        public Query createPhrasePrefixQuery(String field, String queryText, int phraseSlop, int maxExpansions) {
            Query query = createFieldQuery(getAnalyzer(), Occur.MUST, field, queryText, true, phraseSlop);
            if (query instanceof PhraseQuery) {
                PhraseQuery pq = (PhraseQuery)query;
                MultiPhrasePrefixQuery prefixQuery = new MultiPhrasePrefixQuery();
                prefixQuery.setMaxExpansions(maxExpansions);
                Term[] terms = pq.getTerms();
                int[] positions = pq.getPositions();
                for (int i = 0; i < terms.length; i++) {
                    prefixQuery.add(new Term[] {terms[i]}, positions[i]);
                }
                return prefixQuery;
            } else if (query instanceof MultiPhraseQuery) {
                MultiPhraseQuery pq = (MultiPhraseQuery)query;
                MultiPhrasePrefixQuery prefixQuery = new MultiPhrasePrefixQuery();
                prefixQuery.setMaxExpansions(maxExpansions);
                List<Term[]> terms = pq.getTermArrays();
                int[] positions = pq.getPositions();
                for (int i = 0; i < terms.size(); i++) {
                    prefixQuery.add(terms.get(i), positions[i]);
                }
                return prefixQuery;
            }
            return query;
        }


, Instance #
frags: 
(startLine=327 endLine=356 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
        } else if (type == Type.PHRASE_PREFIX) {
            MultiPhrasePrefixQuery mpq = new MultiPhrasePrefixQuery();
            mpq.setSlop(phraseSlop);
            mpq.setMaxExpansions(maxExpansions);
            List<Term> multiTerms = new ArrayList<Term>();
            int position = -1;
            for (int i = 0; i < numTokens; i++) {
                int positionIncrement = 1;
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                positionIncrement = posIncrAtt.getPositionIncrement();

                if (positionIncrement > 0 && multiTerms.size() > 0) {
                    if (enablePositionIncrements) {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                    } else {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                    }
                    multiTerms.clear();
                }
                position += positionIncrement;
                multiTerms.add(new Term(field, termToByteRef(termAtt)));
            }
            if (enablePositionIncrements) {
                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
            } else {
                mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
            }
            return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);
        }

(startLine=278 endLine=307 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
            if (severalTokensAtSamePosition) {
                final MultiPhraseQuery mpq = new MultiPhraseQuery();
                mpq.setSlop(phraseSlop);
                final List<Term> multiTerms = new ArrayList<Term>();
                int position = -1;
                for (int i = 0; i < numTokens; i++) {
                    int positionIncrement = 1;
                    boolean hasNext = buffer.incrementToken();
                    assert hasNext == true;
                    positionIncrement = posIncrAtt.getPositionIncrement();

                    if (positionIncrement > 0 && multiTerms.size() > 0) {
                        if (enablePositionIncrements) {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                        } else {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                        }
                        multiTerms.clear();
                    }
                    position += positionIncrement;
                    //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8 
                    multiTerms.add(new Term(field, termToByteRef(termAtt)));
                }
                if (enablePositionIncrements) {
                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                } else {
                    mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                }
                return wrapSmartNameQuery(mpq, smartNameFieldMappers, parseContext);
            } else {

commonMethod: 
(startLine=297 endLine=317 srcPath=/root/NewExperiment/elasticsearchFilter/01152/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
    protected Query blendTermQuery(Term term, FieldMapper mapper) {
        if (fuzziness != null) {
            if (mapper != null) {
                Query query = mapper.fuzzyQuery(term.text(), fuzziness, fuzzyPrefixLength, maxExpansions, transpositions);
                if (query instanceof FuzzyQuery) {
                    QueryParsers.setRewriteMethod((FuzzyQuery) query, fuzzyRewriteMethod);
                }
            }
            int edits = fuzziness.asDistance(term.text());
            FuzzyQuery query = new FuzzyQuery(term, edits, fuzzyPrefixLength, maxExpansions, transpositions);
            QueryParsers.setRewriteMethod(query, rewriteMethod);
            return query;
        }
        if (mapper != null) {
            Query termQuery = mapper.queryStringTermQuery(term);
            if (termQuery != null) {
                return termQuery;
            }
        }
        return new TermQuery(term);
    }


, Instance #
frags: 
(startLine=283 endLine=300 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
                for (int i = 0; i < numTokens; i++) {
                    int positionIncrement = 1;
                    boolean hasNext = buffer.incrementToken();
                    assert hasNext == true;
                    positionIncrement = posIncrAtt.getPositionIncrement();

                    if (positionIncrement > 0 && multiTerms.size() > 0) {
                        if (enablePositionIncrements) {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                        } else {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                        }
                        multiTerms.clear();
                    }
                    position += positionIncrement;
                    //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8 
                    multiTerms.add(new Term(field, termToByteRef(termAtt)));
                }

(startLine=333 endLine=349 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
            for (int i = 0; i < numTokens; i++) {
                int positionIncrement = 1;
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                positionIncrement = posIncrAtt.getPositionIncrement();

                if (positionIncrement > 0 && multiTerms.size() > 0) {
                    if (enablePositionIncrements) {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                    } else {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                    }
                    multiTerms.clear();
                }
                position += positionIncrement;
                multiTerms.add(new Term(field, termToByteRef(termAtt)));
            }

commonMethod: 
(startLine=87 endLine=108 srcPath=/root/NewExperiment/elasticsearchFilter/01152/src/main/java/org/elasticsearch/common/lucene/search/MultiPhrasePrefixQuery.java)
    /**
     * Allows to specify the relative position of terms within the phrase.
     *
     * @param terms
     * @param position
     * @see org.apache.lucene.search.PhraseQuery#add(Term, int)
     */
    public void add(Term[] terms, int position) {
        if (termArrays.size() == 0)
            field = terms[0].field();

        for (int i = 0; i < terms.length; i++) {
            if (terms[i].field() != field) {
                throw new IllegalArgumentException(
                        "All phrase terms must be in the same field (" + field + "): "
                                + terms[i]);
            }
        }

        termArrays.add(terms);
        positions.add(Integer.valueOf(position));
    }


, Instance #
frags: 
(startLine=283 endLine=300 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
                for (int i = 0; i < numTokens; i++) {
                    int positionIncrement = 1;
                    boolean hasNext = buffer.incrementToken();
                    assert hasNext == true;
                    positionIncrement = posIncrAtt.getPositionIncrement();

                    if (positionIncrement > 0 && multiTerms.size() > 0) {
                        if (enablePositionIncrements) {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                        } else {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                        }
                        multiTerms.clear();
                    }
                    position += positionIncrement;
                    //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8 
                    multiTerms.add(new Term(field, termToByteRef(termAtt)));
                }

(startLine=333 endLine=349 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
            for (int i = 0; i < numTokens; i++) {
                int positionIncrement = 1;
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                positionIncrement = posIncrAtt.getPositionIncrement();

                if (positionIncrement > 0 && multiTerms.size() > 0) {
                    if (enablePositionIncrements) {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                    } else {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                    }
                    multiTerms.clear();
                }
                position += positionIncrement;
                multiTerms.add(new Term(field, termToByteRef(termAtt)));
            }

commonMethod: 
(startLine=67 endLine=71 srcPath=/root/NewExperiment/elasticsearchFilter/01152/src/main/java/org/elasticsearch/index/query/QueryParseContext.java)
    public static String[] setTypesWithPrevious(String[] types) {
        String[] old = typesContext.get();
        setTypes(types);
        return old;
    }


, Instance #
frags: 
(startLine=283 endLine=300 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
                for (int i = 0; i < numTokens; i++) {
                    int positionIncrement = 1;
                    boolean hasNext = buffer.incrementToken();
                    assert hasNext == true;
                    positionIncrement = posIncrAtt.getPositionIncrement();

                    if (positionIncrement > 0 && multiTerms.size() > 0) {
                        if (enablePositionIncrements) {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                        } else {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                        }
                        multiTerms.clear();
                    }
                    position += positionIncrement;
                    //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8 
                    multiTerms.add(new Term(field, termToByteRef(termAtt)));
                }

(startLine=333 endLine=349 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
            for (int i = 0; i < numTokens; i++) {
                int positionIncrement = 1;
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                positionIncrement = posIncrAtt.getPositionIncrement();

                if (positionIncrement > 0 && multiTerms.size() > 0) {
                    if (enablePositionIncrements) {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                    } else {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                    }
                    multiTerms.clear();
                }
                position += positionIncrement;
                multiTerms.add(new Term(field, termToByteRef(termAtt)));
            }

commonMethod: 
(startLine=279 endLine=294 srcPath=/root/NewExperiment/elasticsearchFilter/01152/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
        public Query createCommonTermsQuery(String field, String queryText, Occur highFreqOccur, Occur lowFreqOccur, float maxTermFrequency) {
            Query booleanQuery = createBooleanQuery(field, queryText, Occur.SHOULD);
            if (booleanQuery != null && booleanQuery instanceof BooleanQuery) {
                BooleanQuery bq = (BooleanQuery) booleanQuery;
                ExtendedCommonTermsQuery query = new ExtendedCommonTermsQuery(highFreqOccur, lowFreqOccur, maxTermFrequency, ((BooleanQuery)booleanQuery).isCoordDisabled());
                for (BooleanClause clause : bq.clauses()) {
                    if (!(clause.getQuery() instanceof TermQuery)) {
                        return booleanQuery;
                    }
                    query.add(((TermQuery) clause.getQuery()).getTerm());
                }
                return query;
            }
            return booleanQuery;

        }


, Instance #
frags: 
(startLine=283 endLine=300 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
                for (int i = 0; i < numTokens; i++) {
                    int positionIncrement = 1;
                    boolean hasNext = buffer.incrementToken();
                    assert hasNext == true;
                    positionIncrement = posIncrAtt.getPositionIncrement();

                    if (positionIncrement > 0 && multiTerms.size() > 0) {
                        if (enablePositionIncrements) {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                        } else {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                        }
                        multiTerms.clear();
                    }
                    position += positionIncrement;
                    //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8 
                    multiTerms.add(new Term(field, termToByteRef(termAtt)));
                }

(startLine=333 endLine=349 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
            for (int i = 0; i < numTokens; i++) {
                int positionIncrement = 1;
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                positionIncrement = posIncrAtt.getPositionIncrement();

                if (positionIncrement > 0 && multiTerms.size() > 0) {
                    if (enablePositionIncrements) {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                    } else {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                    }
                    multiTerms.clear();
                }
                position += positionIncrement;
                multiTerms.add(new Term(field, termToByteRef(termAtt)));
            }

commonMethod: 
(startLine=253 endLine=277 srcPath=/root/NewExperiment/elasticsearchFilter/01152/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
        public Query createPhrasePrefixQuery(String field, String queryText, int phraseSlop, int maxExpansions) {
            Query query = createFieldQuery(getAnalyzer(), Occur.MUST, field, queryText, true, phraseSlop);
            if (query instanceof PhraseQuery) {
                PhraseQuery pq = (PhraseQuery)query;
                MultiPhrasePrefixQuery prefixQuery = new MultiPhrasePrefixQuery();
                prefixQuery.setMaxExpansions(maxExpansions);
                Term[] terms = pq.getTerms();
                int[] positions = pq.getPositions();
                for (int i = 0; i < terms.length; i++) {
                    prefixQuery.add(new Term[] {terms[i]}, positions[i]);
                }
                return prefixQuery;
            } else if (query instanceof MultiPhraseQuery) {
                MultiPhraseQuery pq = (MultiPhraseQuery)query;
                MultiPhrasePrefixQuery prefixQuery = new MultiPhrasePrefixQuery();
                prefixQuery.setMaxExpansions(maxExpansions);
                List<Term[]> terms = pq.getTermArrays();
                int[] positions = pq.getPositions();
                for (int i = 0; i < terms.size(); i++) {
                    prefixQuery.add(terms.get(i), positions[i]);
                }
                return prefixQuery;
            }
            return query;
        }


, Instance #
frags: 
(startLine=283 endLine=300 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
                for (int i = 0; i < numTokens; i++) {
                    int positionIncrement = 1;
                    boolean hasNext = buffer.incrementToken();
                    assert hasNext == true;
                    positionIncrement = posIncrAtt.getPositionIncrement();

                    if (positionIncrement > 0 && multiTerms.size() > 0) {
                        if (enablePositionIncrements) {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                        } else {
                            mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                        }
                        multiTerms.clear();
                    }
                    position += positionIncrement;
                    //LUCENE 4 UPGRADE instead of string term we can convert directly from utf-16 to utf-8 
                    multiTerms.add(new Term(field, termToByteRef(termAtt)));
                }

(startLine=333 endLine=349 srcPath=/root/NewExperiment/elasticsearchFilter/01151/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
            for (int i = 0; i < numTokens; i++) {
                int positionIncrement = 1;
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                positionIncrement = posIncrAtt.getPositionIncrement();

                if (positionIncrement > 0 && multiTerms.size() > 0) {
                    if (enablePositionIncrements) {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]), position);
                    } else {
                        mpq.add(multiTerms.toArray(new Term[multiTerms.size()]));
                    }
                    multiTerms.clear();
                }
                position += positionIncrement;
                multiTerms.add(new Term(field, termToByteRef(termAtt)));
            }

commonMethod: 
(startLine=297 endLine=317 srcPath=/root/NewExperiment/elasticsearchFilter/01152/src/main/java/org/elasticsearch/index/search/MatchQuery.java)
    protected Query blendTermQuery(Term term, FieldMapper mapper) {
        if (fuzziness != null) {
            if (mapper != null) {
                Query query = mapper.fuzzyQuery(term.text(), fuzziness, fuzzyPrefixLength, maxExpansions, transpositions);
                if (query instanceof FuzzyQuery) {
                    QueryParsers.setRewriteMethod((FuzzyQuery) query, fuzzyRewriteMethod);
                }
            }
            int edits = fuzziness.asDistance(term.text());
            FuzzyQuery query = new FuzzyQuery(term, edits, fuzzyPrefixLength, maxExpansions, transpositions);
            QueryParsers.setRewriteMethod(query, rewriteMethod);
            return query;
        }
        if (mapper != null) {
            Query termQuery = mapper.queryStringTermQuery(term);
            if (termQuery != null) {
                return termQuery;
            }
        }
        return new TermQuery(term);
    }


, Instance #
frags: 
(startLine=141 endLine=174 srcPath=/root/NewExperiment/elasticsearchFilter/01170/src/test/java/org/elasticsearch/test/rest/test/DoSectionParserTests.java)
    public void testParseDoSectionWithJsonMultipleBodiesRepeatedProperty() throws Exception {
        String[] bodies = new String[] {
                "{ \"index\": { \"_index\":\"test_index\", \"_type\":\"test_type\", \"_id\":\"test_id\" } }",
                "{ \"f1\":\"v1\", \"f2\":42 }",
        };
        parser = YamlXContent.yamlXContent.createParser(
                "bulk:\n" +
                "    refresh: true\n" +
                "    body: \n" +
                "        " + bodies[0] + "\n" +
                "    body: \n" +
                "        " + bodies[1]
        );

        DoSectionParser doSectionParser = new DoSectionParser();
        DoSection doSection = doSectionParser.parse(new RestTestSuiteParseContext("api", "suite", parser, "0.90.7"));
        ApiCallSection apiCallSection = doSection.getApiCallSection();

        assertThat(apiCallSection, notNullValue());
        assertThat(apiCallSection.getApi(), equalTo("bulk"));
        assertThat(apiCallSection.getParams().size(), equalTo(1));
        assertThat(apiCallSection.getParams().get("refresh"), equalTo("true"));
        assertThat(apiCallSection.hasBody(), equalTo(true));
        assertThat(apiCallSection.getBodiesAsList().size(), equalTo(bodies.length));
        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(apiCallSection.getBodiesAsList().get(i), bodies[i]);
        }

        String[] returnedBodies = apiCallSection.getBody().split("\n");
        assertThat(returnedBodies.length, equalTo(bodies.length));
        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(returnedBodies[i], bodies[i]);
        }
    }

(startLine=200 endLine=244 srcPath=/root/NewExperiment/elasticsearchFilter/01170/src/test/java/org/elasticsearch/test/rest/test/DoSectionParserTests.java)
    public void testParseDoSectionWithYamlMultipleBodies() throws Exception {
        parser = YamlXContent.yamlXContent.createParser(
                "bulk:\n" +
                "    refresh: true\n" +
                "    body:\n" +
                "        - index:\n" +
                "            _index: test_index\n" +
                "            _type:  test_type\n" +
                "            _id:    test_id\n" +
                "        - f1: v1\n" +
                "          f2: 42\n" +
                "        - index:\n" +
                "            _index: test_index2\n" +
                "            _type:  test_type2\n" +
                "            _id:    test_id2\n" +
                "        - f1: v2\n" +
                "          f2: 47"
        );
        String[] bodies = new String[4];
        bodies[0] = "{\"index\": {\"_index\": \"test_index\", \"_type\":  \"test_type\", \"_id\": \"test_id\"}}";
        bodies[1] = "{ \"f1\":\"v1\", \"f2\": 42 }";
        bodies[2] = "{\"index\": {\"_index\": \"test_index2\", \"_type\":  \"test_type2\", \"_id\": \"test_id2\"}}";
        bodies[3] = "{ \"f1\":\"v2\", \"f2\": 47 }";

        DoSectionParser doSectionParser = new DoSectionParser();
        DoSection doSection = doSectionParser.parse(new RestTestSuiteParseContext("api", "suite", parser, "0.90.7"));
        ApiCallSection apiCallSection = doSection.getApiCallSection();

        assertThat(apiCallSection, notNullValue());
        assertThat(apiCallSection.getApi(), equalTo("bulk"));
        assertThat(apiCallSection.getParams().size(), equalTo(1));
        assertThat(apiCallSection.getParams().get("refresh"), equalTo("true"));
        assertThat(apiCallSection.hasBody(), equalTo(true));
        assertThat(apiCallSection.getBodiesAsList().size(), equalTo(bodies.length));

        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(apiCallSection.getBodiesAsList().get(i), bodies[i]);
        }

        String[] returnedBodies = apiCallSection.getBody().split("\n");
        assertThat(returnedBodies.length, equalTo(bodies.length));
        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(returnedBodies[i], bodies[i]);
        }
    }

(startLine=247 endLine=284 srcPath=/root/NewExperiment/elasticsearchFilter/01170/src/test/java/org/elasticsearch/test/rest/test/DoSectionParserTests.java)
    public void testParseDoSectionWithYamlMultipleBodiesRepeatedProperty() throws Exception {
        parser = YamlXContent.yamlXContent.createParser(
                "bulk:\n" +
                "    refresh: true\n" +
                "    body:\n" +
                "        index:\n" +
                "            _index: test_index\n" +
                "            _type:  test_type\n" +
                "            _id:    test_id\n" +
                "    body:\n" +
                "        f1: v1\n" +
                "        f2: 42\n"
        );
        String[] bodies = new String[2];
        bodies[0] = "{\"index\": {\"_index\": \"test_index\", \"_type\":  \"test_type\", \"_id\": \"test_id\"}}";
        bodies[1] = "{ \"f1\":\"v1\", \"f2\": 42 }";

        DoSectionParser doSectionParser = new DoSectionParser();
        DoSection doSection = doSectionParser.parse(new RestTestSuiteParseContext("api", "suite", parser, "0.90.7"));
        ApiCallSection apiCallSection = doSection.getApiCallSection();

        assertThat(apiCallSection, notNullValue());
        assertThat(apiCallSection.getApi(), equalTo("bulk"));
        assertThat(apiCallSection.getParams().size(), equalTo(1));
        assertThat(apiCallSection.getParams().get("refresh"), equalTo("true"));
        assertThat(apiCallSection.hasBody(), equalTo(true));
        assertThat(apiCallSection.getBodiesAsList().size(), equalTo(bodies.length));

        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(apiCallSection.getBodiesAsList().get(i), bodies[i]);
        }

        String[] returnedBodies = apiCallSection.getBody().split("\n");
        assertThat(returnedBodies.length, equalTo(bodies.length));
        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(returnedBodies[i], bodies[i]);
        }
    }

commonMethod: 
(startLine=60 endLine=62 srcPath=/root/NewExperiment/elasticsearchFilter/01171/src/test/java/org/elasticsearch/test/rest/section/ApiCallSection.java)
    public List<Map<String, Object>> getBodies() {
        return ImmutableList.copyOf(bodies);
    }


, Instance #
frags: 
(startLine=200 endLine=244 srcPath=/root/NewExperiment/elasticsearchFilter/01170/src/test/java/org/elasticsearch/test/rest/test/DoSectionParserTests.java)
    public void testParseDoSectionWithYamlMultipleBodies() throws Exception {
        parser = YamlXContent.yamlXContent.createParser(
                "bulk:\n" +
                "    refresh: true\n" +
                "    body:\n" +
                "        - index:\n" +
                "            _index: test_index\n" +
                "            _type:  test_type\n" +
                "            _id:    test_id\n" +
                "        - f1: v1\n" +
                "          f2: 42\n" +
                "        - index:\n" +
                "            _index: test_index2\n" +
                "            _type:  test_type2\n" +
                "            _id:    test_id2\n" +
                "        - f1: v2\n" +
                "          f2: 47"
        );
        String[] bodies = new String[4];
        bodies[0] = "{\"index\": {\"_index\": \"test_index\", \"_type\":  \"test_type\", \"_id\": \"test_id\"}}";
        bodies[1] = "{ \"f1\":\"v1\", \"f2\": 42 }";
        bodies[2] = "{\"index\": {\"_index\": \"test_index2\", \"_type\":  \"test_type2\", \"_id\": \"test_id2\"}}";
        bodies[3] = "{ \"f1\":\"v2\", \"f2\": 47 }";

        DoSectionParser doSectionParser = new DoSectionParser();
        DoSection doSection = doSectionParser.parse(new RestTestSuiteParseContext("api", "suite", parser, "0.90.7"));
        ApiCallSection apiCallSection = doSection.getApiCallSection();

        assertThat(apiCallSection, notNullValue());
        assertThat(apiCallSection.getApi(), equalTo("bulk"));
        assertThat(apiCallSection.getParams().size(), equalTo(1));
        assertThat(apiCallSection.getParams().get("refresh"), equalTo("true"));
        assertThat(apiCallSection.hasBody(), equalTo(true));
        assertThat(apiCallSection.getBodiesAsList().size(), equalTo(bodies.length));

        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(apiCallSection.getBodiesAsList().get(i), bodies[i]);
        }

        String[] returnedBodies = apiCallSection.getBody().split("\n");
        assertThat(returnedBodies.length, equalTo(bodies.length));
        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(returnedBodies[i], bodies[i]);
        }
    }

(startLine=247 endLine=284 srcPath=/root/NewExperiment/elasticsearchFilter/01170/src/test/java/org/elasticsearch/test/rest/test/DoSectionParserTests.java)
    public void testParseDoSectionWithYamlMultipleBodiesRepeatedProperty() throws Exception {
        parser = YamlXContent.yamlXContent.createParser(
                "bulk:\n" +
                "    refresh: true\n" +
                "    body:\n" +
                "        index:\n" +
                "            _index: test_index\n" +
                "            _type:  test_type\n" +
                "            _id:    test_id\n" +
                "    body:\n" +
                "        f1: v1\n" +
                "        f2: 42\n"
        );
        String[] bodies = new String[2];
        bodies[0] = "{\"index\": {\"_index\": \"test_index\", \"_type\":  \"test_type\", \"_id\": \"test_id\"}}";
        bodies[1] = "{ \"f1\":\"v1\", \"f2\": 42 }";

        DoSectionParser doSectionParser = new DoSectionParser();
        DoSection doSection = doSectionParser.parse(new RestTestSuiteParseContext("api", "suite", parser, "0.90.7"));
        ApiCallSection apiCallSection = doSection.getApiCallSection();

        assertThat(apiCallSection, notNullValue());
        assertThat(apiCallSection.getApi(), equalTo("bulk"));
        assertThat(apiCallSection.getParams().size(), equalTo(1));
        assertThat(apiCallSection.getParams().get("refresh"), equalTo("true"));
        assertThat(apiCallSection.hasBody(), equalTo(true));
        assertThat(apiCallSection.getBodiesAsList().size(), equalTo(bodies.length));

        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(apiCallSection.getBodiesAsList().get(i), bodies[i]);
        }

        String[] returnedBodies = apiCallSection.getBody().split("\n");
        assertThat(returnedBodies.length, equalTo(bodies.length));
        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(returnedBodies[i], bodies[i]);
        }
    }

(startLine=141 endLine=174 srcPath=/root/NewExperiment/elasticsearchFilter/01170/src/test/java/org/elasticsearch/test/rest/test/DoSectionParserTests.java)
    public void testParseDoSectionWithJsonMultipleBodiesRepeatedProperty() throws Exception {
        String[] bodies = new String[] {
                "{ \"index\": { \"_index\":\"test_index\", \"_type\":\"test_type\", \"_id\":\"test_id\" } }",
                "{ \"f1\":\"v1\", \"f2\":42 }",
        };
        parser = YamlXContent.yamlXContent.createParser(
                "bulk:\n" +
                "    refresh: true\n" +
                "    body: \n" +
                "        " + bodies[0] + "\n" +
                "    body: \n" +
                "        " + bodies[1]
        );

        DoSectionParser doSectionParser = new DoSectionParser();
        DoSection doSection = doSectionParser.parse(new RestTestSuiteParseContext("api", "suite", parser, "0.90.7"));
        ApiCallSection apiCallSection = doSection.getApiCallSection();

        assertThat(apiCallSection, notNullValue());
        assertThat(apiCallSection.getApi(), equalTo("bulk"));
        assertThat(apiCallSection.getParams().size(), equalTo(1));
        assertThat(apiCallSection.getParams().get("refresh"), equalTo("true"));
        assertThat(apiCallSection.hasBody(), equalTo(true));
        assertThat(apiCallSection.getBodiesAsList().size(), equalTo(bodies.length));
        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(apiCallSection.getBodiesAsList().get(i), bodies[i]);
        }

        String[] returnedBodies = apiCallSection.getBody().split("\n");
        assertThat(returnedBodies.length, equalTo(bodies.length));
        for (int i = 0; i < bodies.length; i++) {
            assertJsonEquals(returnedBodies[i], bodies[i]);
        }
    }

commonMethod: 
(startLine=60 endLine=62 srcPath=/root/NewExperiment/elasticsearchFilter/01171/src/test/java/org/elasticsearch/test/rest/section/ApiCallSection.java)
    public List<Map<String, Object>> getBodies() {
        return ImmutableList.copyOf(bodies);
    }


, Instance #
frags: 
(startLine=66 endLine=89 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/aggregations/bucket/ShardSizeTermsTests.java)
    public void noShardSize_string() throws Exception {
        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addAggregation(terms("keys").field("key").size(3).order(Terms.Order.count(false)))
                .execute().actionGet();

        Terms  terms = response.getAggregations().get("keys");
        Collection<Terms.Bucket> buckets = terms.getBuckets();
        assertThat(buckets.size(), equalTo(3));
        Map<String, Long> expected = ImmutableMap.<String, Long>builder()
                .put("1", 8l)
                .put("3", 8l)
                .put("2", 4l)
                .build();
        for (Terms.Bucket bucket : buckets) {
            assertThat(bucket.getDocCount(), equalTo(expected.get(bucket.getKeyAsText().string())));
        }
    }

(startLine=92 endLine=116 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/aggregations/bucket/ShardSizeTermsTests.java)
    public void withShardSize_string() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addAggregation(terms("keys").field("key").size(3).shardSize(5).order(Terms.Order.count(false)))
                .execute().actionGet();

        Terms terms = response.getAggregations().get("keys");
        Collection<Terms.Bucket> buckets = terms.getBuckets();
        assertThat(buckets.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<String, Long> expected = ImmutableMap.<String, Long>builder()
                .put("1", 8l)
                .put("3", 8l)
                .put("2", 5l) // <-- count is now fixed
                .build();
        for (Terms.Bucket bucket : buckets) {
            assertThat(bucket.getDocCount(), equalTo(expected.get(bucket.getKeyAsText().string())));
        }
    }

(startLine=119 endLine=143 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/aggregations/bucket/ShardSizeTermsTests.java)
    public void withShardSize_string_singleShard() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type").setRouting("1")
                .setQuery(matchAllQuery())
                .addAggregation(terms("keys").field("key").size(3).shardSize(5).order(Terms.Order.count(false)))
                .execute().actionGet();

        Terms terms = response.getAggregations().get("keys");
        Collection<Terms.Bucket> buckets = terms.getBuckets();
        assertThat(buckets.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<String, Long> expected = ImmutableMap.<String, Long>builder()
                .put("1", 5l)
                .put("2", 4l)
                .put("3", 3l) // <-- count is now fixed
                .build();
        for (Terms.Bucket bucket: buckets) {
            assertThat(bucket.getDocCount(), equalTo(expected.get(bucket.getKey())));
        }
    }

(startLine=146 endLine=170 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/aggregations/bucket/ShardSizeTermsTests.java)
    public void noShardSize_long() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=long")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addAggregation(terms("keys").field("key").size(3).order(Terms.Order.count(false)))
                .execute().actionGet();

        Terms terms = response.getAggregations().get("keys");
        Collection<Terms.Bucket> buckets = terms.getBuckets();
        assertThat(buckets.size(), equalTo(3));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 4l)
                .build();
        for (Terms.Bucket bucket : buckets) {
            assertThat(bucket.getDocCount(), equalTo(expected.get(bucket.getKeyAsNumber().intValue())));
        }
    }

(startLine=173 endLine=197 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/aggregations/bucket/ShardSizeTermsTests.java)
    public void withShardSize_long() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=long")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addAggregation(terms("keys").field("key").size(3).shardSize(5).order(Terms.Order.count(false)))
                .execute().actionGet();

        Terms terms = response.getAggregations().get("keys");
        Collection<Terms.Bucket> buckets = terms.getBuckets();
        assertThat(buckets.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 5l) // <-- count is now fixed
                .build();
        for (Terms.Bucket bucket : buckets) {
            assertThat(bucket.getDocCount(), equalTo(expected.get(bucket.getKeyAsNumber().intValue())));
        }
    }

(startLine=200 endLine=224 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/aggregations/bucket/ShardSizeTermsTests.java)
    public void withShardSize_long_singleShard() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=long")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type").setRouting("1")
                .setQuery(matchAllQuery())
                .addAggregation(terms("keys").field("key").size(3).shardSize(5).order(Terms.Order.count(false)))
                .execute().actionGet();

        Terms terms = response.getAggregations().get("keys");
        Collection<Terms.Bucket> buckets = terms.getBuckets();
        assertThat(buckets.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 5l)
                .put(2, 4l)
                .put(3, 3l)
                .build();
        for (Terms.Bucket bucket : buckets) {
            assertThat(bucket.getDocCount(), equalTo(expected.get(bucket.getKeyAsNumber().intValue())));
        }
    }

(startLine=227 endLine=251 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/aggregations/bucket/ShardSizeTermsTests.java)
    public void noShardSize_double() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=double")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addAggregation(terms("keys").field("key").size(3).order(Terms.Order.count(false)))
                .execute().actionGet();

        Terms terms = response.getAggregations().get("keys");
        Collection<Terms.Bucket> buckets = terms.getBuckets();
        assertThat(buckets.size(), equalTo(3));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 4l)
                .build();
        for (Terms.Bucket bucket : buckets) {
            assertThat(bucket.getDocCount(), equalTo(expected.get(bucket.getKeyAsNumber().intValue())));
        }
    }

(startLine=254 endLine=278 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/aggregations/bucket/ShardSizeTermsTests.java)
    public void withShardSize_double() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=double")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addAggregation(terms("keys").field("key").size(3).shardSize(5).order(Terms.Order.count(false)))
                .execute().actionGet();

        Terms terms = response.getAggregations().get("keys");
        Collection<Terms.Bucket> buckets = terms.getBuckets();
        assertThat(buckets.size(), equalTo(3));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 5l) // <-- count is now fixed
                .build();
        for (Terms.Bucket bucket : buckets) {
            assertThat(bucket.getDocCount(), equalTo(expected.get(bucket.getKeyAsNumber().intValue())));
        }
    }

(startLine=281 endLine=305 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/aggregations/bucket/ShardSizeTermsTests.java)
    public void withShardSize_double_singleShard() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=double")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type").setRouting("1")
                .setQuery(matchAllQuery())
                .addAggregation(terms("keys").field("key").size(3).shardSize(5).order(Terms.Order.count(false)))
                .execute().actionGet();

        Terms terms = response.getAggregations().get("keys");
        Collection<Terms.Bucket> buckets = terms.getBuckets();
        assertThat(buckets.size(), equalTo(3));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 5l)
                .put(2, 4l)
                .put(3, 3l)
                .build();
        for (Terms.Bucket bucket : buckets) {
            assertThat(bucket.getDocCount(), equalTo(expected.get(bucket.getKeyAsNumber().intValue())));
        }
    }

commonMethod: 
(startLine=62 endLine=65 srcPath=/root/NewExperiment/elasticsearchFilter/01179/src/test/java/org/elasticsearch/search/aggregations/bucket/ShardSizeTests.java)
    protected void createIdx(String keyFieldMapping) {
        assertAcked(prepareCreate("idx")
                .addMapping("type", "key", keyFieldMapping));
    }


, Instance #
frags: 
(startLine=1397 endLine=1440 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/child/SimpleChildQuerySearchTests.java)
    public void testDeleteByQuery_has_child() throws Exception {
        client().admin().indices().prepareCreate("test")
                .setSettings(
                        ImmutableSettings.settingsBuilder()
                                .put("index.number_of_shards", 1)
                                .put("index.number_of_replicas", 1)
                                .put("index.refresh_interval", "-1")
                )
                .addMapping("parent")
                .addMapping("child", "_parent", "type=parent")
                .get();
        ensureGreen();

        // index simple data
        client().prepareIndex("test", "parent", "p1").setSource("p_field", "p_value1").get();
        client().prepareIndex("test", "child", "c1").setSource("c_field", "red").setParent("p1").get();
        client().prepareIndex("test", "child", "c2").setSource("c_field", "yellow").setParent("p1").get();
        client().prepareIndex("test", "parent", "p2").setSource("p_field", "p_value2").get();
        client().admin().indices().prepareFlush("test").get();
        client().prepareIndex("test", "child", "c3").setSource("c_field", "blue").setParent("p2").get();
        client().prepareIndex("test", "child", "c4").setSource("c_field", "red").setParent("p2").get();
        client().prepareIndex("test", "parent", "p3").setSource("p_field", "p_value3").get();
        client().admin().indices().prepareFlush("test").get();
        client().prepareIndex("test", "child", "c5").setSource("c_field", "blue").setParent("p3").get();
        client().prepareIndex("test", "child", "c6").setSource("c_field", "red").setParent("p3").get();
        client().admin().indices().prepareRefresh().get();
        // p4 will not be found via search api, but will be deleted via delete_by_query api!
        client().prepareIndex("test", "parent", "p4").setSource("p_field", "p_value4").get();
        client().prepareIndex("test", "child", "c7").setSource("c_field", "blue").setParent("p4").get();
        client().prepareIndex("test", "child", "c8").setSource("c_field", "red").setParent("p4").get();

        SearchResponse searchResponse = client().prepareSearch("test")
                .setQuery(randomHasChild("child", "c_field", "blue"))
                .get();
        assertHitCount(searchResponse, 2l);

        client().prepareDeleteByQuery("test").setQuery(randomHasChild("child", "c_field", "blue")).get();
        client().admin().indices().prepareRefresh("test").get();

        searchResponse = client().prepareSearch("test")
                .setQuery(randomHasChild("child", "c_field", "blue"))
                .get();
        assertHitCount(searchResponse, 0l);
    }

(startLine=1443 endLine=1484 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/child/SimpleChildQuerySearchTests.java)
    public void testDeleteByQuery_has_child_SingleRefresh() throws Exception {
        client().admin().indices().prepareCreate("test")
                .setSettings(
                        ImmutableSettings.settingsBuilder()
                                .put("index.number_of_shards", 1)
                                .put("index.number_of_replicas", 1)
                                .put("index.refresh_interval", "-1")
                )
                .addMapping("parent")
                .addMapping("child", "_parent", "type=parent")
                .get();
        ensureGreen();

        // index simple data
        client().prepareIndex("test", "parent", "p1").setSource("p_field", "p_value1").get();
        client().prepareIndex("test", "child", "c1").setSource("c_field", "red").setParent("p1").get();
        client().prepareIndex("test", "child", "c2").setSource("c_field", "yellow").setParent("p1").get();
        client().admin().indices().prepareFlush().get();
        client().prepareIndex("test", "parent", "p2").setSource("p_field", "p_value2").get();
        client().prepareIndex("test", "child", "c3").setSource("c_field", "blue").setParent("p2").get();
        client().prepareIndex("test", "child", "c4").setSource("c_field", "red").setParent("p2").get();
        client().prepareIndex("test", "parent", "p3").setSource("p_field", "p_value3").get();
        client().prepareIndex("test", "child", "c5").setSource("c_field", "blue").setParent("p3").get();
        client().prepareIndex("test", "child", "c6").setSource("c_field", "red").setParent("p3").get();
        client().prepareIndex("test", "parent", "p4").setSource("p_field", "p_value4").get();
        client().prepareIndex("test", "child", "c7").setSource("c_field", "blue").setParent("p4").get();
        client().prepareIndex("test", "child", "c8").setSource("c_field", "red").setParent("p4").get();
        client().admin().indices().prepareRefresh().get();

        SearchResponse searchResponse = client().prepareSearch("test")
                .setQuery(randomHasChild("child", "c_field", "blue"))
                .get();
        assertHitCount(searchResponse, 3l);

        client().prepareDeleteByQuery("test").setQuery(randomHasChild("child", "c_field", "blue")).get();
        client().admin().indices().prepareRefresh("test").get();

        searchResponse = client().prepareSearch("test")
                .setQuery(randomHasChild("child", "c_field", "blue"))
                .get();
        assertHitCount(searchResponse, 0l);
    }

commonMethod: 
(startLine=374 endLine=391 srcPath=/root/NewExperiment/elasticsearchFilter/01179/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java)
    /**
     * Returns a settings object used in {@link #createIndex(String...)} and {@link #prepareCreate(String)} and friends.
     * This method can be overwritten by subclasses to set defaults for the indices that are created by the test.
     * By default it returns a settings object that sets a random number of shards. Number of shards and replicas
     * can be controlled through specific methods.
     */
    public Settings indexSettings() {
        ImmutableSettings.Builder builder = ImmutableSettings.builder();
        int numberOfShards = numberOfShards();
        if (numberOfShards > 0) {
            builder.put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, numberOfShards).build();
        }
        int numberOfReplicas = numberOfReplicas();
        if (numberOfReplicas >= 0) {
            builder.put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, numberOfReplicas).build();
        }
        return builder.build();
    }


, Instance #
frags: 
(startLine=63 endLine=88 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/terms/ShardSizeTermsFacetTests.java)
    public void noShardSize_string() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsFacet("keys").field("key").size(3).order(TermsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsFacet terms = facets.facet("keys");
        List<? extends TermsFacet.Entry> entries = terms.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<String, Integer> expected = ImmutableMap.<String, Integer>builder()
                .put("1", 8)
                .put("3", 8)
                .put("2", 4)
                .build();
        for (TermsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTerm().string())));
        }
    }

(startLine=91 endLine=116 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/terms/ShardSizeTermsFacetTests.java)
    public void withShardSize_string() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsFacet("keys").field("key").size(3).shardSize(5).order(TermsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsFacet terms = facets.facet("keys");
        List<? extends TermsFacet.Entry> entries = terms.getEntries();
        assertThat(entries.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<String, Integer> expected = ImmutableMap.<String, Integer>builder()
                .put("1", 8)
                .put("3", 8)
                .put("2", 5) // <-- count is now fixed
                .build();
        for (TermsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTerm().string())));
        }
    }

(startLine=119 endLine=144 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/terms/ShardSizeTermsFacetTests.java)
    public void withShardSize_string_singleShard() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type").setRouting("1")
                .setQuery(matchAllQuery())
                .addFacet(termsFacet("keys").field("key").size(3).shardSize(5).order(TermsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsFacet terms = facets.facet("keys");
        List<? extends TermsFacet.Entry> entries = terms.getEntries();
        assertThat(entries.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<String, Integer> expected = ImmutableMap.<String, Integer>builder()
                .put("1", 5)
                .put("2", 4)
                .put("3", 3) // <-- count is now fixed
                .build();
        for (TermsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTerm().string())));
        }
    }

(startLine=147 endLine=172 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/terms/ShardSizeTermsFacetTests.java)
    public void withShardSize_string_withExecutionHintMap() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsFacet("keys").field("key").size(3).shardSize(5).executionHint("map").order(TermsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsFacet terms = facets.facet("keys");
        List<? extends TermsFacet.Entry> entries = terms.getEntries();
        assertThat(entries.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<String, Integer> expected = ImmutableMap.<String, Integer>builder()
                .put("1", 8)
                .put("3", 8)
                .put("2", 5) // <-- count is now fixed
                .build();
        for (TermsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTerm().string())));
        }
    }

(startLine=175 endLine=200 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/terms/ShardSizeTermsFacetTests.java)
    public void withShardSize_string_withExecutionHintMap_singleShard() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type").setRouting("1")
                .setQuery(matchAllQuery())
                .addFacet(termsFacet("keys").field("key").size(3).shardSize(5).executionHint("map").order(TermsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsFacet terms = facets.facet("keys");
        List<? extends TermsFacet.Entry> entries = terms.getEntries();
        assertThat(entries.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<String, Integer> expected = ImmutableMap.<String, Integer>builder()
                .put("1", 5)
                .put("2", 4)
                .put("3", 3) // <-- count is now fixed
                .build();
        for (TermsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTerm().string())));
        }
    }

(startLine=203 endLine=228 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/terms/ShardSizeTermsFacetTests.java)
    public void noShardSize_long() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=long")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsFacet("keys").field("key").size(3).order(TermsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsFacet terms = facets.facet("keys");
        List<? extends TermsFacet.Entry> entries = terms.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<Integer, Integer> expected = ImmutableMap.<Integer, Integer>builder()
                .put(1, 8)
                .put(3, 8)
                .put(2, 4)
                .build();
        for (TermsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=231 endLine=256 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/terms/ShardSizeTermsFacetTests.java)
    public void withShardSize_long() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=long")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsFacet("keys").field("key").size(3).shardSize(5).order(TermsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsFacet terms = facets.facet("keys");
        List<? extends TermsFacet.Entry> entries = terms.getEntries();
        assertThat(entries.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<Integer, Integer> expected = ImmutableMap.<Integer, Integer>builder()
                .put(1, 8)
                .put(3, 8)
                .put(2, 5) // <-- count is now fixed
                .build();
        for (TermsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=259 endLine=284 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/terms/ShardSizeTermsFacetTests.java)
    public void withShardSize_long_singleShard() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=long")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type").setRouting("1")
                .setQuery(matchAllQuery())
                .addFacet(termsFacet("keys").field("key").size(3).shardSize(5).order(TermsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsFacet terms = facets.facet("keys");
        List<? extends TermsFacet.Entry> entries = terms.getEntries();
        assertThat(entries.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<Integer, Integer> expected = ImmutableMap.<Integer, Integer>builder()
                .put(1, 5)
                .put(2, 4)
                .put(3, 3)
                .build();
        for (TermsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=287 endLine=312 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/terms/ShardSizeTermsFacetTests.java)
    public void noShardSize_double() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=double")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsFacet("keys").field("key").size(3).order(TermsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsFacet terms = facets.facet("keys");
        List<? extends TermsFacet.Entry> entries = terms.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<Integer, Integer> expected = ImmutableMap.<Integer, Integer>builder()
                .put(1, 8)
                .put(3, 8)
                .put(2, 4)
                .build();
        for (TermsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=315 endLine=340 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/terms/ShardSizeTermsFacetTests.java)
    public void withShardSize_double() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=double")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsFacet("keys").field("key").size(3).shardSize(5).order(TermsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsFacet terms = facets.facet("keys");
        List<? extends TermsFacet.Entry> entries = terms.getEntries();
        assertThat(entries.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<Integer, Integer> expected = ImmutableMap.<Integer, Integer>builder()
                .put(1, 8)
                .put(3, 8)
                .put(2, 5) // <-- count is now fixed
                .build();
        for (TermsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=63 endLine=88 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void noShardSize_string() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(3).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<String, Long> expected = ImmutableMap.<String, Long>builder()
                .put("1", 8l)
                .put("3", 8l)
                .put("2", 4l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTerm().string())));
        }
    }

(startLine=91 endLine=118 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void noShardSize_string_allTerms() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(0).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(5));
        Map<String, Long> expected = ImmutableMap.<String, Long>builder()
                .put("1", 8l)
                .put("3", 8l)
                .put("2", 5l)
                .put("4", 4l)
                .put("5", 2l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTerm().string())));
        }
    }

(startLine=121 endLine=148 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void withShardSize_string_allTerms() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(0).shardSize(3).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(5));
        Map<String, Long> expected = ImmutableMap.<String, Long>builder()
                .put("1", 8l)
                .put("3", 8l)
                .put("2", 5l)
                .put("4", 4l)
                .put("5", 2l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTerm().string())));
        }
    }

(startLine=151 endLine=176 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void withShardSize_string() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(3).shardSize(5).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<String, Long> expected = ImmutableMap.<String, Long>builder()
                .put("1", 8l)
                .put("3", 8l)
                .put("2", 5l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTerm().string())));
        }
    }

(startLine=179 endLine=204 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void withShardSize_string_singleShard() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=string,index=not_analyzed")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type").setRouting("1")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(3).shardSize(5).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<String, Long> expected = ImmutableMap.<String, Long>builder()
                .put("1", 5l)
                .put("2", 4l)
                .put("3", 3l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTerm().string())));
        }
    }

(startLine=207 endLine=232 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void noShardSize_long() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=long")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(3).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 4l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=235 endLine=262 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void noShardSize_long_allTerms() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=long")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(0).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(5));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 5l)
                .put(4, 4l)
                .put(5, 2l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=265 endLine=292 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void withShardSize_long_allTerms() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=long")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(0).shardSize(3).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(5));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 5l)
                .put(4, 4l)
                .put(5, 2l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=295 endLine=320 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void withShardSize_long() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=long")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(3).shardSize(5).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 5l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=323 endLine=348 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void withShardSize_long_singleShard() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=long")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type").setRouting("1")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(3).shardSize(5).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 5l)
                .put(2, 4l)
                .put(3, 3l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=351 endLine=376 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void noShardSize_double() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=double")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(3).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 4l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=379 endLine=406 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void noShardSize_double_allTerms() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=double")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(0).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(5));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 5l)
                .put(4, 4l)
                .put(5, 2l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=409 endLine=436 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void withShardSize_double_allTerms() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=double")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(0).shardSize(3).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(5));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 5l)
                .put(4, 4l)
                .put(5, 2l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=439 endLine=464 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void withShardSize_double() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=double")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(3).shardSize(5).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 8l)
                .put(3, 8l)
                .put(2, 5l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=343 endLine=368 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/terms/ShardSizeTermsFacetTests.java)
    public void withShardSize_double_singleShard() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=double")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type").setRouting("1")
                .setQuery(matchAllQuery())
                .addFacet(termsFacet("keys").field("key").size(3).shardSize(5).order(TermsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsFacet terms = facets.facet("keys");
        List<? extends TermsFacet.Entry> entries = terms.getEntries();
        assertThat(entries.size(), equalTo(3)); // we still only return 3 entries (based on the 'size' param)
        Map<Integer, Integer> expected = ImmutableMap.<Integer, Integer>builder()
                .put(1, 5)
                .put(2, 4)
                .put(3, 3)
                .build();
        for (TermsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

(startLine=467 endLine=492 srcPath=/root/NewExperiment/elasticsearchFilter/01178/src/test/java/org/elasticsearch/search/facet/termsstats/ShardSizeTermsStatsFacetTests.java)
    public void withShardSize_double_singleShard() throws Exception {

        client().admin().indices().prepareCreate("idx")
                .addMapping("type", "key", "type=double")
                .execute().actionGet();

        indexData();

        SearchResponse response = client().prepareSearch("idx").setTypes("type").setRouting("1")
                .setQuery(matchAllQuery())
                .addFacet(termsStatsFacet("keys").keyField("key").valueField("value").size(3).shardSize(5).order(TermsStatsFacet.ComparatorType.COUNT))
                .execute().actionGet();

        Facets facets = response.getFacets();
        TermsStatsFacet facet = facets.facet("keys");
        List<? extends TermsStatsFacet.Entry> entries = facet.getEntries();
        assertThat(entries.size(), equalTo(3));
        Map<Integer, Long> expected = ImmutableMap.<Integer, Long>builder()
                .put(1, 5l)
                .put(2, 4l)
                .put(3, 3l)
                .build();
        for (TermsStatsFacet.Entry entry : entries) {
            assertThat(entry.getCount(), equalTo(expected.get(entry.getTermAsNumber().intValue())));
        }
    }

commonMethod: 
(startLine=62 endLine=65 srcPath=/root/NewExperiment/elasticsearchFilter/01179/src/test/java/org/elasticsearch/search/aggregations/bucket/ShardSizeTests.java)
    protected void createIdx(String keyFieldMapping) {
        assertAcked(prepareCreate("idx")
                .addMapping("type", "key", keyFieldMapping));
    }


, Instance #
frags: 
(startLine=193 endLine=224 srcPath=/root/NewExperiment/elasticsearchFilter/01181/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            final Query query = getQuery(doc);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                if (context.highlight() != null) {
                    context.parsedQuery(new ParsedQuery(query, ImmutableMap.<String, Filter>of()));
                    context.hitContext().cache().clear();
                }

                searcher.search(query, collector);
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(values.copyShared());
                        if (context.highlight() != null) {
                            highlightPhase.hitExecute(context, context.hitContext());
                            hls.add(context.hitContext().hit().getHighlightFields());
                        }
                    }
                    counter++;
                    if (facetAndAggregatorCollector != null) {
                        facetAndAggregatorCollector.collect(doc);
                    }
                }
            } catch (IOException e) {
                logger.warn("[" + spare.bytes.utf8ToString() + "] failed to execute query", e);
            }
        }

(startLine=312 endLine=343 srcPath=/root/NewExperiment/elasticsearchFilter/01181/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            final Query query = getQuery(doc);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                if (context.highlight() != null) {
                    context.parsedQuery(new ParsedQuery(query, ImmutableMap.<String, Filter>of()));
                    context.hitContext().cache().clear();
                }
                searcher.search(query, collector);
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(values.copyShared());
                        scores.add(scorer.score());
                        if (context.highlight() != null) {
                            highlightPhase.hitExecute(context, context.hitContext());
                            hls.add(context.hitContext().hit().getHighlightFields());
                        }
                    }
                    counter++;
                    if (facetAndAggregatorCollector != null) {
                        facetAndAggregatorCollector.collect(doc);
                    }
                }
            } catch (IOException e) {
                logger.warn("[" + spare.bytes.utf8ToString() + "] failed to execute query", e);
            }
        }

commonMethod: 
(startLine=114 endLine=118 srcPath=/root/NewExperiment/elasticsearchFilter/01182/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
    public void postMatch(int doc) throws IOException {
        for (Collector collector : facetAndAggregatorCollector) {
            collector.collect(doc);
        }
    }


, Instance #
frags: 
(startLine=200 endLine=221 srcPath=/root/NewExperiment/elasticsearchFilter/01181/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
            try {
                collector.reset();
                if (context.highlight() != null) {
                    context.parsedQuery(new ParsedQuery(query, ImmutableMap.<String, Filter>of()));
                    context.hitContext().cache().clear();
                }

                searcher.search(query, collector);
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(values.copyShared());
                        if (context.highlight() != null) {
                            highlightPhase.hitExecute(context, context.hitContext());
                            hls.add(context.hitContext().hit().getHighlightFields());
                        }
                    }
                    counter++;
                    if (facetAndAggregatorCollector != null) {
                        facetAndAggregatorCollector.collect(doc);
                    }
                }
            } catch (IOException e) {

(startLine=319 endLine=340 srcPath=/root/NewExperiment/elasticsearchFilter/01181/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
            try {
                collector.reset();
                if (context.highlight() != null) {
                    context.parsedQuery(new ParsedQuery(query, ImmutableMap.<String, Filter>of()));
                    context.hitContext().cache().clear();
                }
                searcher.search(query, collector);
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(values.copyShared());
                        scores.add(scorer.score());
                        if (context.highlight() != null) {
                            highlightPhase.hitExecute(context, context.hitContext());
                            hls.add(context.hitContext().hit().getHighlightFields());
                        }
                    }
                    counter++;
                    if (facetAndAggregatorCollector != null) {
                        facetAndAggregatorCollector.collect(doc);
                    }
                }
            } catch (IOException e) {

commonMethod: 
(startLine=114 endLine=118 srcPath=/root/NewExperiment/elasticsearchFilter/01182/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
    public void postMatch(int doc) throws IOException {
        for (Collector collector : facetAndAggregatorCollector) {
            collector.collect(doc);
        }
    }


, Instance #
frags: 
(startLine=250 endLine=269 srcPath=/root/NewExperiment/elasticsearchFilter/01181/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            final Query query = getQuery(doc);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                searcher.search(query, collector);
                if (collector.exists()) {
                    topDocsCollector.collect(doc);
                    if (facetAndAggregatorCollector != null) {
                        facetAndAggregatorCollector.collect(doc);
                    }
                }
            } catch (IOException e) {
                logger.warn("[" + spare.bytes.utf8ToString() + "] failed to execute query", e);
            }
        }

(startLine=376 endLine=395 srcPath=/root/NewExperiment/elasticsearchFilter/01181/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
        public void collect(int doc) throws IOException {
            final Query query = getQuery(doc);
            if (query == null) {
                // log???
                return;
            }
            // run the query
            try {
                collector.reset();
                searcher.search(query, collector);
                if (collector.exists()) {
                    counter++;
                    if (facetAndAggregatorCollector != null) {
                        facetAndAggregatorCollector.collect(doc);
                    }
                }
            } catch (IOException e) {
                logger.warn("[" + spare.bytes.utf8ToString() + "] failed to execute query", e);
            }
        }

commonMethod: 
(startLine=114 endLine=118 srcPath=/root/NewExperiment/elasticsearchFilter/01182/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
    public void postMatch(int doc) throws IOException {
        for (Collector collector : facetAndAggregatorCollector) {
            collector.collect(doc);
        }
    }


, Instance #
frags: 
(startLine=208 endLine=220 srcPath=/root/NewExperiment/elasticsearchFilter/01181/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(values.copyShared());
                        if (context.highlight() != null) {
                            highlightPhase.hitExecute(context, context.hitContext());
                            hls.add(context.hitContext().hit().getHighlightFields());
                        }
                    }
                    counter++;
                    if (facetAndAggregatorCollector != null) {
                        facetAndAggregatorCollector.collect(doc);
                    }
                }

(startLine=326 endLine=339 srcPath=/root/NewExperiment/elasticsearchFilter/01181/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
                if (collector.exists()) {
                    if (!limit || counter < size) {
                        matches.add(values.copyShared());
                        scores.add(scorer.score());
                        if (context.highlight() != null) {
                            highlightPhase.hitExecute(context, context.hitContext());
                            hls.add(context.hitContext().hit().getHighlightFields());
                        }
                    }
                    counter++;
                    if (facetAndAggregatorCollector != null) {
                        facetAndAggregatorCollector.collect(doc);
                    }
                }

commonMethod: 
(startLine=114 endLine=118 srcPath=/root/NewExperiment/elasticsearchFilter/01182/src/main/java/org/elasticsearch/percolator/QueryCollector.java)
    public void postMatch(int doc) throws IOException {
        for (Collector collector : facetAndAggregatorCollector) {
            collector.collect(doc);
        }
    }


, Instance #
frags: 
(startLine=132 endLine=139 srcPath=/root/NewExperiment/elasticsearchFilter/01183/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/DoubleTerms.java)
            for (Terms.Bucket bucket : terms.buckets) {
                List<Bucket> existingBuckets = buckets.v().get(((Bucket) bucket).term);
                if (existingBuckets == null) {
                    existingBuckets = new ArrayList<Bucket>(aggregations.size());
                    buckets.v().put(((Bucket) bucket).term, existingBuckets);
                }
                existingBuckets.add((Bucket) bucket);
            }

(startLine=129 endLine=136 srcPath=/root/NewExperiment/elasticsearchFilter/01183/src/main/java/org/elasticsearch/search/aggregations/bucket/terms/LongTerms.java)
            for (Terms.Bucket bucket : terms.buckets) {
                List<Bucket> existingBuckets = buckets.v().get(((Bucket) bucket).term);
                if (existingBuckets == null) {
                    existingBuckets = new ArrayList<Bucket>(aggregations.size());
                    buckets.v().put(((Bucket) bucket).term, existingBuckets);
                }
                existingBuckets.add((Bucket) bucket);
            }

commonMethod: 
(startLine=93 endLine=95 srcPath=/root/NewExperiment/elasticsearchFilter/01184/src/main/java/org/elasticsearch/search/aggregations/InternalAggregation.java)
        public BigArrays bigArrays() {
            return bigArrays;
        }


, Instance #
frags: 
(startLine=72 endLine=228 srcPath=/root/NewExperiment/elasticsearchFilter/01191/src/test/java/org/elasticsearch/indexlifecycle/IndexLifecycleActionTests.java)
    public void testIndexLifecycleActionsWith11Shards1Backup() throws Exception {
        Settings settings = settingsBuilder()
                .put(SETTING_NUMBER_OF_SHARDS, 11)
                .put(SETTING_NUMBER_OF_REPLICAS, 1)
                .put("cluster.routing.schedule", "20ms") // reroute every 20ms so we identify new nodes fast
                .build();

        // start one server
        logger.info("Starting sever1");
        final String server_1 = cluster().startNode(settings);
        final String node1 = getLocalNodeId(server_1);

        logger.info("Creating index [test]");
        CreateIndexResponse createIndexResponse = client().admin().indices().create(createIndexRequest("test")).actionGet();
        assertThat(createIndexResponse.isAcknowledged(), equalTo(true));

        logger.info("Running Cluster Health");
        ClusterHealthResponse clusterHealth = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForYellowStatus().execute().actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.YELLOW));

        ClusterState clusterState = client().admin().cluster().prepareState().get().getState();
        RoutingNode routingNodeEntry1 = clusterState.readOnlyRoutingNodes().node(node1);
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), equalTo(11));

        logger.info("Starting server2");
        // start another server
        String server_2 = cluster().startNode(settings);

        // first wait for 2 nodes in the cluster
        logger.info("Running Cluster Health");
        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        final String node2 = getLocalNodeId(server_2);


        // explicitly call reroute, so shards will get relocated to the new node (we delay it in ES in case other nodes join)
        client().admin().cluster().prepareReroute().execute().actionGet();

        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2").waitForRelocatingShards(0)).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getNumberOfDataNodes(), equalTo(2));
        assertThat(clusterHealth.getInitializingShards(), equalTo(0));
        assertThat(clusterHealth.getUnassignedShards(), equalTo(0));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(22));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));


        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes(), node1, node2);
        routingNodeEntry1 = clusterState.readOnlyRoutingNodes().node(node1);
        assertThat(routingNodeEntry1.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), equalTo(11));
        RoutingNode routingNodeEntry2 = clusterState.readOnlyRoutingNodes().node(node2);
        assertThat(routingNodeEntry2.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), equalTo(11));

        logger.info("Starting server3");
        // start another server
        String server_3 = cluster().startNode(settings);

        // first wait for 3 nodes in the cluster
        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3")).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));


        final String node3 = getLocalNodeId(server_3);


        // explicitly call reroute, so shards will get relocated to the new node (we delay it in ES in case other nodes join)
        client().admin().cluster().prepareReroute().execute().actionGet();

        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3").waitForRelocatingShards(0)).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getNumberOfDataNodes(), equalTo(3));
        assertThat(clusterHealth.getInitializingShards(), equalTo(0));
        assertThat(clusterHealth.getUnassignedShards(), equalTo(0));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(22));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));


        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes(), node1, node2, node3);

        routingNodeEntry1 = clusterState.readOnlyRoutingNodes().node(node1);
        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().node(node2);
        RoutingNode routingNodeEntry3 = clusterState.readOnlyRoutingNodes().node(node3);

        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED) + routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(22));

        assertThat(routingNodeEntry1.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), anyOf(equalTo(7), equalTo(8)));

        assertThat(routingNodeEntry2.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), anyOf(equalTo(7), equalTo(8)));

        assertThat(routingNodeEntry3.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(7));

        client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder()
                .put("discovery.zen.minimum_master_nodes", 2)) // we are shutting down a node - make sure we don't have 2 clusters if we test network
                .get();
        logger.info("Closing server1");
        // kill the first server
        cluster().stopRandomNode(TestCluster.nameFilter(server_1));
        // verify health
        logger.info("Running Cluster Health");
        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        client().admin().cluster().prepareReroute().get();

        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForRelocatingShards(0).waitForNodes("2")).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(22));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));

        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes(), node3, node2);
        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().node(node2);
        routingNodeEntry3 = clusterState.readOnlyRoutingNodes().node(node3);

        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(22));

        assertThat(routingNodeEntry2.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), equalTo(11));

        assertThat(routingNodeEntry3.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(11));


        logger.info("Deleting index [test]");
        // last, lets delete the index
        DeleteIndexResponse deleteIndexResponse = client().admin().indices().prepareDelete("test").execute().actionGet();
        assertThat(deleteIndexResponse.isAcknowledged(), equalTo(true));

        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes(), node3, node2);
        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().node(node2);
        assertThat(routingNodeEntry2.isEmpty(), equalTo(true));

        routingNodeEntry3 = clusterState.readOnlyRoutingNodes().node(node3);
        assertThat(routingNodeEntry3.isEmpty(), equalTo(true));
    }

(startLine=240 endLine=400 srcPath=/root/NewExperiment/elasticsearchFilter/01191/src/test/java/org/elasticsearch/indexlifecycle/IndexLifecycleActionTests.java)
    public void testIndexLifecycleActionsWith11Shards0Backup() throws Exception {

        Settings settings = settingsBuilder()
                .put(SETTING_NUMBER_OF_SHARDS, 11)
                .put(SETTING_NUMBER_OF_REPLICAS, 0)
                .put("cluster.routing.schedule", "20ms") // reroute every 20ms so we identify new nodes fast
                .build();

        // start one server
        logger.info("Starting server1");
        final String server_1 = cluster().startNode(settings);

        final String node1 = getLocalNodeId(server_1);

        logger.info("Creating index [test]");
        CreateIndexResponse createIndexResponse = client().admin().indices().create(createIndexRequest("test")).actionGet();
        assertThat(createIndexResponse.isAcknowledged(), equalTo(true));

        logger.info("Running Cluster Health");
        ClusterHealthResponse clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus()).actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(11));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));

        ClusterState clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes(), node1);
        RoutingNode routingNodeEntry1 = clusterState.readOnlyRoutingNodes().node(node1);
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), equalTo(11));

        // start another server
        logger.info("Starting server2");
        final String server_2 = cluster().startNode(settings);

        // first wait for 2 nodes in the cluster
        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        final String node2 = getLocalNodeId(server_2);

        // explicitly call reroute, so shards will get relocated to the new node (we delay it in ES in case other nodes join)
        client().admin().cluster().prepareReroute().execute().actionGet();

        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForRelocatingShards(0).waitForNodes("2")).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getNumberOfDataNodes(), equalTo(2));
        assertThat(clusterHealth.getInitializingShards(), equalTo(0));
        assertThat(clusterHealth.getUnassignedShards(), equalTo(0));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(11));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));


        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes(), node1, node2);
        routingNodeEntry1 = clusterState.readOnlyRoutingNodes().node(node1);
        assertThat(routingNodeEntry1.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), anyOf(equalTo(6), equalTo(5)));
        RoutingNode routingNodeEntry2 = clusterState.readOnlyRoutingNodes().node(node2);
        assertThat(routingNodeEntry2.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), anyOf(equalTo(5), equalTo(6)));

        // start another server
        logger.info("Starting server3");
        final String server_3 = cluster().startNode();

        // first wait for 3 nodes in the cluster
        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3")).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        final String node3 = getLocalNodeId(server_3);
        // explicitly call reroute, so shards will get relocated to the new node (we delay it in ES in case other nodes join)
        client().admin().cluster().prepareReroute().execute().actionGet();

        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("3").waitForRelocatingShards(0)).actionGet();
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getNumberOfDataNodes(), equalTo(3));
        assertThat(clusterHealth.getInitializingShards(), equalTo(0));
        assertThat(clusterHealth.getUnassignedShards(), equalTo(0));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(11));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));


        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes(), node1, node2, node3);
        routingNodeEntry1 = clusterState.readOnlyRoutingNodes().node(node1);
        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().node(node2);
        RoutingNode routingNodeEntry3 = clusterState.readOnlyRoutingNodes().node(node3);

        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED) + routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(11));

        assertThat(routingNodeEntry1.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry1.numberOfShardsWithState(STARTED), anyOf(equalTo(5), equalTo(4), equalTo(3)));

        assertThat(routingNodeEntry2.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), anyOf(equalTo(5), equalTo(4), equalTo(3)));

        assertThat(routingNodeEntry3.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(3));

        client().admin().cluster().prepareUpdateSettings().setTransientSettings(settingsBuilder()
                .put("discovery.zen.minimum_master_nodes", 2)) // we are shutting down a node - make sure we don't have 2 clusters if we test network
                .get();
        logger.info("Closing server1");
        // kill the first server
        cluster().stopRandomNode(TestCluster.nameFilter(server_1));

        logger.info("Running Cluster Health");
        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2")).actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));

        client().admin().cluster().prepareReroute().get();

        logger.info("Running Cluster Health");
        clusterHealth = client().admin().cluster().health(clusterHealthRequest().waitForGreenStatus().waitForNodes("2").waitForRelocatingShards(0)).actionGet();
        logger.info("Done Cluster Health, status " + clusterHealth.getStatus());
        assertThat(clusterHealth.isTimedOut(), equalTo(false));
        assertThat(clusterHealth.getStatus(), equalTo(ClusterHealthStatus.GREEN));
        assertThat(clusterHealth.getRelocatingShards(), equalTo(0));
        assertThat(clusterHealth.getActiveShards(), equalTo(11));
        assertThat(clusterHealth.getActivePrimaryShards(), equalTo(11));

        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes(), node3, node2);

        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().node(node2);
        routingNodeEntry3 = clusterState.readOnlyRoutingNodes().node(node3);

        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED) + routingNodeEntry3.numberOfShardsWithState(STARTED), equalTo(11));

        assertThat(routingNodeEntry2.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry2.numberOfShardsWithState(STARTED), anyOf(equalTo(5), equalTo(6)));

        assertThat(routingNodeEntry3.numberOfShardsWithState(RELOCATING), equalTo(0));
        assertThat(routingNodeEntry3.numberOfShardsWithState(INITIALIZING), equalTo(0));
        assertThat(routingNodeEntry3.numberOfShardsWithState(STARTED), anyOf(equalTo(5), equalTo(6)));

        logger.info("Deleting index [test]");
        // last, lets delete the index
        DeleteIndexResponse deleteIndexResponse = client().admin().indices().delete(deleteIndexRequest("test")).actionGet();
        assertThat(deleteIndexResponse.isAcknowledged(), equalTo(true));

        clusterState = client().admin().cluster().prepareState().get().getState();
        assertNodesPresent(clusterState.readOnlyRoutingNodes(), node3, node2);

        routingNodeEntry2 = clusterState.readOnlyRoutingNodes().node(node2);
        assertThat(routingNodeEntry2.isEmpty(), equalTo(true));

        routingNodeEntry3 = clusterState.readOnlyRoutingNodes().node(node3);
        assertThat(routingNodeEntry3.isEmpty(), equalTo(true));
    }

commonMethod: 
(startLine=616 endLine=624 srcPath=/root/NewExperiment/elasticsearchFilter/01192/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java)
    /**
     * Sets the cluster's minimum master node and make sure the response is acknowledge.
     * Note: this doesn't guaranty the new settings is in effect, just that it has been received bu all nodes.
     */
    public void setMinimumMasterNodes(int n) {
        assertTrue(client().admin().cluster().prepareUpdateSettings().setTransientSettings(
                settingsBuilder().put(ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES, n))
                .get().isAcknowledged());
    }


, Instance #
frags: 
(startLine=794 endLine=811 srcPath=/root/NewExperiment/elasticsearchFilter/01193/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java)
        if (frequently()) {
            logger.info("Index [{}] docs async: [{}] bulk: [{}]", builders.size(), true, false);
            final CountDownLatch latch = new CountDownLatch(builders.size());
            latches.add(latch);
            for (IndexRequestBuilder indexRequestBuilder : builders) {
                indexRequestBuilder.execute(new PayloadLatchedActionListener<IndexResponse, IndexRequestBuilder>(indexRequestBuilder, latch, errors));
                if (rarely()) {
                    if (rarely()) {
                        client().admin().indices().prepareRefresh(indices).setIndicesOptions(IndicesOptions.lenient()).execute(new LatchedActionListener<RefreshResponse>(newLatch(latches)));
                    } else if (rarely()) {
                        client().admin().indices().prepareFlush(indices).setIndicesOptions(IndicesOptions.lenient()).execute(new LatchedActionListener<FlushResponse>(newLatch(latches)));
                    } else if (rarely()) {
                        client().admin().indices().prepareOptimize(indices).setIndicesOptions(IndicesOptions.lenient()).setMaxNumSegments(between(1, 10)).setFlush(random.nextBoolean()).execute(new LatchedActionListener<OptimizeResponse>(newLatch(latches)));
                    }
                }
            }

        } else if (randomBoolean()) {

(startLine=811 endLine=825 srcPath=/root/NewExperiment/elasticsearchFilter/01193/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java)
        } else if (randomBoolean()) {
            logger.info("Index [{}] docs async: [{}] bulk: [{}]", builders.size(), false, false);
            for (IndexRequestBuilder indexRequestBuilder : builders) {
                indexRequestBuilder.execute().actionGet();
                if (rarely()) {
                    if (rarely()) {
                        client().admin().indices().prepareRefresh(indices).setIndicesOptions(IndicesOptions.lenient()).execute(new LatchedActionListener<RefreshResponse>(newLatch(latches)));
                    } else if (rarely()) {
                        client().admin().indices().prepareFlush(indices).setIndicesOptions(IndicesOptions.lenient()).execute(new LatchedActionListener<FlushResponse>(newLatch(latches)));
                    } else if (rarely()) {
                        client().admin().indices().prepareOptimize(indices).setIndicesOptions(IndicesOptions.lenient()).setMaxNumSegments(between(1, 10)).setFlush(random.nextBoolean()).execute(new LatchedActionListener<OptimizeResponse>(newLatch(latches)));
                    }
                }
            }
        } else {

commonMethod: 
(startLine=857 endLine=877 srcPath=/root/NewExperiment/elasticsearchFilter/01194/src/test/java/org/elasticsearch/test/ElasticsearchIntegrationTest.java)
    /**
     * Maybe refresh, optimize, or flush then always make sure there aren't too many in flight async operations. 
     */
    private void postIndexAsyncActions(String[] indices, List<CountDownLatch> inFlightAsyncOperations) throws InterruptedException {
        if (rarely()) {
            if (rarely()) {
                client().admin().indices().prepareRefresh(indices).setIndicesOptions(IndicesOptions.lenient()).execute(
                        new LatchedActionListener<RefreshResponse>(newLatch(inFlightAsyncOperations)));
            } else if (rarely()) {
                client().admin().indices().prepareFlush(indices).setIndicesOptions(IndicesOptions.lenient()).execute(
                        new LatchedActionListener<FlushResponse>(newLatch(inFlightAsyncOperations)));
            } else if (rarely()) {
                client().admin().indices().prepareOptimize(indices).setIndicesOptions(IndicesOptions.lenient()).setMaxNumSegments(between(1, 10)).setFlush(randomBoolean()).execute(
                        new LatchedActionListener<OptimizeResponse>(newLatch(inFlightAsyncOperations)));
            }
        }
        while (inFlightAsyncOperations.size() > MAX_IN_FLIGHT_ASYNC_INDEXES) {
            int waitFor = between(0, inFlightAsyncOperations.size() - 1);
            inFlightAsyncOperations.remove(waitFor).await();
        }
    }


, Instance #
frags: 
(startLine=193 endLine=235 srcPath=/root/NewExperiment/elasticsearchFilter/01267/src/test/java/org/elasticsearch/nested/SimpleNestedTests.java)
    private void simpleNestedDeleteByQuery(int total, int docToDelete) throws Exception {

        assertAcked(prepareCreate("test")
                .setSettings(settingsBuilder().put(indexSettings()).put("index.referesh_interval", -1).build())
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("nested1")
                        .field("type", "nested")
                        .endObject()
                        .endObject().endObject().endObject()));

        ensureGreen();

        for (int i = 0; i < total; i++) {
            client().prepareIndex("test", "type1", Integer.toString(i)).setSource(jsonBuilder().startObject()
                    .field("field1", "value1")
                    .startArray("nested1")
                    .startObject()
                    .field("n_field1", "n_value1_1")
                    .field("n_field2", "n_value2_1")
                    .endObject()
                    .startObject()
                    .field("n_field1", "n_value1_2")
                    .field("n_field2", "n_value2_2")
                    .endObject()
                    .endArray()
                    .endObject()).execute().actionGet();
        }


        flush();
        IndicesStatusResponse statusResponse = client().admin().indices().prepareStatus().execute().actionGet();
        assertThat(statusResponse.getIndex("test").getDocs().getNumDocs(), equalTo(total * 3l));

        client().prepareDeleteByQuery("test").setQuery(QueryBuilders.idsQuery("type1").ids(Integer.toString(docToDelete))).execute().actionGet();
        flush();
        refresh();
        statusResponse = client().admin().indices().prepareStatus().execute().actionGet();
        assertThat(statusResponse.getIndex("test").getDocs().getNumDocs(), equalTo((total * 3l) - 3));

        for (int i = 0; i < total; i++) {
            assertThat(client().prepareGet("test", "type1", Integer.toString(i)).execute().actionGet().isExists(), equalTo(i != docToDelete));
        }
    }

(startLine=252 endLine=287 srcPath=/root/NewExperiment/elasticsearchFilter/01267/src/test/java/org/elasticsearch/nested/SimpleNestedTests.java)
    private void noChildrenNestedDeleteByQuery(long total, int docToDelete) throws Exception {

        assertAcked(prepareCreate("test")
                .setSettings(settingsBuilder().put(indexSettings()).put("index.referesh_interval", -1).build())
                .addMapping("type1", jsonBuilder().startObject().startObject("type1").startObject("properties")
                        .startObject("nested1")
                        .field("type", "nested")
                        .endObject()
                        .endObject().endObject().endObject()));

        ensureGreen();


        for (int i = 0; i < total; i++) {
            client().prepareIndex("test", "type1", Integer.toString(i)).setSource(jsonBuilder().startObject()
                    .field("field1", "value1")
                    .endObject()).execute().actionGet();
        }


        flush();
        refresh();

        IndicesStatusResponse statusResponse = client().admin().indices().prepareStatus().execute().actionGet();
        assertThat(statusResponse.getIndex("test").getDocs().getNumDocs(), equalTo(total));

        client().prepareDeleteByQuery("test").setQuery(QueryBuilders.idsQuery("type1").ids(Integer.toString(docToDelete))).execute().actionGet();
        flush();
        refresh();
        statusResponse = client().admin().indices().prepareStatus().execute().actionGet();
        assertThat(statusResponse.getIndex("test").getDocs().getNumDocs(), equalTo((total) - 1));

        for (int i = 0; i < total; i++) {
            assertThat(client().prepareGet("test", "type1", Integer.toString(i)).execute().actionGet().isExists(), equalTo(i != docToDelete));
        }
    }

commonMethod: 
(startLine=1211 endLine=1218 srcPath=/root/NewExperiment/elasticsearchFilter/01268/src/test/java/org/elasticsearch/nested/SimpleNestedTests.java)
    /**
     */
    private void assertDocumentCount(String index, long numdocs) {
        IndicesStatsResponse stats = admin().indices().prepareStats(index).clear().setDocs(true).get();
        assertNoFailures(stats);
        assertThat(stats.getIndex(index).getPrimaries().docs.getCount(), is(numdocs));

    }


, Instance #
frags: 
(startLine=98 endLine=139 srcPath=/root/NewExperiment/elasticsearchFilter/01339/src/main/java/org/elasticsearch/gateway/GatewayService.java)
    protected void doStart() throws ElasticsearchException {
        gateway.start();
        // if we received initial state, see if we can recover within the start phase, so we hold the
        // node from starting until we recovered properly
        if (discoveryService.initialStateReceived()) {
            ClusterState clusterState = clusterService.state();
            DiscoveryNodes nodes = clusterState.nodes();
            if (clusterState.nodes().localNodeMaster() && clusterState.blocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK)) {
                if (clusterState.blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK)) {
                    logger.debug("not recovering from gateway, no master elected yet");
                } else if (recoverAfterNodes != -1 && (nodes.masterAndDataNodes().size()) < recoverAfterNodes) {
                    logger.debug("not recovering from gateway, nodes_size (data+master) [" + nodes.masterAndDataNodes().size() + "] < recover_after_nodes [" + recoverAfterNodes + "]");
                } else if (recoverAfterDataNodes != -1 && nodes.dataNodes().size() < recoverAfterDataNodes) {
                    logger.debug("not recovering from gateway, nodes_size (data) [" + nodes.dataNodes().size() + "] < recover_after_data_nodes [" + recoverAfterDataNodes + "]");
                } else if (recoverAfterMasterNodes != -1 && nodes.masterNodes().size() < recoverAfterMasterNodes) {
                    logger.debug("not recovering from gateway, nodes_size (master) [" + nodes.masterNodes().size() + "] < recover_after_master_nodes [" + recoverAfterMasterNodes + "]");
                } else {
                    boolean ignoreRecoverAfterTime;
                    if (expectedNodes == -1 && expectedMasterNodes == -1 && expectedDataNodes == -1) {
                        // no expected is set, don't ignore the timeout
                        ignoreRecoverAfterTime = false;
                    } else {
                        // one of the expected is set, see if all of them meet the need, and ignore the timeout in this case
                        ignoreRecoverAfterTime = true;
                        if (expectedNodes != -1 && (nodes.masterAndDataNodes().size() < expectedNodes)) { // does not meet the expected...
                            ignoreRecoverAfterTime = false;
                        }
                        if (expectedMasterNodes != -1 && (nodes.masterNodes().size() < expectedMasterNodes)) { // does not meet the expected...
                            ignoreRecoverAfterTime = false;
                        }
                        if (expectedDataNodes != -1 && (nodes.dataNodes().size() < expectedDataNodes)) { // does not meet the expected...
                            ignoreRecoverAfterTime = false;
                        }
                    }
                    performStateRecovery(ignoreRecoverAfterTime);
                }
            }
        } else {
            logger.debug("can't wait on start for (possibly) reading state from gateway, will do it asynchronously");
        }
        clusterService.addLast(this);
    }

(startLine=153 endLine=201 srcPath=/root/NewExperiment/elasticsearchFilter/01339/src/main/java/org/elasticsearch/gateway/GatewayService.java)
    public void clusterChanged(final ClusterChangedEvent event) {
        if (lifecycle.stoppedOrClosed()) {
            return;
        }
        if (event.state().blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK)) {
            // we need to clear those flags, since we might need to recover again in case we disconnect
            // from the cluster and then reconnect
            recovered.set(false);
            scheduledRecovery.set(false);
        }
        if (event.localNodeMaster() && event.state().blocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK)) {
            ClusterState clusterState = event.state();
            DiscoveryNodes nodes = clusterState.nodes();
            if (event.state().blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK)) {
                logger.debug("not recovering from gateway, no master elected yet");
            } else if (recoverAfterNodes != -1 && (nodes.masterAndDataNodes().size()) < recoverAfterNodes) {
                logger.debug("not recovering from gateway, nodes_size (data+master) [" + nodes.masterAndDataNodes().size() + "] < recover_after_nodes [" + recoverAfterNodes + "]");
            } else if (recoverAfterDataNodes != -1 && nodes.dataNodes().size() < recoverAfterDataNodes) {
                logger.debug("not recovering from gateway, nodes_size (data) [" + nodes.dataNodes().size() + "] < recover_after_data_nodes [" + recoverAfterDataNodes + "]");
            } else if (recoverAfterMasterNodes != -1 && nodes.masterNodes().size() < recoverAfterMasterNodes) {
                logger.debug("not recovering from gateway, nodes_size (master) [" + nodes.masterNodes().size() + "] < recover_after_master_nodes [" + recoverAfterMasterNodes + "]");
            } else {
                boolean ignoreRecoverAfterTime;
                if (expectedNodes == -1 && expectedMasterNodes == -1 && expectedDataNodes == -1) {
                    // no expected is set, don't ignore the timeout
                    ignoreRecoverAfterTime = false;
                } else {
                    // one of the expected is set, see if all of them meet the need, and ignore the timeout in this case
                    ignoreRecoverAfterTime = true;
                    if (expectedNodes != -1 && (nodes.masterAndDataNodes().size() < expectedNodes)) { // does not meet the expected...
                        ignoreRecoverAfterTime = false;
                    }
                    if (expectedMasterNodes != -1 && (nodes.masterNodes().size() < expectedMasterNodes)) { // does not meet the expected...
                        ignoreRecoverAfterTime = false;
                    }
                    if (expectedDataNodes != -1 && (nodes.dataNodes().size() < expectedDataNodes)) { // does not meet the expected...
                        ignoreRecoverAfterTime = false;
                    }
                }
                final boolean fIgnoreRecoverAfterTime = ignoreRecoverAfterTime;
                threadPool.generic().execute(new Runnable() {
                    @Override
                    public void run() {
                        performStateRecovery(fIgnoreRecoverAfterTime);
                    }
                });
            }
        }
    }

commonMethod: 
(startLine=148 endLine=182 srcPath=/root/NewExperiment/elasticsearchFilter/01340/src/main/java/org/elasticsearch/gateway/GatewayService.java)
    protected void checkStateMeetsSettingsAndMaybeRecover(ClusterState state, boolean asyncRecovery) {
        DiscoveryNodes nodes = state.nodes();
        if (state.blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK)) {
            logger.debug("not recovering from gateway, no master elected yet");
        } else if (recoverAfterNodes != -1 && (nodes.masterAndDataNodes().size()) < recoverAfterNodes) {
            logger.debug("not recovering from gateway, nodes_size (data+master) [" + nodes.masterAndDataNodes().size() + "] < recover_after_nodes [" + recoverAfterNodes + "]");
        } else if (recoverAfterDataNodes != -1 && nodes.dataNodes().size() < recoverAfterDataNodes) {
            logger.debug("not recovering from gateway, nodes_size (data) [" + nodes.dataNodes().size() + "] < recover_after_data_nodes [" + recoverAfterDataNodes + "]");
        } else if (recoverAfterMasterNodes != -1 && nodes.masterNodes().size() < recoverAfterMasterNodes) {
            logger.debug("not recovering from gateway, nodes_size (master) [" + nodes.masterNodes().size() + "] < recover_after_master_nodes [" + recoverAfterMasterNodes + "]");
        } else {
            boolean enforceRecoverAfterTime;
            String reason;
            if (expectedNodes == -1 && expectedMasterNodes == -1 && expectedDataNodes == -1) {
                // no expected is set, honor the setting if they are there
                enforceRecoverAfterTime = true;
                reason = "recovery_after_time was set to [" + recoverAfterTime + "]";
            } else {
                // one of the expected is set, see if all of them meet the need, and ignore the timeout in this case
                enforceRecoverAfterTime = false;
                reason = "";
                if (expectedNodes != -1 && (nodes.masterAndDataNodes().size() < expectedNodes)) { // does not meet the expected...
                    enforceRecoverAfterTime = true;
                    reason = "expecting [" + expectedNodes + "] nodes, but only have [" + nodes.masterAndDataNodes().size() + "]";
                } else if (expectedDataNodes != -1 && (nodes.dataNodes().size() < expectedDataNodes)) { // does not meet the expected...
                    enforceRecoverAfterTime = true;
                    reason = "expecting [" + expectedDataNodes + "] data nodes, but only have [" + nodes.dataNodes().size() + "]";
                } else if (expectedMasterNodes != -1 && (nodes.masterNodes().size() < expectedMasterNodes)) { // does not meet the expected...
                    enforceRecoverAfterTime = true;
                    reason = "expecting [" + expectedMasterNodes + "] master nodes, but only have [" + nodes.masterNodes().size() + "]";
                }
            }
            performStateRecovery(asyncRecovery, enforceRecoverAfterTime, reason);
        }
    }


, Instance #
frags: 
(startLine=119 endLine=131 srcPath=/root/NewExperiment/elasticsearchFilter/01339/src/main/java/org/elasticsearch/gateway/GatewayService.java)
                    } else {
                        // one of the expected is set, see if all of them meet the need, and ignore the timeout in this case
                        ignoreRecoverAfterTime = true;
                        if (expectedNodes != -1 && (nodes.masterAndDataNodes().size() < expectedNodes)) { // does not meet the expected...
                            ignoreRecoverAfterTime = false;
                        }
                        if (expectedMasterNodes != -1 && (nodes.masterNodes().size() < expectedMasterNodes)) { // does not meet the expected...
                            ignoreRecoverAfterTime = false;
                        }
                        if (expectedDataNodes != -1 && (nodes.dataNodes().size() < expectedDataNodes)) { // does not meet the expected...
                            ignoreRecoverAfterTime = false;
                        }
                    }

(startLine=179 endLine=191 srcPath=/root/NewExperiment/elasticsearchFilter/01339/src/main/java/org/elasticsearch/gateway/GatewayService.java)
                } else {
                    // one of the expected is set, see if all of them meet the need, and ignore the timeout in this case
                    ignoreRecoverAfterTime = true;
                    if (expectedNodes != -1 && (nodes.masterAndDataNodes().size() < expectedNodes)) { // does not meet the expected...
                        ignoreRecoverAfterTime = false;
                    }
                    if (expectedMasterNodes != -1 && (nodes.masterNodes().size() < expectedMasterNodes)) { // does not meet the expected...
                        ignoreRecoverAfterTime = false;
                    }
                    if (expectedDataNodes != -1 && (nodes.dataNodes().size() < expectedDataNodes)) { // does not meet the expected...
                        ignoreRecoverAfterTime = false;
                    }
                }

commonMethod: 
(startLine=148 endLine=182 srcPath=/root/NewExperiment/elasticsearchFilter/01340/src/main/java/org/elasticsearch/gateway/GatewayService.java)
    protected void checkStateMeetsSettingsAndMaybeRecover(ClusterState state, boolean asyncRecovery) {
        DiscoveryNodes nodes = state.nodes();
        if (state.blocks().hasGlobalBlock(Discovery.NO_MASTER_BLOCK)) {
            logger.debug("not recovering from gateway, no master elected yet");
        } else if (recoverAfterNodes != -1 && (nodes.masterAndDataNodes().size()) < recoverAfterNodes) {
            logger.debug("not recovering from gateway, nodes_size (data+master) [" + nodes.masterAndDataNodes().size() + "] < recover_after_nodes [" + recoverAfterNodes + "]");
        } else if (recoverAfterDataNodes != -1 && nodes.dataNodes().size() < recoverAfterDataNodes) {
            logger.debug("not recovering from gateway, nodes_size (data) [" + nodes.dataNodes().size() + "] < recover_after_data_nodes [" + recoverAfterDataNodes + "]");
        } else if (recoverAfterMasterNodes != -1 && nodes.masterNodes().size() < recoverAfterMasterNodes) {
            logger.debug("not recovering from gateway, nodes_size (master) [" + nodes.masterNodes().size() + "] < recover_after_master_nodes [" + recoverAfterMasterNodes + "]");
        } else {
            boolean enforceRecoverAfterTime;
            String reason;
            if (expectedNodes == -1 && expectedMasterNodes == -1 && expectedDataNodes == -1) {
                // no expected is set, honor the setting if they are there
                enforceRecoverAfterTime = true;
                reason = "recovery_after_time was set to [" + recoverAfterTime + "]";
            } else {
                // one of the expected is set, see if all of them meet the need, and ignore the timeout in this case
                enforceRecoverAfterTime = false;
                reason = "";
                if (expectedNodes != -1 && (nodes.masterAndDataNodes().size() < expectedNodes)) { // does not meet the expected...
                    enforceRecoverAfterTime = true;
                    reason = "expecting [" + expectedNodes + "] nodes, but only have [" + nodes.masterAndDataNodes().size() + "]";
                } else if (expectedDataNodes != -1 && (nodes.dataNodes().size() < expectedDataNodes)) { // does not meet the expected...
                    enforceRecoverAfterTime = true;
                    reason = "expecting [" + expectedDataNodes + "] data nodes, but only have [" + nodes.dataNodes().size() + "]";
                } else if (expectedMasterNodes != -1 && (nodes.masterNodes().size() < expectedMasterNodes)) { // does not meet the expected...
                    enforceRecoverAfterTime = true;
                    reason = "expecting [" + expectedMasterNodes + "] master nodes, but only have [" + nodes.masterNodes().size() + "]";
                }
            }
            performStateRecovery(asyncRecovery, enforceRecoverAfterTime, reason);
        }
    }


, Instance #
frags: 
(startLine=51 endLine=57 srcPath=/root/NewExperiment/elasticsearchFilter/01484/src/main/java/org/elasticsearch/index/analysis/EdgeNGramTokenFilterFactory.java)
    public EdgeNGramTokenFilterFactory(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name, settings);
        this.minGram = settings.getAsInt("min_gram", NGramTokenFilter.DEFAULT_MIN_NGRAM_SIZE);
        this.maxGram = settings.getAsInt("max_gram", NGramTokenFilter.DEFAULT_MAX_NGRAM_SIZE);
        this.side = EdgeNGramTokenFilter.Side.getSide(settings.get("side", Lucene43EdgeNGramTokenizer.DEFAULT_SIDE.getLabel()));
        this.esVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, org.elasticsearch.Version.CURRENT);
    }

(startLine=57 endLine=64 srcPath=/root/NewExperiment/elasticsearchFilter/01484/src/main/java/org/elasticsearch/index/analysis/EdgeNGramTokenizerFactory.java)
    public EdgeNGramTokenizerFactory(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {
        super(index, indexSettings, name, settings);
        this.minGram = settings.getAsInt("min_gram", NGramTokenizer.DEFAULT_MIN_NGRAM_SIZE);
        this.maxGram = settings.getAsInt("max_gram", NGramTokenizer.DEFAULT_MAX_NGRAM_SIZE);
        this.side = Lucene43EdgeNGramTokenizer.Side.getSide(settings.get("side", Lucene43EdgeNGramTokenizer.DEFAULT_SIDE.getLabel()));
        this.matcher = parseTokenChars(settings.getAsArray("token_chars"));
        this.esVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, org.elasticsearch.Version.CURRENT);
    }

commonMethod: 
(startLine=397 endLine=407 srcPath=/root/NewExperiment/elasticsearchFilter/01485/src/main/java/org/elasticsearch/Version.java)
    /**
     * Return the {@link Version} of Elasticsearch that has been used to create an index given its settings.
     * @throws ElasticsearchIllegalStateException if the given index settings doesn't contain a value for the key {@value IndexMetaData#SETTING_VERSION_CREATED}
     */
    public static Version indexCreated(Settings indexSettings) {
        final Version indexVersion = indexSettings.getAsVersion(IndexMetaData.SETTING_VERSION_CREATED, null);
        if (indexVersion == null) {
            throw new ElasticsearchIllegalStateException("[" + IndexMetaData.SETTING_VERSION_CREATED + "] is not present in the index settings for index with uuid: [" + indexSettings.get(IndexMetaData.SETTING_UUID) + "]");
        }
        return indexVersion;
    }


, Instance #
frags: 
(startLine=82 endLine=91 srcPath=/root/NewExperiment/elasticsearchFilter/01627/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/StatsAggegator.java)
        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = bigArrays.resize(counts, overSize);
            sums = bigArrays.resize(sums, overSize);
            mins = bigArrays.resize(mins, overSize);
            maxes = bigArrays.resize(maxes, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

(startLine=87 endLine=97 srcPath=/root/NewExperiment/elasticsearchFilter/01627/src/main/java/org/elasticsearch/search/aggregations/metrics/stats/extended/ExtendedStatsAggregator.java)
        if (owningBucketOrdinal >= counts.size()) {
            final long from = counts.size();
            final long overSize = BigArrays.overSize(owningBucketOrdinal + 1);
            counts = bigArrays.resize(counts, overSize);
            sums = bigArrays.resize(sums, overSize);
            mins = bigArrays.resize(mins, overSize);
            maxes = bigArrays.resize(maxes, overSize);
            sumOfSqrs = bigArrays.resize(sumOfSqrs, overSize);
            mins.fill(from, overSize, Double.POSITIVE_INFINITY);
            maxes.fill(from, overSize, Double.NEGATIVE_INFINITY);
        }

commonMethod: 
(startLine=274 endLine=278 srcPath=/root/NewExperiment/elasticsearchFilter/01628/src/main/java/org/elasticsearch/search/aggregations/support/ValuesSource.java)
            @Override
            public SortedNumericDoubleValues doubleValues(LeafReaderContext context) throws IOException {
                script.setNextReader(context);
                return new DoubleValues(delegate.doubleValues(context), script);
            }


, Instance #
frags: 
(startLine=53 endLine=68 srcPath=/root/NewExperiment/elasticsearchFilter/01689/src/main/java/org/elasticsearch/search/highlight/vectorhighlight/SourceSimpleFragmentsBuilder.java)
    protected Field[] getFields(IndexReader reader, int docId, String fieldName) throws IOException {
        // we know its low level reader, and matching docId, since that's how we call the highlighter with
        SearchLookup lookup = searchContext.lookup();
        lookup.setNextReader((LeafReaderContext) reader.getContext());
        lookup.setNextDocId(docId);

        List<Object> values = lookup.source().extractRawValues(hitContext.getSourcePath(mapper.names().sourcePath()));
        if (values.isEmpty()) {
            return EMPTY_FIELDS;
        }
        Field[] fields = new Field[values.size()];
        for (int i = 0; i < values.size(); i++) {
            fields[i] = new Field(mapper.names().indexName(), values.get(i).toString(), TextField.TYPE_NOT_STORED);
        }
        return fields;
    }

(startLine=57 endLine=69 srcPath=/root/NewExperiment/elasticsearchFilter/01689/src/main/java/org/elasticsearch/search/highlight/vectorhighlight/SourceScoreOrderFragmentsBuilder.java)
    protected Field[] getFields(IndexReader reader, int docId, String fieldName) throws IOException {
        // we know its low level reader, and matching docId, since that's how we call the highlighter with
        SearchLookup lookup = searchContext.lookup();
        lookup.setNextReader((LeafReaderContext) reader.getContext());
        lookup.setNextDocId(docId);

        List<Object> values = lookup.source().extractRawValues(hitContext.getSourcePath(mapper.names().sourcePath()));
        Field[] fields = new Field[values.size()];
        for (int i = 0; i < values.size(); i++) {
            fields[i] = new Field(mapper.names().indexName(), values.get(i).toString(), TextField.TYPE_NOT_STORED);
        }
        return fields;
    }

commonMethod: 
(startLine=102 endLine=111 srcPath=/root/NewExperiment/elasticsearchFilter/01690/src/main/java/org/elasticsearch/search/lookup/SourceLookup.java)
    public void setSegmentAndDocument(LeafReaderContext context, int docId) {
        if (this.reader == context.reader() && this.docId == docId) {
            // if we are called with the same document, don't invalidate source
            return;
        }
        this.reader = context.reader();
        this.source = null;
        this.sourceAsBytes = null;
        this.docId = docId;
    }


, Instance #
frags: 
(startLine=62 endLine=91 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/search/child/ParentIdsFilter.java)
                                           LongBitSet parentOrds, long numFoundParents) {
        if (numFoundParents == 1) {
            BytesRef id = globalValues.lookupOrd((int) parentOrds.nextSetBit(0));
            if (nonNestedDocsFilter != null) {
                List<Filter> filters = Arrays.asList(
                        new TermFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(parentType, id))),
                        nonNestedDocsFilter
                );
                return new AndFilter(filters);
            } else {
                return new TermFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(parentType, id)));
            }
        } else {
            BytesRefHash parentIds= null;
            boolean constructed = false;
            try {
                parentIds = new BytesRefHash(numFoundParents, searchContext.bigArrays());
                for (long parentOrd = parentOrds.nextSetBit(0); parentOrd != -1; parentOrd = parentOrds.nextSetBit(parentOrd + 1)) {
                    parentIds.add(globalValues.lookupOrd((int) parentOrd));
                }
                constructed = true;
            } finally {
                if (!constructed) {
                    Releasables.close(parentIds);
                }
            }
            searchContext.addReleasable(parentIds, SearchContext.Lifetime.COLLECTION);
            return new ParentIdsFilter(parentType, nonNestedDocsFilter, parentIds);
        }
    }

(startLine=95 endLine=124 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/search/child/ParentIdsFilter.java)
                                           LongHash parentIdxs, long numFoundParents) {
        if (numFoundParents == 1) {
            BytesRef id = globalValues.lookupOrd((int) parentIdxs.get(0));
            if (nonNestedDocsFilter != null) {
                List<Filter> filters = Arrays.asList(
                        new TermFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(parentType, id))),
                        nonNestedDocsFilter
                );
                return new AndFilter(filters);
            } else {
                return new TermFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(parentType, id)));
            }
        } else {
            BytesRefHash parentIds = null;
            boolean constructed = false;
            try {
                parentIds = new BytesRefHash(numFoundParents, searchContext.bigArrays());
                for (int id = 0; id < parentIdxs.size(); id++) {
                    parentIds.add(globalValues.lookupOrd((int) parentIdxs.get(id)));
                }
                constructed = true;
            } finally {
                if (!constructed) {
                    Releasables.close(parentIds);
                }
            }
            searchContext.addReleasable(parentIds, SearchContext.Lifetime.COLLECTION);
            return new ParentIdsFilter(parentType, nonNestedDocsFilter, parentIds);
        }
    }

commonMethod: 
(startLine=177 endLine=180 srcPath=/root/NewExperiment/elasticsearchFilter/01699/src/main/java/org/elasticsearch/common/lucene/search/Queries.java)
    /** Wrap as a {@link Filter}. */
    public static Filter wrap(Query query) {
        return wrap(query, null);
    }


, Instance #
frags: 
(startLine=63 endLine=74 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/search/child/ParentIdsFilter.java)
        if (numFoundParents == 1) {
            BytesRef id = globalValues.lookupOrd((int) parentOrds.nextSetBit(0));
            if (nonNestedDocsFilter != null) {
                List<Filter> filters = Arrays.asList(
                        new TermFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(parentType, id))),
                        nonNestedDocsFilter
                );
                return new AndFilter(filters);
            } else {
                return new TermFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(parentType, id)));
            }
        } else {

(startLine=96 endLine=107 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/search/child/ParentIdsFilter.java)
        if (numFoundParents == 1) {
            BytesRef id = globalValues.lookupOrd((int) parentIdxs.get(0));
            if (nonNestedDocsFilter != null) {
                List<Filter> filters = Arrays.asList(
                        new TermFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(parentType, id))),
                        nonNestedDocsFilter
                );
                return new AndFilter(filters);
            } else {
                return new TermFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(parentType, id)));
            }
        } else {

commonMethod: 
(startLine=177 endLine=180 srcPath=/root/NewExperiment/elasticsearchFilter/01699/src/main/java/org/elasticsearch/common/lucene/search/Queries.java)
    /** Wrap as a {@link Filter}. */
    public static Filter wrap(Query query) {
        return wrap(query, null);
    }


, Instance #
frags: 
(startLine=241 endLine=254 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/mapper/internal/IdFieldMapper.java)
    public Filter prefixFilter(Object value, @Nullable QueryParseContext context) {
        if (fieldType.indexOptions() != IndexOptions.NONE || context == null) {
            return super.prefixFilter(value, context);
        }
        Collection<String> queryTypes = context.queryTypes();
        if (queryTypes.size() == 1) {
            return new PrefixFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(Iterables.getFirst(queryTypes, null), BytesRefs.toBytesRef(value))));
        }
        XBooleanFilter filter = new XBooleanFilter();
        for (String queryType : queryTypes) {
            filter.add(new PrefixFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(queryType, BytesRefs.toBytesRef(value)))), BooleanClause.Occur.SHOULD);
        }
        return filter;
    }

(startLine=282 endLine=297 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/mapper/internal/IdFieldMapper.java)
    public Filter regexpFilter(Object value, int flags, int maxDeterminizedStates, @Nullable QueryParseContext context) {
        if (fieldType.indexOptions() != IndexOptions.NONE || context == null) {
            return super.regexpFilter(value, flags, maxDeterminizedStates, context);
        }
        Collection<String> queryTypes = context.queryTypes();
        if (queryTypes.size() == 1) {
            return new RegexpFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(Iterables.getFirst(queryTypes, null), BytesRefs.toBytesRef(value))),
                                    flags, maxDeterminizedStates);
        }
        XBooleanFilter filter = new XBooleanFilter();
        for (String queryType : queryTypes) {
            filter.add(new RegexpFilter(new Term(UidFieldMapper.NAME, Uid.createUidAsBytes(queryType, BytesRefs.toBytesRef(value))),
                                        flags, maxDeterminizedStates), BooleanClause.Occur.SHOULD);
        }
        return filter;
    }

commonMethod: 
(startLine=177 endLine=180 srcPath=/root/NewExperiment/elasticsearchFilter/01699/src/main/java/org/elasticsearch/common/lucene/search/Queries.java)
    /** Wrap as a {@link Filter}. */
    public static Filter wrap(Query query) {
        return wrap(query, null);
    }


, Instance #
frags: 
(startLine=208 endLine=220 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/query/TermsFilterParser.java)
            } else if (EXECUTION_VALUE_BOOL.equals(execution)) {
                XBooleanFilter boolFiler = new XBooleanFilter();
                if (fieldMapper != null) {
                    for (Object term : terms) {
                        boolFiler.add(parseContext.cacheFilter(fieldMapper.termFilter(term, parseContext), null, parseContext.autoFilterCachePolicy()), BooleanClause.Occur.SHOULD);
                    }
                } else {
                    for (Object term : terms) {
                        boolFiler.add(parseContext.cacheFilter(new TermFilter(new Term(fieldName, BytesRefs.toBytesRef(term))), null, parseContext.autoFilterCachePolicy()), BooleanClause.Occur.SHOULD);
                    }
                }
                filter = boolFiler;
            } else if (EXECUTION_VALUE_BOOL_NOCACHE.equals(execution)) {

(startLine=220 endLine=232 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/query/TermsFilterParser.java)
            } else if (EXECUTION_VALUE_BOOL_NOCACHE.equals(execution)) {
                XBooleanFilter boolFiler = new XBooleanFilter();
                if (fieldMapper != null) {
                    for (Object term : terms) {
                        boolFiler.add(fieldMapper.termFilter(term, parseContext), BooleanClause.Occur.SHOULD);
                    }
                } else {
                    for (Object term : terms) {
                        boolFiler.add(new TermFilter(new Term(fieldName, BytesRefs.toBytesRef(term))), BooleanClause.Occur.SHOULD);
                    }
                }
                filter = boolFiler;
            } else if (EXECUTION_VALUE_AND.equals(execution)) {

commonMethod: 
(startLine=177 endLine=180 srcPath=/root/NewExperiment/elasticsearchFilter/01699/src/main/java/org/elasticsearch/common/lucene/search/Queries.java)
    /** Wrap as a {@link Filter}. */
    public static Filter wrap(Query query) {
        return wrap(query, null);
    }


, Instance #
frags: 
(startLine=232 endLine=244 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/query/TermsFilterParser.java)
            } else if (EXECUTION_VALUE_AND.equals(execution)) {
                List<Filter> filters = Lists.newArrayList();
                if (fieldMapper != null) {
                    for (Object term : terms) {
                        filters.add(parseContext.cacheFilter(fieldMapper.termFilter(term, parseContext), null, parseContext.autoFilterCachePolicy()));
                    }
                } else {
                    for (Object term : terms) {
                        filters.add(parseContext.cacheFilter(new TermFilter(new Term(fieldName, BytesRefs.toBytesRef(term))), null, parseContext.autoFilterCachePolicy()));
                    }
                }
                filter = new AndFilter(filters);
            } else if (EXECUTION_VALUE_AND_NOCACHE.equals(execution)) {

(startLine=256 endLine=268 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/query/TermsFilterParser.java)
            } else if (EXECUTION_VALUE_OR.equals(execution)) {
                List<Filter> filters = Lists.newArrayList();
                if (fieldMapper != null) {
                    for (Object term : terms) {
                        filters.add(parseContext.cacheFilter(fieldMapper.termFilter(term, parseContext), null, parseContext.autoFilterCachePolicy()));
                    }
                } else {
                    for (Object term : terms) {
                        filters.add(parseContext.cacheFilter(new TermFilter(new Term(fieldName, BytesRefs.toBytesRef(term))), null, parseContext.autoFilterCachePolicy()));
                    }
                }
                filter = new OrFilter(filters);
            } else if (EXECUTION_VALUE_OR_NOCACHE.equals(execution)) {

commonMethod: 
(startLine=177 endLine=180 srcPath=/root/NewExperiment/elasticsearchFilter/01699/src/main/java/org/elasticsearch/common/lucene/search/Queries.java)
    /** Wrap as a {@link Filter}. */
    public static Filter wrap(Query query) {
        return wrap(query, null);
    }


, Instance #
frags: 
(startLine=244 endLine=256 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/query/TermsFilterParser.java)
            } else if (EXECUTION_VALUE_AND_NOCACHE.equals(execution)) {
                List<Filter> filters = Lists.newArrayList();
                if (fieldMapper != null) {
                    for (Object term : terms) {
                        filters.add(fieldMapper.termFilter(term, parseContext));
                    }
                } else {
                    for (Object term : terms) {
                        filters.add(new TermFilter(new Term(fieldName, BytesRefs.toBytesRef(term))));
                    }
                }
                filter = new AndFilter(filters);
            } else if (EXECUTION_VALUE_OR.equals(execution)) {

(startLine=268 endLine=280 srcPath=/root/NewExperiment/elasticsearchFilter/01698/src/main/java/org/elasticsearch/index/query/TermsFilterParser.java)
            } else if (EXECUTION_VALUE_OR_NOCACHE.equals(execution)) {
                List<Filter> filters = Lists.newArrayList();
                if (fieldMapper != null) {
                    for (Object term : terms) {
                        filters.add(fieldMapper.termFilter(term, parseContext));
                    }
                } else {
                    for (Object term : terms) {
                        filters.add(new TermFilter(new Term(fieldName, BytesRefs.toBytesRef(term))));
                    }
                }
                filter = new OrFilter(filters);
            } else {

commonMethod: 
(startLine=177 endLine=180 srcPath=/root/NewExperiment/elasticsearchFilter/01699/src/main/java/org/elasticsearch/common/lucene/search/Queries.java)
    /** Wrap as a {@link Filter}. */
    public static Filter wrap(Query query) {
        return wrap(query, null);
    }


, Instance #
frags: 
(startLine=198 endLine=257 srcPath=/root/NewExperiment/elasticsearchFilter/01703/src/test/java/org/elasticsearch/index/IndexWithShadowReplicasTests.java)
    public void testReplicaToPrimaryPromotion() throws Exception {
        Settings nodeSettings = ImmutableSettings.builder()
                .put("node.add_id_to_custom_path", false)
                .put("node.enable_custom_paths", true)
                .build();

        String node1 = internalCluster().startNode(nodeSettings);
        Path dataPath = createTempDir();
        String IDX = "test";

        Settings idxSettings = ImmutableSettings.builder()
                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)
                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1)
                .put(IndexMetaData.SETTING_DATA_PATH, dataPath.toAbsolutePath().toString())
                .put(IndexMetaData.SETTING_SHADOW_REPLICAS, true)
                .put(IndexMetaData.SETTING_SHARED_FILESYSTEM, true)
                .build();

        prepareCreate(IDX).setSettings(idxSettings).addMapping("doc", "foo", "type=string").get();
        ensureYellow(IDX);
        client().prepareIndex(IDX, "doc", "1").setSource("foo", "bar").get();
        client().prepareIndex(IDX, "doc", "2").setSource("foo", "bar").get();

        GetResponse gResp1 = client().prepareGet(IDX, "doc", "1").setFields("foo").get();
        GetResponse gResp2 = client().prepareGet(IDX, "doc", "2").setFields("foo").get();
        assertTrue(gResp1.isExists());
        assertTrue(gResp2.isExists());
        assertThat(gResp1.getField("foo").getValue().toString(), equalTo("bar"));
        assertThat(gResp2.getField("foo").getValue().toString(), equalTo("bar"));

        // Node1 has the primary, now node2 has the replica
        String node2 = internalCluster().startNode(nodeSettings);
        ensureGreen(IDX);
        client().admin().cluster().prepareHealth().setWaitForNodes("2").get();
        flushAndRefresh(IDX);

        logger.info("--> stopping node1 [{}]", node1);
        internalCluster().stopRandomNode(InternalTestCluster.nameFilter(node1));
        ensureYellow(IDX);

        logger.info("--> performing query");
        SearchResponse resp = client().prepareSearch(IDX).setQuery(matchAllQuery()).get();
        assertHitCount(resp, 2);

        gResp1 = client().prepareGet(IDX, "doc", "1").setFields("foo").get();
        gResp2 = client().prepareGet(IDX, "doc", "2").setFields("foo").get();
        assertTrue(gResp1.isExists());
        assertTrue(gResp2.toString(), gResp2.isExists());
        assertThat(gResp1.getField("foo").getValue().toString(), equalTo("bar"));
        assertThat(gResp2.getField("foo").getValue().toString(), equalTo("bar"));

        client().prepareIndex(IDX, "doc", "1").setSource("foo", "foobar").get();
        client().prepareIndex(IDX, "doc", "2").setSource("foo", "foobar").get();
        gResp1 = client().prepareGet(IDX, "doc", "1").setFields("foo").get();
        gResp2 = client().prepareGet(IDX, "doc", "2").setFields("foo").get();
        assertTrue(gResp1.isExists());
        assertTrue(gResp2.toString(), gResp2.isExists());
        assertThat(gResp1.getField("foo").getValue().toString(), equalTo("foobar"));
        assertThat(gResp2.getField("foo").getValue().toString(), equalTo("foobar"));
    }

(startLine=260 endLine=321 srcPath=/root/NewExperiment/elasticsearchFilter/01703/src/test/java/org/elasticsearch/index/IndexWithShadowReplicasTests.java)
    public void testPrimaryRelocation() throws Exception {
        Settings nodeSettings = ImmutableSettings.builder()
                .put("node.add_id_to_custom_path", false)
                .put("node.enable_custom_paths", true)
                .build();

        String node1 = internalCluster().startNode(nodeSettings);
        Path dataPath = createTempDir();
        String IDX = "test";

        Settings idxSettings = ImmutableSettings.builder()
                .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)
                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1)
                .put(IndexMetaData.SETTING_DATA_PATH, dataPath.toAbsolutePath().toString())
                .put(IndexMetaData.SETTING_SHADOW_REPLICAS, true)
                .put(IndexMetaData.SETTING_SHARED_FILESYSTEM, true)
                .build();

        prepareCreate(IDX).setSettings(idxSettings).addMapping("doc", "foo", "type=string").get();
        ensureYellow(IDX);
        client().prepareIndex(IDX, "doc", "1").setSource("foo", "bar").get();
        client().prepareIndex(IDX, "doc", "2").setSource("foo", "bar").get();

        GetResponse gResp1 = client().prepareGet(IDX, "doc", "1").setFields("foo").get();
        GetResponse gResp2 = client().prepareGet(IDX, "doc", "2").setFields("foo").get();
        assertTrue(gResp1.isExists());
        assertTrue(gResp2.isExists());
        assertThat(gResp1.getField("foo").getValue().toString(), equalTo("bar"));
        assertThat(gResp2.getField("foo").getValue().toString(), equalTo("bar"));

        // Node1 has the primary, now node2 has the replica
        String node2 = internalCluster().startNode(nodeSettings);
        ensureGreen(IDX);
        client().admin().cluster().prepareHealth().setWaitForNodes("2").get();
        flushAndRefresh(IDX);

        // now prevent primary from being allocated on node 1 move to node_3
        String node3 = internalCluster().startNode(nodeSettings);
        Settings build = ImmutableSettings.builder().put("index.routing.allocation.exclude._name", node1).build();
        client().admin().indices().prepareUpdateSettings(IDX).setSettings(build).execute().actionGet();

        ensureGreen(IDX);
        logger.info("--> performing query");
        SearchResponse resp = client().prepareSearch(IDX).setQuery(matchAllQuery()).get();
        assertHitCount(resp, 2);

        gResp1 = client().prepareGet(IDX, "doc", "1").setFields("foo").get();
        gResp2 = client().prepareGet(IDX, "doc", "2").setFields("foo").get();
        assertTrue(gResp1.isExists());
        assertTrue(gResp2.toString(), gResp2.isExists());
        assertThat(gResp1.getField("foo").getValue().toString(), equalTo("bar"));
        assertThat(gResp2.getField("foo").getValue().toString(), equalTo("bar"));

        client().prepareIndex(IDX, "doc", "3").setSource("foo", "bar").get();
        client().prepareIndex(IDX, "doc", "4").setSource("foo", "bar").get();
        gResp1 = client().prepareGet(IDX, "doc", "3").setPreference("_primary").setFields("foo").get();
        gResp2 = client().prepareGet(IDX, "doc", "4").setPreference("_primary").setFields("foo").get();
        assertTrue(gResp1.isExists());
        assertTrue(gResp2.isExists());
        assertThat(gResp1.getField("foo").getValue().toString(), equalTo("bar"));
        assertThat(gResp2.getField("foo").getValue().toString(), equalTo("bar"));
    }

commonMethod: 
(startLine=69 endLine=75 srcPath=/root/NewExperiment/elasticsearchFilter/01704/src/test/java/org/elasticsearch/index/IndexWithShadowReplicasTests.java)
    private Settings nodeSettings() {
        return ImmutableSettings.builder()
                .put("node.add_id_to_custom_path", false)
                .put("node.enable_custom_paths", true)
                .put("index.store.fs.fs_lock", randomFrom("native", "simple"))
                .build();
    }


, Instance #
frags: 
(startLine=510 endLine=517 srcPath=/root/NewExperiment/elasticsearchFilter/01710/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java)
        if (freeBytes < freeBytesThresholdHigh.bytes()) {
            if (logger.isDebugEnabled()) {
                logger.debug("Less than the required {} free bytes threshold ({} bytes free) on node {}, shard cannot remain",
                        freeBytesThresholdHigh, freeBytes, node.nodeId());
            }
            return allocation.decision(Decision.NO, NAME, "after allocation less than required [%s] free on node, free: [%s]",
                    freeBytesThresholdHigh, new ByteSizeValue(freeBytes));
        }

(startLine=518 endLine=525 srcPath=/root/NewExperiment/elasticsearchFilter/01710/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java)
        if (freeDiskPercentage < freeDiskThresholdHigh) {
            if (logger.isDebugEnabled()) {
                logger.debug("Less than the required {}% free disk threshold ({}% free) on node {}, shard cannot remain",
                        freeDiskThresholdHigh, freeDiskPercentage, node.nodeId());
            }
            return allocation.decision(Decision.NO, NAME, "after allocation less than required [%s%%] free disk on node, free: [%s%%]",
                    freeDiskThresholdHigh, freeDiskPercentage);
        }

commonMethod: 
(startLine=440 endLine=466 srcPath=/root/NewExperiment/elasticsearchFilter/01711/core/src/main/java/org/elasticsearch/cluster/routing/allocation/decider/DiskThresholdDecider.java)
    private DiskUsage getDiskUsage(RoutingNode node, RoutingAllocation allocation) {
        ClusterInfo clusterInfo = allocation.clusterInfo();
        Map<String, DiskUsage> usages = clusterInfo.getNodeDiskUsages();
        DiskUsage usage = usages.get(node.nodeId());
        if (usage == null) {
            // If there is no usage, and we have other nodes in the cluster,
            // use the average usage for all nodes as the usage for this node
            usage = averageUsage(node, usages);
            if (logger.isDebugEnabled()) {
                logger.debug("Unable to determine disk usage for {}, defaulting to average across nodes [{} total] [{} free] [{}% free]",
                        node.nodeId(), usage.getTotalBytes(), usage.getFreeBytes(), usage.getFreeDiskAsPercentage());
            }
        }

        if (includeRelocations) {
            Map<String, Long> shardSizes = clusterInfo.getShardSizes();
            long relocatingShardsSize = sizeOfRelocatingShards(node, shardSizes, true);
            DiskUsage usageIncludingRelocations = new DiskUsage(node.nodeId(), node.node().name(),
                    usage.getTotalBytes(), usage.getFreeBytes() - relocatingShardsSize);
            if (logger.isTraceEnabled()) {
                logger.trace("usage without relocations: {}", usage);
                logger.trace("usage with relocations: [{} bytes] {}", relocatingShardsSize, usageIncludingRelocations);
            }
            usage = usageIncludingRelocations;
        }
        return usage;
    }


, Instance #
frags: 
(startLine=50 endLine=60 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/ExistsQueryParser.java)
            } else if (token.isValue()) {
                if ("field".equals(currentFieldName)) {
                    fieldPattern = parser.text();
                } else if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "[" + ExistsQueryBuilder.NAME + "] query does not support [" + currentFieldName + "]");
                }
            } else {

(startLine=75 endLine=85 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/DisMaxQueryParser.java)
            } else {
                if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else if ("tie_breaker".equals(currentFieldName) || "tieBreaker".equals(currentFieldName)) {
                    tieBreaker = parser.floatValue();
                } else if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "[dis_max] query does not support [" + currentFieldName + "]");
                }
            }

(startLine=51 endLine=61 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/TypeQueryParser.java)
            } else if (token.isValue()) {
                if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else if ("value".equals(currentFieldName)) {
                    type = parser.utf8Bytes();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "[" + TypeQueryBuilder.NAME + "] filter doesn't support [" + currentFieldName + "]");
                }
            } else {

(startLine=63 endLine=73 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/SpanFirstQueryParser.java)
            } else {
                if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else if ("end".equals(currentFieldName)) {
                    end = parser.intValue();
                } else if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "[span_first] query does not support [" + currentFieldName + "]");
                }
            }

commonMethod: 
(startLine=49 endLine=59 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/main/java/org/elasticsearch/common/ParseFieldMatcher.java)
    /**
     * Matches a {@link ParseField} against a field name, and throws deprecation exception depending on the current
     * value of the {@link #PARSE_STRICT} setting.
     * @param fieldName the field name found in the request while parsing
     * @param parseField the parse field that we are looking for
     * @throws IllegalArgumentException whenever we are in strict mode and the request contained a deprecated field
     * @return true whenever the parse field that we are looking for was found, false otherwise
     */
    public boolean match(String fieldName, ParseField parseField) {
        return parseField.match(fieldName, parseFlags);
    }


, Instance #
frags: 
(startLine=50 endLine=60 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/ExistsQueryParser.java)
            } else if (token.isValue()) {
                if ("field".equals(currentFieldName)) {
                    fieldPattern = parser.text();
                } else if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "[" + ExistsQueryBuilder.NAME + "] query does not support [" + currentFieldName + "]");
                }
            } else {

(startLine=75 endLine=85 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/DisMaxQueryParser.java)
            } else {
                if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else if ("tie_breaker".equals(currentFieldName) || "tieBreaker".equals(currentFieldName)) {
                    tieBreaker = parser.floatValue();
                } else if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "[dis_max] query does not support [" + currentFieldName + "]");
                }
            }

(startLine=51 endLine=61 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/TypeQueryParser.java)
            } else if (token.isValue()) {
                if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else if ("value".equals(currentFieldName)) {
                    type = parser.utf8Bytes();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "[" + TypeQueryBuilder.NAME + "] filter doesn't support [" + currentFieldName + "]");
                }
            } else {

(startLine=63 endLine=73 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/SpanFirstQueryParser.java)
            } else {
                if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else if ("end".equals(currentFieldName)) {
                    end = parser.intValue();
                } else if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "[span_first] query does not support [" + currentFieldName + "]");
                }
            }

commonMethod: 
(startLine=134 endLine=136 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/main/java/org/elasticsearch/index/query/QueryParseContext.java)
    public ParseFieldMatcher parseFieldMatcher() {
        return parseFieldMatcher;
    }


, Instance #
frags: 
(startLine=43 endLine=57 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/MatchNoneQueryParser.java)
        while (((token = parser.nextToken()) != XContentParser.Token.END_OBJECT && token != XContentParser.Token.END_ARRAY)) {
            if (token == XContentParser.Token.FIELD_NAME) {
                currentFieldName = parser.currentName();
            } else if (token.isValue()) {
                if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "["+MatchNoneQueryBuilder.NAME+"] query does not support [" + currentFieldName + "]");
                }
            } else {
                throw new ParsingException(parser.getTokenLocation(), "[" + MatchNoneQueryBuilder.NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]");
            }
        }

(startLine=46 endLine=60 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/MatchAllQueryParser.java)
        while (((token = parser.nextToken()) != XContentParser.Token.END_OBJECT && token != XContentParser.Token.END_ARRAY)) {
            if (token == XContentParser.Token.FIELD_NAME) {
                currentFieldName = parser.currentName();
            } else if (token.isValue()) {
                if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "[" + MatchAllQueryBuilder.NAME + "] query does not support [" + currentFieldName + "]");
                }
            } else {
                throw new ParsingException(parser.getTokenLocation(), "[" + MatchAllQueryBuilder.NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]");
            }
        }

commonMethod: 
(startLine=49 endLine=59 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/main/java/org/elasticsearch/common/ParseFieldMatcher.java)
    /**
     * Matches a {@link ParseField} against a field name, and throws deprecation exception depending on the current
     * value of the {@link #PARSE_STRICT} setting.
     * @param fieldName the field name found in the request while parsing
     * @param parseField the parse field that we are looking for
     * @throws IllegalArgumentException whenever we are in strict mode and the request contained a deprecated field
     * @return true whenever the parse field that we are looking for was found, false otherwise
     */
    public boolean match(String fieldName, ParseField parseField) {
        return parseField.match(fieldName, parseFlags);
    }


, Instance #
frags: 
(startLine=43 endLine=57 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/MatchNoneQueryParser.java)
        while (((token = parser.nextToken()) != XContentParser.Token.END_OBJECT && token != XContentParser.Token.END_ARRAY)) {
            if (token == XContentParser.Token.FIELD_NAME) {
                currentFieldName = parser.currentName();
            } else if (token.isValue()) {
                if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "["+MatchNoneQueryBuilder.NAME+"] query does not support [" + currentFieldName + "]");
                }
            } else {
                throw new ParsingException(parser.getTokenLocation(), "[" + MatchNoneQueryBuilder.NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]");
            }
        }

(startLine=46 endLine=60 srcPath=/root/NewExperiment/elasticsearchFilter/01768/core/src/main/java/org/elasticsearch/index/query/MatchAllQueryParser.java)
        while (((token = parser.nextToken()) != XContentParser.Token.END_OBJECT && token != XContentParser.Token.END_ARRAY)) {
            if (token == XContentParser.Token.FIELD_NAME) {
                currentFieldName = parser.currentName();
            } else if (token.isValue()) {
                if ("_name".equals(currentFieldName)) {
                    queryName = parser.text();
                } else if ("boost".equals(currentFieldName)) {
                    boost = parser.floatValue();
                } else {
                    throw new ParsingException(parser.getTokenLocation(), "[" + MatchAllQueryBuilder.NAME + "] query does not support [" + currentFieldName + "]");
                }
            } else {
                throw new ParsingException(parser.getTokenLocation(), "[" + MatchAllQueryBuilder.NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]");
            }
        }

commonMethod: 
(startLine=134 endLine=136 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/main/java/org/elasticsearch/index/query/QueryParseContext.java)
    public ParseFieldMatcher parseFieldMatcher() {
        return parseFieldMatcher;
    }


, Instance #
frags: 
(startLine=41 endLine=66 srcPath=/root/NewExperiment/elasticsearchFilter/01768/plugins/mapper-attachments/src/test/java/org/elasticsearch/mapper/attachments/SimpleAttachmentMapperTests.java)
    public void testSimpleMappings() throws Exception {
        DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(createTempDir(), Settings.EMPTY).documentMapperParser();
        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());
        String mapping = copyToStringFromClasspath("/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping.json");
        DocumentMapper docMapper = mapperParser.parse(mapping);
        byte[] html = copyToBytesFromClasspath("/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html");

        BytesReference json = jsonBuilder().startObject().field("file", html).endObject().bytes();
        ParseContext.Document doc = docMapper.parse("person", "person", "1", json).rootDoc();

        assertThat(doc.get(docMapper.mappers().getMapper("file.content_type").fieldType().names().indexName()), startsWith("application/xhtml+xml"));
        assertThat(doc.get(docMapper.mappers().getMapper("file.title").fieldType().names().indexName()), equalTo("XHTML test document"));
        assertThat(doc.get(docMapper.mappers().getMapper("file.content").fieldType().names().indexName()), containsString("This document tests the ability of Apache Tika to extract content"));

        // re-parse it
        String builtMapping = docMapper.mappingSource().string();
        docMapper = mapperParser.parse(builtMapping);

        json = jsonBuilder().startObject().field("file", html).endObject().bytes();

        doc = docMapper.parse("person", "person", "1", json).rootDoc();

        assertThat(doc.get(docMapper.mappers().getMapper("file.content_type").fieldType().names().indexName()), startsWith("application/xhtml+xml"));
        assertThat(doc.get(docMapper.mappers().getMapper("file.title").fieldType().names().indexName()), equalTo("XHTML test document"));
        assertThat(doc.get(docMapper.mappers().getMapper("file.content").fieldType().names().indexName()), containsString("This document tests the ability of Apache Tika to extract content"));
    }

(startLine=87 endLine=112 srcPath=/root/NewExperiment/elasticsearchFilter/01768/plugins/mapper-attachments/src/test/java/org/elasticsearch/mapper/attachments/SimpleAttachmentMapperTests.java)
    public void testSimpleMappingsWithAllFields() throws Exception {
        DocumentMapperParser mapperParser = MapperTestUtils.newMapperService(createTempDir(), Settings.EMPTY).documentMapperParser();
        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());
        String mapping = copyToStringFromClasspath("/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping-all-fields.json");
        DocumentMapper docMapper = mapperParser.parse(mapping);
        byte[] html = copyToBytesFromClasspath("/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html");

        BytesReference json = jsonBuilder().startObject().field("file", html).endObject().bytes();
        ParseContext.Document doc = docMapper.parse("person", "person", "1", json).rootDoc();

        assertThat(doc.get(docMapper.mappers().getMapper("file.content_type").fieldType().names().indexName()), startsWith("application/xhtml+xml"));
        assertThat(doc.get(docMapper.mappers().getMapper("file.title").fieldType().names().indexName()), equalTo("XHTML test document"));
        assertThat(doc.get(docMapper.mappers().getMapper("file.content").fieldType().names().indexName()), containsString("This document tests the ability of Apache Tika to extract content"));

        // re-parse it
        String builtMapping = docMapper.mappingSource().string();
        docMapper = mapperParser.parse(builtMapping);

        json = jsonBuilder().startObject().field("file", html).endObject().bytes();

        doc = docMapper.parse("person", "person", "1", json).rootDoc();

        assertThat(doc.get(docMapper.mappers().getMapper("file.content_type").fieldType().names().indexName()), startsWith("application/xhtml+xml"));
        assertThat(doc.get(docMapper.mappers().getMapper("file.title").fieldType().names().indexName()), equalTo("XHTML test document"));
        assertThat(doc.get(docMapper.mappers().getMapper("file.content").fieldType().names().indexName()), containsString("This document tests the ability of Apache Tika to extract content"));
    }

commonMethod: 
(startLine=33 endLine=37 srcPath=/root/NewExperiment/elasticsearchFilter/01769/plugins/mapper-attachments/src/test/java/org/elasticsearch/mapper/attachments/AttachmentUnitTestCase.java)
    protected static IndicesModule getIndicesModuleWithRegisteredAttachmentMapper() {
        IndicesModule indicesModule = new IndicesModule();
        indicesModule.registerMapper(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());
        return indicesModule;
    }


, Instance #
frags: 
(startLine=130 endLine=174 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/test/java/org/elasticsearch/common/lucene/all/SimpleAllTests.java)
    public void testSimpleAllNoBoost() throws Exception {
        Directory dir = new RAMDirectory();
        IndexWriter indexWriter = new IndexWriter(dir, new IndexWriterConfig(Lucene.STANDARD_ANALYZER));

        Document doc = new Document();
        doc.add(new Field("_id", "1", StoredField.TYPE));
        AllEntries allEntries = new AllEntries();
        allEntries.addText("field1", "something", 1.0f);
        allEntries.addText("field2", "else", 1.0f);
        allEntries.reset();
        doc.add(new TextField("_all", AllTokenStream.allTokenStream("_all", allEntries, Lucene.STANDARD_ANALYZER)));

        indexWriter.addDocument(doc);

        doc = new Document();
        doc.add(new Field("_id", "2", StoredField.TYPE));
        allEntries = new AllEntries();
        allEntries.addText("field1", "else", 1.0f);
        allEntries.addText("field2", "something", 1.0f);
        allEntries.reset();
        doc.add(new TextField("_all", AllTokenStream.allTokenStream("_all", allEntries, Lucene.STANDARD_ANALYZER)));

        indexWriter.addDocument(doc);

        IndexReader reader = DirectoryReader.open(indexWriter, true);
        IndexSearcher searcher = new IndexSearcher(reader);

        Query query = new AllTermQuery(new Term("_all", "else"));
        TopDocs docs = searcher.search(query, 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(0));
        assertExplanationScore(searcher, query, docs.scoreDocs[0]);
        assertThat(docs.scoreDocs[1].doc, equalTo(1));
        assertExplanationScore(searcher, query, docs.scoreDocs[1]);

        query = new AllTermQuery(new Term("_all", "something"));
        docs = searcher.search(query, 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(0));
        assertExplanationScore(searcher, query, docs.scoreDocs[0]);
        assertThat(docs.scoreDocs[1].doc, equalTo(1));
        assertExplanationScore(searcher, query, docs.scoreDocs[1]);

        indexWriter.close();
    }

(startLine=176 endLine=221 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/test/java/org/elasticsearch/common/lucene/all/SimpleAllTests.java)
    public void testSimpleAllWithBoost() throws Exception {
        Directory dir = new RAMDirectory();
        IndexWriter indexWriter = new IndexWriter(dir, new IndexWriterConfig(Lucene.STANDARD_ANALYZER));

        Document doc = new Document();
        doc.add(new Field("_id", "1", StoredField.TYPE));
        AllEntries allEntries = new AllEntries();
        allEntries.addText("field1", "something", 1.0f);
        allEntries.addText("field2", "else", 1.0f);
        allEntries.reset();
        doc.add(new TextField("_all", AllTokenStream.allTokenStream("_all", allEntries, Lucene.STANDARD_ANALYZER)));

        indexWriter.addDocument(doc);

        doc = new Document();
        doc.add(new Field("_id", "2", StoredField.TYPE));
        allEntries = new AllEntries();
        allEntries.addText("field1", "else", 2.0f);
        allEntries.addText("field2", "something", 1.0f);
        allEntries.reset();
        doc.add(new TextField("_all", AllTokenStream.allTokenStream("_all", allEntries, Lucene.STANDARD_ANALYZER)));

        indexWriter.addDocument(doc);

        IndexReader reader = DirectoryReader.open(indexWriter, true);
        IndexSearcher searcher = new IndexSearcher(reader);

        // this one is boosted. so the second doc is more relevant
        Query query = new AllTermQuery(new Term("_all", "else"));
        TopDocs docs = searcher.search(query, 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(1));
        assertExplanationScore(searcher, query, docs.scoreDocs[0]);
        assertThat(docs.scoreDocs[1].doc, equalTo(0));
        assertExplanationScore(searcher, query, docs.scoreDocs[1]);

        query = new AllTermQuery(new Term("_all", "something"));
        docs = searcher.search(query, 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(0));
        assertExplanationScore(searcher, query, docs.scoreDocs[0]);
        assertThat(docs.scoreDocs[1].doc, equalTo(1));
        assertExplanationScore(searcher, query, docs.scoreDocs[1]);

        indexWriter.close();
    }

commonMethod: 
(startLine=51 endLine=57 srcPath=/root/NewExperiment/elasticsearchFilter/01770/core/src/test/java/org/elasticsearch/common/lucene/all/SimpleAllTests.java)
    private FieldType getAllFieldType() {
        FieldType ft = new FieldType();
        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
        ft.setTokenized(true);
        ft.freeze();
        return ft;
    }


, Instance #
frags: 
(startLine=223 endLine=271 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/test/java/org/elasticsearch/common/lucene/all/SimpleAllTests.java)
    public void testMultipleTokensAllNoBoost() throws Exception {
        Directory dir = new RAMDirectory();
        IndexWriter indexWriter = new IndexWriter(dir, new IndexWriterConfig(Lucene.STANDARD_ANALYZER));

        Document doc = new Document();
        doc.add(new Field("_id", "1", StoredField.TYPE));
        AllEntries allEntries = new AllEntries();
        allEntries.addText("field1", "something moo", 1.0f);
        allEntries.addText("field2", "else koo", 1.0f);
        allEntries.reset();
        doc.add(new TextField("_all", AllTokenStream.allTokenStream("_all", allEntries, Lucene.STANDARD_ANALYZER)));

        indexWriter.addDocument(doc);

        doc = new Document();
        doc.add(new Field("_id", "2", StoredField.TYPE));
        allEntries = new AllEntries();
        allEntries.addText("field1", "else koo", 1.0f);
        allEntries.addText("field2", "something moo", 1.0f);
        allEntries.reset();
        doc.add(new TextField("_all", AllTokenStream.allTokenStream("_all", allEntries, Lucene.STANDARD_ANALYZER)));

        indexWriter.addDocument(doc);

        IndexReader reader = DirectoryReader.open(indexWriter, true);
        IndexSearcher searcher = new IndexSearcher(reader);

        TopDocs docs = searcher.search(new AllTermQuery(new Term("_all", "else")), 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(0));
        assertThat(docs.scoreDocs[1].doc, equalTo(1));

        docs = searcher.search(new AllTermQuery(new Term("_all", "koo")), 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(0));
        assertThat(docs.scoreDocs[1].doc, equalTo(1));

        docs = searcher.search(new AllTermQuery(new Term("_all", "something")), 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(0));
        assertThat(docs.scoreDocs[1].doc, equalTo(1));

        docs = searcher.search(new AllTermQuery(new Term("_all", "moo")), 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(0));
        assertThat(docs.scoreDocs[1].doc, equalTo(1));

        indexWriter.close();
    }

(startLine=273 endLine=321 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/test/java/org/elasticsearch/common/lucene/all/SimpleAllTests.java)
    public void testMultipleTokensAllWithBoost() throws Exception {
        Directory dir = new RAMDirectory();
        IndexWriter indexWriter = new IndexWriter(dir, new IndexWriterConfig(Lucene.STANDARD_ANALYZER));

        Document doc = new Document();
        doc.add(new Field("_id", "1", StoredField.TYPE));
        AllEntries allEntries = new AllEntries();
        allEntries.addText("field1", "something moo", 1.0f);
        allEntries.addText("field2", "else koo", 1.0f);
        allEntries.reset();
        doc.add(new TextField("_all", AllTokenStream.allTokenStream("_all", allEntries, Lucene.STANDARD_ANALYZER)));

        indexWriter.addDocument(doc);

        doc = new Document();
        doc.add(new Field("_id", "2", StoredField.TYPE));
        allEntries = new AllEntries();
        allEntries.addText("field1", "else koo", 2.0f);
        allEntries.addText("field2", "something moo", 1.0f);
        allEntries.reset();
        doc.add(new TextField("_all", AllTokenStream.allTokenStream("_all", allEntries, Lucene.STANDARD_ANALYZER)));

        indexWriter.addDocument(doc);

        IndexReader reader = DirectoryReader.open(indexWriter, true);
        IndexSearcher searcher = new IndexSearcher(reader);

        TopDocs docs = searcher.search(new AllTermQuery(new Term("_all", "else")), 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(1));
        assertThat(docs.scoreDocs[1].doc, equalTo(0));

        docs = searcher.search(new AllTermQuery(new Term("_all", "koo")), 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(1));
        assertThat(docs.scoreDocs[1].doc, equalTo(0));

        docs = searcher.search(new AllTermQuery(new Term("_all", "something")), 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(0));
        assertThat(docs.scoreDocs[1].doc, equalTo(1));

        docs = searcher.search(new AllTermQuery(new Term("_all", "moo")), 10);
        assertThat(docs.totalHits, equalTo(2));
        assertThat(docs.scoreDocs[0].doc, equalTo(0));
        assertThat(docs.scoreDocs[1].doc, equalTo(1));

        indexWriter.close();
    }

commonMethod: 
(startLine=51 endLine=57 srcPath=/root/NewExperiment/elasticsearchFilter/01770/core/src/test/java/org/elasticsearch/common/lucene/all/SimpleAllTests.java)
    private FieldType getAllFieldType() {
        FieldType ft = new FieldType();
        ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
        ft.setTokenized(true);
        ft.freeze();
        return ft;
    }


, Instance #
frags: 
(startLine=69 endLine=78 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/main/java/org/elasticsearch/index/mapper/internal/TypeFieldMapper.java)
        static {
            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);
            FIELD_TYPE.setTokenized(false);
            FIELD_TYPE.setStored(false);
            FIELD_TYPE.setOmitNorms(true);
            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);
            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);
            FIELD_TYPE.setNames(new MappedFieldType.Names(NAME));
            FIELD_TYPE.freeze();
        }

(startLine=59 endLine=68 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/main/java/org/elasticsearch/index/mapper/internal/RoutingFieldMapper.java)
        static {
            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);
            FIELD_TYPE.setTokenized(false);
            FIELD_TYPE.setStored(true);
            FIELD_TYPE.setOmitNorms(true);
            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);
            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);
            FIELD_TYPE.setNames(new MappedFieldType.Names(NAME));
            FIELD_TYPE.freeze();
        }

(startLine=65 endLine=74 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/main/java/org/elasticsearch/index/mapper/internal/FieldNamesFieldMapper.java)
        static {
            FIELD_TYPE.setIndexOptions(IndexOptions.DOCS);
            FIELD_TYPE.setTokenized(false);
            FIELD_TYPE.setStored(false);
            FIELD_TYPE.setOmitNorms(true);
            FIELD_TYPE.setIndexAnalyzer(Lucene.KEYWORD_ANALYZER);
            FIELD_TYPE.setSearchAnalyzer(Lucene.KEYWORD_ANALYZER);
            FIELD_TYPE.setNames(new MappedFieldType.Names(NAME));
            FIELD_TYPE.freeze();
        }

commonMethod: 
(startLine=227 endLine=230 srcPath=/root/NewExperiment/elasticsearchFilter/01770/core/src/main/java/org/elasticsearch/index/mapper/MappedFieldType.java)
    public void setName(String name) {
        checkIfFrozen();
        this.name = name;
    }


, Instance #
frags: 
(startLine=91 endLine=101 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/test/java/org/elasticsearch/common/network/NetworkAddressTests.java)
    public void testRoundTripV4() throws Exception {
        byte bytes[] = new byte[4];
        Random random = random();
        for (int i = 0; i < 10000; i++) {
            random.nextBytes(bytes);
            InetAddress expected = Inet4Address.getByAddress(bytes);
            String formatted = NetworkAddress.formatAddress(expected);
            InetAddress actual = InetAddress.getByName(formatted);
            assertEquals(expected, actual);
        }
    }

(startLine=104 endLine=114 srcPath=/root/NewExperiment/elasticsearchFilter/01769/core/src/test/java/org/elasticsearch/common/network/NetworkAddressTests.java)
    public void testRoundTripV6() throws Exception {
        byte bytes[] = new byte[16];
        Random random = random();
        for (int i = 0; i < 10000; i++) {
            random.nextBytes(bytes);
            InetAddress expected = Inet6Address.getByAddress(bytes);
            String formatted = NetworkAddress.formatAddress(expected);
            InetAddress actual = InetAddress.getByName(formatted);
            assertEquals(expected, actual);
        }
    }

commonMethod: 
(startLine=73 endLine=90 srcPath=/root/NewExperiment/elasticsearchFilter/01770/core/src/test/java/org/elasticsearch/common/network/NetworkAddressTests.java)
    /**
     * Round trip test code for both IPv4 and IPv6. {@link InetAddress} contains the {@code getByAddress} and
     * {@code getbyName} methods for both IPv4 and IPv6, unless you also specify a {@code scopeid}, which this does not
     * test.
     *
     * @param bytes 4 (32-bit for IPv4) or 16 bytes (128-bit for IPv6)
     * @throws Exception if any error occurs while interacting with the network address
     */
    private void roundTrip(byte[] bytes) throws Exception {
        Random random = random();
        for (int i = 0; i < 10000; i++) {
            random.nextBytes(bytes);
            InetAddress expected = InetAddress.getByAddress(bytes);
            String formatted = NetworkAddress.format(expected);
            InetAddress actual = InetAddress.getByName(formatted);
            assertEquals(expected, actual);
        }
    }


, Instance #
frags: 
(startLine=86 endLine=92 srcPath=/root/NewExperiment/elasticsearchFilter/01771/core/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java)
    public void testAutoCreationPatternEnabled() {
        Settings settings = Settings.builder().put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(), randomFrom("+index*", "index*")).build();
        AutoCreateIndex autoCreateIndex = new AutoCreateIndex(settings, new IndexNameExpressionResolver(settings));
        ClusterState clusterState = ClusterState.builder(new ClusterName("test")).metaData(MetaData.builder()).build();
        assertThat(autoCreateIndex.shouldAutoCreate("index" + randomAsciiOfLengthBetween(1, 5), clusterState), equalTo(true));
        assertThat(autoCreateIndex.shouldAutoCreate("does_not_match" + randomAsciiOfLengthBetween(1, 5), clusterState), equalTo(false));
    }

(startLine=94 endLine=101 srcPath=/root/NewExperiment/elasticsearchFilter/01771/core/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java)
    public void testAutoCreationPatternDisabled() {
        Settings settings = Settings.builder().put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(), "-index*").build();
        AutoCreateIndex autoCreateIndex = new AutoCreateIndex(settings, new IndexNameExpressionResolver(settings));
        ClusterState clusterState = ClusterState.builder(new ClusterName("test")).metaData(MetaData.builder()).build();
        assertThat(autoCreateIndex.shouldAutoCreate("index" + randomAsciiOfLengthBetween(1, 5), clusterState), equalTo(false));
        //default is false when patterns are specified
        assertThat(autoCreateIndex.shouldAutoCreate("does_not_match" + randomAsciiOfLengthBetween(1, 5), clusterState), equalTo(false));
    }

(startLine=122 endLine=129 srcPath=/root/NewExperiment/elasticsearchFilter/01771/core/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java)
    public void testAutoCreationMultipleIndexNames() {
        Settings settings = Settings.builder().put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(), "test1,test2").build();
        AutoCreateIndex autoCreateIndex = new AutoCreateIndex(settings, new IndexNameExpressionResolver(settings));
        ClusterState clusterState = ClusterState.builder(new ClusterName("test")).metaData(MetaData.builder()).build();
        assertThat(autoCreateIndex.shouldAutoCreate("test1", clusterState), equalTo(true));
        assertThat(autoCreateIndex.shouldAutoCreate("test2", clusterState), equalTo(true));
        assertThat(autoCreateIndex.shouldAutoCreate("does_not_match" + randomAsciiOfLengthBetween(1, 5), clusterState), equalTo(false));
    }

(startLine=131 endLine=138 srcPath=/root/NewExperiment/elasticsearchFilter/01771/core/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java)
    public void testAutoCreationConflictingPatternsFirstWins() {
        Settings settings = Settings.builder().put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(), "+test1,-test1,-test2,+test2").build();
        AutoCreateIndex autoCreateIndex = new AutoCreateIndex(settings, new IndexNameExpressionResolver(settings));
        ClusterState clusterState = ClusterState.builder(new ClusterName("test")).metaData(MetaData.builder()).build();
        assertThat(autoCreateIndex.shouldAutoCreate("test1", clusterState), equalTo(true));
        assertThat(autoCreateIndex.shouldAutoCreate("test2", clusterState), equalTo(false));
        assertThat(autoCreateIndex.shouldAutoCreate("does_not_match" + randomAsciiOfLengthBetween(1, 5), clusterState), equalTo(false));
    }

commonMethod: 
(startLine=184 endLine=187 srcPath=/root/NewExperiment/elasticsearchFilter/01772/core/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java)
    private AutoCreateIndex newAutoCreateIndex(Settings settings) {
        return new AutoCreateIndex(settings, new ClusterSettings(settings,
                ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), new IndexNameExpressionResolver(settings));
    }


, Instance #
frags: 
(startLine=103 endLine=110 srcPath=/root/NewExperiment/elasticsearchFilter/01771/core/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java)
    public void testAutoCreationMultiplePatternsWithWildcards() {
        Settings settings = Settings.builder().put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(), randomFrom("+test*,-index*", "test*,-index*")).build();
        AutoCreateIndex autoCreateIndex = new AutoCreateIndex(settings, new IndexNameExpressionResolver(settings));
        ClusterState clusterState = ClusterState.builder(new ClusterName("test")).metaData(MetaData.builder()).build();
        assertThat(autoCreateIndex.shouldAutoCreate("index" + randomAsciiOfLengthBetween(1, 5), clusterState), equalTo(false));
        assertThat(autoCreateIndex.shouldAutoCreate("test" + randomAsciiOfLengthBetween(1, 5), clusterState), equalTo(true));
        assertThat(autoCreateIndex.shouldAutoCreate("does_not_match" + randomAsciiOfLengthBetween(1, 5), clusterState), equalTo(false));
    }

(startLine=112 endLine=120 srcPath=/root/NewExperiment/elasticsearchFilter/01771/core/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java)
    public void testAutoCreationMultiplePatternsNoWildcards() {
        Settings settings = Settings.builder().put(AutoCreateIndex.AUTO_CREATE_INDEX_SETTING.getKey(), "+test1,-index1").build();
        AutoCreateIndex autoCreateIndex = new AutoCreateIndex(settings, new IndexNameExpressionResolver(settings));
        ClusterState clusterState = ClusterState.builder(new ClusterName("test")).metaData(MetaData.builder()).build();
        assertThat(autoCreateIndex.shouldAutoCreate("test1", clusterState), equalTo(true));
        assertThat(autoCreateIndex.shouldAutoCreate("index" + randomAsciiOfLengthBetween(1, 5), clusterState), equalTo(false));
        assertThat(autoCreateIndex.shouldAutoCreate("test" + randomAsciiOfLengthBetween(2, 5), clusterState), equalTo(false));
        assertThat(autoCreateIndex.shouldAutoCreate("does_not_match" + randomAsciiOfLengthBetween(1, 5), clusterState), equalTo(false));
    }

commonMethod: 
(startLine=184 endLine=187 srcPath=/root/NewExperiment/elasticsearchFilter/01772/core/src/test/java/org/elasticsearch/action/support/AutoCreateIndexTests.java)
    private AutoCreateIndex newAutoCreateIndex(Settings settings) {
        return new AutoCreateIndex(settings, new ClusterSettings(settings,
                ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), new IndexNameExpressionResolver(settings));
    }


, Instance #
frags: 
(startLine=1448 endLine=1463 srcPath=/root/NewExperiment/elasticsearchFilter/01771/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
            {
            _localctx = new BinaryContext(new ExpressionContext(_parentctx, _parentState));
            pushNewRecursionContext(_localctx, _startState, RULE_expression);
            setState(209);
            if (!(precpred(_ctx, 10))) throw new FailedPredicateException(this, "precpred(_ctx, 10)");
            setState(210);
            _la = _input.LA(1);
            if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LSH) | (1L << RSH) | (1L << USH))) != 0)) ) {
            _errHandler.recoverInline(this);
            } else {
              consume();
            }
            setState(211);
            expression(11);
             ((BinaryContext)_localctx).s =  false; 
            }

(startLine=1412 endLine=1427 srcPath=/root/NewExperiment/elasticsearchFilter/01771/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
            {
            _localctx = new BinaryContext(new ExpressionContext(_parentctx, _parentState));
            pushNewRecursionContext(_localctx, _startState, RULE_expression);
            setState(199);
            if (!(precpred(_ctx, 12))) throw new FailedPredicateException(this, "precpred(_ctx, 12)");
            setState(200);
            _la = _input.LA(1);
            if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << MUL) | (1L << DIV) | (1L << REM))) != 0)) ) {
            _errHandler.recoverInline(this);
            } else {
              consume();
            }
            setState(201);
            expression(13);
             ((BinaryContext)_localctx).s =  false; 
            }

commonMethod: 
(startLine=1280 endLine=1318 srcPath=/root/NewExperiment/elasticsearchFilter/01772/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
  public final DecltypeContext decltype() throws RecognitionException {
    DecltypeContext _localctx = new DecltypeContext(_ctx, getState());
    enterRule(_localctx, 20, RULE_decltype);
    try {
      int _alt;
      enterOuterAlt(_localctx, 1);
      {
      setState(217);
      match(TYPE);
      setState(222);
      _errHandler.sync(this);
      _alt = getInterpreter().adaptivePredict(_input,16,_ctx);
      while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
        if ( _alt==1 ) {
          {
          {
          setState(218);
          match(LBRACE);
          setState(219);
          match(RBRACE);
          }
          } 
        }
        setState(224);
        _errHandler.sync(this);
        _alt = getInterpreter().adaptivePredict(_input,16,_ctx);
      }
      }
    }
    catch (RecognitionException re) {
      _localctx.exception = re;
      _errHandler.reportError(this, re);
      _errHandler.recover(this, re);
    }
    finally {
      exitRule();
    }
    return _localctx;
  }


, Instance #
frags: 
(startLine=1466 endLine=1481 srcPath=/root/NewExperiment/elasticsearchFilter/01771/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
            {
            _localctx = new CompContext(new ExpressionContext(_parentctx, _parentState));
            pushNewRecursionContext(_localctx, _startState, RULE_expression);
            setState(214);
            if (!(precpred(_ctx, 9))) throw new FailedPredicateException(this, "precpred(_ctx, 9)");
            setState(215);
            _la = _input.LA(1);
            if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << LT) | (1L << LTE) | (1L << GT) | (1L << GTE))) != 0)) ) {
            _errHandler.recoverInline(this);
            } else {
              consume();
            }
            setState(216);
            expression(10);
             ((CompContext)_localctx).s =  false; 
            }

(startLine=1484 endLine=1499 srcPath=/root/NewExperiment/elasticsearchFilter/01771/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
            {
            _localctx = new CompContext(new ExpressionContext(_parentctx, _parentState));
            pushNewRecursionContext(_localctx, _startState, RULE_expression);
            setState(219);
            if (!(precpred(_ctx, 8))) throw new FailedPredicateException(this, "precpred(_ctx, 8)");
            setState(220);
            _la = _input.LA(1);
            if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << EQ) | (1L << EQR) | (1L << NE) | (1L << NER))) != 0)) ) {
            _errHandler.recoverInline(this);
            } else {
              consume();
            }
            setState(221);
            expression(9);
             ((CompContext)_localctx).s =  false; 
            }

commonMethod: 
(startLine=1280 endLine=1318 srcPath=/root/NewExperiment/elasticsearchFilter/01772/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
  public final DecltypeContext decltype() throws RecognitionException {
    DecltypeContext _localctx = new DecltypeContext(_ctx, getState());
    enterRule(_localctx, 20, RULE_decltype);
    try {
      int _alt;
      enterOuterAlt(_localctx, 1);
      {
      setState(217);
      match(TYPE);
      setState(222);
      _errHandler.sync(this);
      _alt = getInterpreter().adaptivePredict(_input,16,_ctx);
      while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
        if ( _alt==1 ) {
          {
          {
          setState(218);
          match(LBRACE);
          setState(219);
          match(RBRACE);
          }
          } 
        }
        setState(224);
        _errHandler.sync(this);
        _alt = getInterpreter().adaptivePredict(_input,16,_ctx);
      }
      }
    }
    catch (RecognitionException re) {
      _localctx.exception = re;
      _errHandler.reportError(this, re);
      _errHandler.recover(this, re);
    }
    finally {
      exitRule();
    }
    return _localctx;
  }


, Instance #
frags: 
(startLine=1502 endLine=1512 srcPath=/root/NewExperiment/elasticsearchFilter/01771/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
            {
            _localctx = new BinaryContext(new ExpressionContext(_parentctx, _parentState));
            pushNewRecursionContext(_localctx, _startState, RULE_expression);
            setState(224);
            if (!(precpred(_ctx, 7))) throw new FailedPredicateException(this, "precpred(_ctx, 7)");
            setState(225);
            match(BWAND);
            setState(226);
            expression(8);
             ((BinaryContext)_localctx).s =  false; 
            }

(startLine=1515 endLine=1525 srcPath=/root/NewExperiment/elasticsearchFilter/01771/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
            {
            _localctx = new BinaryContext(new ExpressionContext(_parentctx, _parentState));
            pushNewRecursionContext(_localctx, _startState, RULE_expression);
            setState(229);
            if (!(precpred(_ctx, 6))) throw new FailedPredicateException(this, "precpred(_ctx, 6)");
            setState(230);
            match(XOR);
            setState(231);
            expression(7);
             ((BinaryContext)_localctx).s =  false; 
            }

(startLine=1528 endLine=1538 srcPath=/root/NewExperiment/elasticsearchFilter/01771/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
            {
            _localctx = new BinaryContext(new ExpressionContext(_parentctx, _parentState));
            pushNewRecursionContext(_localctx, _startState, RULE_expression);
            setState(234);
            if (!(precpred(_ctx, 5))) throw new FailedPredicateException(this, "precpred(_ctx, 5)");
            setState(235);
            match(BWOR);
            setState(236);
            expression(6);
             ((BinaryContext)_localctx).s =  false; 
            }

commonMethod: 
(startLine=1280 endLine=1318 srcPath=/root/NewExperiment/elasticsearchFilter/01772/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
  public final DecltypeContext decltype() throws RecognitionException {
    DecltypeContext _localctx = new DecltypeContext(_ctx, getState());
    enterRule(_localctx, 20, RULE_decltype);
    try {
      int _alt;
      enterOuterAlt(_localctx, 1);
      {
      setState(217);
      match(TYPE);
      setState(222);
      _errHandler.sync(this);
      _alt = getInterpreter().adaptivePredict(_input,16,_ctx);
      while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
        if ( _alt==1 ) {
          {
          {
          setState(218);
          match(LBRACE);
          setState(219);
          match(RBRACE);
          }
          } 
        }
        setState(224);
        _errHandler.sync(this);
        _alt = getInterpreter().adaptivePredict(_input,16,_ctx);
      }
      }
    }
    catch (RecognitionException re) {
      _localctx.exception = re;
      _errHandler.reportError(this, re);
      _errHandler.recover(this, re);
    }
    finally {
      exitRule();
    }
    return _localctx;
  }


, Instance #
frags: 
(startLine=1541 endLine=1551 srcPath=/root/NewExperiment/elasticsearchFilter/01771/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
            {
            _localctx = new BoolContext(new ExpressionContext(_parentctx, _parentState));
            pushNewRecursionContext(_localctx, _startState, RULE_expression);
            setState(239);
            if (!(precpred(_ctx, 4))) throw new FailedPredicateException(this, "precpred(_ctx, 4)");
            setState(240);
            match(BOOLAND);
            setState(241);
            expression(5);
             ((BoolContext)_localctx).s =  false; 
            }

(startLine=1554 endLine=1564 srcPath=/root/NewExperiment/elasticsearchFilter/01771/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
            {
            _localctx = new BoolContext(new ExpressionContext(_parentctx, _parentState));
            pushNewRecursionContext(_localctx, _startState, RULE_expression);
            setState(244);
            if (!(precpred(_ctx, 3))) throw new FailedPredicateException(this, "precpred(_ctx, 3)");
            setState(245);
            match(BOOLOR);
            setState(246);
            expression(4);
             ((BoolContext)_localctx).s =  false; 
            }

commonMethod: 
(startLine=1280 endLine=1318 srcPath=/root/NewExperiment/elasticsearchFilter/01772/modules/lang-painless/src/main/java/org/elasticsearch/painless/antlr/PainlessParser.java)
  public final DecltypeContext decltype() throws RecognitionException {
    DecltypeContext _localctx = new DecltypeContext(_ctx, getState());
    enterRule(_localctx, 20, RULE_decltype);
    try {
      int _alt;
      enterOuterAlt(_localctx, 1);
      {
      setState(217);
      match(TYPE);
      setState(222);
      _errHandler.sync(this);
      _alt = getInterpreter().adaptivePredict(_input,16,_ctx);
      while ( _alt!=2 && _alt!=org.antlr.v4.runtime.atn.ATN.INVALID_ALT_NUMBER ) {
        if ( _alt==1 ) {
          {
          {
          setState(218);
          match(LBRACE);
          setState(219);
          match(RBRACE);
          }
          } 
        }
        setState(224);
        _errHandler.sync(this);
        _alt = getInterpreter().adaptivePredict(_input,16,_ctx);
      }
      }
    }
    catch (RecognitionException re) {
      _localctx.exception = re;
      _errHandler.reportError(this, re);
      _errHandler.recover(this, re);
    }
    finally {
      exitRule();
    }
    return _localctx;
  }


, Instance #
frags: 
(startLine=46 endLine=86 srcPath=/root/NewExperiment/elasticsearchFilter/01771/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SDo.java)
    void analyze(Variables variables) {
        variables.incrementScope();

        if (block == null) {
            throw createError(new IllegalArgumentException("Extraneous do while loop."));
        }

        block.beginLoop = true;
        block.inLoop = true;

        block.analyze(variables);

        if (block.loopEscape && !block.anyContinue) {
            throw createError(new IllegalArgumentException("Extraneous do while loop."));
        }

        condition.expected = Definition.BOOLEAN_TYPE;
        condition.analyze(variables);
        condition = condition.cast(variables);

        if (condition.constant != null) {
            final boolean continuous = (boolean)condition.constant;

            if (!continuous) {
                throw createError(new IllegalArgumentException("Extraneous do while loop."));
            }

            if (!block.anyBreak) {
                methodEscape = true;
                allEscape = true;
            }
        }

        statementCount = 1;

        if (maxLoopCounter > 0) {
            loopCounterSlot = variables.getVariable(location, "#loop").slot;
        }

        variables.decrementScope();
    }

(startLine=46 endLine=92 srcPath=/root/NewExperiment/elasticsearchFilter/01771/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SWhile.java)
    void analyze(Variables variables) {
        variables.incrementScope();

        condition.expected = Definition.BOOLEAN_TYPE;
        condition.analyze(variables);
        condition = condition.cast(variables);

        boolean continuous = false;

        if (condition.constant != null) {
            continuous = (boolean)condition.constant;

            if (!continuous) {
                throw createError(new IllegalArgumentException("Extraneous while loop."));
            }

            if (block == null) {
                throw createError(new IllegalArgumentException("While loop has no escape."));
            }
        }

        if (block != null) {
            block.beginLoop = true;
            block.inLoop = true;

            block.analyze(variables);

            if (block.loopEscape && !block.anyContinue) {
                throw createError(new IllegalArgumentException("Extraneous while loop."));
            }

            if (continuous && !block.anyBreak) {
                methodEscape = true;
                allEscape = true;
            }

            block.statementCount = Math.max(1, block.statementCount);
        }

        statementCount = 1;

        if (maxLoopCounter > 0) {
            loopCounterSlot = variables.getVariable(location, "#loop").slot;
        }

        variables.decrementScope();
    }

commonMethod: 
(startLine=44 endLine=49 srcPath=/root/NewExperiment/elasticsearchFilter/01772/modules/lang-painless/src/main/java/org/elasticsearch/painless/node/SBlock.java)
    @Override
    void extractVariables(Set<String> variables) {
        for (AStatement statement : statements) {
            statement.extractVariables(variables);
        }
    }


]