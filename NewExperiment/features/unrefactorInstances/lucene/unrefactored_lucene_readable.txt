[<(startLine=108 endLine=120 srcPath=/home/sonia/NewExperiment/luceneFilter/01846/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator.java)
          if (matchingDocs.totalHits < numSegOrds/10) {
            // Remap every ord to global ord as we iterate:
            int doc = 0;
            while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {
              segValues.setDocument(doc);
              int term = (int) segValues.nextOrd();
              while (term != SortedSetDocValues.NO_MORE_ORDS) {
                counts[(int) ordinalMap.getGlobalOrd(segOrd, term)]++;
                term = (int) segValues.nextOrd();
              }
              ++doc;
            }
          } else {
,
(startLine=143 endLine=157 srcPath=/home/sonia/NewExperiment/luceneFilter/01846/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesAccumulator.java)
        } else {
          // No ord mapping (e.g., single segment index):
          // just aggregate directly into counts:

          int doc = 0;
          while (doc < maxDoc && (doc = matchingDocs.bits.nextSetBit(doc)) != -1) {
            segValues.setDocument(doc);
            int term = (int) segValues.nextOrd();
            while (term != SortedSetDocValues.NO_MORE_ORDS) {
              counts[term]++;
              term = (int) segValues.nextOrd();
            }
            ++doc;
          }
        }
,
>
, <(startLine=575 endLine=589 srcPath=/home/sonia/NewExperiment/luceneFilter/00300/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMFeedImplTest.java)
    public void testSetExtensionFactory() {
        QName name = new QName(TEST_LOCAL_NAME);
        try {
            this.impl.getChildParser(name);
            fail("no child hander for this qname");
        } catch (GDataParseException e) {
            // 
        }

        this.impl.setExtensionFactory(new TestExtendsionFactory());

        AtomParser childParser = this.impl.getChildParser(name);
        assertTrue(childParser instanceof TestExtension);

    }
,
(startLine=527 endLine=541 srcPath=/home/sonia/NewExperiment/luceneFilter/00300/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMEntryImplTest.java)
    public void testSetExtensionFactory() {
        QName name = new QName(TEST_LOCAL_NAME);
        try {
            this.impl.getChildParser(name);
            fail("no child hander for this qname");
        } catch (GDataParseException e) {
            // 
        }

        this.impl.setExtensionFactory(new TestExtendsionFactory());

        AtomParser childParser = this.impl.getChildParser(name);
        assertTrue(childParser instanceof TestExtension);

    }
,
>
, <(startLine=246 endLine=263 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/test/org/apache/lucene/search/spans/TestBasics.java)
  public void testSpanFirst() throws Exception {
    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "five"));
    SpanFirstQuery query = new SpanFirstQuery(term1, 1);

    checkHits(query, new int[]
      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513,
       514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527,
       528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541,
       542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555,
       556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569,
       570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583,
       584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
       598, 599});

    assertTrue(searcher.explain(query, 5).getValue() > 0.0f);
    assertTrue(searcher.explain(query, 599).getValue() > 0.0f);

  }
,
(startLine=245 endLine=262 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/test/org/apache/lucene/search/spans/TestBasics.java)
  public void testSpanFirst() throws Exception {
    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "five"));
    SpanFirstQuery query = new SpanFirstQuery(term1, 1);

    checkHits(query, new int[]
      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513,
       514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527,
       528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541,
       542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555,
       556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569,
       570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583,
       584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
       598, 599});

    assertTrue(searcher.explain(query, 5).getValue() > 0.0f);
    assertTrue(searcher.explain(query, 599).getValue() > 0.0f);

  }
,
>
, <(startLine=114 endLine=119 srcPath=/home/sonia/NewExperiment/luceneFilter/00701/lucene/src/test/org/apache/lucene/search/spans/TestBasics.java)
  public void testBoolean2() throws Exception {
    BooleanQuery query = new BooleanQuery();
    query.add(new TermQuery(new Term("field", "sevento")), BooleanClause.Occur.MUST);
    query.add(new TermQuery(new Term("field", "sevenly")), BooleanClause.Occur.MUST);
    checkHits(query, new int[] {});
  }
,
(startLine=113 endLine=118 srcPath=/home/sonia/NewExperiment/luceneFilter/00701/lucene/backwards/src/test/org/apache/lucene/search/spans/TestBasics.java)
  public void testBoolean2() throws Exception {
    BooleanQuery query = new BooleanQuery();
    query.add(new TermQuery(new Term("field", "sevento")), BooleanClause.Occur.MUST);
    query.add(new TermQuery(new Term("field", "sevenly")), BooleanClause.Occur.MUST);
    checkHits(query, new int[] {});
  }
,
>
, <(startLine=260 endLine=353 srcPath=/home/sonia/NewExperiment/luceneFilter/00291/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMSourceImplTest.java)
    public void testProcessEndElement() {
        this.impl.addAuthor(new GOMAuthorImpl());
        this.impl.setId(new GOMIdImpl());
        this.impl.setUpdated(new GOMUpdatedImpl());
        this.impl.setTitle(new GOMTitleImpl());

        this.impl.processEndElement();
        {
            // author missing
            this.impl.getAuthors().clear();
            try {
                this.impl.processEndElement();
                fail("missing elements");
            } catch (GDataParseException e) {
                // 
            }
            this.impl.addAuthor(new GOMAuthorImpl());
        }

        {
            // id missing
            this.impl.setId(null);
            try {
                this.impl.processEndElement();
                fail("missing elements");
            } catch (GDataParseException e) {
                // 
            }
            this.impl.setId(new GOMIdImpl());
        }

        {
            // title missing
            this.impl.setTitle(null);
            try {
                this.impl.processEndElement();
                fail("missing elements");
            } catch (GDataParseException e) {
                // 
            }
            this.impl.setTitle(new GOMTitleImpl());
        }
        {
            // updated missing
            this.impl.setUpdated(null);
            try {
                this.impl.processEndElement();
                fail("missing elements");
            } catch (GDataParseException e) {
                // 
            }
            this.impl.setUpdated(new GOMUpdatedImpl());
        }

        /*
         * atom:feed elements MUST NOT contain more than one atom:link element
         * with a rel attribute value of "alternate" that has the same
         * combination of type and hreflang attribute values.
         */

        {
            // two identical alternate links missing
            GOMLink link = new GOMLinkImpl();
            link.setRel("alternate");
            link.setHrefLang("http://www.apache.org");
            link.setType("text/html");
            this.impl.addLink(link);
            // one is allowed
            this.impl.processEndElement();
            // add a second link
            link = new GOMLinkImpl();
            this.impl.addLink(link);
            link.setRel("next");
            link.setHrefLang("http://www.apache.org");
            link.setType("text/html");
            // one is alternate the other is next
            this.impl.processEndElement();

            // a second "identical" alternate link
            link = new GOMLinkImpl();
            this.impl.addLink(link);
            link.setRel("alternate");
            link.setHrefLang("http://www.apache.org");
            link.setType("text/html");
            try {
                this.impl.processEndElement();
                fail("missing elements");
            } catch (GDataParseException e) {
                // 
            }
            this.impl.setUpdated(new GOMUpdatedImpl());
        }

    }
,
(startLine=301 endLine=394 srcPath=/home/sonia/NewExperiment/luceneFilter/00291/contrib/gdata-server/src/gom/src/test/org/apache/lucene/gdata/gom/core/GOMFeedImplTest.java)
    public void testProcessEndElement() {
        this.impl.addAuthor(new GOMAuthorImpl());
        this.impl.setId(new GOMIdImpl());
        this.impl.setUpdated(new GOMUpdatedImpl());
        this.impl.setTitle(new GOMTitleImpl());

        this.impl.processEndElement();
        {
            // author missing
            this.impl.getAuthors().clear();
            try {
                this.impl.processEndElement();
                fail("missing elements");
            } catch (GDataParseException e) {
                // 
            }
            this.impl.addAuthor(new GOMAuthorImpl());
        }

        {
            // id missing
            this.impl.setId(null);
            try {
                this.impl.processEndElement();
                fail("missing elements");
            } catch (GDataParseException e) {
                // 
            }
            this.impl.setId(new GOMIdImpl());
        }

        {
            // title missing
            this.impl.setTitle(null);
            try {
                this.impl.processEndElement();
                fail("missing elements");
            } catch (GDataParseException e) {
                // 
            }
            this.impl.setTitle(new GOMTitleImpl());
        }
        {
            // updated missing
            this.impl.setUpdated(null);
            try {
                this.impl.processEndElement();
                fail("missing elements");
            } catch (GDataParseException e) {
                // 
            }
            this.impl.setUpdated(new GOMUpdatedImpl());
        }

        /*
         * atom:feed elements MUST NOT contain more than one atom:link element
         * with a rel attribute value of "alternate" that has the same
         * combination of type and hreflang attribute values.
         */

        {
            // two identical alternate links missing
            GOMLink link = new GOMLinkImpl();
            link.setRel("alternate");
            link.setHrefLang("http://www.apache.org");
            link.setType("text/html");
            this.impl.addLink(link);
            // one is allowed
            this.impl.processEndElement();
            // add a second link
            link = new GOMLinkImpl();
            this.impl.addLink(link);
            link.setRel("next");
            link.setHrefLang("http://www.apache.org");
            link.setType("text/html");
            // one is alternate the other is next
            this.impl.processEndElement();

            // a second "identical" alternate link
            link = new GOMLinkImpl();
            this.impl.addLink(link);
            link.setRel("alternate");
            link.setHrefLang("http://www.apache.org");
            link.setType("text/html");
            try {
                this.impl.processEndElement();
                fail("missing elements");
            } catch (GDataParseException e) {
                // 
            }
            this.impl.setUpdated(new GOMUpdatedImpl());
        }

    }
,
>
, <(startLine=586 endLine=601 srcPath=/home/sonia/NewExperiment/luceneFilter/00280/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
      {
        lst = new ArrayList();
        Token t;
        t = new Token("hi",0,2);
        lst.add(t);
        t = new Token("hispeed",0,8);
        lst.add(t);
        t = new Token("speed",3,8);
        t.setPositionIncrement(0);
        lst.add(t);
        t = new Token("10",8,10);
        lst.add(t);
        t = new Token("foo",11,14);
        lst.add(t);
        iter = lst.iterator();
      }
,
(startLine=614 endLine=629 srcPath=/home/sonia/NewExperiment/luceneFilter/00280/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
      {
        lst = new ArrayList();
        Token t;
        t = new Token("hispeed",0,8);
        lst.add(t);
        t = new Token("hi",0,2);
        t.setPositionIncrement(0);
        lst.add(t);
        t = new Token("speed",3,8);
        lst.add(t);
        t = new Token("10",8,10);
        lst.add(t);
        t = new Token("foo",11,14);
        lst.add(t);
        iter = lst.iterator();
      }
,
>
, <(startLine=614 endLine=652 srcPath=/home/sonia/NewExperiment/luceneFilter/00668/lucene/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java)
  public void testFarsi() throws Exception {

    /* build an index */
    RAMDirectory farsiIndex = new RAMDirectory();
    IndexWriter writer = new IndexWriter(farsiIndex, new IndexWriterConfig(
        TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)));
    Document doc = new Document();
    doc.add(new Field("content", "\u0633\u0627\u0628", Field.Store.YES,
        Field.Index.NOT_ANALYZED));
    doc
        .add(new Field("body", "body", Field.Store.YES,
            Field.Index.NOT_ANALYZED));
    writer.addDocument(doc);

    writer.optimize();
    writer.close();

    IndexReader reader = IndexReader.open(farsiIndex, true);
    IndexSearcher search = new IndexSearcher(reader);

    // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
    // RuleBasedCollator. However, the Arabic Locale seems to order the Farsi
    // characters properly.
    Collator c = Collator.getInstance(new Locale("ar"));

    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
    // orders the U+0698 character before the U+0633 character, so the single
    // index Term below should NOT be returned by a ConstantScoreRangeQuery
    // with a Farsi Collator (or an Arabic one for the case when Farsi is
    // not supported).
    ScoreDoc[] result = search.search(csrq("content", "\u062F", "\u0698", T, T,
        c), null, 1000).scoreDocs;
    assertEquals("The index Term should not be included.", 0, result.length);

    result = search.search(csrq("content", "\u0633", "\u0638", T, T, c), null,
        1000).scoreDocs;
    assertEquals("The index Term should be included.", 1, result.length);
    search.close();
  }
,
(startLine=654 endLine=690 srcPath=/home/sonia/NewExperiment/luceneFilter/00668/lucene/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java)
  public void testDanish() throws Exception {

    /* build an index */
    RAMDirectory danishIndex = new RAMDirectory();
    IndexWriter writer = new IndexWriter(danishIndex, new IndexWriterConfig(
        TEST_VERSION_CURRENT, new SimpleAnalyzer(TEST_VERSION_CURRENT)));

    // Danish collation orders the words below in the given order
    // (example taken from TestSort.testInternationalSort() ).
    String[] words = { "H\u00D8T", "H\u00C5T", "MAND" };
    for (int docnum = 0 ; docnum < words.length ; ++docnum) {   
      Document doc = new Document();
      doc.add(new Field("content", words[docnum], 
                        Field.Store.YES, Field.Index.NOT_ANALYZED));
      doc.add(new Field("body", "body",
                        Field.Store.YES, Field.Index.NOT_ANALYZED));
      writer.addDocument(doc);
    }
    writer.optimize();
    writer.close();

    IndexReader reader = IndexReader.open(danishIndex, true);
    IndexSearcher search = new IndexSearcher(reader);

    Collator c = Collator.getInstance(new Locale("da", "dk"));

    // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
    // but Danish collation does.
    ScoreDoc[] result = search.search
      (csrq("content", "H\u00D8T", "MAND", F, F, c), null, 1000).scoreDocs;
    assertEquals("The index Term should be included.", 1, result.length);

    result = search.search
      (csrq("content", "H\u00C5T", "MAND", F, F, c), null, 1000).scoreDocs;
    assertEquals("The index Term should not be included.", 0, result.length);
    search.close();
  }
,
(startLine=339 endLine=377 srcPath=/home/sonia/NewExperiment/luceneFilter/00668/lucene/src/test/org/apache/lucene/search/TestTermRangeFilter.java)
    public void testFarsi() throws Exception {
            
        /* build an index */
      RAMDirectory farsiIndex = new RAMDirectory();
      IndexWriter writer = new IndexWriter(farsiIndex, new IndexWriterConfig(
          TEST_VERSION_CURRENT, new SimpleAnalyzer(
              TEST_VERSION_CURRENT)));
        Document doc = new Document();
        doc.add(new Field("content","\u0633\u0627\u0628", 
                          Field.Store.YES, Field.Index.NOT_ANALYZED));
        doc.add(new Field("body", "body",
                          Field.Store.YES, Field.Index.NOT_ANALYZED));
        writer.addDocument(doc);
            
        writer.optimize();
        writer.close();

        IndexReader reader = IndexReader.open(farsiIndex, true);
        IndexSearcher search = new IndexSearcher(reader);
        Query q = new TermQuery(new Term("body","body"));

        // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
        // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
        // characters properly.
        Collator collator = Collator.getInstance(new Locale("ar"));
        
        // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
        // orders the U+0698 character before the U+0633 character, so the single
        // index Term below should NOT be returned by a TermRangeFilter with a Farsi
        // Collator (or an Arabic one for the case when Farsi is not supported).
        int numHits = search.search
            (q, new TermRangeFilter("content", "\u062F", "\u0698", T, T, collator), 1000).totalHits;
        assertEquals("The index Term should not be included.", 0, numHits);

        numHits = search.search
            (q, new TermRangeFilter("content", "\u0633", "\u0638", T, T, collator), 1000).totalHits;
        assertEquals("The index Term should be included.", 1, numHits);
        search.close();
    }
,
(startLine=379 endLine=417 srcPath=/home/sonia/NewExperiment/luceneFilter/00668/lucene/src/test/org/apache/lucene/search/TestTermRangeFilter.java)
    public void testDanish() throws Exception {
            
        /* build an index */
        RAMDirectory danishIndex = new RAMDirectory();
        IndexWriter writer = new IndexWriter(danishIndex, new IndexWriterConfig(
            TEST_VERSION_CURRENT, new SimpleAnalyzer(
                TEST_VERSION_CURRENT)));
        // Danish collation orders the words below in the given order
        // (example taken from TestSort.testInternationalSort() ).
        String[] words = { "H\u00D8T", "H\u00C5T", "MAND" };
        for (int docnum = 0 ; docnum < words.length ; ++docnum) {   
            Document doc = new Document();
            doc.add(new Field("content", words[docnum], 
                              Field.Store.YES, Field.Index.NOT_ANALYZED));
            doc.add(new Field("body", "body",
                              Field.Store.YES, Field.Index.NOT_ANALYZED));
            writer.addDocument(doc);
        }
        writer.optimize();
        writer.close();

        IndexReader reader = IndexReader.open(danishIndex, true);
        IndexSearcher search = new IndexSearcher(reader);
        Query q = new TermQuery(new Term("body","body"));

        Collator collator = Collator.getInstance(new Locale("da", "dk"));

        // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
        // but Danish collation does.
        int numHits = search.search
            (q, new TermRangeFilter("content", "H\u00D8T", "MAND", F, F, collator), 1000).totalHits;
        assertEquals("The index Term should be included.", 1, numHits);

        numHits = search.search
            (q, new TermRangeFilter("content", "H\u00C5T", "MAND", F, F, collator), 1000).totalHits;
        assertEquals
            ("The index Term should not be included.", 0, numHits);
        search.close();
    }
,
(startLine=71 endLine=99 srcPath=/home/sonia/NewExperiment/luceneFilter/00668/lucene/src/test/org/apache/lucene/collation/CollationTestBase.java)
                                            String secondEnd) throws Exception {
    RAMDirectory ramDir = new RAMDirectory();
    IndexWriter writer = new IndexWriter(ramDir, new IndexWriterConfig(
        TEST_VERSION_CURRENT, analyzer));
    Document doc = new Document();
    doc.add(new Field("content", "\u0633\u0627\u0628", 
                      Field.Store.YES, Field.Index.ANALYZED));
    doc.add(new Field("body", "body",
                      Field.Store.YES, Field.Index.NOT_ANALYZED));
    writer.addDocument(doc);
    writer.close();
    IndexSearcher searcher = new IndexSearcher(ramDir, true);
    Query query = new TermQuery(new Term("body","body"));

    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
    // orders the U+0698 character before the U+0633 character, so the single
    // index Term below should NOT be returned by a TermRangeFilter with a Farsi
    // Collator (or an Arabic one for the case when Farsi searcher not
    // supported).
    ScoreDoc[] result = searcher.search
      (query, new TermRangeFilter("content", firstBeg, firstEnd, true, true), 1).scoreDocs;
    assertEquals("The index Term should not be included.", 0, result.length);

    result = searcher.search
      (query, new TermRangeFilter("content", secondBeg, secondEnd, true, true), 1).scoreDocs;
    assertEquals("The index Term should be included.", 1, result.length);

    searcher.close();
  }
,
(startLine=130 endLine=161 srcPath=/home/sonia/NewExperiment/luceneFilter/00668/lucene/src/test/org/apache/lucene/collation/CollationTestBase.java)
      String firstEnd, String secondBeg, String secondEnd) throws Exception {

    RAMDirectory farsiIndex = new RAMDirectory();
    IndexWriter writer = new IndexWriter(farsiIndex, new IndexWriterConfig(
        TEST_VERSION_CURRENT, analyzer));
    Document doc = new Document();
    doc.add(new Field("content", "\u0633\u0627\u0628", 
                      Field.Store.YES, Field.Index.ANALYZED));
    doc.add(new Field("body", "body",
                      Field.Store.YES, Field.Index.NOT_ANALYZED));
    writer.addDocument(doc);
    writer.close();

    IndexReader reader = IndexReader.open(farsiIndex, true);
    IndexSearcher search = new IndexSearcher(reader);
        
    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
    // orders the U+0698 character before the U+0633 character, so the single
    // index Term below should NOT be returned by a TermRangeQuery
    // with a Farsi Collator (or an Arabic one for the case when Farsi is 
    // not supported).
    Query csrq 
      = new TermRangeQuery("content", firstBeg, firstEnd, true, true);
    ScoreDoc[] result = search.search(csrq, null, 1000).scoreDocs;
    assertEquals("The index Term should not be included.", 0, result.length);

    csrq = new TermRangeQuery
      ("content", secondBeg, secondEnd, true, true);
    result = search.search(csrq, null, 1000).scoreDocs;
    assertEquals("The index Term should be included.", 1, result.length);
    search.close();
  }
,
(startLine=615 endLine=653 srcPath=/home/sonia/NewExperiment/luceneFilter/00668/lucene/backwards/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java)
  public void testFarsi() throws Exception {

    /* build an index */
    RAMDirectory farsiIndex = new RAMDirectory();
    IndexWriter writer = new IndexWriter(farsiIndex, new SimpleAnalyzer(), T,
        IndexWriter.MaxFieldLength.LIMITED);
    Document doc = new Document();
    doc.add(new Field("content", "\u0633\u0627\u0628", Field.Store.YES,
        Field.Index.NOT_ANALYZED));
    doc
        .add(new Field("body", "body", Field.Store.YES,
            Field.Index.NOT_ANALYZED));
    writer.addDocument(doc);

    writer.optimize();
    writer.close();

    IndexReader reader = IndexReader.open(farsiIndex, true);
    IndexSearcher search = new IndexSearcher(reader);

    // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
    // RuleBasedCollator. However, the Arabic Locale seems to order the Farsi
    // characters properly.
    Collator c = Collator.getInstance(new Locale("ar"));

    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
    // orders the U+0698 character before the U+0633 character, so the single
    // index Term below should NOT be returned by a ConstantScoreRangeQuery
    // with a Farsi Collator (or an Arabic one for the case when Farsi is
    // not supported).
    ScoreDoc[] result = search.search(csrq("content", "\u062F", "\u0698", T, T,
        c), null, 1000).scoreDocs;
    assertEquals("The index Term should not be included.", 0, result.length);

    result = search.search(csrq("content", "\u0633", "\u0638", T, T, c), null,
        1000).scoreDocs;
    assertEquals("The index Term should be included.", 1, result.length);
    search.close();
  }
,
(startLine=655 endLine=691 srcPath=/home/sonia/NewExperiment/luceneFilter/00668/lucene/backwards/src/test/org/apache/lucene/search/TestMultiTermConstantScore.java)
  public void testDanish() throws Exception {

    /* build an index */
    RAMDirectory danishIndex = new RAMDirectory();
    IndexWriter writer = new IndexWriter(danishIndex, new SimpleAnalyzer(), T,
                                         IndexWriter.MaxFieldLength.LIMITED);

    // Danish collation orders the words below in the given order
    // (example taken from TestSort.testInternationalSort() ).
    String[] words = { "H\u00D8T", "H\u00C5T", "MAND" };
    for (int docnum = 0 ; docnum < words.length ; ++docnum) {   
      Document doc = new Document();
      doc.add(new Field("content", words[docnum], 
                        Field.Store.YES, Field.Index.NOT_ANALYZED));
      doc.add(new Field("body", "body",
                        Field.Store.YES, Field.Index.NOT_ANALYZED));
      writer.addDocument(doc);
    }
    writer.optimize();
    writer.close();

    IndexReader reader = IndexReader.open(danishIndex, true);
    IndexSearcher search = new IndexSearcher(reader);

    Collator c = Collator.getInstance(new Locale("da", "dk"));

    // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
    // but Danish collation does.
    ScoreDoc[] result = search.search
      (csrq("content", "H\u00D8T", "MAND", F, F, c), null, 1000).scoreDocs;
    assertEquals("The index Term should be included.", 1, result.length);

    result = search.search
      (csrq("content", "H\u00C5T", "MAND", F, F, c), null, 1000).scoreDocs;
    assertEquals("The index Term should not be included.", 0, result.length);
    search.close();
  }
,
(startLine=338 endLine=375 srcPath=/home/sonia/NewExperiment/luceneFilter/00668/lucene/backwards/src/test/org/apache/lucene/search/TestTermRangeFilter.java)
    public void testFarsi() throws Exception {
            
        /* build an index */
        RAMDirectory farsiIndex = new RAMDirectory();
        IndexWriter writer = new IndexWriter(farsiIndex, new SimpleAnalyzer(), T, 
                                             IndexWriter.MaxFieldLength.LIMITED);
        Document doc = new Document();
        doc.add(new Field("content","\u0633\u0627\u0628", 
                          Field.Store.YES, Field.Index.NOT_ANALYZED));
        doc.add(new Field("body", "body",
                          Field.Store.YES, Field.Index.NOT_ANALYZED));
        writer.addDocument(doc);
            
        writer.optimize();
        writer.close();

        IndexReader reader = IndexReader.open(farsiIndex, true);
        IndexSearcher search = new IndexSearcher(reader);
        Query q = new TermQuery(new Term("body","body"));

        // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
        // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
        // characters properly.
        Collator collator = Collator.getInstance(new Locale("ar"));
        
        // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
        // orders the U+0698 character before the U+0633 character, so the single
        // index Term below should NOT be returned by a TermRangeFilter with a Farsi
        // Collator (or an Arabic one for the case when Farsi is not supported).
        int numHits = search.search
            (q, new TermRangeFilter("content", "\u062F", "\u0698", T, T, collator), 1000).totalHits;
        assertEquals("The index Term should not be included.", 0, numHits);

        numHits = search.search
            (q, new TermRangeFilter("content", "\u0633", "\u0638", T, T, collator), 1000).totalHits;
        assertEquals("The index Term should be included.", 1, numHits);
        search.close();
    }
,
(startLine=377 endLine=417 srcPath=/home/sonia/NewExperiment/luceneFilter/00668/lucene/backwards/src/test/org/apache/lucene/search/TestTermRangeFilter.java)
    public void testDanish() throws Exception {
            
        /* build an index */
        RAMDirectory danishIndex = new RAMDirectory();
        IndexWriter writer = new IndexWriter
            (danishIndex, new SimpleAnalyzer(), T, 
             IndexWriter.MaxFieldLength.LIMITED);
        // Danish collation orders the words below in the given order
        // (example taken from TestSort.testInternationalSort() ).
        String[] words = { "H\u00D8T", "H\u00C5T", "MAND" };
        for (int docnum = 0 ; docnum < words.length ; ++docnum) {   
            Document doc = new Document();
            doc.add(new Field("content", words[docnum], 
                              Field.Store.YES, Field.Index.NOT_ANALYZED));
            doc.add(new Field("body", "body",
                              Field.Store.YES, Field.Index.NOT_ANALYZED));
            writer.addDocument(doc);
        }
        writer.optimize();
        writer.close();

        IndexReader reader = IndexReader.open(danishIndex, true);
        IndexSearcher search = new IndexSearcher(reader);
        Query q = new TermQuery(new Term("body","body"));

        Collator collator = Collator.getInstance(new Locale("da", "dk"));
        Query query = new TermRangeQuery
            ("content", "H\u00D8T", "MAND", false, false, collator);

        // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
        // but Danish collation does.
        int numHits = search.search
            (q, new TermRangeFilter("content", "H\u00D8T", "MAND", F, F, collator), 1000).totalHits;
        assertEquals("The index Term should be included.", 1, numHits);

        numHits = search.search
            (q, new TermRangeFilter("content", "H\u00C5T", "MAND", F, F, collator), 1000).totalHits;
        assertEquals
            ("The index Term should not be included.", 0, numHits);
        search.close();
    }
,
>
, <(startLine=317 endLine=330 srcPath=/home/sonia/NewExperiment/luceneFilter/02390/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java)
      {
        final short[] values = new short[entry.count];
        for(int i=0;i<entry.count;i++) {
          values[i] = data.readShort();
        }
        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
        ret.numerics = new NumericDocValues() {
          @Override
          public long get(int idx) {
            return values[idx];
          }
        };
        return ret;
      }
,
(startLine=333 endLine=346 srcPath=/home/sonia/NewExperiment/luceneFilter/02390/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java)
      {
        final int[] values = new int[entry.count];
        for(int i=0;i<entry.count;i++) {
          values[i] = data.readInt();
        }
        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
        ret.numerics = new NumericDocValues() {
          @Override
          public long get(int idx) {
            return values[idx];
          }
        };
        return ret;
      }
,
(startLine=349 endLine=362 srcPath=/home/sonia/NewExperiment/luceneFilter/02390/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java)
      {
        final long[] values = new long[entry.count];
        for(int i=0;i<entry.count;i++) {
          values[i] = data.readLong();
        }
        ret.bytesUsed = RamUsageEstimator.sizeOf(values);
        ret.numerics = new NumericDocValues() {
          @Override
          public long get(int idx) {
            return values[idx];
          }
        };
        return ret;
      }
,
>
, <(startLine=42 endLine=54 srcPath=/home/sonia/NewExperiment/luceneFilter/00678/lucene/contrib/xml-query-parser/src/test/org/apache/lucene/xmlparser/builders/TestNumericRangeFilterBuilder.java)
    public void testGetFilterHandleNumericParseErrorStrict() throws Exception {
        NumericRangeFilterBuilder filterBuilder = new NumericRangeFilterBuilder();
        filterBuilder.setStrictMode(true);

        String xml = "<NumericRangeFilter fieldName='AGE' type='int' lowerTerm='-1' upperTerm='NaN'/>";
        Document doc = getDocumentFromString(xml);
        try {
            filterBuilder.getFilter(doc.getDocumentElement());
        } catch (ParserException e) {
            return;
        }
        fail("Expected to throw " + ParserException.class);
    }
,
(startLine=38 endLine=49 srcPath=/home/sonia/NewExperiment/luceneFilter/00678/lucene/contrib/xml-query-parser/src/test/org/apache/lucene/xmlparser/builders/TestNumericRangeQueryBuilder.java)
    public void testGetFilterHandleNumericParseErrorStrict() throws Exception {
        NumericRangeQueryBuilder filterBuilder = new NumericRangeQueryBuilder();

        String xml = "<NumericRangeQuery fieldName='AGE' type='int' lowerTerm='-1' upperTerm='NaN'/>";
        Document doc = getDocumentFromString(xml);
        try {
            filterBuilder.getQuery(doc.getDocumentElement());
        } catch (ParserException e) {
            return;
        }
        fail("Expected to throw " + ParserException.class);
    }
,
>
, <(startLine=59 endLine=64 srcPath=/home/sonia/NewExperiment/luceneFilter/02023/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestCustomFunctions.java)
  public void testNoArgMethod() throws Exception {
    Map<String,Method> functions = new HashMap<String,Method>();
    functions.put("foo", getClass().getMethod("zeroArgMethod"));
    Expression expr = JavascriptCompiler.compile("foo()", functions, getClass().getClassLoader());
    assertEquals(5, expr.evaluate(0, null), DELTA);
  }
,
(startLine=69 endLine=74 srcPath=/home/sonia/NewExperiment/luceneFilter/02023/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestCustomFunctions.java)
  public void testOneArgMethod() throws Exception {
    Map<String,Method> functions = new HashMap<String,Method>();
    functions.put("foo", getClass().getMethod("oneArgMethod", double.class));
    Expression expr = JavascriptCompiler.compile("foo(3)", functions, getClass().getClassLoader());
    assertEquals(6, expr.evaluate(0, null), DELTA);
  }
,
(startLine=265 endLine=271 srcPath=/home/sonia/NewExperiment/luceneFilter/02023/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestCustomFunctions.java)
  public void testNamespaces() throws Exception {
    Map<String, Method> functions = new HashMap<String, Method>();
    functions.put("foo.bar", getClass().getMethod("zeroArgMethod"));
    String source = "foo.bar()";
    Expression expr = JavascriptCompiler.compile(source, functions, getClass().getClassLoader());
    assertEquals(5, expr.evaluate(0, null), DELTA);
  }
,
>
, <(startLine=475 endLine=483 srcPath=/home/sonia/NewExperiment/luceneFilter/02295/solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java)
  private void handleReloadAction(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {
    log.info("Reloading Collection : " + req.getParamString());
    String name = req.getParams().required().get("name");
    
    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
        RELOAD.toLower(), "name", name);

    handleResponse(RELOAD.toLower(), m, rsp);
  }
,
(startLine=523 endLine=531 srcPath=/home/sonia/NewExperiment/luceneFilter/02295/solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java)
      SolrQueryResponse rsp) throws Exception {
    log.info("Delete alias action : " + req.getParamString());
    String name = req.getParams().required().get("name");
    
    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
        DELETEALIAS.toLower(), "name", name);
    
    handleResponse(DELETEALIAS.toLower(), m, rsp);
  }
,
(startLine=533 endLine=542 srcPath=/home/sonia/NewExperiment/luceneFilter/02295/solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.java)
  private void handleDeleteAction(SolrQueryRequest req, SolrQueryResponse rsp) throws KeeperException, InterruptedException {
    log.info("Deleting Collection : " + req.getParamString());
    
    String name = req.getParams().required().get("name");
    
    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION,
        DELETE.toLower(), "name", name);

    handleResponse(DELETE.toLower(), m, rsp);
  }
,
>
, <(startLine=222 endLine=298 srcPath=/home/sonia/NewExperiment/luceneFilter/00660/lucene/src/java/org/apache/lucene/index/LogMergePolicy.java)
      int maxNumSegments, Set<SegmentInfo> segmentsToOptimize) throws IOException {
    MergeSpecification spec;

    assert maxNumSegments > 0;

    if (!isOptimized(infos, maxNumSegments, segmentsToOptimize)) {

      // Find the newest (rightmost) segment that needs to
      // be optimized (other segments may have been flushed
      // since optimize started):
      int last = infos.size();
      while(last > 0) {
        final SegmentInfo info = infos.info(--last);
        if (segmentsToOptimize.contains(info)) {
          last++;
          break;
        }
      }

      if (last > 0) {

        spec = new MergeSpecification();

        // First, enroll all "full" merges (size
        // mergeFactor) to potentially be run concurrently:
        while (last - maxNumSegments + 1 >= mergeFactor) {
          spec.add(new OneMerge(infos.range(last-mergeFactor, last), useCompoundFile));
          last -= mergeFactor;
        }

        // Only if there are no full merges pending do we
        // add a final partial (< mergeFactor segments) merge:
        if (0 == spec.merges.size()) {
          if (maxNumSegments == 1) {

            // Since we must optimize down to 1 segment, the
            // choice is simple:
            if (last > 1 || !isOptimized(infos.info(0)))
              spec.add(new OneMerge(infos.range(0, last), useCompoundFile));
          } else if (last > maxNumSegments) {

            // Take care to pick a partial merge that is
            // least cost, but does not make the index too
            // lopsided.  If we always just picked the
            // partial tail then we could produce a highly
            // lopsided index over time:

            // We must merge this many segments to leave
            // maxNumSegments in the index (from when
            // optimize was first kicked off):
            final int finalMergeSize = last - maxNumSegments + 1;

            // Consider all possible starting points:
            long bestSize = 0;
            int bestStart = 0;

            for(int i=0;i<last-finalMergeSize+1;i++) {
              long sumSize = 0;
              for(int j=0;j<finalMergeSize;j++)
                sumSize += size(infos.info(j+i));
              if (i == 0 || (sumSize < 2*size(infos.info(i-1)) && sumSize < bestSize)) {
                bestStart = i;
                bestSize = sumSize;
              }
            }

            spec.add(new OneMerge(infos.range(bestStart, bestStart+finalMergeSize), useCompoundFile));
          }
        }
        
      } else
        spec = null;
    } else
      spec = null;

    return spec;
  }
,
(startLine=215 endLine=291 srcPath=/home/sonia/NewExperiment/luceneFilter/00660/lucene/backwards/src/java/org/apache/lucene/index/LogMergePolicy.java)
      int maxNumSegments, Set<SegmentInfo> segmentsToOptimize) throws IOException {
    MergeSpecification spec;

    assert maxNumSegments > 0;

    if (!isOptimized(infos, maxNumSegments, segmentsToOptimize)) {

      // Find the newest (rightmost) segment that needs to
      // be optimized (other segments may have been flushed
      // since optimize started):
      int last = infos.size();
      while(last > 0) {
        final SegmentInfo info = infos.info(--last);
        if (segmentsToOptimize.contains(info)) {
          last++;
          break;
        }
      }

      if (last > 0) {

        spec = new MergeSpecification();

        // First, enroll all "full" merges (size
        // mergeFactor) to potentially be run concurrently:
        while (last - maxNumSegments + 1 >= mergeFactor) {
          spec.add(new OneMerge(infos.range(last-mergeFactor, last), useCompoundFile));
          last -= mergeFactor;
        }

        // Only if there are no full merges pending do we
        // add a final partial (< mergeFactor segments) merge:
        if (0 == spec.merges.size()) {
          if (maxNumSegments == 1) {

            // Since we must optimize down to 1 segment, the
            // choice is simple:
            if (last > 1 || !isOptimized(infos.info(0)))
              spec.add(new OneMerge(infos.range(0, last), useCompoundFile));
          } else if (last > maxNumSegments) {

            // Take care to pick a partial merge that is
            // least cost, but does not make the index too
            // lopsided.  If we always just picked the
            // partial tail then we could produce a highly
            // lopsided index over time:

            // We must merge this many segments to leave
            // maxNumSegments in the index (from when
            // optimize was first kicked off):
            final int finalMergeSize = last - maxNumSegments + 1;

            // Consider all possible starting points:
            long bestSize = 0;
            int bestStart = 0;

            for(int i=0;i<last-finalMergeSize+1;i++) {
              long sumSize = 0;
              for(int j=0;j<finalMergeSize;j++)
                sumSize += size(infos.info(j+i));
              if (i == 0 || (sumSize < 2*size(infos.info(i-1)) && sumSize < bestSize)) {
                bestStart = i;
                bestSize = sumSize;
              }
            }

            spec.add(new OneMerge(infos.range(bestStart, bestStart+finalMergeSize), useCompoundFile));
          }
        }
        
      } else
        spec = null;
    } else
      spec = null;

    return spec;
  }
,
>
, <(startLine=59 endLine=73 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/contrib/queries/src/java/org/apache/lucene/search/BooleanFilter.java)
    if (shouldFilters != null) {
      for (int i = 0; i < shouldFilters.size(); i++) {
        if (res == null) {
          res = new OpenBitSetDISI(getDISI(shouldFilters, i, reader), reader.maxDoc());
        } else { 
          DocIdSet dis = shouldFilters.get(i).getDocIdSet(reader);
          if(dis instanceof OpenBitSet) {
            // optimized case for OpenBitSets
            res.or((OpenBitSet) dis);
          } else {
            res.inPlaceOr(getDISI(shouldFilters, i, reader));
          }
        }
      }
    }
,
(startLine=92 endLine=106 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/contrib/queries/src/java/org/apache/lucene/search/BooleanFilter.java)
    if (mustFilters!=null) {
      for (int i = 0; i < mustFilters.size(); i++) {
        if (res == null) {
          res = new OpenBitSetDISI(getDISI(mustFilters, i, reader), reader.maxDoc());
        } else {
          DocIdSet dis = mustFilters.get(i).getDocIdSet(reader);
          if(dis instanceof OpenBitSet) {
            // optimized case for OpenBitSets
            res.and((OpenBitSet) dis);
          } else {
            res.inPlaceAnd(getDISI(mustFilters, i, reader));
          }
        }
      }
    }
,
>
, <(startLine=199 endLine=213 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/src/java/org/apache/lucene/util/BitVector.java)
  private boolean isSparse() {
    // note: order of comparisons below set to favor smaller values (no binary range search.)
    // note: adding 4 because we start with ((int) -1) to indicate d-gaps format.
    // note: we write the d-gap for the byte number, and the byte (bits[i]) itself, therefore
    //       multiplying count by (8+8) or (8+16) or (8+24) etc.:
    //       - first 8 for writing bits[i] (1 byte vs. 1 bit), and 
    //       - second part for writing the byte-number d-gap as vint. 
    // note: factor is for read/write of byte-arrays being faster than vints.  
    int factor = 10;  
    if (bits.length < (1<< 7)) return factor * (4 + (8+ 8)*count()) < size();
    if (bits.length < (1<<14)) return factor * (4 + (8+16)*count()) < size();
    if (bits.length < (1<<21)) return factor * (4 + (8+24)*count()) < size();
    if (bits.length < (1<<28)) return factor * (4 + (8+32)*count()) < size();
    return                            factor * (4 + (8+40)*count()) < size();
  }
,
(startLine=186 endLine=200 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/backwards/src/java/org/apache/lucene/util/BitVector.java)
  private boolean isSparse() {
    // note: order of comparisons below set to favor smaller values (no binary range search.)
    // note: adding 4 because we start with ((int) -1) to indicate d-gaps format.
    // note: we write the d-gap for the byte number, and the byte (bits[i]) itself, therefore
    //       multiplying count by (8+8) or (8+16) or (8+24) etc.:
    //       - first 8 for writing bits[i] (1 byte vs. 1 bit), and 
    //       - second part for writing the byte-number d-gap as vint. 
    // note: factor is for read/write of byte-arrays being faster than vints.  
    int factor = 10;  
    if (bits.length < (1<< 7)) return factor * (4 + (8+ 8)*count()) < size();
    if (bits.length < (1<<14)) return factor * (4 + (8+16)*count()) < size();
    if (bits.length < (1<<21)) return factor * (4 + (8+24)*count()) < size();
    if (bits.length < (1<<28)) return factor * (4 + (8+32)*count()) < size();
    return                            factor * (4 + (8+40)*count()) < size();
  }
,
>
, <(startLine=75 endLine=84 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/test/org/apache/lucene/analysis/TestCharTokenizers.java)
  public void testMaxWordLength() throws IOException {
    StringBuilder builder = new StringBuilder();

    for (int i = 0; i < 255; i++) {
      builder.append("A");
    }
    LowerCaseTokenizer tokenizer = new LowerCaseTokenizer(
        TEST_VERSION_CURRENT, new StringReader(builder.toString() + builder.toString()));
    assertTokenStreamContents(tokenizer, new String[] {builder.toString().toLowerCase(), builder.toString().toLowerCase()});
  }
,
(startLine=89 endLine=99 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/test/org/apache/lucene/analysis/TestCharTokenizers.java)
  public void testMaxWordLengthWithSupplementary() throws IOException {
    StringBuilder builder = new StringBuilder();

    for (int i = 0; i < 254; i++) {
      builder.append("A");
    }
    builder.append("\ud801\udc1c");
    LowerCaseTokenizer tokenizer = new LowerCaseTokenizer(
        TEST_VERSION_CURRENT, new StringReader(builder.toString() + builder.toString()));
    assertTokenStreamContents(tokenizer, new String[] {builder.toString().toLowerCase(), builder.toString().toLowerCase()});
  }
,
>
, <(startLine=70 endLine=94 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/java/org/apache/lucene/search/function/ByteFieldSource.java)
  public DocValues getCachedFieldValues (FieldCache cache, String field, IndexReader reader) throws IOException {
    final byte[] arr = cache.getBytes(reader, field, parser);
    return new DocValues() {
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
      @Override
      public float floatVal(int doc) { 
        return arr[doc]; 
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#intVal(int) */
      @Override
      public  int intVal(int doc) { 
        return arr[doc]; 
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#toString(int) */
      @Override
      public String toString(int doc) { 
        return  description() + '=' + intVal(doc);  
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#getInnerArray() */
      @Override
      Object getInnerArray() {
        return arr;
      }
    };
  }
,
(startLine=71 endLine=96 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/java/org/apache/lucene/search/function/OrdFieldSource.java)
  public DocValues getValues(IndexReader reader) throws IOException {
    final int[] arr = FieldCache.DEFAULT.getStringIndex(reader, field).order;
    return new DocValues() {
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
      @Override
      public float floatVal(int doc) {
        return arr[doc];
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#strVal(int) */
      @Override
      public String strVal(int doc) {
        // the string value of the ordinal, not the string itself
        return Integer.toString(arr[doc]);
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#toString(int) */
      @Override
      public String toString(int doc) {
        return description() + '=' + intVal(doc);
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#getInnerArray() */
      @Override
      Object getInnerArray() {
        return arr;
      }
    };
  }
,
(startLine=70 endLine=94 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/java/org/apache/lucene/search/function/IntFieldSource.java)
  public DocValues getCachedFieldValues (FieldCache cache, String field, IndexReader reader) throws IOException {
    final int[] arr = cache.getInts(reader, field, parser);
    return new DocValues() {
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
      @Override
      public float floatVal(int doc) { 
        return arr[doc]; 
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#intVal(int) */
      @Override
      public  int intVal(int doc) { 
        return arr[doc]; 
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#toString(int) */
      @Override
      public String toString(int doc) { 
        return  description() + '=' + intVal(doc);  
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#getInnerArray() */
      @Override
      Object getInnerArray() {
        return arr;
      }
    };
  }
,
(startLine=70 endLine=94 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/java/org/apache/lucene/search/function/ShortFieldSource.java)
  public DocValues getCachedFieldValues (FieldCache cache, String field, IndexReader reader) throws IOException {
    final short[] arr = cache.getShorts(reader, field, parser);
    return new DocValues() {
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
      @Override
      public float floatVal(int doc) { 
        return arr[doc];
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#intVal(int) */
      @Override
      public  int intVal(int doc) { 
        return arr[doc]; 
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#toString(int) */
      @Override
      public String toString(int doc) { 
        return  description() + '=' + intVal(doc);  
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#getInnerArray() */
      @Override
      Object getInnerArray() {
        return arr;
      }
    };
  }
,
(startLine=76 endLine=100 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/java/org/apache/lucene/search/function/ShortFieldSource.java)
  public DocValues getCachedFieldValues (FieldCache cache, String field, IndexReader reader) throws IOException {
    final short[] arr = cache.getShorts(reader, field, parser);
    return new DocValues() {
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
      @Override
      public float floatVal(int doc) { 
        return (float) arr[doc];
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#intVal(int) */
      @Override
      public  int intVal(int doc) { 
        return arr[doc]; 
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#toString(int) */
      @Override
      public String toString(int doc) { 
        return  description() + '=' + intVal(doc);  
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#getInnerArray() */
      @Override
      Object getInnerArray() {
        return arr;
      }
    };
  }
,
(startLine=76 endLine=100 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/java/org/apache/lucene/search/function/ByteFieldSource.java)
  public DocValues getCachedFieldValues (FieldCache cache, String field, IndexReader reader) throws IOException {
    final byte[] arr = cache.getBytes(reader, field, parser);
    return new DocValues() {
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
      @Override
      public float floatVal(int doc) { 
        return (float) arr[doc]; 
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#intVal(int) */
      @Override
      public  int intVal(int doc) { 
        return arr[doc]; 
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#toString(int) */
      @Override
      public String toString(int doc) { 
        return  description() + '=' + intVal(doc);  
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#getInnerArray() */
      @Override
      Object getInnerArray() {
        return arr;
      }
    };
  }
,
(startLine=74 endLine=99 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/java/org/apache/lucene/search/function/OrdFieldSource.java)
  public DocValues getValues(IndexReader reader) throws IOException {
    final int[] arr = FieldCache.DEFAULT.getStringIndex(reader, field).order;
    return new DocValues() {
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
      @Override
      public float floatVal(int doc) {
        return (float)arr[doc];
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#strVal(int) */
      @Override
      public String strVal(int doc) {
        // the string value of the ordinal, not the string itself
        return Integer.toString(arr[doc]);
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#toString(int) */
      @Override
      public String toString(int doc) {
        return description() + '=' + intVal(doc);
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#getInnerArray() */
      @Override
      Object getInnerArray() {
        return arr;
      }
    };
  }
,
(startLine=76 endLine=100 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/java/org/apache/lucene/search/function/IntFieldSource.java)
  public DocValues getCachedFieldValues (FieldCache cache, String field, IndexReader reader) throws IOException {
    final int[] arr = cache.getInts(reader, field, parser);
    return new DocValues() {
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
      @Override
      public float floatVal(int doc) { 
        return (float) arr[doc]; 
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#intVal(int) */
      @Override
      public  int intVal(int doc) { 
        return arr[doc]; 
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#toString(int) */
      @Override
      public String toString(int doc) { 
        return  description() + '=' + intVal(doc);  
      }
      /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#getInnerArray() */
      @Override
      Object getInnerArray() {
        return arr;
      }
    };
  }
,
>
, <(startLine=1402 endLine=1415 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/java/org/apache/lucene/index/IndexWriter.java)
  private void pushMaxBufferedDocs() {
    if (docWriter.getMaxBufferedDocs() != DISABLE_AUTO_FLUSH) {
      final MergePolicy mp = mergePolicy;
      if (mp instanceof LogDocMergePolicy) {
        LogDocMergePolicy lmp = (LogDocMergePolicy) mp;
        final int maxBufferedDocs = docWriter.getMaxBufferedDocs();
        if (lmp.getMinMergeDocs() != maxBufferedDocs) {
          if (infoStream != null)
            message("now push maxBufferedDocs " + maxBufferedDocs + " to LogDocMergePolicy");
          lmp.setMinMergeDocs(maxBufferedDocs);
        }
      }
    }
  }
,
(startLine=1299 endLine=1312 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/java/org/apache/lucene/index/IndexWriter.java)
  private void pushMaxBufferedDocs() {
    if (docWriter.getMaxBufferedDocs() != DISABLE_AUTO_FLUSH) {
      final MergePolicy mp = mergePolicy;
      if (mp instanceof LogDocMergePolicy) {
        LogDocMergePolicy lmp = (LogDocMergePolicy) mp;
        final int maxBufferedDocs = docWriter.getMaxBufferedDocs();
        if (lmp.getMinMergeDocs() != maxBufferedDocs) {
          if (infoStream != null)
            message("now push maxBufferedDocs " + maxBufferedDocs + " to LogDocMergePolicy");
          lmp.setMinMergeDocs(maxBufferedDocs);
        }
      }
    }
  }
,
>
, <(startLine=611 endLine=714 srcPath=/home/sonia/NewExperiment/luceneFilter/02507/solr/solrj/src/test/org/apache/solr/client/solrj/io/StreamingTest.java)
  private void testMetricStream() throws Exception {

    indexr(id, "0", "a_s", "hello0", "a_i", "100", "a_f", "0");
    indexr(id, "2", "a_s", "hello0", "a_i", "2", "a_f", "0");
    indexr(id, "3", "a_s", "hello3", "a_i", "3", "a_f", "3");
    indexr(id, "4", "a_s", "hello3", "a_i", "4", "a_f", "4");
    indexr(id, "1", "a_s", "hello1", "a_i", "1", "a_f", "1");
    indexr(id, "6", "a_s", "hello1", "a_i", "1", "a_f", "1");
    indexr(id, "7", "a_s", "hello1", "a_i", "1", "a_f", "1");

    commit();

    String zkHost = zkServer.getZkAddress();

    Bucket[] buckets = {new Bucket("a_s")};
    Metric[] metrics = {new SumMetric("a_i", false),
                        new MeanMetric("a_i", false),
                        new CountMetric(),
                        new MinMetric("a_i", false),
                        new MaxMetric("a_i", false)};

    Map params = mapParams("q","*:*","fl","id,a_s,a_i","sort", "a_i asc");
    CloudSolrStream stream = new CloudSolrStream(zkHost, "collection1", params);
    MetricStream mstream = new MetricStream(stream, buckets, metrics, "metric1", new DescBucketComp(0),5);
    getTuples(mstream);

    BucketMetrics[] bucketMetrics = mstream.getBucketMetrics();
    assert(bucketMetrics.length == 3);

    //Bucket should be is descending order based on Metric 0, which is the SumMetric.

    assert(bucketMetrics[0].getKey().toString().equals("hello0"));
    assert(bucketMetrics[1].getKey().toString().equals("hello3"));
    assert(bucketMetrics[2].getKey().toString().equals("hello1"));

    assertMetric(bucketMetrics[0].getMetrics()[0], 102.0d); //Test the first Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[1], 51.0d); //Test the second Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[2], 2.0d); //Test the third Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[3], 2.0d); //Test the fourth Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[4], 100.0d); //Test the fifth Metric of the first BucketMetrics


    assertMetric(bucketMetrics[1].getMetrics()[0], 7.0d);
    assertMetric(bucketMetrics[2].getMetrics()[0], 3.0d);


    params = mapParams("q","*:*","fl","id,a_s,a_i","sort", "a_i asc");
    stream = new CloudSolrStream(zkHost, "collection1", params);
    mstream = new MetricStream(stream, buckets, metrics, "metric1", new AscBucketComp(0),5);
    getTuples(mstream);

    bucketMetrics = mstream.getBucketMetrics();

    assertMetric(bucketMetrics[0].getMetrics()[0], 3.0d); //Test the first Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[1], 1.0d); //Test the second Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[2], 3.0d); //Test the third Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[3], 1.0d); //Test the fourth Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[4], 1.0d); //Test the fifth Metric of the first BucketMetrics

    assertMetric(bucketMetrics[1].getMetrics()[0], 7.0d);
    assertMetric(bucketMetrics[2].getMetrics()[0], 102.0d);

    indexr(id, "8", "a_s", "hello4", "a_i", "1000", "a_f", "1"); //Add a fourth record.
    commit();

    //Test desc comp with more buckets then priority queue can hold.
    params = mapParams("q","*:*","fl","id,a_s,a_i","sort", "a_i asc");
    stream = new CloudSolrStream(zkHost, "collection1", params);
    mstream = new MetricStream(stream, buckets, metrics, "metric1", new DescBucketComp(0),3);
    getTuples(mstream);

    bucketMetrics = mstream.getBucketMetrics();
    assert(bucketMetrics.length == 3);
    assert(bucketMetrics[0].getKey().toString().equals("hello4"));
    assert(bucketMetrics[1].getKey().toString().equals("hello0"));
    assert(bucketMetrics[2].getKey().toString().equals("hello3"));

    //Test asc comp with more buckets then priority queue can hold.
    params = mapParams("q","*:*","fl","id,a_s,a_i","sort", "a_i asc");
    stream = new CloudSolrStream(zkHost, "collection1", params);
    mstream = new MetricStream(stream, buckets, metrics, "metric1", new AscBucketComp(0),3);
    getTuples(mstream);

    bucketMetrics = mstream.getBucketMetrics();
    assert(bucketMetrics.length == 3);
    assert(bucketMetrics[0].getKey().toString().equals("hello1"));
    assert(bucketMetrics[1].getKey().toString().equals("hello3"));
    assert(bucketMetrics[2].getKey().toString().equals("hello0"));


    //Test with no buckets
    params = mapParams("q","*:*","fl","id,a_s,a_i","sort", "a_i asc");
    stream = new CloudSolrStream(zkHost, "collection1", params);
    mstream = new MetricStream(stream, metrics, "metric1");
    getTuples(mstream);

    bucketMetrics = mstream.getBucketMetrics();
    assert(bucketMetrics.length == 1);
    assert(bucketMetrics[0].getKey().toString().equals("metrics"));
    assertMetric(bucketMetrics[0].getMetrics()[0], 1112.0d); //Test the first Metric of the first BucketMetrics

    del("*:*");
    commit();
  }
,
(startLine=717 endLine=821 srcPath=/home/sonia/NewExperiment/luceneFilter/02507/solr/solrj/src/test/org/apache/solr/client/solrj/io/StreamingTest.java)
  private void testParallelMetricStream() throws Exception {

    indexr(id, "0", "a_s", "hello0", "a_i", "100", "a_f", "0");
    indexr(id, "2", "a_s", "hello0", "a_i", "2", "a_f", "0");
    indexr(id, "3", "a_s", "hello3", "a_i", "3", "a_f", "3");
    indexr(id, "4", "a_s", "hello3", "a_i", "4", "a_f", "4");
    indexr(id, "1", "a_s", "hello1", "a_i", "1", "a_f", "1");
    indexr(id, "6", "a_s", "hello1", "a_i", "1", "a_f", "1");
    indexr(id, "7", "a_s", "hello1", "a_i", "1", "a_f", "1");

    commit();

    String zkHost = zkServer.getZkAddress();

    Bucket[] buckets = {new Bucket("a_s")};
    Metric[] metrics = {new SumMetric("a_i", false),
        new MeanMetric("a_i", false),
        new CountMetric(),
        new MinMetric("a_i", false),
        new MaxMetric("a_i", false)};

    Map params = mapParams("q","*:*","fl","id,a_s,a_i","sort", "a_i asc", "partitionKeys", "a_i");
    CloudSolrStream stream = new CloudSolrStream(zkHost, "collection1", params);
    MetricStream mstream = new MetricStream(stream, buckets, metrics, "metric1", new DescBucketComp(0),5);
    ParallelStream pstream = new ParallelStream(zkHost,"collection1",mstream,2,new AscFieldComp("a_i"));
    getTuples(pstream);

    BucketMetrics[] bucketMetrics = mstream.getBucketMetrics();
    assert(bucketMetrics.length == 3);

    //Bucket should be is descending order based on Metric 0, which is the SumMetric.

    assert(bucketMetrics[0].getKey().toString().equals("hello0"));
    assert(bucketMetrics[1].getKey().toString().equals("hello3"));
    assert(bucketMetrics[2].getKey().toString().equals("hello1"));

    assertMetric(bucketMetrics[0].getMetrics()[0], 102.0d); //Test the first Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[1], 51.0d); //Test the second Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[2], 2.0d); //Test the third Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[3], 2.0d); //Test the fourth Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[4], 100.0d); //Test the fifth Metric of the first BucketMetrics


    assertMetric(bucketMetrics[1].getMetrics()[0], 7.0d);
    assertMetric(bucketMetrics[2].getMetrics()[0], 3.0d);


    params = mapParams("q","*:*","fl","id,a_s,a_i","sort", "a_i asc");
    stream = new CloudSolrStream(zkHost, "collection1", params);
    mstream = new MetricStream(stream, buckets, metrics, "metric1", new AscBucketComp(0),5);
    getTuples(mstream);

    bucketMetrics = mstream.getBucketMetrics();

    assertMetric(bucketMetrics[0].getMetrics()[0], 3.0d); //Test the first Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[1], 1.0d); //Test the second Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[2], 3.0d); //Test the third Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[3], 1.0d); //Test the fourth Metric of the first BucketMetrics
    assertMetric(bucketMetrics[0].getMetrics()[4], 1.0d); //Test the fifth Metric of the first BucketMetrics

    assertMetric(bucketMetrics[1].getMetrics()[0], 7.0d);
    assertMetric(bucketMetrics[2].getMetrics()[0], 102.0d);

    indexr(id, "8", "a_s", "hello4", "a_i", "1000", "a_f", "1"); //Add a fourth record.
    commit();

    //Test desc comp with more buckets then priority queue can hold.
    params = mapParams("q","*:*","fl","id,a_s,a_i","sort", "a_i asc");
    stream = new CloudSolrStream(zkHost, "collection1", params);
    mstream = new MetricStream(stream, buckets, metrics, "metric1", new DescBucketComp(0),3);
    getTuples(mstream);

    bucketMetrics = mstream.getBucketMetrics();
    assert(bucketMetrics.length == 3);
    assert(bucketMetrics[0].getKey().toString().equals("hello4"));
    assert(bucketMetrics[1].getKey().toString().equals("hello0"));
    assert(bucketMetrics[2].getKey().toString().equals("hello3"));

    //Test asc comp with more buckets then priority queue can hold.
    params = mapParams("q","*:*","fl","id,a_s,a_i","sort", "a_i asc");
    stream = new CloudSolrStream(zkHost, "collection1", params);
    mstream = new MetricStream(stream, buckets, metrics, "metric1", new AscBucketComp(0),3);
    getTuples(mstream);

    bucketMetrics = mstream.getBucketMetrics();
    assert(bucketMetrics.length == 3);
    assert(bucketMetrics[0].getKey().toString().equals("hello1"));
    assert(bucketMetrics[1].getKey().toString().equals("hello3"));
    assert(bucketMetrics[2].getKey().toString().equals("hello0"));


    //Test with no buckets
    params = mapParams("q","*:*","fl","id,a_s,a_i","sort", "a_i asc");
    stream = new CloudSolrStream(zkHost, "collection1", params);
    mstream = new MetricStream(stream, metrics, "metric1");
    getTuples(mstream);

    bucketMetrics = mstream.getBucketMetrics();
    assert(bucketMetrics.length == 1);
    assert(bucketMetrics[0].getKey().toString().equals("metrics"));
    assertMetric(bucketMetrics[0].getMetrics()[0], 1112.0d); //Test the first Metric of the first BucketMetrics

    del("*:*");
    commit();
  }
,
>
, <(startLine=233 endLine=253 srcPath=/home/sonia/NewExperiment/luceneFilter/00679/lucene/src/test/org/apache/lucene/search/TestTimeLimitingCollector.java)
  public void testModifyResolution() {
    try {
      // increase and test
      long resolution = 20 * TimeLimitingCollector.DEFAULT_RESOLUTION; //400
      TimeLimitingCollector.setResolution(resolution);
      assertEquals(resolution, TimeLimitingCollector.getResolution());
      doTestTimeout(false,true);
      // decrease much and test
      resolution = 5;
      TimeLimitingCollector.setResolution(resolution);
      assertEquals(resolution, TimeLimitingCollector.getResolution());
      doTestTimeout(false,true);
      // return to default and test
      resolution = TimeLimitingCollector.DEFAULT_RESOLUTION;
      TimeLimitingCollector.setResolution(resolution);
      assertEquals(resolution, TimeLimitingCollector.getResolution());
      doTestTimeout(false,true);
    } finally {
      TimeLimitingCollector.setResolution(TimeLimitingCollector.DEFAULT_RESOLUTION);
    }
  }
,
(startLine=234 endLine=254 srcPath=/home/sonia/NewExperiment/luceneFilter/00679/lucene/backwards/src/test/org/apache/lucene/search/TestTimeLimitingCollector.java)
  public void testModifyResolution() {
    try {
      // increase and test
      long resolution = 20 * TimeLimitingCollector.DEFAULT_RESOLUTION; //400
      TimeLimitingCollector.setResolution(resolution);
      assertEquals(resolution, TimeLimitingCollector.getResolution());
      doTestTimeout(false,true);
      // decrease much and test
      resolution = 5;
      TimeLimitingCollector.setResolution(resolution);
      assertEquals(resolution, TimeLimitingCollector.getResolution());
      doTestTimeout(false,true);
      // return to default and test
      resolution = TimeLimitingCollector.DEFAULT_RESOLUTION;
      TimeLimitingCollector.setResolution(resolution);
      assertEquals(resolution, TimeLimitingCollector.getResolution());
      doTestTimeout(false,true);
    } finally {
      TimeLimitingCollector.setResolution(TimeLimitingCollector.DEFAULT_RESOLUTION);
    }
  }
,
>
, <(startLine=497 endLine=505 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/demo/org/apache/lucene/demo/html/HTMLParser.java)
  public HTMLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new HTMLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
,
(startLine=512 endLine=520 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/demo/org/apache/lucene/demo/html/HTMLParser.java)
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
,
(startLine=644 endLine=652 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java)
  public StandardSyntaxParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new StandardSyntaxParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
,
(startLine=659 endLine=667 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java)
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
,
(startLine=496 endLine=504 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/demo/org/apache/lucene/demo/html/HTMLParser.java)
  public HTMLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new HTMLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
,
(startLine=511 endLine=519 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/demo/org/apache/lucene/demo/html/HTMLParser.java)
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }
,
>
, <(startLine=660 endLine=714 srcPath=/home/sonia/NewExperiment/luceneFilter/02326/solr/core/src/test/org/apache/solr/search/TestRecoveryHdfs.java)
  public void testCleanShutdown() throws Exception {
    DirectUpdateHandler2.commitOnClose = true;
    final Semaphore logReplay = new Semaphore(0);
    final Semaphore logReplayFinish = new Semaphore(0);

    UpdateLog.testing_logReplayHook = new Runnable() {
      @Override
      public void run() {
        try {
          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
      }
    };

    UpdateLog.testing_logReplayFinishHook = new Runnable() {
      @Override
      public void run() {
        logReplayFinish.release();
      }
    };


    SolrQueryRequest req = req();
    UpdateHandler uhandler = req.getCore().getUpdateHandler();
    UpdateLog ulog = uhandler.getUpdateLog();

    try {
      clearIndex();
      assertU(commit());

      assertU(adoc("id","E1", "val_i","1"));
      assertU(adoc("id","E2", "val_i","1"));

      // set to a high enough number so this test won't hang on a bug
      logReplay.release(10);

      h.close();
      createCore();

      // make sure the docs got committed
      assertJQ(req("q","*:*"),"/response/numFound==2");

      // make sure no replay happened
      assertEquals(10, logReplay.availablePermits());

    } finally {
      DirectUpdateHandler2.commitOnClose = true;
      UpdateLog.testing_logReplayHook = null;
      UpdateLog.testing_logReplayFinishHook = null;

      req().close();
    }
  }
,
(startLine=667 endLine=721 srcPath=/home/sonia/NewExperiment/luceneFilter/02326/solr/core/src/test/org/apache/solr/search/TestRecovery.java)
  public void testCleanShutdown() throws Exception {
    DirectUpdateHandler2.commitOnClose = true;
    final Semaphore logReplay = new Semaphore(0);
    final Semaphore logReplayFinish = new Semaphore(0);

    UpdateLog.testing_logReplayHook = new Runnable() {
      @Override
      public void run() {
        try {
          assertTrue(logReplay.tryAcquire(timeout, TimeUnit.SECONDS));
        } catch (Exception e) {
          throw new RuntimeException(e);
        }
      }
    };

    UpdateLog.testing_logReplayFinishHook = new Runnable() {
      @Override
      public void run() {
        logReplayFinish.release();
      }
    };


    SolrQueryRequest req = req();
    UpdateHandler uhandler = req.getCore().getUpdateHandler();
    UpdateLog ulog = uhandler.getUpdateLog();

    try {
      clearIndex();
      assertU(commit());

      assertU(adoc("id","E1", "val_i","1"));
      assertU(adoc("id","E2", "val_i","1"));

      // set to a high enough number so this test won't hang on a bug
      logReplay.release(10);

      h.close();
      createCore();

      // make sure the docs got committed
      assertJQ(req("q","*:*"),"/response/numFound==2");

      // make sure no replay happened
      assertEquals(10, logReplay.availablePermits());

    } finally {
      DirectUpdateHandler2.commitOnClose = true;
      UpdateLog.testing_logReplayHook = null;
      UpdateLog.testing_logReplayFinishHook = null;

      req().close();
    }
  }
,
>
, <(startLine=235 endLine=267 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/solr/src/test/org/apache/solr/analysis/TestSynonymFilter.java)
  public void testPositionIncrements() throws IOException {
    SynonymMap map = new SynonymMap();

    boolean orig = false;
    boolean merge = true;

    // test that generated tokens start at the same posInc as the original
    map.add(strings("a"), tokens("aa"), orig, merge);
    assertTokenizesTo(map, tokens("a,5"), 
        new String[] { "aa" },
        new int[] { 5 });
    assertTokenizesTo(map, tokens("a,0"),
        new String[] { "aa" },
        new int[] { 0 });

    // test that offset of first replacement is ignored (always takes the orig offset)
    map.add(strings("b"), tokens("bb,100"), orig, merge);
    assertTokenizesTo(map, tokens("b,5"),
        new String[] { "bb" },
        new int[] { 5 });
    assertTokenizesTo(map, tokens("b,0"),
        new String[] { "bb" },
        new int[] { 0 });

    // test that subsequent tokens are adjusted accordingly
    map.add(strings("c"), tokens("cc,100 c2,2"), orig, merge);
    assertTokenizesTo(map, tokens("c,5"),
        new String[] { "cc", "c2" },
        new int[] { 5, 2 });
    assertTokenizesTo(map, tokens("c,0"),
        new String[] { "cc", "c2" },
        new int[] { 0, 2 });
  }
,
(startLine=270 endLine=302 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/solr/src/test/org/apache/solr/analysis/TestSynonymFilter.java)
  public void testPositionIncrementsWithOrig() throws IOException {
    SynonymMap map = new SynonymMap();

    boolean orig = true;
    boolean merge = true;

    // test that generated tokens start at the same offset as the original
    map.add(strings("a"), tokens("aa"), orig, merge);
    assertTokenizesTo(map, tokens("a,5"),
        new String[] { "a", "aa" },
        new int[] { 5, 0 });
    assertTokenizesTo(map, tokens("a,0"),
        new String[] { "a", "aa" },
        new int[] { 0, 0 });

    // test that offset of first replacement is ignored (always takes the orig offset)
    map.add(strings("b"), tokens("bb,100"), orig, merge);
    assertTokenizesTo(map, tokens("b,5"),
        new String[] { "b", "bb" },
        new int[] { 5, 0 });
    assertTokenizesTo(map, tokens("b,0"),
        new String[] { "b", "bb" },
        new int[] { 0, 0 });

    // test that subsequent tokens are adjusted accordingly
    map.add(strings("c"), tokens("cc,100 c2,2"), orig, merge);
    assertTokenizesTo(map, tokens("c,5"),
        new String[] { "c", "cc", "c2" },
        new int[] { 5, 0, 2 });
    assertTokenizesTo(map, tokens("c,0"),
        new String[] { "c", "cc", "c2" },
        new int[] { 0, 0, 2 });
  }
,
>
, <(startLine=1218 endLine=1246 srcPath=/home/sonia/NewExperiment/luceneFilter/01169/lucene/src/java/org/apache/lucene/search/FieldComparator.java)
    public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {
      final int docBase = context.docBase;
      termsIndex = FieldCache.DEFAULT.getTermsIndex(context.reader, field);
      final PackedInts.Reader docToOrd = termsIndex.getDocToOrd();
      FieldComparator perSegComp = null;
      if (docToOrd.hasArray()) {
        final Object arr = docToOrd.getArray();
        if (arr instanceof byte[]) {
          perSegComp = new ByteOrdComparator((byte[]) arr, termsIndex, docBase);
        } else if (arr instanceof short[]) {
          perSegComp = new ShortOrdComparator((short[]) arr, termsIndex, docBase);
        } else if (arr instanceof int[]) {
          perSegComp = new IntOrdComparator((int[]) arr, termsIndex, docBase);
        }
        // Don't specialize the long[] case since it's not
        // possible, ie, worse case is MAX_INT-1 docs with
        // every one having a unique value.
      }
      if (perSegComp == null) {
        perSegComp = new AnyOrdComparator(docToOrd, termsIndex, docBase);
      }

      currentReaderGen++;
      if (bottomSlot != -1) {
        perSegComp.setBottom(bottomSlot);
      }

      return perSegComp;
    }
,
(startLine=435 endLine=460 srcPath=/home/sonia/NewExperiment/luceneFilter/01169/solr/core/src/java/org/apache/solr/search/MissingStringLastComparatorSource.java)
  public static FieldComparator createComparator(IndexReader reader, TermOrdValComparator_SML parent) throws IOException {
    parent.termsIndex = FieldCache.DEFAULT.getTermsIndex(reader, parent.field);
    final PackedInts.Reader docToOrd = parent.termsIndex.getDocToOrd();
    PerSegmentComparator perSegComp = null;
    if (docToOrd.hasArray()) {
      final Object arr = docToOrd.getArray();
      if (arr instanceof byte[]) {
        perSegComp = new ByteOrdComparator((byte[]) arr, parent);
      } else if (arr instanceof short[]) {
        perSegComp = new ShortOrdComparator((short[]) arr, parent);
      } else if (arr instanceof int[]) {
        perSegComp = new IntOrdComparator((int[]) arr, parent);
      }
    }

    if (perSegComp == null) {
      perSegComp = new AnyOrdComparator(docToOrd, parent);
    }

    if (perSegComp.bottomSlot != -1) {
      perSegComp.setBottom(perSegComp.bottomSlot);
    }

    parent.current = perSegComp;
    return perSegComp;
  }
,
>
, <(startLine=106 endLine=150 srcPath=/home/sonia/NewExperiment/luceneFilter/00343/contrib/miscellaneous/src/java/org/apache/lucene/misc/LengthNormModifier.java)
  public void reSetNorms(String field) throws IOException {
    String fieldName = field.intern();
    int[] termCounts = new int[0];
    
    IndexReader reader = null;
    TermEnum termEnum = null;
    TermDocs termDocs = null;
    try {
      reader = IndexReader.open(dir);
      termCounts = new int[reader.maxDoc()];
      try {
        termEnum = reader.terms(new Term(field,""));
        try {
          termDocs = reader.termDocs();
          do {
            Term term = termEnum.term();
            if (term != null && term.field().equals(fieldName)) {
              termDocs.seek(termEnum.term());
              while (termDocs.next()) {
                termCounts[termDocs.doc()] += termDocs.freq();
              }
            }
          } while (termEnum.next());
        } finally {
          if (null != termDocs) termDocs.close();
        }
      } finally {
        if (null != termEnum) termEnum.close();
      }
    } finally {
      if (null != reader) reader.close();
    }
    
    try {
      reader = IndexReader.open(dir); 
      for (int d = 0; d < termCounts.length; d++) {
        if (! reader.isDeleted(d)) {
          byte norm = sim.encodeNorm(sim.lengthNorm(fieldName, termCounts[d]));
          reader.setNorm(d, fieldName, norm);
        }
      }
    } finally {
      if (null != reader) reader.close();
    }
  }
,
(startLine=106 endLine=158 srcPath=/home/sonia/NewExperiment/luceneFilter/00343/contrib/miscellaneous/src/java/org/apache/lucene/index/FieldNormModifier.java)
  public void reSetNorms(String field) throws IOException {
    String fieldName = field.intern();
    int[] termCounts = new int[0];
    byte[] fakeNorms = new byte[0];
    
    IndexReader reader = null;
    TermEnum termEnum = null;
    TermDocs termDocs = null;
    try {
      reader = IndexReader.open(dir);
      termCounts = new int[reader.maxDoc()];
      // if we are killing norms, get fake ones
      if (sim == null)
        fakeNorms = SegmentReader.createFakeNorms(reader.maxDoc());
      try {
        termEnum = reader.terms(new Term(field,""));
        try {
          termDocs = reader.termDocs();
          do {
            Term term = termEnum.term();
            if (term != null && term.field().equals(fieldName)) {
              termDocs.seek(termEnum.term());
              while (termDocs.next()) {
                termCounts[termDocs.doc()] += termDocs.freq();
              }
            }
          } while (termEnum.next());
          
        } finally {
          if (null != termDocs) termDocs.close();
        }
      } finally {
        if (null != termEnum) termEnum.close();
      }
    } finally {
      if (null != reader) reader.close();
    }
    
    try {
      reader = IndexReader.open(dir); 
      for (int d = 0; d < termCounts.length; d++) {
        if (! reader.isDeleted(d)) {
          if (sim == null)
            reader.setNorm(d, fieldName, fakeNorms[0]);
          else
            reader.setNorm(d, fieldName, sim.encodeNorm(sim.lengthNorm(fieldName, termCounts[d])));
        }
      }
      
    } finally {
      if (null != reader) reader.close();
    }
  }
,
>
, <(startLine=629 endLine=902 srcPath=/home/sonia/NewExperiment/luceneFilter/00645/contrib/analyzers/common/src/java/org/tartarus/snowball/ext/SpanishStemmer.java)
        private boolean r_standard_suffix() {
            int among_var;
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            int v_5;
            // (, line 86
            // [, line 87
            ket = cursor;
            // substring, line 87
            among_var = find_among_b(a_6, 46);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 87
            bra = cursor;
            switch(among_var) {
                case 0:
                    return false;
                case 1:
                    // (, line 98
                    // call R2, line 99
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 99
                    slice_del();
                    break;
                case 2:
                    // (, line 104
                    // call R2, line 105
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 105
                    slice_del();
                    // try, line 106
                    v_1 = limit - cursor;
                    lab0: do {
                        // (, line 106
                        // [, line 106
                        ket = cursor;
                        // literal, line 106
                        if (!(eq_s_b(2, "ic")))
                        {
                            cursor = limit - v_1;
                            break lab0;
                        }
                        // ], line 106
                        bra = cursor;
                        // call R2, line 106
                        if (!r_R2())
                        {
                            cursor = limit - v_1;
                            break lab0;
                        }
                        // delete, line 106
                        slice_del();
                    } while (false);
                    break;
                case 3:
                    // (, line 110
                    // call R2, line 111
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 111
                    slice_from("log");
                    break;
                case 4:
                    // (, line 114
                    // call R2, line 115
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 115
                    slice_from("u");
                    break;
                case 5:
                    // (, line 118
                    // call R2, line 119
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 119
                    slice_from("ente");
                    break;
                case 6:
                    // (, line 122
                    // call R1, line 123
                    if (!r_R1())
                    {
                        return false;
                    }
                    // delete, line 123
                    slice_del();
                    // try, line 124
                    v_2 = limit - cursor;
                    lab1: do {
                        // (, line 124
                        // [, line 125
                        ket = cursor;
                        // substring, line 125
                        among_var = find_among_b(a_3, 4);
                        if (among_var == 0)
                        {
                            cursor = limit - v_2;
                            break lab1;
                        }
                        // ], line 125
                        bra = cursor;
                        // call R2, line 125
                        if (!r_R2())
                        {
                            cursor = limit - v_2;
                            break lab1;
                        }
                        // delete, line 125
                        slice_del();
                        switch(among_var) {
                            case 0:
                                cursor = limit - v_2;
                                break lab1;
                            case 1:
                                // (, line 126
                                // [, line 126
                                ket = cursor;
                                // literal, line 126
                                if (!(eq_s_b(2, "at")))
                                {
                                    cursor = limit - v_2;
                                    break lab1;
                                }
                                // ], line 126
                                bra = cursor;
                                // call R2, line 126
                                if (!r_R2())
                                {
                                    cursor = limit - v_2;
                                    break lab1;
                                }
                                // delete, line 126
                                slice_del();
                                break;
                        }
                    } while (false);
                    break;
                case 7:
                    // (, line 134
                    // call R2, line 135
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 135
                    slice_del();
                    // try, line 136
                    v_3 = limit - cursor;
                    lab2: do {
                        // (, line 136
                        // [, line 137
                        ket = cursor;
                        // substring, line 137
                        among_var = find_among_b(a_4, 3);
                        if (among_var == 0)
                        {
                            cursor = limit - v_3;
                            break lab2;
                        }
                        // ], line 137
                        bra = cursor;
                        switch(among_var) {
                            case 0:
                                cursor = limit - v_3;
                                break lab2;
                            case 1:
                                // (, line 140
                                // call R2, line 140
                                if (!r_R2())
                                {
                                    cursor = limit - v_3;
                                    break lab2;
                                }
                                // delete, line 140
                                slice_del();
                                break;
                        }
                    } while (false);
                    break;
                case 8:
                    // (, line 146
                    // call R2, line 147
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 147
                    slice_del();
                    // try, line 148
                    v_4 = limit - cursor;
                    lab3: do {
                        // (, line 148
                        // [, line 149
                        ket = cursor;
                        // substring, line 149
                        among_var = find_among_b(a_5, 3);
                        if (among_var == 0)
                        {
                            cursor = limit - v_4;
                            break lab3;
                        }
                        // ], line 149
                        bra = cursor;
                        switch(among_var) {
                            case 0:
                                cursor = limit - v_4;
                                break lab3;
                            case 1:
                                // (, line 152
                                // call R2, line 152
                                if (!r_R2())
                                {
                                    cursor = limit - v_4;
                                    break lab3;
                                }
                                // delete, line 152
                                slice_del();
                                break;
                        }
                    } while (false);
                    break;
                case 9:
                    // (, line 158
                    // call R2, line 159
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 159
                    slice_del();
                    // try, line 160
                    v_5 = limit - cursor;
                    lab4: do {
                        // (, line 160
                        // [, line 161
                        ket = cursor;
                        // literal, line 161
                        if (!(eq_s_b(2, "at")))
                        {
                            cursor = limit - v_5;
                            break lab4;
                        }
                        // ], line 161
                        bra = cursor;
                        // call R2, line 161
                        if (!r_R2())
                        {
                            cursor = limit - v_5;
                            break lab4;
                        }
                        // delete, line 161
                        slice_del();
                    } while (false);
                    break;
            }
            return true;
        }
,
(startLine=714 endLine=972 srcPath=/home/sonia/NewExperiment/luceneFilter/00645/contrib/analyzers/common/src/java/org/tartarus/snowball/ext/ItalianStemmer.java)
        private boolean r_standard_suffix() {
            int among_var;
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            // (, line 103
            // [, line 104
            ket = cursor;
            // substring, line 104
            among_var = find_among_b(a_6, 51);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 104
            bra = cursor;
            switch(among_var) {
                case 0:
                    return false;
                case 1:
                    // (, line 111
                    // call R2, line 111
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 111
                    slice_del();
                    break;
                case 2:
                    // (, line 113
                    // call R2, line 113
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 113
                    slice_del();
                    // try, line 114
                    v_1 = limit - cursor;
                    lab0: do {
                        // (, line 114
                        // [, line 114
                        ket = cursor;
                        // literal, line 114
                        if (!(eq_s_b(2, "ic")))
                        {
                            cursor = limit - v_1;
                            break lab0;
                        }
                        // ], line 114
                        bra = cursor;
                        // call R2, line 114
                        if (!r_R2())
                        {
                            cursor = limit - v_1;
                            break lab0;
                        }
                        // delete, line 114
                        slice_del();
                    } while (false);
                    break;
                case 3:
                    // (, line 117
                    // call R2, line 117
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 117
                    slice_from("log");
                    break;
                case 4:
                    // (, line 119
                    // call R2, line 119
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 119
                    slice_from("u");
                    break;
                case 5:
                    // (, line 121
                    // call R2, line 121
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 121
                    slice_from("ente");
                    break;
                case 6:
                    // (, line 123
                    // call RV, line 123
                    if (!r_RV())
                    {
                        return false;
                    }
                    // delete, line 123
                    slice_del();
                    break;
                case 7:
                    // (, line 124
                    // call R1, line 125
                    if (!r_R1())
                    {
                        return false;
                    }
                    // delete, line 125
                    slice_del();
                    // try, line 126
                    v_2 = limit - cursor;
                    lab1: do {
                        // (, line 126
                        // [, line 127
                        ket = cursor;
                        // substring, line 127
                        among_var = find_among_b(a_4, 4);
                        if (among_var == 0)
                        {
                            cursor = limit - v_2;
                            break lab1;
                        }
                        // ], line 127
                        bra = cursor;
                        // call R2, line 127
                        if (!r_R2())
                        {
                            cursor = limit - v_2;
                            break lab1;
                        }
                        // delete, line 127
                        slice_del();
                        switch(among_var) {
                            case 0:
                                cursor = limit - v_2;
                                break lab1;
                            case 1:
                                // (, line 128
                                // [, line 128
                                ket = cursor;
                                // literal, line 128
                                if (!(eq_s_b(2, "at")))
                                {
                                    cursor = limit - v_2;
                                    break lab1;
                                }
                                // ], line 128
                                bra = cursor;
                                // call R2, line 128
                                if (!r_R2())
                                {
                                    cursor = limit - v_2;
                                    break lab1;
                                }
                                // delete, line 128
                                slice_del();
                                break;
                        }
                    } while (false);
                    break;
                case 8:
                    // (, line 133
                    // call R2, line 134
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 134
                    slice_del();
                    // try, line 135
                    v_3 = limit - cursor;
                    lab2: do {
                        // (, line 135
                        // [, line 136
                        ket = cursor;
                        // substring, line 136
                        among_var = find_among_b(a_5, 3);
                        if (among_var == 0)
                        {
                            cursor = limit - v_3;
                            break lab2;
                        }
                        // ], line 136
                        bra = cursor;
                        switch(among_var) {
                            case 0:
                                cursor = limit - v_3;
                                break lab2;
                            case 1:
                                // (, line 137
                                // call R2, line 137
                                if (!r_R2())
                                {
                                    cursor = limit - v_3;
                                    break lab2;
                                }
                                // delete, line 137
                                slice_del();
                                break;
                        }
                    } while (false);
                    break;
                case 9:
                    // (, line 141
                    // call R2, line 142
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 142
                    slice_del();
                    // try, line 143
                    v_4 = limit - cursor;
                    lab3: do {
                        // (, line 143
                        // [, line 143
                        ket = cursor;
                        // literal, line 143
                        if (!(eq_s_b(2, "at")))
                        {
                            cursor = limit - v_4;
                            break lab3;
                        }
                        // ], line 143
                        bra = cursor;
                        // call R2, line 143
                        if (!r_R2())
                        {
                            cursor = limit - v_4;
                            break lab3;
                        }
                        // delete, line 143
                        slice_del();
                        // [, line 143
                        ket = cursor;
                        // literal, line 143
                        if (!(eq_s_b(2, "ic")))
                        {
                            cursor = limit - v_4;
                            break lab3;
                        }
                        // ], line 143
                        bra = cursor;
                        // call R2, line 143
                        if (!r_R2())
                        {
                            cursor = limit - v_4;
                            break lab3;
                        }
                        // delete, line 143
                        slice_del();
                    } while (false);
                    break;
            }
            return true;
        }
,
(startLine=571 endLine=825 srcPath=/home/sonia/NewExperiment/luceneFilter/00645/contrib/analyzers/common/src/java/org/tartarus/snowball/ext/PortugueseStemmer.java)
        private boolean r_standard_suffix() {
            int among_var;
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            // (, line 76
            // [, line 77
            ket = cursor;
            // substring, line 77
            among_var = find_among_b(a_5, 45);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 77
            bra = cursor;
            switch(among_var) {
                case 0:
                    return false;
                case 1:
                    // (, line 92
                    // call R2, line 93
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 93
                    slice_del();
                    break;
                case 2:
                    // (, line 97
                    // call R2, line 98
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 98
                    slice_from("log");
                    break;
                case 3:
                    // (, line 101
                    // call R2, line 102
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 102
                    slice_from("u");
                    break;
                case 4:
                    // (, line 105
                    // call R2, line 106
                    if (!r_R2())
                    {
                        return false;
                    }
                    // <-, line 106
                    slice_from("ente");
                    break;
                case 5:
                    // (, line 109
                    // call R1, line 110
                    if (!r_R1())
                    {
                        return false;
                    }
                    // delete, line 110
                    slice_del();
                    // try, line 111
                    v_1 = limit - cursor;
                    lab0: do {
                        // (, line 111
                        // [, line 112
                        ket = cursor;
                        // substring, line 112
                        among_var = find_among_b(a_2, 4);
                        if (among_var == 0)
                        {
                            cursor = limit - v_1;
                            break lab0;
                        }
                        // ], line 112
                        bra = cursor;
                        // call R2, line 112
                        if (!r_R2())
                        {
                            cursor = limit - v_1;
                            break lab0;
                        }
                        // delete, line 112
                        slice_del();
                        switch(among_var) {
                            case 0:
                                cursor = limit - v_1;
                                break lab0;
                            case 1:
                                // (, line 113
                                // [, line 113
                                ket = cursor;
                                // literal, line 113
                                if (!(eq_s_b(2, "at")))
                                {
                                    cursor = limit - v_1;
                                    break lab0;
                                }
                                // ], line 113
                                bra = cursor;
                                // call R2, line 113
                                if (!r_R2())
                                {
                                    cursor = limit - v_1;
                                    break lab0;
                                }
                                // delete, line 113
                                slice_del();
                                break;
                        }
                    } while (false);
                    break;
                case 6:
                    // (, line 121
                    // call R2, line 122
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 122
                    slice_del();
                    // try, line 123
                    v_2 = limit - cursor;
                    lab1: do {
                        // (, line 123
                        // [, line 124
                        ket = cursor;
                        // substring, line 124
                        among_var = find_among_b(a_3, 3);
                        if (among_var == 0)
                        {
                            cursor = limit - v_2;
                            break lab1;
                        }
                        // ], line 124
                        bra = cursor;
                        switch(among_var) {
                            case 0:
                                cursor = limit - v_2;
                                break lab1;
                            case 1:
                                // (, line 127
                                // call R2, line 127
                                if (!r_R2())
                                {
                                    cursor = limit - v_2;
                                    break lab1;
                                }
                                // delete, line 127
                                slice_del();
                                break;
                        }
                    } while (false);
                    break;
                case 7:
                    // (, line 133
                    // call R2, line 134
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 134
                    slice_del();
                    // try, line 135
                    v_3 = limit - cursor;
                    lab2: do {
                        // (, line 135
                        // [, line 136
                        ket = cursor;
                        // substring, line 136
                        among_var = find_among_b(a_4, 3);
                        if (among_var == 0)
                        {
                            cursor = limit - v_3;
                            break lab2;
                        }
                        // ], line 136
                        bra = cursor;
                        switch(among_var) {
                            case 0:
                                cursor = limit - v_3;
                                break lab2;
                            case 1:
                                // (, line 139
                                // call R2, line 139
                                if (!r_R2())
                                {
                                    cursor = limit - v_3;
                                    break lab2;
                                }
                                // delete, line 139
                                slice_del();
                                break;
                        }
                    } while (false);
                    break;
                case 8:
                    // (, line 145
                    // call R2, line 146
                    if (!r_R2())
                    {
                        return false;
                    }
                    // delete, line 146
                    slice_del();
                    // try, line 147
                    v_4 = limit - cursor;
                    lab3: do {
                        // (, line 147
                        // [, line 148
                        ket = cursor;
                        // literal, line 148
                        if (!(eq_s_b(2, "at")))
                        {
                            cursor = limit - v_4;
                            break lab3;
                        }
                        // ], line 148
                        bra = cursor;
                        // call R2, line 148
                        if (!r_R2())
                        {
                            cursor = limit - v_4;
                            break lab3;
                        }
                        // delete, line 148
                        slice_del();
                    } while (false);
                    break;
                case 9:
                    // (, line 152
                    // call RV, line 153
                    if (!r_RV())
                    {
                        return false;
                    }
                    // literal, line 153
                    if (!(eq_s_b(1, "e")))
                    {
                        return false;
                    }
                    // <-, line 154
                    slice_from("ir");
                    break;
            }
            return true;
        }
,
>
, <(startLine=710 endLine=736 srcPath=/home/sonia/NewExperiment/luceneFilter/02849/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggesterTest.java)
        for(int token=0;token < numTokens;token++) {
          String s;
          while (true) {
            // TODO: would be nice to fix this slowCompletor/comparator to
            // use full range, but we might lose some coverage too...
            s = TestUtil.randomSimpleString(random());
            if (s.length() > 0) {
              if (token > 0) {
                key += " ";
              }
              if (preserveSep && analyzedKey.length() > 0 && analyzedKey.charAt(analyzedKey.length()-1) != SEP) {
                analyzedKey += SEP;
              }
              key += s;
              if (s.length() == 1 && isStopChar(s.charAt(0), numStopChars)) {
                lastRemoved = true;
                if (preserveSep && preserveHoles) {
                  analyzedKey += SEP;
                }
              } else {
                lastRemoved = false;
                analyzedKey += s;
              }
              break;
            }
          }
        }
,
(startLine=651 endLine=677 srcPath=/home/sonia/NewExperiment/luceneFilter/02849/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/FuzzySuggesterTest.java)
        for(int token=0;token < numTokens;token++) {
          String s;
          while (true) {
            // TODO: would be nice to fix this slowCompletor/comparator to
            // use full range, but we might lose some coverage too...
            s = TestUtil.randomSimpleString(random());
            if (s.length() > 0) {
              if (token > 0) {
                key += " ";
              }
              if (preserveSep && analyzedKey.length() > 0 && (unicodeAware ? analyzedKey.codePointAt(analyzedKey.codePointCount(0, analyzedKey.length())-1) != ' ' : analyzedKey.charAt(analyzedKey.length()-1) != ' ')) {
                analyzedKey += " ";
              }
              key += s;
              if (s.length() == 1 && isStopChar(s.charAt(0), numStopChars)) {
                if (preserveSep && preserveHoles) {
                  analyzedKey += '\u0000';
                }
                lastRemoved = true;
              } else {
                analyzedKey += s;
                lastRemoved = false;
              }
              break;
            }
          }
        }
,
>
, <(startLine=166 endLine=177 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/solr/src/java/org/apache/solr/search/HashDocSet.java)
   } else {

     int[] result = new int[size()];
     int resultCount=0;
     for (int i=0; i<table.length; i++) {
       int id=table[i];
       if (id >= 0 && other.exists(id)) {
         result[resultCount++]=id;
       }
     }
     return new HashDocSet(result,0,resultCount);
   }
,
(startLine=212 endLine=223 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/solr/src/java/org/apache/solr/search/HashDocSet.java)
  public DocSet andNot(DocSet other) {
    int[] result = new int[size()];
    int resultCount=0;

    for (int i=0; i<table.length; i++) {
      int id=table[i];
      if (id >= 0 && !other.exists(id)) {
        result[resultCount++]=id;
      }
    }
    return new HashDocSet(result,0,resultCount);
  }
,
>
, <(startLine=230 endLine=244 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/test/org/apache/lucene/search/spans/TestBasics.java)
  public void testNpeInSpanNearInSpanFirstInSpanNot() throws Exception {
    int n = 5;
    SpanTermQuery hun = new SpanTermQuery(new Term("field", "hundred"));
    SpanTermQuery term40 = new SpanTermQuery(new Term("field", "forty"));
    SpanTermQuery term40c = (SpanTermQuery)term40.clone();

    SpanFirstQuery include = new SpanFirstQuery(term40, n);
    SpanNearQuery near = new SpanNearQuery(new SpanQuery[]{hun, term40c},
                                           n-1, true);
    SpanFirstQuery exclude = new SpanFirstQuery(near, n-1);
    SpanNotQuery q = new SpanNotQuery(include, exclude);
    
    checkHits(q, new int[]{40,41,42,43,44,45,46,47,48,49});
    
  }
,
(startLine=229 endLine=243 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/test/org/apache/lucene/search/spans/TestBasics.java)
  public void testNpeInSpanNearInSpanFirstInSpanNot() throws Exception {
    int n = 5;
    SpanTermQuery hun = new SpanTermQuery(new Term("field", "hundred"));
    SpanTermQuery term40 = new SpanTermQuery(new Term("field", "forty"));
    SpanTermQuery term40c = (SpanTermQuery)term40.clone();

    SpanFirstQuery include = new SpanFirstQuery(term40, n);
    SpanNearQuery near = new SpanNearQuery(new SpanQuery[]{hun, term40c},
                                           n-1, true);
    SpanFirstQuery exclude = new SpanFirstQuery(near, n-1);
    SpanNotQuery q = new SpanNotQuery(include, exclude);
    
    checkHits(q, new int[]{40,41,42,43,44,45,46,47,48,49});
    
  }
,
>
, <(startLine=47 endLine=79 srcPath=/home/sonia/NewExperiment/luceneFilter/02277/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java)
  public void write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext) throws IOException {
    final String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene46SegmentInfoFormat.SI_EXTENSION);
    si.addFile(fileName);

    final IndexOutput output = dir.createOutput(fileName, ioContext);

    boolean success = false;
    try {
      CodecUtil.writeHeader(output, Lucene46SegmentInfoFormat.CODEC_NAME, Lucene46SegmentInfoFormat.VERSION_CURRENT);
      Version version = si.getVersion();
      if (version.major < 4) {
        throw new IllegalArgumentException("invalid major version: should be >= 4 but got: " + version.major + " segment=" + si);
      }
      // Write the Lucene version that created this segment, since 3.1
      output.writeString(version.toString());
      output.writeInt(si.getDocCount());

      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
      output.writeStringStringMap(si.getDiagnostics());
      output.writeStringSet(si.files());
      output.writeString(si.getId());
      CodecUtil.writeFooter(output);
      success = true;
    } finally {
      if (!success) {
        IOUtils.closeWhileHandlingException(output);
        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?
        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);
      } else {
        output.close();
      }
    }
  }
,
(startLine=47 endLine=79 srcPath=/home/sonia/NewExperiment/luceneFilter/02277/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoWriter.java)
  public void write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext) throws IOException {
    final String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene50SegmentInfoFormat.SI_EXTENSION);
    si.addFile(fileName);

    final IndexOutput output = dir.createOutput(fileName, ioContext);

    boolean success = false;
    try {
      CodecUtil.writeHeader(output, Lucene50SegmentInfoFormat.CODEC_NAME, Lucene50SegmentInfoFormat.VERSION_CURRENT);
      Version version = si.getVersion();
      if (version.major < 5) {
        throw new IllegalArgumentException("invalid major version: should be >= 5 but got: " + version.major + " segment=" + si);
      }
      // Write the Lucene version that created this segment, since 3.1
      output.writeString(version.toString());
      output.writeInt(si.getDocCount());

      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
      output.writeStringStringMap(si.getDiagnostics());
      output.writeStringSet(si.files());
      output.writeString(si.getId());
      CodecUtil.writeFooter(output);
      success = true;
    } finally {
      if (!success) {
        IOUtils.closeWhileHandlingException(output);
        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?
        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);
      } else {
        output.close();
      }
    }
  }
,
>
, <(startLine=671 endLine=704 srcPath=/home/sonia/NewExperiment/luceneFilter/00654/lucene/src/java/org/apache/lucene/index/CheckIndex.java)
  private Status.StoredFieldStatus testStoredFields(SegmentInfo info, SegmentReader reader, NumberFormat format) {
    final Status.StoredFieldStatus status = new Status.StoredFieldStatus();

    try {
      if (infoStream != null) {
        infoStream.print("    test: stored fields.......");
      }

      // Scan stored fields for all documents
      for (int j = 0; j < info.docCount; ++j) {
        if (!reader.isDeleted(j)) {
          status.docCount++;
          Document doc = reader.document(j);
          status.totFields += doc.getFields().size();
        }
      }      

      // Validate docCount
      if (status.docCount != reader.numDocs()) {
        throw new RuntimeException("docCount=" + status.docCount + " but saw " + status.docCount + " undeleted docs");
      }

      msg("OK [" + status.totFields + " total field count; avg " + 
          format.format((((float) status.totFields)/status.docCount)) + " fields per doc]");      
    } catch (Throwable e) {
      msg("ERROR [" + String.valueOf(e.getMessage()) + "]");
      status.error = e;
      if (infoStream != null) {
        e.printStackTrace(infoStream);
      }
    }

    return status;
  }
,
(startLine=674 endLine=707 srcPath=/home/sonia/NewExperiment/luceneFilter/00654/lucene/backwards/src/java/org/apache/lucene/index/CheckIndex.java)
  private Status.StoredFieldStatus testStoredFields(SegmentInfo info, SegmentReader reader, NumberFormat format) {
    final Status.StoredFieldStatus status = new Status.StoredFieldStatus();

    try {
      if (infoStream != null) {
        infoStream.print("    test: stored fields.......");
      }

      // Scan stored fields for all documents
      for (int j = 0; j < info.docCount; ++j) {
        if (!reader.isDeleted(j)) {
          status.docCount++;
          Document doc = reader.document(j);
          status.totFields += doc.getFields().size();
        }
      }      

      // Validate docCount
      if (status.docCount != reader.numDocs()) {
        throw new RuntimeException("docCount=" + status.docCount + " but saw " + status.docCount + " undeleted docs");
      }

      msg("OK [" + status.totFields + " total field count; avg " + 
          format.format((((float) status.totFields)/status.docCount)) + " fields per doc]");      
    } catch (Throwable e) {
      msg("ERROR [" + String.valueOf(e.getMessage()) + "]");
      status.error = e;
      if (infoStream != null) {
        e.printStackTrace(infoStream);
      }
    }

    return status;
  }
,
>
, <(startLine=108 endLine=130 srcPath=/home/sonia/NewExperiment/luceneFilter/01276/solr/solrj/src/java/org/apache/solr/common/util/XML.java)
  public final static void writeUnescapedXML(Writer out, String tag, String val, Object... attrs) throws IOException {
    out.write('<');
    out.write(tag);
    for (int i=0; i<attrs.length; i++) {
      out.write(' ');
      out.write(attrs[i++].toString());
      out.write('=');
      out.write('"');
      out.write(attrs[i].toString());
      out.write('"');
    }
    if (val == null) {
      out.write('/');
      out.write('>');
    } else {
      out.write('>');
      out.write(val);
      out.write('<');
      out.write('/');
      out.write(tag);
      out.write('>');
    }
  }
,
(startLine=133 endLine=155 srcPath=/home/sonia/NewExperiment/luceneFilter/01276/solr/solrj/src/java/org/apache/solr/common/util/XML.java)
  public final static void writeXML(Writer out, String tag, String val, Object... attrs) throws IOException {
    out.write('<');
    out.write(tag);
    for (int i=0; i<attrs.length; i++) {
      out.write(' ');
      out.write(attrs[i++].toString());
      out.write('=');
      out.write('"');
      escapeAttributeValue(attrs[i].toString(), out);
      out.write('"');
    }
    if (val == null) {
      out.write('/');
      out.write('>');
    } else {
      out.write('>');
      escapeCharData(val,out);
      out.write('<');
      out.write('/');
      out.write(tag);
      out.write('>');
    }
  }
,
>
, <(startLine=153 endLine=167 srcPath=/home/sonia/NewExperiment/luceneFilter/00136/sandbox/contributions/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    {
        doSearching("Kennedy");
//        QueryHighlightExtractor highlighter = new QueryHighlightExtractor(this, query, new StandardAnalyzer());
        Highlighter highlighter =new Highlighter(this,new QueryScorer(query));
        highlighter.setTextFragmenter(new SimpleFragmenter(40));

        for (int i = 0; i < hits.length(); i++)
        {
            String text = hits.doc(i).get(FIELD_NAME);
            TokenStream tokenStream=analyzer.tokenStream(FIELD_NAME,new StringReader(text));
            String result = highlighter.getBestFragment(tokenStream,text);
            System.out.println("\t" + result);
        }
        assertTrue("Failed to find correct number of highlights " + numHighlights + " found", numHighlights == 4);
    }
,
(startLine=217 endLine=231 srcPath=/home/sonia/NewExperiment/luceneFilter/00136/sandbox/contributions/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    {
        doSearching("Kennedy");
        Highlighter highlighter =
            new Highlighter(this,new QueryScorer(query));

        for (int i = 0; i < hits.length(); i++)
        {
            String text = hits.doc(i).get(FIELD_NAME);
            TokenStream tokenStream=analyzer.tokenStream(FIELD_NAME,new StringReader(text));

            String result = highlighter.getBestFragment(tokenStream,text);
            System.out.println("\t" + result);
        }
        assertTrue("Failed to find correct number of highlights " + numHighlights + " found", numHighlights == 4);
    }
,
>
, <(startLine=230 endLine=244 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/src/test/org/apache/lucene/search/spans/TestBasics.java)
  public void testNpeInSpanNearInSpanFirstInSpanNot() throws Exception {
    int n = 5;
    SpanTermQuery hun = new SpanTermQuery(new Term("field", "hundred"));
    SpanTermQuery term40 = new SpanTermQuery(new Term("field", "forty"));
    SpanTermQuery term40c = (SpanTermQuery)term40.clone();

    SpanFirstQuery include = new SpanFirstQuery(term40, n);
    SpanNearQuery near = new SpanNearQuery(new SpanQuery[]{hun, term40c},
                                           n-1, true);
    SpanFirstQuery exclude = new SpanFirstQuery(near, n-1);
    SpanNotQuery q = new SpanNotQuery(include, exclude);
    
    checkHits(q, new int[]{40,41,42,43,44,45,46,47,48,49});
    
  }
,
(startLine=229 endLine=243 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/backwards/src/test/org/apache/lucene/search/spans/TestBasics.java)
  public void testNpeInSpanNearInSpanFirstInSpanNot() throws Exception {
    int n = 5;
    SpanTermQuery hun = new SpanTermQuery(new Term("field", "hundred"));
    SpanTermQuery term40 = new SpanTermQuery(new Term("field", "forty"));
    SpanTermQuery term40c = (SpanTermQuery)term40.clone();

    SpanFirstQuery include = new SpanFirstQuery(term40, n);
    SpanNearQuery near = new SpanNearQuery(new SpanQuery[]{hun, term40c},
                                           n-1, true);
    SpanFirstQuery exclude = new SpanFirstQuery(near, n-1);
    SpanNotQuery q = new SpanNotQuery(include, exclude);
    
    checkHits(q, new int[]{40,41,42,43,44,45,46,47,48,49});
    
  }
,
>
, <(startLine=96 endLine=116 srcPath=/home/sonia/NewExperiment/luceneFilter/00704/lucene/src/java/org/apache/lucene/document/CompressionTools.java)
  public static byte[] decompress(byte[] value) throws DataFormatException {
    // Create an expandable byte array to hold the decompressed data
    ByteArrayOutputStream bos = new ByteArrayOutputStream(value.length);

    Inflater decompressor = new Inflater();

    try {
      decompressor.setInput(value);

      // Decompress the data
      final byte[] buf = new byte[1024];
      while (!decompressor.finished()) {
        int count = decompressor.inflate(buf);
        bos.write(buf, 0, count);
      }
    } finally {  
      decompressor.end();
    }
    
    return bos.toByteArray();
  }
,
(startLine=94 endLine=114 srcPath=/home/sonia/NewExperiment/luceneFilter/00704/lucene/backwards/src/java/org/apache/lucene/document/CompressionTools.java)
  public static byte[] decompress(byte[] value) throws DataFormatException {
    // Create an expandable byte array to hold the decompressed data
    ByteArrayOutputStream bos = new ByteArrayOutputStream(value.length);

    Inflater decompressor = new Inflater();

    try {
      decompressor.setInput(value);

      // Decompress the data
      final byte[] buf = new byte[1024];
      while (!decompressor.finished()) {
        int count = decompressor.inflate(buf);
        bos.write(buf, 0, count);
      }
    } finally {  
      decompressor.end();
    }
    
    return bos.toByteArray();
  }
,
>
, <(startLine=152 endLine=174 srcPath=/home/sonia/NewExperiment/luceneFilter/00698/lucene/src/test/org/apache/lucene/search/TestMultiThreadTermVectors.java)
  private void testTermVectors() throws Exception {
    // check:
    int numDocs = reader.numDocs();
    long start = 0L;
    for (int docId = 0; docId < numDocs; docId++) {
      start = System.currentTimeMillis();
      TermFreqVector [] vectors = reader.getTermFreqVectors(docId);
      timeElapsed += System.currentTimeMillis()-start;
      
      // verify vectors result
      verifyVectors(vectors, docId);
      
      start = System.currentTimeMillis();
      TermFreqVector vector = reader.getTermFreqVector(docId, "field");
      timeElapsed += System.currentTimeMillis()-start;
      
      vectors = new TermFreqVector[1];
      vectors[0] = vector;
      
      verifyVectors(vectors, docId);
      
    }
  }
,
(startLine=152 endLine=174 srcPath=/home/sonia/NewExperiment/luceneFilter/00698/lucene/backwards/src/test/org/apache/lucene/search/TestMultiThreadTermVectors.java)
  private void testTermVectors() throws Exception {
    // check:
    int numDocs = reader.numDocs();
    long start = 0L;
    for (int docId = 0; docId < numDocs; docId++) {
      start = System.currentTimeMillis();
      TermFreqVector [] vectors = reader.getTermFreqVectors(docId);
      timeElapsed += System.currentTimeMillis()-start;
      
      // verify vectors result
      verifyVectors(vectors, docId);
      
      start = System.currentTimeMillis();
      TermFreqVector vector = reader.getTermFreqVector(docId, "field");
      timeElapsed += System.currentTimeMillis()-start;
      
      vectors = new TermFreqVector[1];
      vectors[0] = vector;
      
      verifyVectors(vectors, docId);
      
    }
  }
,
>
, <(startLine=158 endLine=168 srcPath=/home/sonia/NewExperiment/luceneFilter/00690/lucene/contrib/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/WriteLineDocTaskTest.java)
  public void testBZip2() throws Exception {
    
    // Create a document in bz2 format.
    File file = new File(getWorkDir(), "one-line.bz2");
    PerfRunData runData = createPerfRunData(file, true, "true", WriteLineDocMaker.class.getName());
    WriteLineDocTask wldt = new WriteLineDocTask(runData);
    wldt.doLogic();
    wldt.close();
    
    doReadTest(file, true, "title", "date", "body");
  }
,
(startLine=170 endLine=180 srcPath=/home/sonia/NewExperiment/luceneFilter/00690/lucene/contrib/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/WriteLineDocTaskTest.java)
  public void testBZip2AutoDetect() throws Exception {
    
    // Create a document in bz2 format.
    File file = new File(getWorkDir(), "one-line.bz2");
    PerfRunData runData = createPerfRunData(file, false, null, WriteLineDocMaker.class.getName());
    WriteLineDocTask wldt = new WriteLineDocTask(runData);
    wldt.doLogic();
    wldt.close();
    
    doReadTest(file, true, "title", "date", "body");
  }
,
(startLine=182 endLine=192 srcPath=/home/sonia/NewExperiment/luceneFilter/00690/lucene/contrib/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/WriteLineDocTaskTest.java)
  public void testRegularFile() throws Exception {
    
    // Create a document in regular format.
    File file = new File(getWorkDir(), "one-line");
    PerfRunData runData = createPerfRunData(file, true, "false", WriteLineDocMaker.class.getName());
    WriteLineDocTask wldt = new WriteLineDocTask(runData);
    wldt.doLogic();
    wldt.close();
    
    doReadTest(file, false, "title", "date", "body");
  }
,
(startLine=194 endLine=205 srcPath=/home/sonia/NewExperiment/luceneFilter/00690/lucene/contrib/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/WriteLineDocTaskTest.java)
  public void testCharsReplace() throws Exception {
    // WriteLineDocTask replaced only \t characters w/ a space, since that's its
    // separator char. However, it didn't replace newline characters, which
    // resulted in errors in LineDocSource.
    File file = new File(getWorkDir(), "one-line");
    PerfRunData runData = createPerfRunData(file, false, null, NewLinesDocMaker.class.getName());
    WriteLineDocTask wldt = new WriteLineDocTask(runData);
    wldt.doLogic();
    wldt.close();
    
    doReadTest(file, false, "title text", "date text", "body text two");
  }
,
(startLine=207 endLine=218 srcPath=/home/sonia/NewExperiment/luceneFilter/00690/lucene/contrib/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/WriteLineDocTaskTest.java)
  public void testEmptyBody() throws Exception {
    // WriteLineDocTask threw away documents w/ no BODY element, even if they
    // had a TITLE element (LUCENE-1755). It should throw away documents if they
    // don't have BODY nor TITLE
    File file = new File(getWorkDir(), "one-line");
    PerfRunData runData = createPerfRunData(file, false, null, NoBodyDocMaker.class.getName());
    WriteLineDocTask wldt = new WriteLineDocTask(runData);
    wldt.doLogic();
    wldt.close();
    
    doReadTest(file, false, "title", "date", null);
  }
,
(startLine=220 endLine=228 srcPath=/home/sonia/NewExperiment/luceneFilter/00690/lucene/contrib/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/WriteLineDocTaskTest.java)
  public void testEmptyTitle() throws Exception {
    File file = new File(getWorkDir(), "one-line");
    PerfRunData runData = createPerfRunData(file, false, null, NoTitleDocMaker.class.getName());
    WriteLineDocTask wldt = new WriteLineDocTask(runData);
    wldt.doLogic();
    wldt.close();
    
    doReadTest(file, false, "", "date", "body");
  }
,
>
, <(startLine=130 endLine=180 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/solr/src/common/org/apache/solr/common/util/Hash.java)
  public static int lookup3ycs(CharSequence s, int start, int end, int initval) {
    int a,b,c;
    a = b = c = 0xdeadbeef + initval;
    // only difference from lookup3 is that "+ (length<<2)" is missing
    // since we don't know the number of code points to start with,
    // and don't want to have to pre-scan the string to find out.

    int i=start;
    boolean mixed=true;  // have the 3 state variables been adequately mixed?
    for(;;) {
      if (i>= end) break;
      mixed=false;
      char ch;
      ch = s.charAt(i++);
      a += Character.isHighSurrogate(ch) && i< end ? Character.toCodePoint(ch, s.charAt(i++)) : ch;
      if (i>= end) break;
      ch = s.charAt(i++);
      b += Character.isHighSurrogate(ch) && i< end ? Character.toCodePoint(ch, s.charAt(i++)) : ch;
      if (i>= end) break;
      ch = s.charAt(i++);
      c += Character.isHighSurrogate(ch) && i< end ? Character.toCodePoint(ch, s.charAt(i++)) : ch;
      if (i>= end) break;

      // mix(a,b,c)... Java needs "out" parameters!!!
      // Note: recent JVMs (Sun JDK6) turn pairs of shifts (needed to do a rotate)
      // into real x86 rotate instructions.
      {
        a -= c;  a ^= (c<<4)|(c>>>-4);   c += b;
        b -= a;  b ^= (a<<6)|(a>>>-6);   a += c;
        c -= b;  c ^= (b<<8)|(b>>>-8);   b += a;
        a -= c;  a ^= (c<<16)|(c>>>-16); c += b;
        b -= a;  b ^= (a<<19)|(a>>>-19); a += c;
        c -= b;  c ^= (b<<4)|(b>>>-4);   b += a;
      }
      mixed=true;
    }


    if (!mixed) {
      // final(a,b,c)
        c ^= b; c -= (b<<14)|(b>>>-14);
        a ^= c; a -= (c<<11)|(c>>>-11);
        b ^= a; b -= (a<<25)|(a>>>-25);
        c ^= b; c -= (b<<16)|(b>>>-16);
        a ^= c; a -= (c<<4)|(c>>>-4);
        b ^= a; b -= (a<<14)|(a>>>-14);
        c ^= b; c -= (b<<24)|(b>>>-24);
    }

    return c;
  }
,
(startLine=189 endLine=240 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/solr/src/common/org/apache/solr/common/util/Hash.java)
  public static long lookup3ycs64(CharSequence s, int start, int end, long initval) {
    int a,b,c;
    a = b = c = 0xdeadbeef + (int)initval;
    c += (int)(initval>>>32);
    // only difference from lookup3 is that "+ (length<<2)" is missing
    // since we don't know the number of code points to start with,
    // and don't want to have to pre-scan the string to find out.

    int i=start;
    boolean mixed=true;  // have the 3 state variables been adequately mixed?
    for(;;) {
      if (i>= end) break;
      mixed=false;
      char ch;
      ch = s.charAt(i++);
      a += Character.isHighSurrogate(ch) && i< end ? Character.toCodePoint(ch, s.charAt(i++)) : ch;
      if (i>= end) break;
      ch = s.charAt(i++);
      b += Character.isHighSurrogate(ch) && i< end ? Character.toCodePoint(ch, s.charAt(i++)) : ch;
      if (i>= end) break;
      ch = s.charAt(i++);
      c += Character.isHighSurrogate(ch) && i< end ? Character.toCodePoint(ch, s.charAt(i++)) : ch;
      if (i>= end) break;

      // mix(a,b,c)... Java needs "out" parameters!!!
      // Note: recent JVMs (Sun JDK6) turn pairs of shifts (needed to do a rotate)
      // into real x86 rotate instructions.
      {
        a -= c;  a ^= (c<<4)|(c>>>-4);   c += b;
        b -= a;  b ^= (a<<6)|(a>>>-6);   a += c;
        c -= b;  c ^= (b<<8)|(b>>>-8);   b += a;
        a -= c;  a ^= (c<<16)|(c>>>-16); c += b;
        b -= a;  b ^= (a<<19)|(a>>>-19); a += c;
        c -= b;  c ^= (b<<4)|(b>>>-4);   b += a;
      }
      mixed=true;
    }


    if (!mixed) {
      // final(a,b,c)
        c ^= b; c -= (b<<14)|(b>>>-14);
        a ^= c; a -= (c<<11)|(c>>>-11);
        b ^= a; b -= (a<<25)|(a>>>-25);
        c ^= b; c -= (b<<16)|(b>>>-16);
        a ^= c; a -= (c<<4)|(c>>>-4);
        b ^= a; b -= (a<<14)|(a>>>-14);
        c ^= b; c -= (b<<24)|(b>>>-24);
    }

    return c + (((long)b) << 32);
  }
,
>
, <(startLine=92 endLine=101 srcPath=/home/sonia/NewExperiment/luceneFilter/00671/lucene/src/java/org/apache/lucene/search/ConjunctionScorer.java)
  private int doNext() throws IOException {
    int first = 0;
    int doc = scorers[scorers.length - 1].docID();
    Scorer firstScorer;
    while ((firstScorer = scorers[first]).docID() < doc) {
      doc = firstScorer.advance(doc);
      first = first == scorers.length - 1 ? 0 : first + 1;
    }
    return doc;
  }
,
(startLine=92 endLine=101 srcPath=/home/sonia/NewExperiment/luceneFilter/00671/lucene/backwards/src/java/org/apache/lucene/search/ConjunctionScorer.java)
  private int doNext() throws IOException {
    int first = 0;
    int doc = scorers[scorers.length - 1].docID();
    Scorer firstScorer;
    while ((firstScorer = scorers[first]).docID() < doc) {
      doc = firstScorer.advance(doc);
      first = first == scorers.length - 1 ? 0 : first + 1;
    }
    return doc;
  }
,
>
, <(startLine=4080 endLine=4122 srcPath=/home/sonia/NewExperiment/luceneFilter/00685/lucene/src/java/org/apache/lucene/index/IndexWriter.java)
  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException {

    if (merge.registerDone)
      return true;

    if (stopMerges) {
      merge.abort();
      throw new MergePolicy.MergeAbortedException("merge is aborted: " + merge.segString(directory));
    }

    final int count = merge.segments.size();
    boolean isExternal = false;
    for(int i=0;i<count;i++) {
      final SegmentInfo info = merge.segments.info(i);
      if (mergingSegments.contains(info))
        return false;
      if (segmentInfos.indexOf(info) == -1)
        return false;
      if (info.dir != directory)
        isExternal = true;
    }

    ensureContiguousMerge(merge);

    pendingMerges.add(merge);

    if (infoStream != null)
      message("add merge to pendingMerges: " + merge.segString(directory) + " [total " + pendingMerges.size() + " pending]");

    merge.mergeGen = mergeGen;
    merge.isExternal = isExternal;

    // OK it does not conflict; now record that this merge
    // is running (while synchronized) to avoid race
    // condition where two conflicting merges from different
    // threads, start
    for(int i=0;i<count;i++)
      mergingSegments.add(merge.segments.info(i));

    // Merge is now registered
    merge.registerDone = true;
    return true;
  }
,
(startLine=3939 endLine=3981 srcPath=/home/sonia/NewExperiment/luceneFilter/00685/lucene/backwards/src/java/org/apache/lucene/index/IndexWriter.java)
  final synchronized boolean registerMerge(MergePolicy.OneMerge merge) throws MergePolicy.MergeAbortedException {

    if (merge.registerDone)
      return true;

    if (stopMerges) {
      merge.abort();
      throw new MergePolicy.MergeAbortedException("merge is aborted: " + merge.segString(directory));
    }

    final int count = merge.segments.size();
    boolean isExternal = false;
    for(int i=0;i<count;i++) {
      final SegmentInfo info = merge.segments.info(i);
      if (mergingSegments.contains(info))
        return false;
      if (segmentInfos.indexOf(info) == -1)
        return false;
      if (info.dir != directory)
        isExternal = true;
    }

    ensureContiguousMerge(merge);

    pendingMerges.add(merge);

    if (infoStream != null)
      message("add merge to pendingMerges: " + merge.segString(directory) + " [total " + pendingMerges.size() + " pending]");

    merge.mergeGen = mergeGen;
    merge.isExternal = isExternal;

    // OK it does not conflict; now record that this merge
    // is running (while synchronized) to avoid race
    // condition where two conflicting merges from different
    // threads, start
    for(int i=0;i<count;i++)
      mergingSegments.add(merge.segments.info(i));

    // Merge is now registered
    merge.registerDone = true;
    return true;
  }
,
>
, <(startLine=125 endLine=134 srcPath=/home/sonia/NewExperiment/luceneFilter/00199/src/test-deprecated/org/apache/lucene/search/spans/TestBasics.java)
  public void testSpanNearUnordered() throws Exception {
    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "nine"));
    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "six"));
    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                            4, false);

    checkHits(query, new int[]
      {609, 629, 639, 649, 659, 669, 679, 689, 699,
       906, 926, 936, 946, 956, 966, 976, 986, 996});
  }
,
(startLine=129 endLine=138 srcPath=/home/sonia/NewExperiment/luceneFilter/00199/src/test/org/apache/lucene/search/spans/TestBasics.java)
  public void testSpanNearUnordered() throws Exception {
    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "nine"));
    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "six"));
    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                            4, false);

    checkHits(query, new int[]
      {609, 629, 639, 649, 659, 669, 679, 689, 699,
       906, 926, 936, 946, 956, 966, 976, 986, 996});
  }
,
>
, <(startLine=4083 endLine=4116 srcPath=/home/sonia/NewExperiment/luceneFilter/00695/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java)
  public void testDoubleOffsetCounting() throws Exception {
    MockRAMDirectory dir = new MockRAMDirectory();
    IndexWriter w = new IndexWriter(dir, new IndexWriterConfig(
        TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)));
    Document doc = new Document();
    Field f = new Field("field", "abcd", Field.Store.NO, Field.Index.NOT_ANALYZED, Field.TermVector.WITH_POSITIONS_OFFSETS);
    doc.add(f);
    doc.add(f);
    Field f2 = new Field("field", "", Field.Store.NO, Field.Index.NOT_ANALYZED, Field.TermVector.WITH_POSITIONS_OFFSETS);
    doc.add(f2);
    doc.add(f);
    w.addDocument(doc);
    w.close();

    IndexReader r = IndexReader.open(dir, true);
    TermVectorOffsetInfo[] termOffsets = ((TermPositionVector) r.getTermFreqVector(0, "field")).getOffsets(0);

    // Token "" occurred once
    assertEquals(1, termOffsets.length);
    assertEquals(8, termOffsets[0].getStartOffset());
    assertEquals(8, termOffsets[0].getEndOffset());

    // Token "abcd" occurred three times
    termOffsets = ((TermPositionVector) r.getTermFreqVector(0, "field")).getOffsets(1);
    assertEquals(3, termOffsets.length);
    assertEquals(0, termOffsets[0].getStartOffset());
    assertEquals(4, termOffsets[0].getEndOffset());
    assertEquals(4, termOffsets[1].getStartOffset());
    assertEquals(8, termOffsets[1].getEndOffset());
    assertEquals(8, termOffsets[2].getStartOffset());
    assertEquals(12, termOffsets[2].getEndOffset());
    r.close();
    dir.close();
  }
,
(startLine=4090 endLine=4122 srcPath=/home/sonia/NewExperiment/luceneFilter/00695/lucene/backwards/src/test/org/apache/lucene/index/TestIndexWriter.java)
  public void testDoubleOffsetCounting() throws Exception {
    MockRAMDirectory dir = new MockRAMDirectory();
    IndexWriter w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);
    Document doc = new Document();
    Field f = new Field("field", "abcd", Field.Store.NO, Field.Index.NOT_ANALYZED, Field.TermVector.WITH_POSITIONS_OFFSETS);
    doc.add(f);
    doc.add(f);
    Field f2 = new Field("field", "", Field.Store.NO, Field.Index.NOT_ANALYZED, Field.TermVector.WITH_POSITIONS_OFFSETS);
    doc.add(f2);
    doc.add(f);
    w.addDocument(doc);
    w.close();

    IndexReader r = IndexReader.open(dir, true);
    TermVectorOffsetInfo[] termOffsets = ((TermPositionVector) r.getTermFreqVector(0, "field")).getOffsets(0);

    // Token "" occurred once
    assertEquals(1, termOffsets.length);
    assertEquals(8, termOffsets[0].getStartOffset());
    assertEquals(8, termOffsets[0].getEndOffset());

    // Token "abcd" occurred three times
    termOffsets = ((TermPositionVector) r.getTermFreqVector(0, "field")).getOffsets(1);
    assertEquals(3, termOffsets.length);
    assertEquals(0, termOffsets[0].getStartOffset());
    assertEquals(4, termOffsets[0].getEndOffset());
    assertEquals(4, termOffsets[1].getStartOffset());
    assertEquals(8, termOffsets[1].getEndOffset());
    assertEquals(8, termOffsets[2].getStartOffset());
    assertEquals(12, termOffsets[2].getEndOffset());
    r.close();
    dir.close();
  }
,
>
, <(startLine=119 endLine=128 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java)
    boolean testPoint(String name) {
      if (doFail.get() != null && !name.equals("startDoFlush") && r.nextInt(20) == 17) {
        if (VERBOSE) {
          System.out.println(Thread.currentThread().getName() + ": NOW FAIL: " + name);
          //new Throwable().printStackTrace(System.out);
        }
        throw new RuntimeException(Thread.currentThread().getName() + ": intentionally failing at " + name);
      }
      return true;
    }
,
(startLine=122 endLine=131 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/backwards/src/test/org/apache/lucene/index/TestIndexWriterExceptions.java)
    boolean testPoint(String name) {
      if (doFail.get() != null && !name.equals("startDoFlush") && r.nextInt(20) == 17) {
        if (DEBUG) {
          System.out.println(Thread.currentThread().getName() + ": NOW FAIL: " + name);
          //new Throwable().printStackTrace(System.out);
        }
        throw new RuntimeException(Thread.currentThread().getName() + ": intentionally failing at " + name);
      }
      return true;
    }
,
>
, <(startLine=48 endLine=63 srcPath=/home/sonia/NewExperiment/luceneFilter/00669/lucene/src/demo/org/apache/lucene/demo/html/SimpleCharStream.java)
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           System.arraycopy(buffer, 0, newbuffer,
                                             bufsize - tokenBegin, bufpos);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
           bufcolumn = newbufcolumn;

           maxNextCharInd = (bufpos += (bufsize - tokenBegin));
        }
,
(startLine=98 endLine=112 srcPath=/home/sonia/NewExperiment/luceneFilter/00669/lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java)
      {
        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
        buffer = newbuffer;

        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
        bufline = newbufline;

        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
        bufcolumn = newbufcolumn;

        bufpos += (bufsize - tokenBegin);
    }
,
(startLine=48 endLine=63 srcPath=/home/sonia/NewExperiment/luceneFilter/00669/lucene/backwards/src/demo/org/apache/lucene/demo/html/SimpleCharStream.java)
        {
           System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
           System.arraycopy(buffer, 0, newbuffer,
                                             bufsize - tokenBegin, bufpos);
           buffer = newbuffer;

           System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
           System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
           bufline = newbufline;

           System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
           System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
           bufcolumn = newbufcolumn;

           maxNextCharInd = (bufpos += (bufsize - tokenBegin));
        }
,
>
, <(startLine=361 endLine=447 srcPath=/home/sonia/NewExperiment/luceneFilter/01934/lucene/core/src/java/org/apache/lucene/codecs/lucene42/Lucene42DocValuesProducer.java)
  public SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {
    final FSTEntry entry = fsts.get(field.number);
    if (entry.numOrds == 0) {
      return SortedSetDocValues.EMPTY; // empty FST!
    }
    FST<Long> instance;
    synchronized(this) {
      instance = fstInstances.get(field.number);
      if (instance == null) {
        data.seek(entry.offset);
        instance = new FST<Long>(data, PositiveIntOutputs.getSingleton());
        fstInstances.put(field.number, instance);
      }
    }
    final BinaryDocValues docToOrds = getBinary(field);
    final FST<Long> fst = instance;
    
    // per-thread resources
    final BytesReader in = fst.getBytesReader();
    final Arc<Long> firstArc = new Arc<Long>();
    final Arc<Long> scratchArc = new Arc<Long>();
    final IntsRef scratchInts = new IntsRef();
    final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst); 
    final BytesRef ref = new BytesRef();
    final ByteArrayDataInput input = new ByteArrayDataInput();
    return new SortedSetDocValues() {
      long currentOrd;

      @Override
      public long nextOrd() {
        if (input.eof()) {
          return NO_MORE_ORDS;
        } else {
          currentOrd += input.readVLong();
          return currentOrd;
        }
      }
      
      @Override
      public void setDocument(int docID) {
        docToOrds.get(docID, ref);
        input.reset(ref.bytes, ref.offset, ref.length);
        currentOrd = 0;
      }

      @Override
      public void lookupOrd(long ord, BytesRef result) {
        try {
          in.setPosition(0);
          fst.getFirstArc(firstArc);
          IntsRef output = Util.getByOutput(fst, ord, in, firstArc, scratchArc, scratchInts);
          result.bytes = new byte[output.length];
          result.offset = 0;
          result.length = 0;
          Util.toBytesRef(output, result);
        } catch (IOException bogus) {
          throw new RuntimeException(bogus);
        }
      }

      @Override
      public long lookupTerm(BytesRef key) {
        try {
          InputOutput<Long> o = fstEnum.seekCeil(key);
          if (o == null) {
            return -getValueCount()-1;
          } else if (o.input.equals(key)) {
            return o.output.intValue();
          } else {
            return -o.output-1;
          }
        } catch (IOException bogus) {
          throw new RuntimeException(bogus);
        }
      }

      @Override
      public long getValueCount() {
        return entry.numOrds;
      }

      @Override
      public TermsEnum termsEnum() {
        return new FSTTermsEnum(fst);
      }
    };
  }
,
(startLine=380 endLine=466 srcPath=/home/sonia/NewExperiment/luceneFilter/01934/lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java)
  public SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {
    final FSTEntry entry = fsts.get(field.number);
    if (entry.numOrds == 0) {
      return SortedSetDocValues.EMPTY; // empty FST!
    }
    FST<Long> instance;
    synchronized(this) {
      instance = fstInstances.get(field.number);
      if (instance == null) {
        data.seek(entry.offset);
        instance = new FST<Long>(data, PositiveIntOutputs.getSingleton());
        fstInstances.put(field.number, instance);
      }
    }
    final BinaryDocValues docToOrds = getBinary(field);
    final FST<Long> fst = instance;
    
    // per-thread resources
    final BytesReader in = fst.getBytesReader();
    final Arc<Long> firstArc = new Arc<Long>();
    final Arc<Long> scratchArc = new Arc<Long>();
    final IntsRef scratchInts = new IntsRef();
    final BytesRefFSTEnum<Long> fstEnum = new BytesRefFSTEnum<Long>(fst); 
    final BytesRef ref = new BytesRef();
    final ByteArrayDataInput input = new ByteArrayDataInput();
    return new SortedSetDocValues() {
      long currentOrd;

      @Override
      public long nextOrd() {
        if (input.eof()) {
          return NO_MORE_ORDS;
        } else {
          currentOrd += input.readVLong();
          return currentOrd;
        }
      }
      
      @Override
      public void setDocument(int docID) {
        docToOrds.get(docID, ref);
        input.reset(ref.bytes, ref.offset, ref.length);
        currentOrd = 0;
      }

      @Override
      public void lookupOrd(long ord, BytesRef result) {
        try {
          in.setPosition(0);
          fst.getFirstArc(firstArc);
          IntsRef output = Util.getByOutput(fst, ord, in, firstArc, scratchArc, scratchInts);
          result.bytes = new byte[output.length];
          result.offset = 0;
          result.length = 0;
          Util.toBytesRef(output, result);
        } catch (IOException bogus) {
          throw new RuntimeException(bogus);
        }
      }

      @Override
      public long lookupTerm(BytesRef key) {
        try {
          InputOutput<Long> o = fstEnum.seekCeil(key);
          if (o == null) {
            return -getValueCount()-1;
          } else if (o.input.equals(key)) {
            return o.output.intValue();
          } else {
            return -o.output-1;
          }
        } catch (IOException bogus) {
          throw new RuntimeException(bogus);
        }
      }

      @Override
      public long getValueCount() {
        return entry.numOrds;
      }

      @Override
      public TermsEnum termsEnum() {
        return new FSTTermsEnum(fst);
      }
    };
  }
,
>
, <(startLine=224 endLine=283 srcPath=/home/sonia/NewExperiment/luceneFilter/01726/lucene/analysis/common/src/java/org/tartarus/snowball/ext/FrenchStemmer.java)
                                        lab5: do {
                                            // (, line 40
                                            if (!(in_grouping(g_v, 97, 251)))
                                            {
                                                break lab5;
                                            }
                                            // [, line 40
                                            bra = cursor;
                                            // or, line 40
                                            lab6: do {
                                                v_4 = cursor;
                                                lab7: do {
                                                    // (, line 40
                                                    // literal, line 40
                                                    if (!(eq_s(1, "u")))
                                                    {
                                                        break lab7;
                                                    }
                                                    // ], line 40
                                                    ket = cursor;
                                                    if (!(in_grouping(g_v, 97, 251)))
                                                    {
                                                        break lab7;
                                                    }
                                                    // <-, line 40
                                                    slice_from("U");
                                                    break lab6;
                                                } while (false);
                                                cursor = v_4;
                                                lab8: do {
                                                    // (, line 41
                                                    // literal, line 41
                                                    if (!(eq_s(1, "i")))
                                                    {
                                                        break lab8;
                                                    }
                                                    // ], line 41
                                                    ket = cursor;
                                                    if (!(in_grouping(g_v, 97, 251)))
                                                    {
                                                        break lab8;
                                                    }
                                                    // <-, line 41
                                                    slice_from("I");
                                                    break lab6;
                                                } while (false);
                                                cursor = v_4;
                                                // (, line 42
                                                // literal, line 42
                                                if (!(eq_s(1, "y")))
                                                {
                                                    break lab5;
                                                }
                                                // ], line 42
                                                ket = cursor;
                                                // <-, line 42
                                                slice_from("Y");
                                            } while (false);
                                            break lab4;
                                        } while (false);
,
(startLine=334 endLine=399 srcPath=/home/sonia/NewExperiment/luceneFilter/01726/lucene/analysis/common/src/java/org/tartarus/snowball/ext/ItalianStemmer.java)
                    {
                        v_3 = cursor;
                        lab3: do {
                            // goto, line 46
                            golab4: while(true)
                            {
                                v_4 = cursor;
                                lab5: do {
                                    // (, line 46
                                    if (!(in_grouping(g_v, 97, 249)))
                                    {
                                        break lab5;
                                    }
                                    // [, line 47
                                    bra = cursor;
                                    // or, line 47
                                    lab6: do {
                                        v_5 = cursor;
                                        lab7: do {
                                            // (, line 47
                                            // literal, line 47
                                            if (!(eq_s(1, "u")))
                                            {
                                                break lab7;
                                            }
                                            // ], line 47
                                            ket = cursor;
                                            if (!(in_grouping(g_v, 97, 249)))
                                            {
                                                break lab7;
                                            }
                                            // <-, line 47
                                            slice_from("U");
                                            break lab6;
                                        } while (false);
                                        cursor = v_5;
                                        // (, line 48
                                        // literal, line 48
                                        if (!(eq_s(1, "i")))
                                        {
                                            break lab5;
                                        }
                                        // ], line 48
                                        ket = cursor;
                                        if (!(in_grouping(g_v, 97, 249)))
                                        {
                                            break lab5;
                                        }
                                        // <-, line 48
                                        slice_from("I");
                                    } while (false);
                                    cursor = v_4;
                                    break golab4;
                                } while (false);
                                cursor = v_4;
                                if (cursor >= limit)
                                {
                                    break lab3;
                                }
                                cursor++;
                            }
                            continue replab2;
                        } while (false);
                        cursor = v_3;
                        break replab2;
                    }
,
(startLine=99 endLine=164 srcPath=/home/sonia/NewExperiment/luceneFilter/01726/lucene/analysis/common/src/java/org/tartarus/snowball/ext/German2Stemmer.java)
                    {
                        v_2 = cursor;
                        lab1: do {
                            // goto, line 30
                            golab2: while(true)
                            {
                                v_3 = cursor;
                                lab3: do {
                                    // (, line 30
                                    if (!(in_grouping(g_v, 97, 252)))
                                    {
                                        break lab3;
                                    }
                                    // [, line 31
                                    bra = cursor;
                                    // or, line 31
                                    lab4: do {
                                        v_4 = cursor;
                                        lab5: do {
                                            // (, line 31
                                            // literal, line 31
                                            if (!(eq_s(1, "u")))
                                            {
                                                break lab5;
                                            }
                                            // ], line 31
                                            ket = cursor;
                                            if (!(in_grouping(g_v, 97, 252)))
                                            {
                                                break lab5;
                                            }
                                            // <-, line 31
                                            slice_from("U");
                                            break lab4;
                                        } while (false);
                                        cursor = v_4;
                                        // (, line 32
                                        // literal, line 32
                                        if (!(eq_s(1, "y")))
                                        {
                                            break lab3;
                                        }
                                        // ], line 32
                                        ket = cursor;
                                        if (!(in_grouping(g_v, 97, 252)))
                                        {
                                            break lab3;
                                        }
                                        // <-, line 32
                                        slice_from("Y");
                                    } while (false);
                                    cursor = v_3;
                                    break golab2;
                                } while (false);
                                cursor = v_3;
                                if (cursor >= limit)
                                {
                                    break lab1;
                                }
                                cursor++;
                            }
                            continue replab0;
                        } while (false);
                        cursor = v_2;
                        break replab0;
                    }
,
(startLine=128 endLine=193 srcPath=/home/sonia/NewExperiment/luceneFilter/01726/lucene/analysis/common/src/java/org/tartarus/snowball/ext/GermanStemmer.java)
                    {
                        v_4 = cursor;
                        lab5: do {
                            // goto, line 36
                            golab6: while(true)
                            {
                                v_5 = cursor;
                                lab7: do {
                                    // (, line 36
                                    if (!(in_grouping(g_v, 97, 252)))
                                    {
                                        break lab7;
                                    }
                                    // [, line 37
                                    bra = cursor;
                                    // or, line 37
                                    lab8: do {
                                        v_6 = cursor;
                                        lab9: do {
                                            // (, line 37
                                            // literal, line 37
                                            if (!(eq_s(1, "u")))
                                            {
                                                break lab9;
                                            }
                                            // ], line 37
                                            ket = cursor;
                                            if (!(in_grouping(g_v, 97, 252)))
                                            {
                                                break lab9;
                                            }
                                            // <-, line 37
                                            slice_from("U");
                                            break lab8;
                                        } while (false);
                                        cursor = v_6;
                                        // (, line 38
                                        // literal, line 38
                                        if (!(eq_s(1, "y")))
                                        {
                                            break lab7;
                                        }
                                        // ], line 38
                                        ket = cursor;
                                        if (!(in_grouping(g_v, 97, 252)))
                                        {
                                            break lab7;
                                        }
                                        // <-, line 38
                                        slice_from("Y");
                                    } while (false);
                                    cursor = v_5;
                                    break golab6;
                                } while (false);
                                cursor = v_5;
                                if (cursor >= limit)
                                {
                                    break lab5;
                                }
                                cursor++;
                            }
                            continue replab4;
                        } while (false);
                        cursor = v_4;
                        break replab4;
                    }
,
(startLine=278 endLine=352 srcPath=/home/sonia/NewExperiment/luceneFilter/01726/lucene/analysis/common/src/java/org/tartarus/snowball/ext/RomanianStemmer.java)
                private boolean r_prelude() {
            int v_1;
            int v_2;
            int v_3;
                    // (, line 31
                    // repeat, line 32
                    replab0: while(true)
                    {
                        v_1 = cursor;
                        lab1: do {
                            // goto, line 32
                            golab2: while(true)
                            {
                                v_2 = cursor;
                                lab3: do {
                                    // (, line 32
                                    if (!(in_grouping(g_v, 97, 259)))
                                    {
                                        break lab3;
                                    }
                                    // [, line 33
                                    bra = cursor;
                                    // or, line 33
                                    lab4: do {
                                        v_3 = cursor;
                                        lab5: do {
                                            // (, line 33
                                            // literal, line 33
                                            if (!(eq_s(1, "u")))
                                            {
                                                break lab5;
                                            }
                                            // ], line 33
                                            ket = cursor;
                                            if (!(in_grouping(g_v, 97, 259)))
                                            {
                                                break lab5;
                                            }
                                            // <-, line 33
                                            slice_from("U");
                                            break lab4;
                                        } while (false);
                                        cursor = v_3;
                                        // (, line 34
                                        // literal, line 34
                                        if (!(eq_s(1, "i")))
                                        {
                                            break lab3;
                                        }
                                        // ], line 34
                                        ket = cursor;
                                        if (!(in_grouping(g_v, 97, 259)))
                                        {
                                            break lab3;
                                        }
                                        // <-, line 34
                                        slice_from("I");
                                    } while (false);
                                    cursor = v_2;
                                    break golab2;
                                } while (false);
                                cursor = v_2;
                                if (cursor >= limit)
                                {
                                    break lab1;
                                }
                                cursor++;
                            }
                            continue replab0;
                        } while (false);
                        cursor = v_1;
                        break replab0;
                    }
                    return true;
                }
,
>
, <(startLine=86 endLine=102 srcPath=/home/sonia/NewExperiment/luceneFilter/03319/lucene/core/src/java/org/apache/lucene/search/PointInSetQuery.java)
    while ((current = packedPoints.next()) != null) {
      if (current.length != numDims * bytesPerDim) {
        throw new IllegalArgumentException("packed point length should be " + (numDims * bytesPerDim) + " but got " + current.length + "; field=\"" + field + "\" numDims=" + numDims + " bytesPerDim=" + bytesPerDim);
      }
      if (previous == null) {
        previous = new BytesRefBuilder();
      } else {
        int cmp = previous.get().compareTo(current);
        if (cmp == 0) {
          continue; // deduplicate
        } else if (cmp > 0) {
          throw new IllegalArgumentException("values are out of order: saw " + previous + " before " + current);
        }
      }
      builder.add(field, current);
      previous.copyBytes(current);
    }
,
(startLine=522 endLine=538 srcPath=/home/sonia/NewExperiment/luceneFilter/03319/solr/core/src/java/org/apache/solr/search/GraphTermsQParserPlugin.java)
    while ((current = packedPoints.next()) != null) {
      if (current.length != numDims * bytesPerDim) {
        throw new IllegalArgumentException("packed point length should be " + (numDims * bytesPerDim) + " but got " + current.length + "; field=\"" + field + "\" numDims=" + numDims + " bytesPerDim=" + bytesPerDim);
      }
      if (previous == null) {
        previous = new BytesRefBuilder();
      } else {
        int cmp = previous.get().compareTo(current);
        if (cmp == 0) {
          continue; // deduplicate
        } else if (cmp > 0) {
          throw new IllegalArgumentException("values are out of order: saw " + previous + " before " + current);
        }
      }
      builder.add(field, current);
      previous.copyBytes(current);
    }
,
>
, <(startLine=283 endLine=301 srcPath=/home/sonia/NewExperiment/luceneFilter/00678/lucene/src/test/org/apache/lucene/store/TestLockFactory.java)
                if (writer != null) {
                    try {
                        addDoc(writer);
                    } catch (IOException e) {
                        hitException = true;
                        System.out.println("Stress Test Index Writer: addDoc hit unexpected exception: " + e.toString());
                        e.printStackTrace(System.out);
                        break;
                    }
                    try {
                        writer.close();
                    } catch (IOException e) {
                        hitException = true;
                        System.out.println("Stress Test Index Writer: close hit unexpected exception: " + e.toString());
                        e.printStackTrace(System.out);
                        break;
                    }
                    writer = null;
                }
,
(startLine=272 endLine=290 srcPath=/home/sonia/NewExperiment/luceneFilter/00678/lucene/backwards/src/test/org/apache/lucene/store/TestLockFactory.java)
                if (writer != null) {
                    try {
                        addDoc(writer);
                    } catch (IOException e) {
                        hitException = true;
                        System.out.println("Stress Test Index Writer: addDoc hit unexpected exception: " + e.toString());
                        e.printStackTrace(System.out);
                        break;
                    }
                    try {
                        writer.close();
                    } catch (IOException e) {
                        hitException = true;
                        System.out.println("Stress Test Index Writer: close hit unexpected exception: " + e.toString());
                        e.printStackTrace(System.out);
                        break;
                    }
                    writer = null;
                }
,
>
, <(startLine=200 endLine=223 srcPath=/home/sonia/NewExperiment/luceneFilter/03272/solr/core/src/test/org/apache/solr/legacy/TestNumericRangeQuery32.java)
  private void testLeftOpenRange(int precisionStep) throws Exception {
    String field="field"+precisionStep;
    int count=3000;
    int upper=(count-1)*distance + (distance/3) + startOffset;
    LegacyNumericRangeQuery<Integer> q= LegacyNumericRangeQuery.newIntRange(field, precisionStep, null, upper, true, true);
    TopDocs topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
    ScoreDoc[] sd = topDocs.scoreDocs;
    assertNotNull(sd);
    assertEquals("Score doc count", count, sd.length );
    Document doc=searcher.doc(sd[0].doc);
    assertEquals("First doc", startOffset, doc.getField(field).numericValue().intValue());
    doc=searcher.doc(sd[sd.length-1].doc);
    assertEquals("Last doc", (count-1)*distance+startOffset, doc.getField(field).numericValue().intValue());
    
    q= LegacyNumericRangeQuery.newIntRange(field, precisionStep, null, upper, false, true);
    topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
    sd = topDocs.scoreDocs;
    assertNotNull(sd);
    assertEquals("Score doc count", count, sd.length );
    doc=searcher.doc(sd[0].doc);
    assertEquals("First doc", startOffset, doc.getField(field).numericValue().intValue());
    doc=searcher.doc(sd[sd.length-1].doc);
    assertEquals("Last doc", (count-1)*distance+startOffset, doc.getField(field).numericValue().intValue());
  }
,
(startLine=240 endLine=263 srcPath=/home/sonia/NewExperiment/luceneFilter/03272/solr/core/src/test/org/apache/solr/legacy/TestNumericRangeQuery32.java)
  private void testRightOpenRange(int precisionStep) throws Exception {
    String field="field"+precisionStep;
    int count=3000;
    int lower=(count-1)*distance + (distance/3) +startOffset;
    LegacyNumericRangeQuery<Integer> q= LegacyNumericRangeQuery.newIntRange(field, precisionStep, lower, null, true, true);
    TopDocs topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
    ScoreDoc[] sd = topDocs.scoreDocs;
    assertNotNull(sd);
    assertEquals("Score doc count", noDocs-count, sd.length );
    Document doc=searcher.doc(sd[0].doc);
    assertEquals("First doc", count*distance+startOffset, doc.getField(field).numericValue().intValue());
    doc=searcher.doc(sd[sd.length-1].doc);
    assertEquals("Last doc", (noDocs-1)*distance+startOffset, doc.getField(field).numericValue().intValue());

    q= LegacyNumericRangeQuery.newIntRange(field, precisionStep, lower, null, true, false);
    topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
    sd = topDocs.scoreDocs;
    assertNotNull(sd);
    assertEquals("Score doc count", noDocs-count, sd.length );
    doc=searcher.doc(sd[0].doc);
    assertEquals("First doc", count*distance+startOffset, doc.getField(field).numericValue().intValue() );
    doc=searcher.doc(sd[sd.length-1].doc);
    assertEquals("Last doc", (noDocs-1)*distance+startOffset, doc.getField(field).numericValue().intValue() );
  }
,
(startLine=214 endLine=237 srcPath=/home/sonia/NewExperiment/luceneFilter/03272/solr/core/src/test/org/apache/solr/legacy/TestNumericRangeQuery64.java)
  private void testLeftOpenRange(int precisionStep) throws Exception {
    String field="field"+precisionStep;
    int count=3000;
    long upper=(count-1)*distance + (distance/3) + startOffset;
    LegacyNumericRangeQuery<Long> q= LegacyNumericRangeQuery.newLongRange(field, precisionStep, null, upper, true, true);
    TopDocs topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
    ScoreDoc[] sd = topDocs.scoreDocs;
    assertNotNull(sd);
    assertEquals("Score doc count", count, sd.length );
    Document doc=searcher.doc(sd[0].doc);
    assertEquals("First doc", startOffset, doc.getField(field).numericValue().longValue() );
    doc=searcher.doc(sd[sd.length-1].doc);
    assertEquals("Last doc", (count-1)*distance+startOffset, doc.getField(field).numericValue().longValue() );

    q= LegacyNumericRangeQuery.newLongRange(field, precisionStep, null, upper, false, true);
    topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
    sd = topDocs.scoreDocs;
    assertNotNull(sd);
    assertEquals("Score doc count", count, sd.length );
    doc=searcher.doc(sd[0].doc);
    assertEquals("First doc", startOffset, doc.getField(field).numericValue().longValue() );
    doc=searcher.doc(sd[sd.length-1].doc);
    assertEquals("Last doc", (count-1)*distance+startOffset, doc.getField(field).numericValue().longValue() );
  }
,
(startLine=259 endLine=282 srcPath=/home/sonia/NewExperiment/luceneFilter/03272/solr/core/src/test/org/apache/solr/legacy/TestNumericRangeQuery64.java)
  private void testRightOpenRange(int precisionStep) throws Exception {
    String field="field"+precisionStep;
    int count=3000;
    long lower=(count-1)*distance + (distance/3) +startOffset;
    LegacyNumericRangeQuery<Long> q= LegacyNumericRangeQuery.newLongRange(field, precisionStep, lower, null, true, true);
    TopDocs topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
    ScoreDoc[] sd = topDocs.scoreDocs;
    assertNotNull(sd);
    assertEquals("Score doc count", noDocs-count, sd.length );
    Document doc=searcher.doc(sd[0].doc);
    assertEquals("First doc", count*distance+startOffset, doc.getField(field).numericValue().longValue() );
    doc=searcher.doc(sd[sd.length-1].doc);
    assertEquals("Last doc", (noDocs-1)*distance+startOffset, doc.getField(field).numericValue().longValue() );

    q= LegacyNumericRangeQuery.newLongRange(field, precisionStep, lower, null, true, false);
    topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
    sd = topDocs.scoreDocs;
    assertNotNull(sd);
    assertEquals("Score doc count", noDocs-count, sd.length );
    doc=searcher.doc(sd[0].doc);
    assertEquals("First doc", count*distance+startOffset, doc.getField(field).numericValue().longValue() );
    doc=searcher.doc(sd[sd.length-1].doc);
    assertEquals("Last doc", (noDocs-1)*distance+startOffset, doc.getField(field).numericValue().longValue() );
  }
,
>
, <(startLine=172 endLine=196 srcPath=/home/sonia/NewExperiment/luceneFilter/00687/lucene/contrib/db/bdb/src/test/org/apache/lucene/store/db/DbStoreTest.java)
        try {
            txn = env.beginTransaction(null, null);
            store = new DbDirectory(txn, index, blocks);

            gen = new Random(seed);
            start = new Date();

            for (int i = 0; i < count; i++) {
                String name = i + ".dat";
                int length = gen.nextInt() & LENGTH_MASK;
                IndexInput file = store.openInput(name);

                if (file.length() != length)
                    throw new Exception("length incorrect");

                for (int j = 0; j < length; j++) {
                    byte b = (byte)(gen.nextInt() & 0x7F);

                    if (file.readByte() != b)
                        throw new Exception("contents incorrect");
                }

                file.close();
            }
        } catch (IOException e) {
,
(startLine=170 endLine=194 srcPath=/home/sonia/NewExperiment/luceneFilter/00687/lucene/contrib/db/bdb-je/src/test/org/apache/lucene/store/je/JEStoreTest.java)
        try {
            txn = env.beginTransaction(null, null);
            store = new JEDirectory(txn, index, blocks);

            gen = new Random(seed);
            start = new Date();

            for (int i = 0; i < count; i++) {
                String name = i + ".dat";
                int length = gen.nextInt() & LENGTH_MASK;
                IndexInput file = store.openInput(name);

                if (file.length() != length)
                    throw new Exception("length incorrect");

                for (int j = 0; j < length; j++) {
                    byte b = (byte) (gen.nextInt() & 0x7F);

                    if (file.readByte() != b)
                        throw new Exception("contents incorrect");
                }

                file.close();
            }
        } catch (IOException e) {
,
(startLine=359 endLine=389 srcPath=/home/sonia/NewExperiment/luceneFilter/00687/lucene/contrib/db/bdb-je/src/test/org/apache/lucene/store/je/JEStoreTest.java)
        try {
            txn = env.beginTransaction(null, null);
            store = new JEDirectory(txn, index, blocks);

            gen = new Random(seed);
            start = new Date();

            for (int i = 0; i < count; i++) {
                int length = gen.nextInt() & LENGTH_MASK;

                if (i % 2 != 0) {
                    String name = i + ".dat";
                    IndexInput file = store.openInput(name);
                    if (file.length() != length)
                        throw new Exception("length incorrect");

                    for (int j = 0; j < length; j++) {
                        byte b = (byte) (gen.nextInt() & 0x7F);

                        if (file.readByte() != b)
                            throw new Exception("contents incorrect");
                    }

                    file.close();
                } else {
                    for (int j = 0; j < length; j++) {
                        gen.nextInt();
                    }
                }
            }
        } catch (IOException e) {
,
>
, <(startLine=939 endLine=958 srcPath=/home/sonia/NewExperiment/luceneFilter/01850/lucene/core/src/test/org/apache/lucene/index/TestDirectoryReader.java)
  public void testGetSumDocFreq() throws Exception {
    Directory dir = newDirectory();
    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
    Document d = new Document();
    d.add(newTextField("f", "a", Field.Store.NO));
    writer.addDocument(d);
    d = new Document();
    d.add(newTextField("f", "b", Field.Store.NO));
    writer.addDocument(d);
    DirectoryReader r = writer.getReader();
    writer.close();
    try {
      // Make sure codec impls getSumDocFreq (eg PreFlex doesn't)
      Assume.assumeTrue(r.getSumDocFreq("f") != -1);
      assertEquals(2, r.getSumDocFreq("f"));
    } finally {
      r.close();
      dir.close();
    }
  }
,
(startLine=960 endLine=979 srcPath=/home/sonia/NewExperiment/luceneFilter/01850/lucene/core/src/test/org/apache/lucene/index/TestDirectoryReader.java)
  public void testGetDocCount() throws Exception {
    Directory dir = newDirectory();
    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
    Document d = new Document();
    d.add(newTextField("f", "a", Field.Store.NO));
    writer.addDocument(d);
    d = new Document();
    d.add(newTextField("f", "a", Field.Store.NO));
    writer.addDocument(d);
    DirectoryReader r = writer.getReader();
    writer.close();
    try {
      // Make sure codec impls getSumDocFreq (eg PreFlex doesn't)
      Assume.assumeTrue(r.getDocCount("f") != -1);
      assertEquals(2, r.getDocCount("f"));
    } finally {
      r.close();
      dir.close();
    }
  }
,
(startLine=981 endLine=1000 srcPath=/home/sonia/NewExperiment/luceneFilter/01850/lucene/core/src/test/org/apache/lucene/index/TestDirectoryReader.java)
  public void testGetSumTotalTermFreq() throws Exception {
    Directory dir = newDirectory();
    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())));
    Document d = new Document();
    d.add(newTextField("f", "a b b", Field.Store.NO));
    writer.addDocument(d);
    d = new Document();
    d.add(newTextField("f", "a a b", Field.Store.NO));
    writer.addDocument(d);
    DirectoryReader r = writer.getReader();
    writer.close();
    try {
      // Make sure codec impls getSumDocFreq (eg PreFlex doesn't)
      Assume.assumeTrue(r.getSumTotalTermFreq("f") != -1);
      assertEquals(6, r.getSumTotalTermFreq("f"));
    } finally {
      r.close();
      dir.close();
    }
  }
,
>
, <(startLine=206 endLine=215 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/src/test/org/apache/lucene/search/TestFilteredQuery.java)
  public void testBoolean2() throws Exception {
    BooleanQuery bq = new BooleanQuery();
    Query query = new FilteredQuery(bq,
        new SingleDocTestFilter(0));
    bq.add(new TermQuery(new Term("field", "one")), BooleanClause.Occur.SHOULD);
    bq.add(new TermQuery(new Term("field", "two")), BooleanClause.Occur.SHOULD);
    ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;
    assertEquals(1, hits.length);
    QueryUtils.check(query,searcher);    
  }
,
(startLine=207 endLine=216 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/backwards/src/test/org/apache/lucene/search/TestFilteredQuery.java)
  public void testBoolean2() throws Exception {
    BooleanQuery bq = new BooleanQuery();
    Query query = new FilteredQuery(bq,
        new SingleDocTestFilter(0));
    bq.add(new TermQuery(new Term("field", "one")), BooleanClause.Occur.SHOULD);
    bq.add(new TermQuery(new Term("field", "two")), BooleanClause.Occur.SHOULD);
    ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;
    assertEquals(1, hits.length);
    QueryUtils.check(query,searcher);    
  }
,
>
, <(startLine=326 endLine=332 srcPath=/home/sonia/NewExperiment/luceneFilter/02785/solr/core/src/java/org/apache/solr/update/UpdateLog.java)
      for (int i=startingUpdates.deleteByQueryList.size()-1; i>=0; i--) {
        Update update = startingUpdates.deleteByQueryList.get(i);
        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);
        long version = (Long) dbq.get(1);
        String q = (String) dbq.get(2);
        trackDeleteByQuery(q, version);
      }
,
(startLine=251 endLine=257 srcPath=/home/sonia/NewExperiment/luceneFilter/02785/solr/core/src/java/org/apache/solr/update/HdfsUpdateLog.java)
      for (int i = startingUpdates.deleteByQueryList.size() - 1; i >= 0; i--) {
        Update update = startingUpdates.deleteByQueryList.get(i);
        List<Object> dbq = (List<Object>) update.log.lookup(update.pointer);
        long version = (Long) dbq.get(1);
        String q = (String) dbq.get(2);
        trackDeleteByQuery(q, version);
      }
,
>
, <(startLine=1301 endLine=1314 srcPath=/home/sonia/NewExperiment/luceneFilter/01071/lucene/src/java/org/apache/lucene/search/FieldComparator.java)
    public int compare(int slot1, int slot2) {
      final BytesRef val1 = values[slot1];
      final BytesRef val2 = values[slot2];
      if (val1 == null) {
        if (val2 == null) {
          return 0;
        }
        return -1;
      } else if (val2 == null) {
        return 1;
      }

      return val1.compareTo(val2);
    }
,
(startLine=52 endLine=64 srcPath=/home/sonia/NewExperiment/luceneFilter/01071/lucene/contrib/queries/src/java/org/apache/lucene/search/SlowCollatedStringComparator.java)
  public int compare(int slot1, int slot2) {
    final String val1 = values[slot1];
    final String val2 = values[slot2];
    if (val1 == null) {
      if (val2 == null) {
        return 0;
      }
      return -1;
    } else if (val2 == null) {
      return 1;
    }
    return collator.compare(val1, val2);
  }
,
>
, <(startLine=703 endLine=870 srcPath=/home/sonia/NewExperiment/luceneFilter/00698/lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen.java)
  public void testThreadSafety() throws Exception {
    final Directory dir = new MockRAMDirectory();
    final int n = 30;

    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(
        TEST_VERSION_CURRENT, new StandardAnalyzer(TEST_VERSION_CURRENT)));
    for (int i = 0; i < n; i++) {
      writer.addDocument(createDocument(i, 3));
    }
    writer.optimize();
    writer.close();

    final TestReopen test = new TestReopen() {      
      @Override
      protected void modifyIndex(int i) throws IOException {
        if (i % 3 == 0) {
          IndexReader modifier = IndexReader.open(dir, false);
          modifier.setNorm(i, "field1", 50);
          modifier.close();
        } else if (i % 3 == 1) {
          IndexReader modifier = IndexReader.open(dir, false);
          modifier.deleteDocument(i % modifier.maxDoc());
          modifier.close();
        } else {
          IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(
              TEST_VERSION_CURRENT, new StandardAnalyzer(TEST_VERSION_CURRENT)));
          modifier.addDocument(createDocument(n + i, 6));
          modifier.close();
        }
      }

      @Override
      protected IndexReader openReader() throws IOException {
        return IndexReader.open(dir, false);
      }      
    };
    
    final List<ReaderCouple> readers = Collections.synchronizedList(new ArrayList<ReaderCouple>());
    IndexReader firstReader = IndexReader.open(dir, false);
    IndexReader reader = firstReader;
    final Random rnd = newRandom();
    
    ReaderThread[] threads = new ReaderThread[n];
    final Set<IndexReader> readersToClose = Collections.synchronizedSet(new HashSet<IndexReader>());
    
    for (int i = 0; i < n; i++) {
      if (i % 2 == 0) {
        IndexReader refreshed = reader.reopen();
        if (refreshed != reader) {
          readersToClose.add(reader);
        }
        reader = refreshed;
      }
      final IndexReader r = reader;
      
      final int index = i;    
      
      ReaderThreadTask task;
      
      if (i < 4 ||( i >=10 && i < 14) || i > 18) {
        task = new ReaderThreadTask() {
          
          @Override
          public void run() throws Exception {
            while (!stopped) {
              if (index % 2 == 0) {
                // refresh reader synchronized
                ReaderCouple c = (refreshReader(r, test, index, true));
                readersToClose.add(c.newReader);
                readersToClose.add(c.refreshedReader);
                readers.add(c);
                // prevent too many readers
                break;
              } else {
                // not synchronized
                IndexReader refreshed = r.reopen();
                
                
                IndexSearcher searcher = new IndexSearcher(refreshed);
                ScoreDoc[] hits = searcher.search(
                    new TermQuery(new Term("field1", "a" + rnd.nextInt(refreshed.maxDoc()))),
                    null, 1000).scoreDocs;
                if (hits.length > 0) {
                  searcher.doc(hits[0].doc);
                }
                
                // r might have changed because this is not a 
                // synchronized method. However we don't want
                // to make it synchronized to test 
                // thread-safety of IndexReader.close().
                // That's why we add refreshed also to 
                // readersToClose, because double closing is fine
                if (refreshed != r) {
                  refreshed.close();
                }
                readersToClose.add(refreshed);
              }
              synchronized(this) {
                wait(1000);
              }
            }
          }
          
        };
      } else {
        task = new ReaderThreadTask() {
          @Override
          public void run() throws Exception {
            while (!stopped) {
              int numReaders = readers.size();
              if (numReaders > 0) {
                ReaderCouple c =  readers.get(rnd.nextInt(numReaders));
                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);
              }
              
              synchronized(this) {
                wait(100);
              }
            }
                        
          }
          
        };
      }
      
      threads[i] = new ReaderThread(task);
      threads[i].start();
    }
    
    synchronized(this) {
      wait(1000);
    }
    
    for (int i = 0; i < n; i++) {
      if (threads[i] != null) {
        threads[i].stopThread();
      }
    }
    
    for (int i = 0; i < n; i++) {
      if (threads[i] != null) {
        threads[i].join();
        if (threads[i].error != null) {
          String msg = "Error occurred in thread " + threads[i].getName() + ":\n" + threads[i].error.getMessage();
          fail(msg);
        }
      }
      
    }
    
    for (final IndexReader readerToClose : readersToClose) {
      readerToClose.close();
    }
    
    firstReader.close();
    reader.close();
    
    for (final IndexReader readerToClose : readersToClose) {
      assertReaderClosed(readerToClose, true, true);
    }

    assertReaderClosed(reader, true, true);
    assertReaderClosed(firstReader, true, true);

    FlexTestUtil.verifyFlexVsPreFlex(rnd, dir);

    dir.close();
  }
,
(startLine=702 endLine=867 srcPath=/home/sonia/NewExperiment/luceneFilter/00698/lucene/backwards/src/test/org/apache/lucene/index/TestIndexReaderReopen.java)
  public void testThreadSafety() throws Exception {
    final Directory dir = new MockRAMDirectory();
    final int n = 30;

    IndexWriter writer = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);
    for (int i = 0; i < n; i++) {
      writer.addDocument(createDocument(i, 3));
    }
    writer.optimize();
    writer.close();

    final TestReopen test = new TestReopen() {      
      @Override
      protected void modifyIndex(int i) throws IOException {
        if (i % 3 == 0) {
          IndexReader modifier = IndexReader.open(dir, false);
          modifier.setNorm(i, "field1", 50);
          modifier.close();
        } else if (i % 3 == 1) {
          IndexReader modifier = IndexReader.open(dir, false);
          modifier.deleteDocument(i % modifier.maxDoc());
          modifier.close();
        } else {
          IndexWriter modifier = new IndexWriter(dir, new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.LIMITED);
          modifier.addDocument(createDocument(n + i, 6));
          modifier.close();
        }
      }

      @Override
      protected IndexReader openReader() throws IOException {
        return IndexReader.open(dir, false);
      }      
    };
    
    final List readers = Collections.synchronizedList(new ArrayList());
    IndexReader firstReader = IndexReader.open(dir, false);
    IndexReader reader = firstReader;
    final Random rnd = newRandom();
    
    ReaderThread[] threads = new ReaderThread[n];
    final Set readersToClose = Collections.synchronizedSet(new HashSet());
    
    for (int i = 0; i < n; i++) {
      if (i % 2 == 0) {
        IndexReader refreshed = reader.reopen();
        if (refreshed != reader) {
          readersToClose.add(reader);
        }
        reader = refreshed;
      }
      final IndexReader r = reader;
      
      final int index = i;    
      
      ReaderThreadTask task;
      
      if (i < 4 ||( i >=10 && i < 14) || i > 18) {
        task = new ReaderThreadTask() {
          
          @Override
          public void run() throws Exception {
            while (!stopped) {
              if (index % 2 == 0) {
                // refresh reader synchronized
                ReaderCouple c = (refreshReader(r, test, index, true));
                readersToClose.add(c.newReader);
                readersToClose.add(c.refreshedReader);
                readers.add(c);
                // prevent too many readers
                break;
              } else {
                // not synchronized
                IndexReader refreshed = r.reopen();
                
                
                IndexSearcher searcher = new IndexSearcher(refreshed);
                ScoreDoc[] hits = searcher.search(
                    new TermQuery(new Term("field1", "a" + rnd.nextInt(refreshed.maxDoc()))),
                    null, 1000).scoreDocs;
                if (hits.length > 0) {
                  searcher.doc(hits[0].doc);
                }
                
                // r might have changed because this is not a 
                // synchronized method. However we don't want
                // to make it synchronized to test 
                // thread-safety of IndexReader.close().
                // That's why we add refreshed also to 
                // readersToClose, because double closing is fine
                if (refreshed != r) {
                  refreshed.close();
                }
                readersToClose.add(refreshed);
              }
              synchronized(this) {
                wait(1000);
              }
            }
          }
          
        };
      } else {
        task = new ReaderThreadTask() {
          @Override
          public void run() throws Exception {
            while (!stopped) {
              int numReaders = readers.size();
              if (numReaders > 0) {
                ReaderCouple c = (ReaderCouple) readers.get(rnd.nextInt(numReaders));
                TestIndexReader.assertIndexEquals(c.newReader, c.refreshedReader);
              }
              
              synchronized(this) {
                wait(100);
              }
            }
                        
          }
          
        };
      }
      
      threads[i] = new ReaderThread(task);
      threads[i].start();
    }
    
    synchronized(this) {
      wait(1000);
    }
    
    for (int i = 0; i < n; i++) {
      if (threads[i] != null) {
        threads[i].stopThread();
      }
    }
    
    for (int i = 0; i < n; i++) {
      if (threads[i] != null) {
        threads[i].join();
        if (threads[i].error != null) {
          String msg = "Error occurred in thread " + threads[i].getName() + ":\n" + threads[i].error.getMessage();
          fail(msg);
        }
      }
      
    }
    
    Iterator it = readersToClose.iterator();
    while (it.hasNext()) {
      ((IndexReader) it.next()).close();
    }
    
    firstReader.close();
    reader.close();
    
    it = readersToClose.iterator();
    while (it.hasNext()) {
      assertReaderClosed((IndexReader) it.next(), true, true);
    }

    assertReaderClosed(reader, true, true);
    assertReaderClosed(firstReader, true, true);

    dir.close();
  }
,
>
, <(startLine=866 endLine=918 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/contrib/analyzers/common/src/java/org/tartarus/snowball/ext/EnglishStemmer.java)
        private boolean r_Step_4() {
            int among_var;
            int v_1;
            // (, line 140
            // [, line 141
            ket = cursor;
            // substring, line 141
            among_var = find_among_b(a_7, 18);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 141
            bra = cursor;
            // call R2, line 141
            if (!r_R2())
            {
                return false;
            }
            switch(among_var) {
                case 0:
                    return false;
                case 1:
                    // (, line 144
                    // delete, line 144
                    slice_del();
                    break;
                case 2:
                    // (, line 145
                    // or, line 145
                    lab0: do {
                        v_1 = limit - cursor;
                        lab1: do {
                            // literal, line 145
                            if (!(eq_s_b(1, "s")))
                            {
                                break lab1;
                            }
                            break lab0;
                        } while (false);
                        cursor = limit - v_1;
                        // literal, line 145
                        if (!(eq_s_b(1, "t")))
                        {
                            return false;
                        }
                    } while (false);
                    // delete, line 145
                    slice_del();
                    break;
            }
            return true;
        }
,
(startLine=270 endLine=317 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/contrib/analyzers/common/src/java/org/tartarus/snowball/ext/RussianStemmer.java)
        private boolean r_perfective_gerund() {
            int among_var;
            int v_1;
            // (, line 71
            // [, line 72
            ket = cursor;
            // substring, line 72
            among_var = find_among_b(a_0, 9);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 72
            bra = cursor;
            switch(among_var) {
                case 0:
                    return false;
                case 1:
                    // (, line 76
                    // or, line 76
                    lab0: do {
                        v_1 = limit - cursor;
                        lab1: do {
                            // literal, line 76
                            if (!(eq_s_b(1, "\u0430")))
                            {
                                break lab1;
                            }
                            break lab0;
                        } while (false);
                        cursor = limit - v_1;
                        // literal, line 76
                        if (!(eq_s_b(1, "\u044F")))
                        {
                            return false;
                        }
                    } while (false);
                    // delete, line 76
                    slice_del();
                    break;
                case 2:
                    // (, line 83
                    // delete, line 83
                    slice_del();
                    break;
            }
            return true;
        }
,
(startLine=432 endLine=479 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/contrib/analyzers/common/src/java/org/tartarus/snowball/ext/RussianStemmer.java)
        private boolean r_verb() {
            int among_var;
            int v_1;
            // (, line 136
            // [, line 137
            ket = cursor;
            // substring, line 137
            among_var = find_among_b(a_4, 46);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 137
            bra = cursor;
            switch(among_var) {
                case 0:
                    return false;
                case 1:
                    // (, line 143
                    // or, line 143
                    lab0: do {
                        v_1 = limit - cursor;
                        lab1: do {
                            // literal, line 143
                            if (!(eq_s_b(1, "\u0430")))
                            {
                                break lab1;
                            }
                            break lab0;
                        } while (false);
                        cursor = limit - v_1;
                        // literal, line 143
                        if (!(eq_s_b(1, "\u044F")))
                        {
                            return false;
                        }
                    } while (false);
                    // delete, line 143
                    slice_del();
                    break;
                case 2:
                    // (, line 151
                    // delete, line 151
                    slice_del();
                    break;
            }
            return true;
        }
,
(startLine=476 endLine=528 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/contrib/analyzers/common/src/java/org/tartarus/snowball/ext/PorterStemmer.java)
        private boolean r_Step_4() {
            int among_var;
            int v_1;
            // (, line 91
            // [, line 92
            ket = cursor;
            // substring, line 92
            among_var = find_among_b(a_5, 19);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 92
            bra = cursor;
            // call R2, line 92
            if (!r_R2())
            {
                return false;
            }
            switch(among_var) {
                case 0:
                    return false;
                case 1:
                    // (, line 95
                    // delete, line 95
                    slice_del();
                    break;
                case 2:
                    // (, line 96
                    // or, line 96
                    lab0: do {
                        v_1 = limit - cursor;
                        lab1: do {
                            // literal, line 96
                            if (!(eq_s_b(1, "s")))
                            {
                                break lab1;
                            }
                            break lab0;
                        } while (false);
                        cursor = limit - v_1;
                        // literal, line 96
                        if (!(eq_s_b(1, "t")))
                        {
                            return false;
                        }
                    } while (false);
                    // delete, line 96
                    slice_del();
                    break;
            }
            return true;
        }
,
>
, <(startLine=221 endLine=237 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java)
  public synchronized void sync() {
    while(mergeThreadCount() > 0) {
      if (verbose())
        message("now wait for threads; currently " + mergeThreads.size() + " still running");
      final int count = mergeThreads.size();
      if (verbose()) {
        for(int i=0;i<count;i++)
          message("    " + i + ": " + mergeThreads.get(i));
      }
      
      try {
        wait();
      } catch (InterruptedException ie) {
        throw new ThreadInterruptedException(ie);
      }
    }
  }
,
(startLine=121 endLine=137 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java)
  public synchronized void sync() {
    while(mergeThreadCount() > 0) {
      if (verbose())
        message("now wait for threads; currently " + mergeThreads.size() + " still running");
      final int count = mergeThreads.size();
      if (verbose()) {
        for(int i=0;i<count;i++)
          message("    " + i + ": " + mergeThreads.get(i));
      }
      
      try {
        wait();
      } catch (InterruptedException ie) {
        throw new ThreadInterruptedException(ie);
      }
    }
  }
,
>
, <(startLine=59 endLine=84 srcPath=/home/sonia/NewExperiment/luceneFilter/00680/solr/src/test/org/apache/solr/analysis/EnglishPorterFilterFactoryTest.java)
  public void testProtected() throws Exception {
    EnglishStemmer stemmer = new EnglishStemmer();
    String[] test = {"The", "fledgling", "banks", "were", "counting", "on", "a", "big", "boom", "in", "banking"};
    String[] gold = new String[test.length];
    for (int i = 0; i < test.length; i++) {
      if (test[i].equals("fledgling") == false && test[i].equals("banks") == false) {
        stemmer.setCurrent(test[i]);
        stemmer.stem();
        gold[i] = stemmer.getCurrent();
      } else {
        gold[i] = test[i];
      }
    }

    EnglishPorterFilterFactory factory = new EnglishPorterFilterFactory();
    Map<String, String> args = new HashMap<String, String>(DEFAULT_VERSION_PARAM);
    args.put(EnglishPorterFilterFactory.PROTECTED_TOKENS, "who-cares.txt");
    factory.init(args);
    List<String> lines = new ArrayList<String>();
    Collections.addAll(lines, "banks", "fledgling");
    factory.inform(new LinesMockSolrResourceLoader(lines));
    Tokenizer tokenizer = new WhitespaceTokenizer(DEFAULT_VERSION,
        new StringReader(StrUtils.join(Arrays.asList(test), ' ')));
    TokenStream stream = factory.create(tokenizer);
    assertTokenStreamContents(stream, gold);
  }
,
(startLine=66 endLine=91 srcPath=/home/sonia/NewExperiment/luceneFilter/00680/solr/src/test/org/apache/solr/analysis/SnowballPorterFilterFactoryTest.java)
  public void testProtectedOld() throws Exception {
    EnglishStemmer stemmer = new EnglishStemmer();
    String[] test = {"The", "fledgling", "banks", "were", "counting", "on", "a", "big", "boom", "in", "banking"};
    String[] gold = new String[test.length];
    for (int i = 0; i < test.length; i++) {
      if (test[i].equals("fledgling") == false && test[i].equals("banks") == false) {
        stemmer.setCurrent(test[i]);
        stemmer.stem();
        gold[i] = stemmer.getCurrent();
      } else {
        gold[i] = test[i];
      }
    }

    EnglishPorterFilterFactory factory = new EnglishPorterFilterFactory();
    Map<String, String> args = new HashMap<String, String>(DEFAULT_VERSION_PARAM);
    args.put(SnowballPorterFilterFactory.PROTECTED_TOKENS, "who-cares.txt");
    factory.init(args);
    List<String> lines = new ArrayList<String>();
    Collections.addAll(lines, "banks", "fledgling");
    factory.inform(new LinesMockSolrResourceLoader(lines));
    Tokenizer tokenizer = new WhitespaceTokenizer(DEFAULT_VERSION,
        new StringReader(StrUtils.join(Arrays.asList(test), ' ')));
    TokenStream stream = factory.create(tokenizer);
    assertTokenStreamContents(stream, gold);
  }
,
>
, <(startLine=63 endLine=70 srcPath=/home/sonia/NewExperiment/luceneFilter/03343/lucene/analysis/common/src/java/org/apache/lucene/analysis/pattern/SimplePatternSplitTokenizerFactory.java)
  public SimplePatternSplitTokenizerFactory(Map<String,String> args) {
    super(args);
    maxDeterminizedStates = getInt(args, "maxDeterminizedStates", Operations.DEFAULT_MAX_DETERMINIZED_STATES);
    dfa = Operations.determinize(new RegExp(require(args, PATTERN)).toAutomaton(), maxDeterminizedStates);
    if (args.isEmpty() == false) {
      throw new IllegalArgumentException("Unknown parameters: " + args);
    }
  }
,
(startLine=63 endLine=70 srcPath=/home/sonia/NewExperiment/luceneFilter/03343/lucene/analysis/common/src/java/org/apache/lucene/analysis/pattern/SimplePatternTokenizerFactory.java)
  public SimplePatternTokenizerFactory(Map<String,String> args) {
    super(args);
    maxDeterminizedStates = getInt(args, "maxDeterminizedStates", Operations.DEFAULT_MAX_DETERMINIZED_STATES);
    dfa = Operations.determinize(new RegExp(require(args, PATTERN)).toAutomaton(), maxDeterminizedStates);
    if (args.isEmpty() == false) {
      throw new IllegalArgumentException("Unknown parameters: " + args);
    }
  }
,
>
, <(startLine=819 endLine=871 srcPath=/home/sonia/NewExperiment/luceneFilter/00133/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/EnglishStemmer.java)
        private boolean r_Step_4() {
            int among_var;
            int v_1;
            // (, line 129
            // [, line 130
            ket = cursor;
            // substring, line 130
            among_var = find_among_b(a_6, 18);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 130
            bra = cursor;
            // call R2, line 130
            if (!r_R2())
            {
                return false;
            }
            switch(among_var) {
                case 0:
                    return false;
                case 1:
                    // (, line 133
                    // delete, line 133
                    slice_del();
                    break;
                case 2:
                    // (, line 134
                    // or, line 134
                    lab0: do {
                        v_1 = limit - cursor;
                        lab1: do {
                            // literal, line 134
                            if (!(eq_s_b(1, "s")))
                            {
                                break lab1;
                            }
                            break lab0;
                        } while (false);
                        cursor = limit - v_1;
                        // literal, line 134
                        if (!(eq_s_b(1, "t")))
                        {
                            return false;
                        }
                    } while (false);
                    // delete, line 134
                    slice_del();
                    break;
            }
            return true;
        }
,
(startLine=270 endLine=317 srcPath=/home/sonia/NewExperiment/luceneFilter/00133/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/RussianStemmer.java)
        private boolean r_perfective_gerund() {
            int among_var;
            int v_1;
            // (, line 110
            // [, line 111
            ket = cursor;
            // substring, line 111
            among_var = find_among_b(a_0, 9);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 111
            bra = cursor;
            switch(among_var) {
                case 0:
                    return false;
                case 1:
                    // (, line 115
                    // or, line 115
                    lab0: do {
                        v_1 = limit - cursor;
                        lab1: do {
                            // literal, line 115
                            if (!(eq_s_b(1, "\u00C1")))
                            {
                                break lab1;
                            }
                            break lab0;
                        } while (false);
                        cursor = limit - v_1;
                        // literal, line 115
                        if (!(eq_s_b(1, "\u00D1")))
                        {
                            return false;
                        }
                    } while (false);
                    // delete, line 115
                    slice_del();
                    break;
                case 2:
                    // (, line 122
                    // delete, line 122
                    slice_del();
                    break;
            }
            return true;
        }
,
(startLine=432 endLine=479 srcPath=/home/sonia/NewExperiment/luceneFilter/00133/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/RussianStemmer.java)
        private boolean r_verb() {
            int among_var;
            int v_1;
            // (, line 175
            // [, line 176
            ket = cursor;
            // substring, line 176
            among_var = find_among_b(a_4, 46);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 176
            bra = cursor;
            switch(among_var) {
                case 0:
                    return false;
                case 1:
                    // (, line 182
                    // or, line 182
                    lab0: do {
                        v_1 = limit - cursor;
                        lab1: do {
                            // literal, line 182
                            if (!(eq_s_b(1, "\u00C1")))
                            {
                                break lab1;
                            }
                            break lab0;
                        } while (false);
                        cursor = limit - v_1;
                        // literal, line 182
                        if (!(eq_s_b(1, "\u00D1")))
                        {
                            return false;
                        }
                    } while (false);
                    // delete, line 182
                    slice_del();
                    break;
                case 2:
                    // (, line 190
                    // delete, line 190
                    slice_del();
                    break;
            }
            return true;
        }
,
(startLine=476 endLine=528 srcPath=/home/sonia/NewExperiment/luceneFilter/00133/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/PorterStemmer.java)
        private boolean r_Step_4() {
            int among_var;
            int v_1;
            // (, line 91
            // [, line 92
            ket = cursor;
            // substring, line 92
            among_var = find_among_b(a_5, 19);
            if (among_var == 0)
            {
                return false;
            }
            // ], line 92
            bra = cursor;
            // call R2, line 92
            if (!r_R2())
            {
                return false;
            }
            switch(among_var) {
                case 0:
                    return false;
                case 1:
                    // (, line 95
                    // delete, line 95
                    slice_del();
                    break;
                case 2:
                    // (, line 96
                    // or, line 96
                    lab0: do {
                        v_1 = limit - cursor;
                        lab1: do {
                            // literal, line 96
                            if (!(eq_s_b(1, "s")))
                            {
                                break lab1;
                            }
                            break lab0;
                        } while (false);
                        cursor = limit - v_1;
                        // literal, line 96
                        if (!(eq_s_b(1, "t")))
                        {
                            return false;
                        }
                    } while (false);
                    // delete, line 96
                    slice_del();
                    break;
            }
            return true;
        }
,
>
, <(startLine=46 endLine=58 srcPath=/home/sonia/NewExperiment/luceneFilter/01719/solr/solrj/src/test/org/apache/solr/common/util/ContentStreamTest.java)
  {
    InputStream is = new SolrResourceLoader(null, null).openResource( "solrj/README" );
    assertNotNull( is );
    File file = new File(TEMP_DIR, "README");
    FileOutputStream os = new FileOutputStream(file);
    IOUtils.copy(is, os);
    os.close();
    
    ContentStreamBase stream = new ContentStreamBase.FileStream( file );
    assertEquals( file.length(), stream.getSize().intValue() );
    assertTrue( IOUtils.contentEquals( new FileInputStream( file ), stream.getStream() ) );
    assertTrue( IOUtils.contentEquals( new InputStreamReader(new FileInputStream(file), "UTF-8"), stream.getReader() ) );
  }
,
(startLine=62 endLine=75 srcPath=/home/sonia/NewExperiment/luceneFilter/01719/solr/solrj/src/test/org/apache/solr/common/util/ContentStreamTest.java)
  {
    InputStream is = new SolrResourceLoader(null, null).openResource( "solrj/README" );
    assertNotNull( is );
    File file = new File(TEMP_DIR, "README");
    FileOutputStream os = new FileOutputStream(file);
    IOUtils.copy(is, os);
    os.close();
    
    ContentStreamBase stream = new ContentStreamBase.URLStream( new URL(file.toURI().toASCIIString()) );
    assertTrue( IOUtils.contentEquals( new FileInputStream( file ), stream.getStream() ) );
    assertEquals( file.length(), stream.getSize().intValue() );
    assertTrue( IOUtils.contentEquals( new InputStreamReader(new FileInputStream(file), "UTF-8"), stream.getReader() ) );
    assertEquals( file.length(), stream.getSize().intValue() );
  }
,
>
, <(startLine=773 endLine=784 srcPath=/home/sonia/NewExperiment/luceneFilter/03020/lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java)
      for(int contentID=0;contentID<3;contentID++) {
        final ScoreDoc[] hits = s.search(new TermQuery(new Term("content", "real"+contentID)), numDocs).scoreDocs;
        for(ScoreDoc hit : hits) {
          int idValue = (int) docIDToID.get(hit.doc);

          final GroupDoc gd = groupDocs[idValue];
          seenIDs.add(idValue);
          assertTrue(gd.score == 0.0);
          gd.score = hit.score;
          assertEquals(gd.id, idValue);
        }
      }
,
(startLine=296 endLine=306 srcPath=/home/sonia/NewExperiment/luceneFilter/03020/lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java)
      for (int contentID = 0; contentID < 3; contentID++) {
        final ScoreDoc[] hits = s.search(new TermQuery(new Term("content", "real" + contentID)), numDocs).scoreDocs;
        for (ScoreDoc hit : hits) {
          int idValue = (int) docIdToFieldId.get(hit.doc);
          final GroupDoc gd = groupDocs[idValue];
          assertEquals(gd.id, idValue);
          seenIDs.add(idValue);
          assertTrue(gd.score == 0.0);
          gd.score = hit.score;
        }
      }
,
>
, <(startLine=121 endLine=137 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/java/org/apache/lucene/search/FieldValueHitQueue.java)
    protected boolean lessThan(final Entry hitA, final Entry hitB) {

      assert hitA != hitB;
      assert hitA.slot != hitB.slot;

      int numComparators = comparators.length;
      for (int i = 0; i < numComparators; ++i) {
        final int c = reverseMul[i] * comparators[i].compare(hitA.slot, hitB.slot);
        if (c != 0) {
          // Short circuit
          return c > 0;
        }
      }

      // avoid random sort order that could lead to duplicates (bug #31241):
      return hitA.doc > hitB.doc;
    }
,
(startLine=124 endLine=140 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/java/org/apache/lucene/search/FieldValueHitQueue.java)
    protected boolean lessThan(final Entry hitA, final Entry hitB) {

      assert hitA != hitB;
      assert hitA.slot != hitB.slot;

      int numComparators = comparators.length;
      for (int i = 0; i < numComparators; ++i) {
        final int c = reverseMul[i] * comparators[i].compare(hitA.slot, hitB.slot);
        if (c != 0) {
          // Short circuit
          return c > 0;
        }
      }

      // avoid random sort order that could lead to duplicates (bug #31241):
      return hitA.doc > hitB.doc;
    }
,
>
, <(startLine=279 endLine=288 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriterPerField.java)
    void copyTo(ParallelPostingsArray toArray, int numToCopy) {
      assert toArray instanceof TermVectorsPostingsArray;
      TermVectorsPostingsArray to = (TermVectorsPostingsArray) toArray;

      super.copyTo(toArray, numToCopy);

      System.arraycopy(freqs, 0, to.freqs, 0, size);
      System.arraycopy(lastOffsets, 0, to.lastOffsets, 0, size);
      System.arraycopy(lastPositions, 0, to.lastPositions, 0, size);
    }
,
(startLine=279 endLine=288 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriterPerField.java)
    void copyTo(ParallelPostingsArray toArray, int numToCopy) {
      assert toArray instanceof TermVectorsPostingsArray;
      TermVectorsPostingsArray to = (TermVectorsPostingsArray) toArray;

      super.copyTo(toArray, numToCopy);

      System.arraycopy(freqs, 0, to.freqs, 0, size);
      System.arraycopy(lastOffsets, 0, to.lastOffsets, 0, size);
      System.arraycopy(lastPositions, 0, to.lastPositions, 0, size);
    }
,
>
, <(startLine=172 endLine=191 srcPath=/home/sonia/NewExperiment/luceneFilter/00681/lucene/src/test/org/apache/lucene/index/TestIndexReaderClone.java)
  public void testCloneReadOnlyToWriteable() throws Exception {
    final Directory dir1 = new MockRAMDirectory();

    TestIndexReaderReopen.createIndex(dir1, true);
    IndexReader reader1 = IndexReader.open(dir1, true);

    IndexReader reader2 = reader1.clone(false);
    if (isReadOnly(reader2)) {
      fail("reader should not be read only");
    }
    assertFalse("deleting from the original reader should not have worked", deleteWorked(1, reader1));
    // this readonly reader shouldn't yet have a write lock
    if (reader2.hasChanges) {
      fail("cloned reader should not have write lock");
    }
    assertTrue("deleting from the cloned reader should have worked", deleteWorked(1, reader2));
    reader1.close();
    reader2.close();
    dir1.close();
  }
,
(startLine=177 endLine=196 srcPath=/home/sonia/NewExperiment/luceneFilter/00681/lucene/backwards/src/test/org/apache/lucene/index/TestIndexReaderClone.java)
  public void testCloneReadOnlyToWriteable() throws Exception {
    final Directory dir1 = new MockRAMDirectory();

    TestIndexReaderReopen.createIndex(dir1, true);
    IndexReader reader1 = IndexReader.open(dir1, true);

    IndexReader reader2 = reader1.clone(false);
    if (isReadOnly(reader2)) {
      fail("reader should not be read only");
    }
    assertFalse("deleting from the original reader should not have worked", deleteWorked(1, reader1));
    // this readonly reader shouldn't yet have a write lock
    if (reader2.hasChanges) {
      fail("cloned reader should not have write lock");
    }
    assertTrue("deleting from the cloned reader should have worked", deleteWorked(1, reader2));
    reader1.close();
    reader2.close();
    dir1.close();
  }
,
>
, <(startLine=124 endLine=187 srcPath=/home/sonia/NewExperiment/luceneFilter/00655/lucene/src/test/org/apache/lucene/analysis/TestTeeSinkTokenFilter.java)
  public void performance() throws Exception {
    int[] tokCount = {100, 500, 1000, 2000, 5000, 10000};
    int[] modCounts = {1, 2, 5, 10, 20, 50, 100, 200, 500};
    for (int k = 0; k < tokCount.length; k++) {
      StringBuilder buffer = new StringBuilder();
      System.out.println("-----Tokens: " + tokCount[k] + "-----");
      for (int i = 0; i < tokCount[k]; i++) {
        buffer.append(English.intToEnglish(i).toUpperCase()).append(' ');
      }
      //make sure we produce the same tokens
      TeeSinkTokenFilter teeStream = new TeeSinkTokenFilter(new StandardFilter(new StandardTokenizer(TEST_VERSION_CURRENT, new StringReader(buffer.toString()))));
      TokenStream sink = teeStream.newSinkTokenStream(new ModuloSinkFilter(100));
      teeStream.consumeAllTokens();
      TokenStream stream = new ModuloTokenFilter(new StandardFilter(new StandardTokenizer(TEST_VERSION_CURRENT, new StringReader(buffer.toString()))), 100);
      TermAttribute tfTok = stream.addAttribute(TermAttribute.class);
      TermAttribute sinkTok = sink.addAttribute(TermAttribute.class);
      for (int i=0; stream.incrementToken(); i++) {
        assertTrue(sink.incrementToken());
        assertTrue(tfTok + " is not equal to " + sinkTok + " at token: " + i, tfTok.equals(sinkTok) == true);
      }
      
      //simulate two fields, each being analyzed once, for 20 documents
      for (int j = 0; j < modCounts.length; j++) {
        int tfPos = 0;
        long start = System.currentTimeMillis();
        for (int i = 0; i < 20; i++) {
          stream = new StandardFilter(new StandardTokenizer(TEST_VERSION_CURRENT, new StringReader(buffer.toString())));
          PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);
          while (stream.incrementToken()) {
            tfPos += posIncrAtt.getPositionIncrement();
          }
          stream = new ModuloTokenFilter(new StandardFilter(new StandardTokenizer(TEST_VERSION_CURRENT, new StringReader(buffer.toString()))), modCounts[j]);
          posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);
          while (stream.incrementToken()) {
            tfPos += posIncrAtt.getPositionIncrement();
          }
        }
        long finish = System.currentTimeMillis();
        System.out.println("ModCount: " + modCounts[j] + " Two fields took " + (finish - start) + " ms");
        int sinkPos = 0;
        //simulate one field with one sink
        start = System.currentTimeMillis();
        for (int i = 0; i < 20; i++) {
          teeStream = new TeeSinkTokenFilter(new StandardFilter(new StandardTokenizer(TEST_VERSION_CURRENT, new StringReader(buffer.toString()))));
          sink = teeStream.newSinkTokenStream(new ModuloSinkFilter(modCounts[j]));
          PositionIncrementAttribute posIncrAtt = teeStream.getAttribute(PositionIncrementAttribute.class);
          while (teeStream.incrementToken()) {
            sinkPos += posIncrAtt.getPositionIncrement();
          }
          //System.out.println("Modulo--------");
          posIncrAtt = sink.getAttribute(PositionIncrementAttribute.class);
          while (sink.incrementToken()) {
            sinkPos += posIncrAtt.getPositionIncrement();
          }
        }
        finish = System.currentTimeMillis();
        System.out.println("ModCount: " + modCounts[j] + " Tee fields took " + (finish - start) + " ms");
        assertTrue(sinkPos + " does not equal: " + tfPos, sinkPos == tfPos);

      }
      System.out.println("- End Tokens: " + tokCount[k] + "-----");
    }

  }
,
(startLine=164 endLine=227 srcPath=/home/sonia/NewExperiment/luceneFilter/00655/lucene/backwards/src/test/org/apache/lucene/analysis/TestTeeSinkTokenFilter.java)
  public void performance() throws Exception {
    int[] tokCount = {100, 500, 1000, 2000, 5000, 10000};
    int[] modCounts = {1, 2, 5, 10, 20, 50, 100, 200, 500};
    for (int k = 0; k < tokCount.length; k++) {
      StringBuilder buffer = new StringBuilder();
      System.out.println("-----Tokens: " + tokCount[k] + "-----");
      for (int i = 0; i < tokCount[k]; i++) {
        buffer.append(English.intToEnglish(i).toUpperCase()).append(' ');
      }
      //make sure we produce the same tokens
      TeeSinkTokenFilter teeStream = new TeeSinkTokenFilter(new StandardFilter(new StandardTokenizer(Version.LUCENE_CURRENT, new StringReader(buffer.toString()))));
      TokenStream sink = teeStream.newSinkTokenStream(new ModuloSinkFilter(100));
      teeStream.consumeAllTokens();
      TokenStream stream = new ModuloTokenFilter(new StandardFilter(new StandardTokenizer(Version.LUCENE_CURRENT, new StringReader(buffer.toString()))), 100);
      TermAttribute tfTok = stream.addAttribute(TermAttribute.class);
      TermAttribute sinkTok = sink.addAttribute(TermAttribute.class);
      for (int i=0; stream.incrementToken(); i++) {
        assertTrue(sink.incrementToken());
        assertTrue(tfTok + " is not equal to " + sinkTok + " at token: " + i, tfTok.equals(sinkTok) == true);
      }
      
      //simulate two fields, each being analyzed once, for 20 documents
      for (int j = 0; j < modCounts.length; j++) {
        int tfPos = 0;
        long start = System.currentTimeMillis();
        for (int i = 0; i < 20; i++) {
          stream = new StandardFilter(new StandardTokenizer(Version.LUCENE_CURRENT, new StringReader(buffer.toString())));
          PositionIncrementAttribute posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);
          while (stream.incrementToken()) {
            tfPos += posIncrAtt.getPositionIncrement();
          }
          stream = new ModuloTokenFilter(new StandardFilter(new StandardTokenizer(Version.LUCENE_CURRENT, new StringReader(buffer.toString()))), modCounts[j]);
          posIncrAtt = stream.getAttribute(PositionIncrementAttribute.class);
          while (stream.incrementToken()) {
            tfPos += posIncrAtt.getPositionIncrement();
          }
        }
        long finish = System.currentTimeMillis();
        System.out.println("ModCount: " + modCounts[j] + " Two fields took " + (finish - start) + " ms");
        int sinkPos = 0;
        //simulate one field with one sink
        start = System.currentTimeMillis();
        for (int i = 0; i < 20; i++) {
          teeStream = new TeeSinkTokenFilter(new StandardFilter(new StandardTokenizer(Version.LUCENE_CURRENT, new StringReader(buffer.toString()))));
          sink = teeStream.newSinkTokenStream(new ModuloSinkFilter(modCounts[j]));
          PositionIncrementAttribute posIncrAtt = teeStream.getAttribute(PositionIncrementAttribute.class);
          while (teeStream.incrementToken()) {
            sinkPos += posIncrAtt.getPositionIncrement();
          }
          //System.out.println("Modulo--------");
          posIncrAtt = sink.getAttribute(PositionIncrementAttribute.class);
          while (sink.incrementToken()) {
            sinkPos += posIncrAtt.getPositionIncrement();
          }
        }
        finish = System.currentTimeMillis();
        System.out.println("ModCount: " + modCounts[j] + " Tee fields took " + (finish - start) + " ms");
        assertTrue(sinkPos + " does not equal: " + tfPos, sinkPos == tfPos);

      }
      System.out.println("- End Tokens: " + tokCount[k] + "-----");
    }

  }
,
>
, <(startLine=126 endLine=134 srcPath=/home/sonia/NewExperiment/luceneFilter/00664/lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragmentsBuilder.java)
      int startOffset, int endOffset ){
    while( buffer.length() < endOffset && index[0] < values.length ){
      if( index[0] > 0 && values[index[0]].length() > 0 )
        buffer.append( ' ' );
      buffer.append( values[index[0]++] );
    }
    int eo = buffer.length() < endOffset ? buffer.length() : endOffset;
    return buffer.substring( startOffset, eo );
  }
,
(startLine=137 endLine=145 srcPath=/home/sonia/NewExperiment/luceneFilter/00664/lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragmentsBuilder.java)
      int startOffset, int endOffset ){
    while( buffer.length() < endOffset && index[0] < values.length ){
      if( index[0] > 0 && values[index[0]].isTokenized() && values[index[0]].stringValue().length() > 0 )
        buffer.append( ' ' );
      buffer.append( values[index[0]++].stringValue() );
    }
    int eo = buffer.length() < endOffset ? buffer.length() : endOffset;
    return buffer.substring( startOffset, eo );
  }
,
>
, <(startLine=715 endLine=727 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/java/org/apache/lucene/util/BitUtil.java)
    } else {
      // grab upper 32 bits
      int upper=(int)(val>>32);
      lowByte = upper & 0xff;
      if (lowByte != 0) return ntzTable[lowByte] + 32;
      lowByte = (upper>>>8) & 0xff;
      if (lowByte != 0) return ntzTable[lowByte] + 40;
      lowByte = (upper>>>16) & 0xff;
      if (lowByte != 0) return ntzTable[lowByte] + 48;
      // no need to mask off low byte for the last byte in the 32 bit word
      // no need to check for zero on the last byte either.
      return ntzTable[upper>>>24] + 56;
    }
,
(startLine=716 endLine=728 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/java/org/apache/lucene/util/BitUtil.java)
    } else {
      // grab upper 32 bits
      int upper=(int)(val>>32);
      lowByte = upper & 0xff;
      if (lowByte != 0) return ntzTable[lowByte] + 32;
      lowByte = (upper>>>8) & 0xff;
      if (lowByte != 0) return ntzTable[lowByte] + 40;
      lowByte = (upper>>>16) & 0xff;
      if (lowByte != 0) return ntzTable[lowByte] + 48;
      // no need to mask off low byte for the last byte in the 32 bit word
      // no need to check for zero on the last byte either.
      return ntzTable[upper>>>24] + 56;
    }
,
>
, <(startLine=195 endLine=211 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence.java)
        } else {
          try {
            final int inc = task.runAndMaybeStats(letChildReport);
            count += inc;
            if (countsByTime != null) {
              final int slot = (int) ((System.currentTimeMillis()-t0)/logByTimeMsec);
              if (slot >= countsByTime.length) {
                countsByTime = ArrayUtil.grow(countsByTime, 1+slot);
              }
              countsByTime[slot] += inc;
            }
            if (anyExhaustibleTasks)
              updateExhausted(task);
          } catch (NoMoreDataException e) {
            exhausted = true;
          }
        }
,
(startLine=263 endLine=276 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence.java)
        try {
          final int inc = task.runAndMaybeStats(letChildReport);
          count += inc;
          if (countsByTime != null) {
            final int slot = (int) ((System.currentTimeMillis()-t0)/logByTimeMsec);
            if (slot >= countsByTime.length) {
              countsByTime = ArrayUtil.grow(countsByTime, 1+slot);
            }
            countsByTime[slot] += inc;
          }

          if (anyExhaustibleTasks)
            updateExhausted(task);
        } catch (NoMoreDataException e) {
,
>
, <(startLine=43 endLine=77 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/test/org/apache/lucene/util/TestFieldCacheSanityChecker.java)
  protected void setUp() throws Exception {
    super.setUp();

    RAMDirectory dirA = new RAMDirectory();
    RAMDirectory dirB = new RAMDirectory();

    IndexWriter wA = new IndexWriter(dirA, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)));
    IndexWriter wB = new IndexWriter(dirB, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)));

    long theLong = Long.MAX_VALUE;
    double theDouble = Double.MAX_VALUE;
    byte theByte = Byte.MAX_VALUE;
    short theShort = Short.MAX_VALUE;
    int theInt = Integer.MAX_VALUE;
    float theFloat = Float.MAX_VALUE;
    for (int i = 0; i < NUM_DOCS; i++){
      Document doc = new Document();
      doc.add(new Field("theLong", String.valueOf(theLong--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      doc.add(new Field("theDouble", String.valueOf(theDouble--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      doc.add(new Field("theByte", String.valueOf(theByte--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      doc.add(new Field("theShort", String.valueOf(theShort--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      doc.add(new Field("theInt", String.valueOf(theInt--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      doc.add(new Field("theFloat", String.valueOf(theFloat--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      if (0 == i % 3) {
        wA.addDocument(doc);
      } else {
        wB.addDocument(doc);
      }
    }
    wA.close();
    wB.close();
    readerA = IndexReader.open(dirA, true);
    readerB = IndexReader.open(dirB, true);
    readerX = new MultiReader(new IndexReader[] { readerA, readerB });
  }
,
(startLine=42 endLine=78 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/test/org/apache/lucene/util/TestFieldCacheSanityChecker.java)
  protected void setUp() throws Exception {
    super.setUp();

    RAMDirectory dirA = new RAMDirectory();
    RAMDirectory dirB = new RAMDirectory();

    IndexWriter wA = new IndexWriter(dirA, new WhitespaceAnalyzer(), true, 
                                     IndexWriter.MaxFieldLength.LIMITED);
    IndexWriter wB = new IndexWriter(dirB, new WhitespaceAnalyzer(), true, 
                                     IndexWriter.MaxFieldLength.LIMITED);

    long theLong = Long.MAX_VALUE;
    double theDouble = Double.MAX_VALUE;
    byte theByte = Byte.MAX_VALUE;
    short theShort = Short.MAX_VALUE;
    int theInt = Integer.MAX_VALUE;
    float theFloat = Float.MAX_VALUE;
    for (int i = 0; i < NUM_DOCS; i++){
      Document doc = new Document();
      doc.add(new Field("theLong", String.valueOf(theLong--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      doc.add(new Field("theDouble", String.valueOf(theDouble--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      doc.add(new Field("theByte", String.valueOf(theByte--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      doc.add(new Field("theShort", String.valueOf(theShort--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      doc.add(new Field("theInt", String.valueOf(theInt--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      doc.add(new Field("theFloat", String.valueOf(theFloat--), Field.Store.NO, Field.Index.NOT_ANALYZED));
      if (0 == i % 3) {
        wA.addDocument(doc);
      } else {
        wB.addDocument(doc);
      }
    }
    wA.close();
    wB.close();
    readerA = IndexReader.open(dirA, true);
    readerB = IndexReader.open(dirB, true);
    readerX = new MultiReader(new IndexReader[] { readerA, readerB });
  }
,
>
, <(startLine=441 endLine=449 srcPath=/home/sonia/NewExperiment/luceneFilter/02879/lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java)
    public static OrdinalMap build(Object owner, SortedDocValues[] values, float acceptableOverheadRatio) throws IOException {
      final TermsEnum[] subs = new TermsEnum[values.length];
      final long[] weights = new long[values.length];
      for (int i = 0; i < values.length; ++i) {
        subs[i] = values[i].termsEnum();
        weights[i] = values[i].getValueCount();
      }
      return build(owner, subs, weights, acceptableOverheadRatio);
    }
,
(startLine=456 endLine=464 srcPath=/home/sonia/NewExperiment/luceneFilter/02879/lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java)
    public static OrdinalMap build(Object owner, SortedSetDocValues[] values, float acceptableOverheadRatio) throws IOException {
      final TermsEnum[] subs = new TermsEnum[values.length];
      final long[] weights = new long[values.length];
      for (int i = 0; i < values.length; ++i) {
        subs[i] = values[i].termsEnum();
        weights[i] = values[i].getValueCount();
      }
      return build(owner, subs, weights, acceptableOverheadRatio);
    }
,
>
, <(startLine=149 endLine=173 srcPath=/home/sonia/NewExperiment/luceneFilter/03245/lucene/backward-codecs/src/test/org/apache/lucene/legacy/TestNumericRangeQuery32.java)
    for (byte i=0; i<2; i++) {
      TopDocs topDocs;
      String type;
      switch (i) {
        case 0:
          type = " (constant score filter rewrite)";
          q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_REWRITE);
          topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
          break;
        case 1:
          type = " (constant score boolean rewrite)";
          q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);
          topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
          break;
        default:
          return;
      }
      ScoreDoc[] sd = topDocs.scoreDocs;
      assertNotNull(sd);
      assertEquals("Score doc count"+type, count, sd.length );
      Document doc=searcher.doc(sd[0].doc);
      assertEquals("First doc"+type, 2*distance+startOffset, doc.getField(field).numericValue().intValue());
      doc=searcher.doc(sd[sd.length-1].doc);
      assertEquals("Last doc"+type, (1+count)*distance+startOffset, doc.getField(field).numericValue().intValue());
    }
,
(startLine=158 endLine=182 srcPath=/home/sonia/NewExperiment/luceneFilter/03245/lucene/backward-codecs/src/test/org/apache/lucene/legacy/TestNumericRangeQuery64.java)
    for (byte i=0; i<2; i++) {
      TopDocs topDocs;
      String type;
      switch (i) {
        case 0:
          type = " (constant score filter rewrite)";
          q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_REWRITE);
          topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
          break;
        case 1:
          type = " (constant score boolean rewrite)";
          q.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);
          topDocs = searcher.search(q, noDocs, Sort.INDEXORDER);
          break;
        default:
          return;
      }
      ScoreDoc[] sd = topDocs.scoreDocs;
      assertNotNull(sd);
      assertEquals("Score doc count"+type, count, sd.length );
      Document doc=searcher.doc(sd[0].doc);
      assertEquals("First doc"+type, 2*distance+startOffset, doc.getField(field).numericValue().longValue() );
      doc=searcher.doc(sd[sd.length-1].doc);
      assertEquals("Last doc"+type, (1+count)*distance+startOffset, doc.getField(field).numericValue().longValue() );
    }
,
>
, <(startLine=54 endLine=73 srcPath=/home/sonia/NewExperiment/luceneFilter/01195/lucene/src/test/org/apache/lucene/search/TestTermRangeQuery.java)
  public void testExclusive() throws Exception {
    Query query = TermRangeQuery.newStringRange("content", "A", "C", false, false);
    initializeIndex(new String[] {"A", "B", "C", "D"});
    IndexSearcher searcher = new IndexSearcher(dir, true);
    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals("A,B,C,D, only B in range", 1, hits.length);
    searcher.close();

    initializeIndex(new String[] {"A", "B", "D"});
    searcher = new IndexSearcher(dir, true);
    hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals("A,B,D, only B in range", 1, hits.length);
    searcher.close();

    addDoc("C");
    searcher = new IndexSearcher(dir, true);
    hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals("C added, still only B in range", 1, hits.length);
    searcher.close();
  }
,
(startLine=75 endLine=95 srcPath=/home/sonia/NewExperiment/luceneFilter/01195/lucene/src/test/org/apache/lucene/search/TestTermRangeQuery.java)
  public void testInclusive() throws Exception {
    Query query = TermRangeQuery.newStringRange("content", "A", "C", true, true);

    initializeIndex(new String[]{"A", "B", "C", "D"});
    IndexSearcher searcher = new IndexSearcher(dir, true);
    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals("A,B,C,D - A,B,C in range", 3, hits.length);
    searcher.close();

    initializeIndex(new String[]{"A", "B", "D"});
    searcher = new IndexSearcher(dir, true);
    hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals("A,B,D - A and B in range", 2, hits.length);
    searcher.close();

    addDoc("C");
    searcher = new IndexSearcher(dir, true);
    hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals("C added - A, B, C in range", 3, hits.length);
    searcher.close();
  }
,
>
, <(startLine=659 endLine=683 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java)
      for(int iter=0;iter<10;iter++) {
        for(int i=0;i<19;i++)
          writer.addDocument(doc);

        ((ConcurrentMergeScheduler) writer.getConfig().getMergeScheduler()).sync();
        writer.commit();

        SegmentInfos sis = new SegmentInfos();
        sis.read(dir);

        final int segCount = sis.size();

        writer.optimize(7);
        writer.commit();

        sis = new SegmentInfos();
        ((ConcurrentMergeScheduler) writer.getConfig().getMergeScheduler()).sync();
        sis.read(dir);
        final int optSegCount = sis.size();

        if (segCount < 7)
          assertEquals(segCount, optSegCount);
        else
          assertEquals(7, optSegCount);
      }
,
(startLine=664 endLine=688 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/backwards/src/test/org/apache/lucene/index/TestIndexWriter.java)
      for(int iter=0;iter<10;iter++) {
        for(int i=0;i<19;i++)
          writer.addDocument(doc);

        ((ConcurrentMergeScheduler) writer.getMergeScheduler()).sync();
        writer.commit();

        SegmentInfos sis = new SegmentInfos();
        sis.read(dir);

        final int segCount = sis.size();

        writer.optimize(7);
        writer.commit();

        sis = new SegmentInfos();
        ((ConcurrentMergeScheduler) writer.getMergeScheduler()).sync();
        sis.read(dir);
        final int optSegCount = sis.size();

        if (segCount < 7)
          assertEquals(segCount, optSegCount);
        else
          assertEquals(7, optSegCount);
      }
,
>
, <(startLine=1050 endLine=1058 srcPath=/home/sonia/NewExperiment/luceneFilter/03379/solr/contrib/analytics/src/test/org/apache/solr/analytics/legacy/facet/LegacyFieldFacetTest.java)
  private void checkStddevs(ArrayList<Double> list1, ArrayList<Double> list2) {
    Collections.sort(list1);
    Collections.sort(list2);
    for (int i = 0; i<list1.size(); i++) {
      if ((Math.abs(list1.get(i)-list2.get(i))<.00000000001) == false) {
        Assert.assertEquals(getRawResponse(), list1.get(i), list2.get(i), 0.00000000001);
      }
    }
  }
,
(startLine=1196 endLine=1204 srcPath=/home/sonia/NewExperiment/luceneFilter/03379/solr/contrib/analytics/src/test/org/apache/solr/analytics/legacy/facet/LegacyFieldFacetCloudTest.java)
  private void checkStddevs(NamedList<Object> response, ArrayList<Double> list1, ArrayList<Double> list2) {
    Collections.sort(list1);
    Collections.sort(list2);
    for (int i = 0; i<list2.size(); i++) {
      if ((Math.abs(list1.get(i)-list2.get(i))<.00000000001) == false) {
        Assert.assertEquals(response.toString(), list1.get(i), list2.get(i), 0.00000000001);
      }
    }
  }
,
>
, <(startLine=86 endLine=94 srcPath=/home/sonia/NewExperiment/luceneFilter/00684/lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/query/QueryAutoStopWordAnalyzer.java)
  public int addStopWords(IndexReader reader, int maxDocFreq) throws IOException {
    int numStopWords = 0;
    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.INDEXED);
    for (Iterator<String> iter = fieldNames.iterator(); iter.hasNext();) {
      String fieldName = iter.next();
      numStopWords += addStopWords(reader, fieldName, maxDocFreq);
    }
    return numStopWords;
  }
,
(startLine=106 endLine=114 srcPath=/home/sonia/NewExperiment/luceneFilter/00684/lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/query/QueryAutoStopWordAnalyzer.java)
  public int addStopWords(IndexReader reader, float maxPercentDocs) throws IOException {
    int numStopWords = 0;
    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.INDEXED);
    for (Iterator<String> iter = fieldNames.iterator(); iter.hasNext();) {
      String fieldName = iter.next();
      numStopWords += addStopWords(reader, fieldName, maxPercentDocs);
    }
    return numStopWords;
  }
,
>
, <(startLine=577 endLine=614 srcPath=/home/sonia/NewExperiment/luceneFilter/02782/lucene/core/src/java/org/apache/lucene/codecs/lucene54/Lucene54DocValuesConsumer.java)
  private Iterable<Number> docToSetId(SortedSet<LongsRef> uniqueValueSets, Iterable<Number> docToValueCount, Iterable<Number> values) {
    final Map<LongsRef, Integer> setIds = new HashMap<>();
    int i = 0;
    for (LongsRef set : uniqueValueSets) {
      setIds.put(set, i++);
    }
    assert i == uniqueValueSets.size();

    return new Iterable<Number>() {

      @Override
      public Iterator<Number> iterator() {
        final Iterator<Number> valueCountIterator = docToValueCount.iterator();
        final Iterator<Number> valueIterator = values.iterator();
        final LongsRef docValues = new LongsRef(256);
        return new Iterator<Number>() {

          @Override
          public boolean hasNext() {
            return valueCountIterator.hasNext();
          }

          @Override
          public Number next() {
            docValues.length = valueCountIterator.next().intValue();
            for (int i = 0; i < docValues.length; ++i) {
              docValues.longs[i] = valueIterator.next().longValue();
            }
            final Integer id = setIds.get(docValues);
            assert id != null;
            return id;
          }

        };

      }
    };
  }
,
(startLine=576 endLine=613 srcPath=/home/sonia/NewExperiment/luceneFilter/02782/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene50/Lucene50DocValuesConsumer.java)
  private Iterable<Number> docToSetId(SortedSet<LongsRef> uniqueValueSets, Iterable<Number> docToValueCount, Iterable<Number> values) {
    final Map<LongsRef, Integer> setIds = new HashMap<>();
    int i = 0;
    for (LongsRef set : uniqueValueSets) {
      setIds.put(set, i++);
    }
    assert i == uniqueValueSets.size();

    return new Iterable<Number>() {

      @Override
      public Iterator<Number> iterator() {
        final Iterator<Number> valueCountIterator = docToValueCount.iterator();
        final Iterator<Number> valueIterator = values.iterator();
        final LongsRef docValues = new LongsRef(256);
        return new Iterator<Number>() {

          @Override
          public boolean hasNext() {
            return valueCountIterator.hasNext();
          }

          @Override
          public Number next() {
            docValues.length = valueCountIterator.next().intValue();
            for (int i = 0; i < docValues.length; ++i) {
              docValues.longs[i] = valueIterator.next().longValue();
            }
            final Integer id = setIds.get(docValues);
            assert id != null;
            return id;
          }

        };

      }
    };
  }
,
>
, <(startLine=102 endLine=145 srcPath=/home/sonia/NewExperiment/luceneFilter/00895/lucene/src/java/org/apache/lucene/search/cache/ByteValuesCreator.java)
  {
    if( parser == null ) {
      parser = FieldCache.DEFAULT_BYTE_PARSER;
    }
    setParserAndResetCounts(vals, parser);

    Terms terms = MultiFields.getTerms(reader, field);
    int maxDoc = reader.maxDoc();
    vals.values = new byte[maxDoc];
    if (terms != null) {
      final TermsEnum termsEnum = terms.iterator();
      OpenBitSet validBits = (hasOption(OPTION_CACHE_BITS)) ? new OpenBitSet( maxDoc ) : null;
      DocsEnum docs = null;
      try {
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final byte termval = parser.parseByte(term);
          docs = termsEnum.docs(null, docs);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            vals.values[docID] = termval;
            vals.numDocs++;
            if( validBits != null ) {
              validBits.set( docID );
            }
          }
          vals.numTerms++;
        }
      } catch (FieldCache.StopFillCacheException stop) {}

      if( vals.valid == null ) {
        vals.valid = checkMatchAllBits( validBits, vals.numDocs, maxDoc );
      }
    }
    if( vals.valid == null && vals.numDocs < 1 ) {
      vals.valid = new Bits.MatchNoBits( maxDoc );
    }
  }
,
(startLine=103 endLine=146 srcPath=/home/sonia/NewExperiment/luceneFilter/00895/lucene/src/java/org/apache/lucene/search/cache/ShortValuesCreator.java)
  {
    if( parser == null ) {
      parser = FieldCache.DEFAULT_SHORT_PARSER;
    }
    setParserAndResetCounts(vals, parser);

    Terms terms = MultiFields.getTerms(reader, field);
    int maxDoc = reader.maxDoc();
    vals.values = new short[maxDoc];
    if (terms != null) {
      final TermsEnum termsEnum = terms.iterator();
      OpenBitSet validBits = (hasOption(OPTION_CACHE_BITS)) ? new OpenBitSet( maxDoc ) : null;
      DocsEnum docs = null;
      try {
        while(true) {
          final BytesRef term = termsEnum.next();
          if (term == null) {
            break;
          }
          final Short termval = parser.parseShort(term);
          docs = termsEnum.docs(null, docs);
          while (true) {
            final int docID = docs.nextDoc();
            if (docID == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            vals.values[docID] = termval;
            vals.numDocs++;
            if( validBits != null ) {
              validBits.set( docID );
            }
          }
          vals.numTerms++;
        }
      } catch (FieldCache.StopFillCacheException stop) {}

      if( vals.valid == null ) {
        vals.valid = checkMatchAllBits( validBits, vals.numDocs, maxDoc );
      }
    }
    if( vals.valid == null && vals.numDocs < 1 ) {
      vals.valid = new Bits.MatchNoBits( maxDoc );
    }
  }
,
>
, <(startLine=218 endLine=231 srcPath=/home/sonia/NewExperiment/luceneFilter/00684/lucene/src/test/org/apache/lucene/index/TestParallelReader.java)
  private void queryTest(Query query) throws IOException {
    ScoreDoc[] parallelHits = parallel.search(query, null, 1000).scoreDocs;
    ScoreDoc[] singleHits = single.search(query, null, 1000).scoreDocs;
    assertEquals(parallelHits.length, singleHits.length);
    for(int i = 0; i < parallelHits.length; i++) {
      assertEquals(parallelHits[i].score, singleHits[i].score, 0.001f);
      Document docParallel = parallel.doc(parallelHits[i].doc);
      Document docSingle = single.doc(singleHits[i].doc);
      assertEquals(docParallel.get("f1"), docSingle.get("f1"));
      assertEquals(docParallel.get("f2"), docSingle.get("f2"));
      assertEquals(docParallel.get("f3"), docSingle.get("f3"));
      assertEquals(docParallel.get("f4"), docSingle.get("f4"));
    }
  }
,
(startLine=218 endLine=231 srcPath=/home/sonia/NewExperiment/luceneFilter/00684/lucene/backwards/src/test/org/apache/lucene/index/TestParallelReader.java)
  private void queryTest(Query query) throws IOException {
    ScoreDoc[] parallelHits = parallel.search(query, null, 1000).scoreDocs;
    ScoreDoc[] singleHits = single.search(query, null, 1000).scoreDocs;
    assertEquals(parallelHits.length, singleHits.length);
    for(int i = 0; i < parallelHits.length; i++) {
      assertEquals(parallelHits[i].score, singleHits[i].score, 0.001f);
      Document docParallel = parallel.doc(parallelHits[i].doc);
      Document docSingle = single.doc(singleHits[i].doc);
      assertEquals(docParallel.get("f1"), docSingle.get("f1"));
      assertEquals(docParallel.get("f2"), docSingle.get("f2"));
      assertEquals(docParallel.get("f3"), docSingle.get("f3"));
      assertEquals(docParallel.get("f4"), docSingle.get("f4"));
    }
  }
,
>
, <(startLine=195 endLine=202 srcPath=/home/sonia/NewExperiment/luceneFilter/00706/lucene/src/test/org/apache/lucene/index/TestFieldsReader.java)
    for (final Fieldable fieldable : l ) {
      Field field = (Field) fieldable;

      assertTrue("field is null and it shouldn't be", field != null);
      String sv = field.stringValue();
      assertTrue("sv is null and it shouldn't be", sv != null);
      count++;
    }
,
(startLine=187 endLine=193 srcPath=/home/sonia/NewExperiment/luceneFilter/00706/lucene/backwards/src/test/org/apache/lucene/index/TestFieldsReader.java)
    for (Iterator iter = l.iterator(); iter.hasNext();) {
      Field field = (Field) iter.next();
      assertTrue("field is null and it shouldn't be", field != null);
      String sv = field.stringValue();
      assertTrue("sv is null and it shouldn't be", sv != null);
      count++;
    }
,
>
, <(startLine=78 endLine=88 srcPath=/home/sonia/NewExperiment/luceneFilter/00657/lucene/src/java/org/apache/lucene/index/CompoundFileWriter.java)
    CompoundFileWriter(Directory dir, String name, SegmentMerger.CheckAbort checkAbort) {
        if (dir == null)
            throw new NullPointerException("directory cannot be null");
        if (name == null)
            throw new NullPointerException("name cannot be null");
        this.checkAbort = checkAbort;
        directory = dir;
        fileName = name;
        ids = new HashSet<String>();
        entries = new LinkedList<FileEntry>();
    }
,
(startLine=78 endLine=88 srcPath=/home/sonia/NewExperiment/luceneFilter/00657/lucene/backwards/src/java/org/apache/lucene/index/CompoundFileWriter.java)
    CompoundFileWriter(Directory dir, String name, SegmentMerger.CheckAbort checkAbort) {
        if (dir == null)
            throw new NullPointerException("directory cannot be null");
        if (name == null)
            throw new NullPointerException("name cannot be null");
        this.checkAbort = checkAbort;
        directory = dir;
        fileName = name;
        ids = new HashSet<String>();
        entries = new LinkedList<FileEntry>();
    }
,
>
, <(startLine=240 endLine=268 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/src/test/org/apache/lucene/search/TestSort.java)
  public void testTypedSort() throws Exception {
    sort.setSort (new SortField ("int", SortField.INT), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "IGAEC");
    assertMatches (full, queryY, sort, "DHFJB");

    sort.setSort (new SortField ("float", SortField.FLOAT), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "GCIEA");
    assertMatches (full, queryY, sort, "DHJFB");

    sort.setSort (new SortField ("long", SortField.LONG), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "EACGI");
    assertMatches (full, queryY, sort, "FBJHD");

    sort.setSort (new SortField ("double", SortField.DOUBLE), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "AGICE");
    assertMatches (full, queryY, sort, "DJHBF");

    sort.setSort (new SortField ("byte", SortField.BYTE), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "CIGAE");
    assertMatches (full, queryY, sort, "DHFBJ");

    sort.setSort (new SortField ("short", SortField.SHORT), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "IAGCE");
    assertMatches (full, queryY, sort, "DFHBJ");

    sort.setSort (new SortField ("string", SortField.STRING), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "AIGEC");
    assertMatches (full, queryY, sort, "DJHFB");
  }
,
(startLine=236 endLine=264 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/backwards/src/test/org/apache/lucene/search/TestSort.java)
  public void testTypedSort() throws Exception {
    sort.setSort (new SortField ("int", SortField.INT), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "IGAEC");
    assertMatches (full, queryY, sort, "DHFJB");

    sort.setSort (new SortField ("float", SortField.FLOAT), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "GCIEA");
    assertMatches (full, queryY, sort, "DHJFB");

    sort.setSort (new SortField ("long", SortField.LONG), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "EACGI");
    assertMatches (full, queryY, sort, "FBJHD");

    sort.setSort (new SortField ("double", SortField.DOUBLE), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "AGICE");
    assertMatches (full, queryY, sort, "DJHBF");

    sort.setSort (new SortField ("byte", SortField.BYTE), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "CIGAE");
    assertMatches (full, queryY, sort, "DHFBJ");

    sort.setSort (new SortField ("short", SortField.SHORT), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "IAGCE");
    assertMatches (full, queryY, sort, "DFHBJ");

    sort.setSort (new SortField ("string", SortField.STRING), SortField.FIELD_DOC );
    assertMatches (full, queryX, sort, "AIGEC");
    assertMatches (full, queryY, sort, "DJHFB");
  }
,
>
, <(startLine=986 endLine=996 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/test/org/apache/lucene/search/TestSort.java)
  throws IOException {
    HashMap<String,Float> scoreMap = new HashMap<String,Float>();
    int n = hits.length;
    for (int i=0; i<n; ++i) {
      Document doc = searcher.doc(hits[i].doc);
      String[] v = doc.getValues("tracer");
      assertEquals (v.length, 1);
      scoreMap.put (v[0], Float.valueOf(hits[i].score));
    }
    return scoreMap;
  }
,
(startLine=421 endLine=431 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/contrib/remote/src/test/org/apache/lucene/search/TestRemoteSort.java)
  throws IOException {
    HashMap<String, Float> scoreMap = new HashMap<String, Float>();
    int n = hits.length;
    for (int i=0; i<n; ++i) {
      Document doc = searcher.doc(hits[i].doc);
      String[] v = doc.getValues("tracer");
      assertEquals (v.length, 1);
      scoreMap.put (v[0], Float.valueOf(hits[i].score));
    }
    return scoreMap;
  }
,
(startLine=1009 endLine=1019 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/test/org/apache/lucene/search/TestSort.java)
  throws IOException {
    HashMap scoreMap = new HashMap();
    int n = hits.length;
    for (int i=0; i<n; ++i) {
      Document doc = searcher.doc(hits[i].doc);
      String[] v = doc.getValues("tracer");
      assertEquals (v.length, 1);
      scoreMap.put (v[0], Float.valueOf(hits[i].score));
    }
    return scoreMap;
  }
,
>
, <(startLine=3208 endLine=3229 srcPath=/home/sonia/NewExperiment/luceneFilter/00697/lucene/src/java/org/apache/lucene/index/IndexWriter.java)
        for(int i=0;i<numSegments;i++) {
          info = segmentInfos.info(i);
          if (info.dir != directory) {
            done = false;
            final MergePolicy.OneMerge newMerge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), mergePolicy instanceof LogMergePolicy && getUseCompoundFile());

            // Returns true if no running merge conflicts
            // with this one (and, records this merge as
            // pending), ie, this segment is not currently
            // being merged:
            if (registerMerge(newMerge)) {
              merge = newMerge;

              // If this segment is not currently being
              // merged, then advance it to running & run
              // the merge ourself (below):
              pendingMerges.remove(merge);
              runningMerges.add(merge);
              break;
            }
          }
        }
,
(startLine=3096 endLine=3117 srcPath=/home/sonia/NewExperiment/luceneFilter/00697/lucene/backwards/src/java/org/apache/lucene/index/IndexWriter.java)
        for(int i=0;i<numSegments;i++) {
          info = segmentInfos.info(i);
          if (info.dir != directory) {
            done = false;
            final MergePolicy.OneMerge newMerge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), mergePolicy instanceof LogMergePolicy && getUseCompoundFile());

            // Returns true if no running merge conflicts
            // with this one (and, records this merge as
            // pending), ie, this segment is not currently
            // being merged:
            if (registerMerge(newMerge)) {
              merge = newMerge;

              // If this segment is not currently being
              // merged, then advance it to running & run
              // the merge ourself (below):
              pendingMerges.remove(merge);
              runningMerges.add(merge);
              break;
            }
          }
        }
,
>
, <(startLine=37 endLine=42 srcPath=/home/sonia/NewExperiment/luceneFilter/01173/modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestStopFilter.java)
  public void testExactCase() throws IOException {
    StringReader reader = new StringReader("Now is The Time");
    Set<String> stopWords = asSet("is", "the", "Time");
    TokenStream stream = new StopFilter(TEST_VERSION_CURRENT, new MockTokenizer(reader, MockTokenizer.WHITESPACE, false), stopWords, false);
    assertTokenStreamContents(stream, new String[] { "Now", "The" });
  }
,
(startLine=44 endLine=49 srcPath=/home/sonia/NewExperiment/luceneFilter/01173/modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestStopFilter.java)
  public void testIgnoreCase() throws IOException {
    StringReader reader = new StringReader("Now is The Time");
    Set<String> stopWords = asSet( "is", "the", "Time" );
    TokenStream stream = new StopFilter(TEST_VERSION_CURRENT, new MockTokenizer(reader, MockTokenizer.WHITESPACE, false), stopWords, true);
    assertTokenStreamContents(stream, new String[] { "Now" });
  }
,
(startLine=51 endLine=57 srcPath=/home/sonia/NewExperiment/luceneFilter/01173/modules/analysis/common/src/test/org/apache/lucene/analysis/core/TestStopFilter.java)
  public void testStopFilt() throws IOException {
    StringReader reader = new StringReader("Now is The Time");
    String[] stopWords = new String[] { "is", "the", "Time" };
    Set<Object> stopSet = StopFilter.makeStopSet(TEST_VERSION_CURRENT, stopWords);
    TokenStream stream = new StopFilter(TEST_VERSION_CURRENT, new MockTokenizer(reader, MockTokenizer.WHITESPACE, false), stopSet);
    assertTokenStreamContents(stream, new String[] { "Now", "The" });
  }
,
>
, <(startLine=111 endLine=127 srcPath=/home/sonia/NewExperiment/luceneFilter/00054/src/java/org/apache/lucene/search/StringSortedHitQueue.java)
                        do {
                            Term term = enumerator.term();
                            if (term.field() != field) break;

                            // store term text
                            // we expect that there is at most one term per document
                            if (t >= mterms.length) throw new RuntimeException ("there are more terms than documents in field \""+field+"\"");
                            mterms[t] = term.text();

                            // store which documents use this term
                            termDocs.seek (enumerator);
                            while (termDocs.next()) {
                                retArray[termDocs.doc()] = t;
                            }

                            t++;
                        } while (enumerator.next());
,
(startLine=217 endLine=233 srcPath=/home/sonia/NewExperiment/luceneFilter/00054/src/java/org/apache/lucene/search/StringSortedHitQueue.java)
                        do {
                            Term term = enumerator.term();
                            if (term.field() != field) break;

                            // store term text
                            // we expect that there is at most one term per document
                            if (t >= mterms.length) throw new RuntimeException ("there are more terms than documents in field \""+field+"\"");
                            mterms[t] = term.text();

                            // store which documents use this term
                            termDocs.seek (enumerator);
                            while (termDocs.next()) {
                                retArray[termDocs.doc()] = t;
                            }

                            t++;
                        } while (enumerator.next());
,
>
, <(startLine=82 endLine=95 srcPath=/home/sonia/NewExperiment/luceneFilter/00145/contrib/db/src/java/org/apache/lucene/store/db/DbOutputStream.java)
        while (blockPos + len >= BLOCK_LEN) {
            int blockLen = BLOCK_LEN - blockPos;

            System.arraycopy(b, offset, block.getData(), blockPos, blockLen);
            block.put(blocks, txn, flags);

            len -= blockLen;
            offset += blockLen;
            position += blockLen;

            block.seek(position);
            block.get(blocks, txn, flags);
            blockPos = 0;
        }
,
(startLine=88 endLine=100 srcPath=/home/sonia/NewExperiment/luceneFilter/00145/contrib/db/src/java/org/apache/lucene/store/db/DbInputStream.java)
        while (blockPos + len >= DbOutputStream.BLOCK_LEN) {
            int blockLen = DbOutputStream.BLOCK_LEN - blockPos;

            System.arraycopy(block.getData(), blockPos, b, offset, blockLen);

            len -= blockLen;
            offset += blockLen;
            position += blockLen;

            block.seek(position);
            block.get(blocks, txn, flags);
            blockPos = 0;
        }
,
>
, <(startLine=80 endLine=95 srcPath=/home/sonia/NewExperiment/luceneFilter/01290/lucene/src/java/org/apache/lucene/index/AtomicReader.java)
  public final int docFreq(String field, BytesRef term) throws IOException {
    final Fields fields = fields();
    if (fields == null) {
      return 0;
    }
    final Terms terms = fields.terms(field);
    if (terms == null) {
      return 0;
    }
    final TermsEnum termsEnum = terms.iterator(null);
    if (termsEnum.seekExact(term, true)) {
      return termsEnum.docFreq();
    } else {
      return 0;
    }
  }
,
(startLine=102 endLine=117 srcPath=/home/sonia/NewExperiment/luceneFilter/01290/lucene/src/java/org/apache/lucene/index/AtomicReader.java)
  public final long totalTermFreq(String field, BytesRef term) throws IOException {
    final Fields fields = fields();
    if (fields == null) {
      return 0;
    }
    final Terms terms = fields.terms(field);
    if (terms == null) {
      return 0;
    }
    final TermsEnum termsEnum = terms.iterator(null);
    if (termsEnum.seekExact(term, true)) {
      return termsEnum.totalTermFreq();
    } else {
      return 0;
    }
  }
,
>
, <(startLine=180 endLine=232 srcPath=/home/sonia/NewExperiment/luceneFilter/00774/solr/src/test/org/apache/solr/update/DirectUpdateHandlerTest.java)
  public void testAddRollback() throws Exception {
    // re-init the core
    deleteCore();
    initCore("solrconfig.xml", "schema12.xml");

    addSimpleDoc("A");

    // commit "A"
    SolrCore core = h.getCore();
    UpdateHandler updater = core.getUpdateHandler();
    assertTrue( updater instanceof DirectUpdateHandler2 );
    DirectUpdateHandler2 duh2 = (DirectUpdateHandler2)updater;
    CommitUpdateCommand cmtCmd = new CommitUpdateCommand(false);
    cmtCmd.waitSearcher = true;
    assertEquals( 1, duh2.addCommands.get() );
    assertEquals( 1, duh2.addCommandsCumulative.get() );
    assertEquals( 0, duh2.commitCommands.get() );
    updater.commit(cmtCmd);
    assertEquals( 0, duh2.addCommands.get() );
    assertEquals( 1, duh2.addCommandsCumulative.get() );
    assertEquals( 1, duh2.commitCommands.get() );

    addSimpleDoc("B");

    // rollback "B"
    RollbackUpdateCommand rbkCmd = new RollbackUpdateCommand();
    assertEquals( 1, duh2.addCommands.get() );
    assertEquals( 2, duh2.addCommandsCumulative.get() );
    assertEquals( 0, duh2.rollbackCommands.get() );
    updater.rollback(rbkCmd);
    assertEquals( 0, duh2.addCommands.get() );
    assertEquals( 1, duh2.addCommandsCumulative.get() );
    assertEquals( 1, duh2.rollbackCommands.get() );
    
    // search - "B" should not be found.
    Map<String,String> args = new HashMap<String, String>();
    args.put( CommonParams.Q, "id:A OR id:B" );
    args.put( "indent", "true" );
    SolrQueryRequest req = new LocalSolrQueryRequest( core, new MapSolrParams( args) );
    assertQ("\"B\" should not be found.", req
            ,"//*[@numFound='1']"
            ,"//result/doc[1]/str[@name='id'][.='A']"
            );

    // Add a doc after the rollback to make sure we can continue to add/delete documents
    // after a rollback as normal
    addSimpleDoc("ZZZ");
    assertU(commit());
    assertQ("\"ZZZ\" must be found.", req("q", "id:ZZZ")
            ,"//*[@numFound='1']"
            ,"//result/doc[1]/str[@name='id'][.='ZZZ']"
            );
  }
,
(startLine=235 endLine=304 srcPath=/home/sonia/NewExperiment/luceneFilter/00774/solr/src/test/org/apache/solr/update/DirectUpdateHandlerTest.java)
  public void testDeleteRollback() throws Exception {
    // re-init the core
    deleteCore();
    initCore("solrconfig.xml", "schema12.xml");

    addSimpleDoc("A");
    addSimpleDoc("B");

    // commit "A", "B"
    SolrCore core = h.getCore();
    UpdateHandler updater = core.getUpdateHandler();
    assertTrue( updater instanceof DirectUpdateHandler2 );
    DirectUpdateHandler2 duh2 = (DirectUpdateHandler2)updater;
    CommitUpdateCommand cmtCmd = new CommitUpdateCommand(false);
    cmtCmd.waitSearcher = true;
    assertEquals( 2, duh2.addCommands.get() );
    assertEquals( 2, duh2.addCommandsCumulative.get() );
    assertEquals( 0, duh2.commitCommands.get() );
    updater.commit(cmtCmd);
    assertEquals( 0, duh2.addCommands.get() );
    assertEquals( 2, duh2.addCommandsCumulative.get() );
    assertEquals( 1, duh2.commitCommands.get() );

    // search - "A","B" should be found.
    Map<String,String> args = new HashMap<String, String>();
    args.put( CommonParams.Q, "id:A OR id:B" );
    args.put( "indent", "true" );
    SolrQueryRequest req = new LocalSolrQueryRequest( core, new MapSolrParams( args) );
    assertQ("\"A\" and \"B\" should be found.", req
            ,"//*[@numFound='2']"
            ,"//result/doc[1]/str[@name='id'][.='A']"
            ,"//result/doc[2]/str[@name='id'][.='B']"
            );

    // delete "B"
    deleteSimpleDoc("B");
    
    // search - "A","B" should be found.
    assertQ("\"A\" and \"B\" should be found.", req
        ,"//*[@numFound='2']"
        ,"//result/doc[1]/str[@name='id'][.='A']"
        ,"//result/doc[2]/str[@name='id'][.='B']"
        );

    // rollback "B"
    RollbackUpdateCommand rbkCmd = new RollbackUpdateCommand();
    assertEquals( 1, duh2.deleteByIdCommands.get() );
    assertEquals( 1, duh2.deleteByIdCommandsCumulative.get() );
    assertEquals( 0, duh2.rollbackCommands.get() );
    updater.rollback(rbkCmd);
    assertEquals( 0, duh2.deleteByIdCommands.get() );
    assertEquals( 0, duh2.deleteByIdCommandsCumulative.get() );
    assertEquals( 1, duh2.rollbackCommands.get() );
    
    // search - "B" should be found.
    assertQ("\"B\" should be found.", req
        ,"//*[@numFound='2']"
        ,"//result/doc[1]/str[@name='id'][.='A']"
        ,"//result/doc[2]/str[@name='id'][.='B']"
        );

    // Add a doc after the rollback to make sure we can continue to add/delete documents
    // after a rollback as normal
    addSimpleDoc("ZZZ");
    assertU(commit());
    assertQ("\"ZZZ\" must be found.", req("q", "id:ZZZ")
            ,"//*[@numFound='1']"
            ,"//result/doc[1]/str[@name='id'][.='ZZZ']"
            );
  }
,
>
, <(startLine=801 endLine=823 srcPath=/home/sonia/NewExperiment/luceneFilter/00663/lucene/src/test/org/apache/lucene/queryParser/TestQueryParser.java)
    throws Exception {
    Set<Object> stopWords = new HashSet<Object>(1);
    stopWords.add("on");
    StandardAnalyzer oneStopAnalyzer = new StandardAnalyzer(TEST_VERSION_CURRENT, stopWords);
    QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, "field", oneStopAnalyzer);
    Query q = qp.parse("on^1.0");
    assertNotNull(q);
    q = qp.parse("\"hello\"^2.0");
    assertNotNull(q);
    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
    q = qp.parse("hello^2.0");
    assertNotNull(q);
    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
    q = qp.parse("\"on\"^1.0");
    assertNotNull(q);

    QueryParser qp2 = new QueryParser(TEST_VERSION_CURRENT, "field", new StandardAnalyzer(TEST_VERSION_CURRENT));
    q = qp2.parse("the^3");
    // "the" is a stop word so the result is an empty query:
    assertNotNull(q);
    assertEquals("", q.toString());
    assertEquals(1.0f, q.getBoost(), 0.01f);
  }
,
(startLine=905 endLine=929 srcPath=/home/sonia/NewExperiment/luceneFilter/00663/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java)
  public void testBoost() throws Exception {
    StandardAnalyzer oneStopAnalyzer = new StandardAnalyzer(TEST_VERSION_CURRENT, Collections.singleton("on"));
    StandardQueryParser qp = new StandardQueryParser();
    qp.setAnalyzer(oneStopAnalyzer);

    Query q = qp.parse("on^1.0", "field");
    assertNotNull(q);
    q = qp.parse("\"hello\"^2.0", "field");
    assertNotNull(q);
    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
    q = qp.parse("hello^2.0", "field");
    assertNotNull(q);
    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
    q = qp.parse("\"on\"^1.0", "field");
    assertNotNull(q);

    StandardQueryParser qp2 = new StandardQueryParser();
    qp2.setAnalyzer(new StandardAnalyzer(TEST_VERSION_CURRENT));

    q = qp2.parse("the^3", "field");
    // "the" is a stop word so the result is an empty query:
    assertNotNull(q);
    assertEquals("", q.toString());
    assertEquals(1.0f, q.getBoost(), 0.01f);
  }
,
(startLine=896 endLine=917 srcPath=/home/sonia/NewExperiment/luceneFilter/00663/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java)
  public void testBoost() throws Exception {
    StandardAnalyzer oneStopAnalyzer = new StandardAnalyzer(TEST_VERSION_CURRENT, Collections.singleton("on"));
    QueryParserWrapper qp = new QueryParserWrapper("field", oneStopAnalyzer);
    Query q = qp.parse("on^1.0");
    assertNotNull(q);
    q = qp.parse("\"hello\"^2.0");
    assertNotNull(q);
    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
    q = qp.parse("hello^2.0");
    assertNotNull(q);
    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
    q = qp.parse("\"on\"^1.0");
    assertNotNull(q);

    QueryParserWrapper qp2 = new QueryParserWrapper("field",
        new StandardAnalyzer(TEST_VERSION_CURRENT));
    q = qp2.parse("the^3");
    // "the" is a stop word so the result is an empty query:
    assertNotNull(q);
    assertEquals("", q.toString());
    assertEquals(1.0f, q.getBoost(), 0.01f);
  }
,
(startLine=519 endLine=535 srcPath=/home/sonia/NewExperiment/luceneFilter/00663/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java)
    throws Exception {
    StandardAnalyzer oneStopAnalyzer = new StandardAnalyzer(TEST_VERSION_CURRENT, Collections.singleton("on"));
    PrecedenceQueryParser qp = new PrecedenceQueryParser("field", oneStopAnalyzer);
    Query q = qp.parse("on^1.0");
    assertNotNull(q);
    q = qp.parse("\"hello\"^2.0");
    assertNotNull(q);
    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
    q = qp.parse("hello^2.0");
    assertNotNull(q);
    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
    q = qp.parse("\"on\"^1.0");
    assertNotNull(q);

    q = getParser(new StandardAnalyzer(TEST_VERSION_CURRENT)).parse("the^3");
    assertNotNull(q);
  }
,
(startLine=800 endLine=822 srcPath=/home/sonia/NewExperiment/luceneFilter/00663/lucene/backwards/src/test/org/apache/lucene/queryParser/TestQueryParser.java)
    throws Exception {
    Set stopWords = new HashSet(1);
    stopWords.add("on");
    StandardAnalyzer oneStopAnalyzer = new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT, stopWords);
    QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, "field", oneStopAnalyzer);
    Query q = qp.parse("on^1.0");
    assertNotNull(q);
    q = qp.parse("\"hello\"^2.0");
    assertNotNull(q);
    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
    q = qp.parse("hello^2.0");
    assertNotNull(q);
    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
    q = qp.parse("\"on\"^1.0");
    assertNotNull(q);

    QueryParser qp2 = new QueryParser(Version.LUCENE_CURRENT, "field", new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT));
    q = qp2.parse("the^3");
    // "the" is a stop word so the result is an empty query:
    assertNotNull(q);
    assertEquals("", q.toString());
    assertEquals(1.0f, q.getBoost(), 0.01f);
  }
,
>
, <(startLine=339 endLine=359 srcPath=/home/sonia/NewExperiment/luceneFilter/00664/lucene/src/java/org/apache/lucene/index/TermVectorsReader.java)
  TermFreqVector[] get(int docNum) throws IOException {
    TermFreqVector[] result = null;
    if (tvx != null) {
      //We need to offset by
      seekTvx(docNum);
      long tvdPosition = tvx.readLong();

      tvd.seek(tvdPosition);
      int fieldCount = tvd.readVInt();

      // No fields are vectorized for this document
      if (fieldCount != 0) {
        final String[] fields = readFields(fieldCount);
        final long[] tvfPointers = readTvfPointers(fieldCount);
        result = readTermVectors(docNum, fields, tvfPointers);
      }
    } else {
      //System.out.println("No tvx file");
    }
    return result;
  }
,
(startLine=361 endLine=382 srcPath=/home/sonia/NewExperiment/luceneFilter/00664/lucene/src/java/org/apache/lucene/index/TermVectorsReader.java)
  public void get(int docNumber, TermVectorMapper mapper) throws IOException {
    // Check if no term vectors are available for this segment at all
    if (tvx != null) {
      //We need to offset by

      seekTvx(docNumber);
      long tvdPosition = tvx.readLong();

      tvd.seek(tvdPosition);
      int fieldCount = tvd.readVInt();

      // No fields are vectorized for this document
      if (fieldCount != 0) {
        final String[] fields = readFields(fieldCount);
        final long[] tvfPointers = readTvfPointers(fieldCount);
        mapper.setDocumentNumber(docNumber);
        readTermVectors(fields, tvfPointers, mapper);
      }
    } else {
      //System.out.println("No tvx file");
    }
  }
,
(startLine=337 endLine=357 srcPath=/home/sonia/NewExperiment/luceneFilter/00664/lucene/backwards/src/java/org/apache/lucene/index/TermVectorsReader.java)
  TermFreqVector[] get(int docNum) throws IOException {
    TermFreqVector[] result = null;
    if (tvx != null) {
      //We need to offset by
      seekTvx(docNum);
      long tvdPosition = tvx.readLong();

      tvd.seek(tvdPosition);
      int fieldCount = tvd.readVInt();

      // No fields are vectorized for this document
      if (fieldCount != 0) {
        final String[] fields = readFields(fieldCount);
        final long[] tvfPointers = readTvfPointers(fieldCount);
        result = readTermVectors(docNum, fields, tvfPointers);
      }
    } else {
      //System.out.println("No tvx file");
    }
    return result;
  }
,
(startLine=359 endLine=380 srcPath=/home/sonia/NewExperiment/luceneFilter/00664/lucene/backwards/src/java/org/apache/lucene/index/TermVectorsReader.java)
  public void get(int docNumber, TermVectorMapper mapper) throws IOException {
    // Check if no term vectors are available for this segment at all
    if (tvx != null) {
      //We need to offset by

      seekTvx(docNumber);
      long tvdPosition = tvx.readLong();

      tvd.seek(tvdPosition);
      int fieldCount = tvd.readVInt();

      // No fields are vectorized for this document
      if (fieldCount != 0) {
        final String[] fields = readFields(fieldCount);
        final long[] tvfPointers = readTvfPointers(fieldCount);
        mapper.setDocumentNumber(docNumber);
        readTermVectors(fields, tvfPointers, mapper);
      }
    } else {
      //System.out.println("No tvx file");
    }
  }
,
>
, <(startLine=155 endLine=171 srcPath=/home/sonia/NewExperiment/luceneFilter/02964/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/SelectStream.java)
  public Explanation toExplanation(StreamFactory factory) throws IOException {

    Explanation explanation = new StreamExplanation(getStreamNodeId().toString())
      .withChildren(new Explanation[]{
        stream.toExplanation(factory)
      })
      .withFunctionName(factory.getFunctionName(this.getClass()))
      .withImplementingClass(this.getClass().getName())
      .withExpressionType(ExpressionType.STREAM_DECORATOR)
      .withExpression(toExpression(factory, false).toString());   
    
    for(StreamOperation operation : operations){
      explanation.addHelper(operation.toExplanation(factory));
    }
    
    return explanation;
  }
,
(startLine=158 endLine=174 srcPath=/home/sonia/NewExperiment/luceneFilter/02964/solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/RollupStream.java)
  public Explanation toExplanation(StreamFactory factory) throws IOException {

    Explanation explanation = new StreamExplanation(getStreamNodeId().toString())
      .withChildren(new Explanation[]{
        tupleStream.toExplanation(factory)
      })
      .withFunctionName(factory.getFunctionName(this.getClass()))
      .withImplementingClass(this.getClass().getName())
      .withExpressionType(ExpressionType.STREAM_DECORATOR)
      .withExpression(toExpression(factory, false).toString());
    
    for(Metric metric : metrics){
      explanation.withHelper(metric.toExplanation(factory));
    }
    
    return explanation;
  }
,
>
, <(startLine=35 endLine=57 srcPath=/home/sonia/NewExperiment/luceneFilter/00647/solr/src/java/org/apache/solr/search/function/SimpleFloatFunction.java)
  public DocValues getValues(Map context, IndexReader reader) throws IOException {
    final DocValues vals =  source.getValues(context, reader);
    return new DocValues() {
      public float floatVal(int doc) {
    return func(doc, vals);
      }
      public int intVal(int doc) {
        return (int)floatVal(doc);
      }
      public long longVal(int doc) {
        return (long)floatVal(doc);
      }
      public double doubleVal(int doc) {
        return (double)floatVal(doc);
      }
      public String strVal(int doc) {
        return Float.toString(floatVal(doc));
      }
      public String toString(int doc) {
    return name() + '(' + vals.toString(doc) + ')';
      }
    };
  }
,
(startLine=49 endLine=71 srcPath=/home/sonia/NewExperiment/luceneFilter/00647/solr/src/java/org/apache/solr/search/function/LinearFloatFunction.java)
  public DocValues getValues(Map context, IndexReader reader) throws IOException {
    final DocValues vals =  source.getValues(context, reader);
    return new DocValues() {
      public float floatVal(int doc) {
        return vals.floatVal(doc) * slope + intercept;
      }
      public int intVal(int doc) {
        return (int)floatVal(doc);
      }
      public long longVal(int doc) {
        return (long)floatVal(doc);
      }
      public double doubleVal(int doc) {
        return (double)floatVal(doc);
      }
      public String strVal(int doc) {
        return Float.toString(floatVal(doc));
      }
      public String toString(int doc) {
        return slope + "*float(" + vals.toString(doc) + ")+" + intercept;
      }
    };
  }
,
(startLine=53 endLine=76 srcPath=/home/sonia/NewExperiment/luceneFilter/00647/solr/src/java/org/apache/solr/search/function/RangeMapFloatFunction.java)
  public DocValues getValues(Map context, IndexReader reader) throws IOException {
    final DocValues vals =  source.getValues(context, reader);
    return new DocValues() {
      public float floatVal(int doc) {
        float val = vals.floatVal(doc);
        return (val>=min && val<=max) ? target : (defaultVal == null ? val : defaultVal);
      }
      public int intVal(int doc) {
        return (int)floatVal(doc);
      }
      public long longVal(int doc) {
        return (long)floatVal(doc);
      }
      public double doubleVal(int doc) {
        return (double)floatVal(doc);
      }
      public String strVal(int doc) {
        return Float.toString(floatVal(doc));
      }
      public String toString(int doc) {
        return "map(" + vals.toString(doc) + ",min=" + min + ",max=" + max + ",target=" + target + ")";
      }
    };
  }
,
(startLine=48 endLine=71 srcPath=/home/sonia/NewExperiment/luceneFilter/00647/solr/src/java/org/apache/solr/search/function/MaxFloatFunction.java)
  public DocValues getValues(Map context, IndexReader reader) throws IOException {
    final DocValues vals =  source.getValues(context, reader);
    return new DocValues() {
      public float floatVal(int doc) {
    float v = vals.floatVal(doc);
        return v < fval ? fval : v;
      }
      public int intVal(int doc) {
        return (int)floatVal(doc);
      }
      public long longVal(int doc) {
        return (long)floatVal(doc);
      }
      public double doubleVal(int doc) {
        return (double)floatVal(doc);
      }
      public String strVal(int doc) {
        return Float.toString(floatVal(doc));
      }
      public String toString(int doc) {
    return "max(" + vals.toString(doc) + "," + fval + ")";
      }
    };
  }
,
(startLine=60 endLine=84 srcPath=/home/sonia/NewExperiment/luceneFilter/00647/solr/src/java/org/apache/solr/search/function/ReciprocalFloatFunction.java)
  public DocValues getValues(Map context, IndexReader reader) throws IOException {
    final DocValues vals = source.getValues(context, reader);
    return new DocValues() {
      public float floatVal(int doc) {
        return a/(m*vals.floatVal(doc) + b);
      }
      public int intVal(int doc) {
        return (int)floatVal(doc);
      }
      public long longVal(int doc) {
        return (long)floatVal(doc);
      }
      public double doubleVal(int doc) {
        return (double)floatVal(doc);
      }
      public String strVal(int doc) {
        return Float.toString(floatVal(doc));
      }
      public String toString(int doc) {
        return Float.toString(a) + "/("
                + m + "*float(" + vals.toString(doc) + ')'
                + '+' + b + ')';
      }
    };
  }
,
(startLine=46 endLine=69 srcPath=/home/sonia/NewExperiment/luceneFilter/00647/solr/src/java/org/apache/solr/search/function/DualFloatFunction.java)
  public DocValues getValues(Map context, IndexReader reader) throws IOException {
    final DocValues aVals =  a.getValues(context, reader);
    final DocValues bVals =  b.getValues(context, reader);
    return new DocValues() {
      public float floatVal(int doc) {
    return func(doc, aVals, bVals);
      }
      public int intVal(int doc) {
        return (int)floatVal(doc);
      }
      public long longVal(int doc) {
        return (long)floatVal(doc);
      }
      public double doubleVal(int doc) {
        return floatVal(doc);
      }
      public String strVal(int doc) {
        return Float.toString(floatVal(doc));
      }
      public String toString(int doc) {
    return name() + '(' + aVals.toString(doc) + ',' + bVals.toString(doc) + ')';
      }
    };
  }
,
(startLine=750 endLine=772 srcPath=/home/sonia/NewExperiment/luceneFilter/00647/solr/src/java/org/apache/solr/search/ValueSourceParser.java)
    public DocValues getValues(Map context, IndexReader reader) throws IOException {
      final DocValues vals =  source.getValues(context, reader);
      return new DocValues() {
        public float floatVal(int doc) {
          return (float)doubleVal(doc);
        }
        public int intVal(int doc) {
          return (int)doubleVal(doc);
        }
        public long longVal(int doc) {
          return (long)doubleVal(doc);
        }
        public double doubleVal(int doc) {
          return func(doc, vals);
        }
        public String strVal(int doc) {
          return Double.toString(doubleVal(doc));
        }
        public String toString(int doc) {
          return name() + '(' + vals.toString(doc) + ')';
        }
      };
    }
,
(startLine=805 endLine=828 srcPath=/home/sonia/NewExperiment/luceneFilter/00647/solr/src/java/org/apache/solr/search/ValueSourceParser.java)
    public DocValues getValues(Map context, IndexReader reader) throws IOException {
      final DocValues aVals =  a.getValues(context, reader);
      final DocValues bVals =  b.getValues(context, reader);
      return new DocValues() {
        public float floatVal(int doc) {
          return (float)doubleVal(doc);
        }
        public int intVal(int doc) {
          return (int)doubleVal(doc);
        }
        public long longVal(int doc) {
          return (long)doubleVal(doc);
        }
        public double doubleVal(int doc) {
          return func(doc, aVals, bVals);
        }
        public String strVal(int doc) {
          return Double.toString(doubleVal(doc));
        }
        public String toString(int doc) {
          return name() + '(' + aVals.toString(doc) + ',' + bVals.toString(doc) + ')';
        }
      };
    }
,
>
, <(startLine=114 endLine=120 srcPath=/home/sonia/NewExperiment/luceneFilter/03235/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestDocBuilder.java)
    for (int i = 0; i < l.size(); i++) {
      Map<String, Object> map = l.get(i);
      SolrInputDocument doc = swi.docs.get(i);
      for (Map.Entry<String, Object> entry : map.entrySet()) {
        assertEquals(entry.getValue(), doc.getFieldValue(entry.getKey()));
      }
    }
,
(startLine=143 endLine=149 srcPath=/home/sonia/NewExperiment/luceneFilter/03235/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestDocBuilder.java)
    for (int i = 0; i < l.size(); i++) {
      Map<String, Object> map = (Map<String, Object>) l.get(i);
      SolrInputDocument doc = swi.docs.get(i);
      for (Map.Entry<String, Object> entry : map.entrySet()) {
        assertEquals(entry.getValue(), doc.getFieldValue(entry.getKey()));
      }
    }
,
(startLine=171 endLine=178 srcPath=/home/sonia/NewExperiment/luceneFilter/03235/solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestDocBuilder.java)
    for (int i = 0; i < l.size(); i++) {
      Map<String, Object> map = (Map<String, Object>) l.get(i);
      SolrInputDocument doc = swi.docs.get(i);
      for (Map.Entry<String, Object> entry : map.entrySet()) {
        assertEquals(entry.getValue(), doc.getFieldValue(entry.getKey()));
      }
      assertEquals(map.get("desc"), doc.getFieldValue("desc_s"));
    }
,
>
, <(startLine=81 endLine=87 srcPath=/home/sonia/NewExperiment/luceneFilter/02358/lucene/core/src/test/org/apache/lucene/TestSearchForDuplicates.java)
      for (int j = 0; j < MAX_DOCS; j++) {
        Document d = new Document();
        d.add(newTextField(PRIORITY_FIELD, HIGH_PRIORITY, Field.Store.YES));
        d.add(new IntField(ID_FIELD, j, Field.Store.YES));
        d.add(new NumericDocValuesField(ID_FIELD, j));
        writer.addDocument(d);
      }
,
(startLine=127 endLine=133 srcPath=/home/sonia/NewExperiment/luceneFilter/02358/lucene/core/src/test/org/apache/lucene/TestSearch.java)
      for (int j = 0; j < docs.length; j++) {
        Document d = new Document();
        d.add(newTextField("contents", docs[j], Field.Store.YES));
        d.add(new IntField("id", j, Field.Store.NO));
        d.add(new NumericDocValuesField("id", j));
        writer.addDocument(d);
      }
,
>
, <(startLine=3239 endLine=3259 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java)
  public void testExceptionsDuringCommit() throws Throwable {
    MockRAMDirectory dir = new MockRAMDirectory();
    FailOnlyInCommit failure = new FailOnlyInCommit();
    IndexWriter w = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)));
    Document doc = new Document();
    doc.add(new Field("field", "a field", Field.Store.YES,
                      Field.Index.ANALYZED));
    w.addDocument(doc);
    dir.failOn(failure);
    try {
      w.close();
      fail();
    } catch (IOException ioe) {
      fail("expected only RuntimeException");
    } catch (RuntimeException re) {
      // Expected
    }
    assertTrue(failure.fail1 && failure.fail2);
    w.rollback();
    dir.close();
  }
,
(startLine=3246 endLine=3266 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/test/org/apache/lucene/index/TestIndexWriter.java)
  public void testExceptionsDuringCommit() throws Throwable {
    MockRAMDirectory dir = new MockRAMDirectory();
    FailOnlyInCommit failure = new FailOnlyInCommit();
    IndexWriter w = new IndexWriter(dir, new WhitespaceAnalyzer(), true, IndexWriter.MaxFieldLength.UNLIMITED);
    Document doc = new Document();
    doc.add(new Field("field", "a field", Field.Store.YES,
                      Field.Index.ANALYZED));
    w.addDocument(doc);
    dir.failOn(failure);
    try {
      w.close();
      fail();
    } catch (IOException ioe) {
      fail("expected only RuntimeException");
    } catch (RuntimeException re) {
      // Expected
    }
    assertTrue(failure.fail1 && failure.fail2);
    w.rollback();
    dir.close();
  }
,
>
, <(startLine=199 endLine=209 srcPath=/home/sonia/NewExperiment/luceneFilter/00927/lucene/lucene/src/java/org/apache/lucene/util/NumericUtils.java)
    for (int i=val.offset+1, limit=val.offset+val.length; i<limit; i++) {
      sortableBits <<= 7;
      final byte b = val.bytes[i];
      if (b < 0) {
        throw new NumberFormatException(
          "Invalid prefixCoded numerical value representation (byte "+
          Integer.toHexString(b&0xff)+" at position "+(i-val.offset)+" is invalid)"
        );
      }
      sortableBits |= b;
    }
,
(startLine=223 endLine=233 srcPath=/home/sonia/NewExperiment/luceneFilter/00927/lucene/lucene/src/java/org/apache/lucene/util/NumericUtils.java)
    for (int i=val.offset+1, limit=val.offset+val.length; i<limit; i++) {
      sortableBits <<= 7;
      final byte b = val.bytes[i];
      if (b < 0) {
        throw new NumberFormatException(
          "Invalid prefixCoded numerical value representation (byte "+
          Integer.toHexString(b&0xff)+" at position "+(i-val.offset)+" is invalid)"
        );
      }
      sortableBits |= b;
    }
,
>
, <(startLine=869 endLine=885 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java)
    public void testChangesAfterClose() throws IOException {
        Directory dir = new RAMDirectory();

        IndexWriter writer = null;

        writer  = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)));
        addDoc(writer);

        // close
        writer.close();
        try {
          addDoc(writer);
          fail("did not hit AlreadyClosedException");
        } catch (AlreadyClosedException e) {
          // expected
        }
    }
,
(startLine=874 endLine=890 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/backwards/src/test/org/apache/lucene/index/TestIndexWriter.java)
    public void testChangesAfterClose() throws IOException {
        Directory dir = new RAMDirectory();

        IndexWriter writer = null;

        writer  = new IndexWriter(dir, new WhitespaceAnalyzer(), true, IndexWriter.MaxFieldLength.LIMITED);
        addDoc(writer);

        // close
        writer.close();
        try {
          addDoc(writer);
          fail("did not hit AlreadyClosedException");
        } catch (AlreadyClosedException e) {
          // expected
        }
    }
,
>
, <(startLine=92 endLine=157 srcPath=/home/sonia/NewExperiment/luceneFilter/01125/modules/analysis/common/src/java/org/tartarus/snowball/ext/German2Stemmer.java)
            {
                v_2 = cursor;
                lab1: do {
                    // goto, line 30
                    golab2: while(true)
                    {
                        v_3 = cursor;
                        lab3: do {
                            // (, line 30
                            if (!(in_grouping(g_v, 97, 252)))
                            {
                                break lab3;
                            }
                            // [, line 31
                            bra = cursor;
                            // or, line 31
                            lab4: do {
                                v_4 = cursor;
                                lab5: do {
                                    // (, line 31
                                    // literal, line 31
                                    if (!(eq_s(1, "u")))
                                    {
                                        break lab5;
                                    }
                                    // ], line 31
                                    ket = cursor;
                                    if (!(in_grouping(g_v, 97, 252)))
                                    {
                                        break lab5;
                                    }
                                    // <-, line 31
                                    slice_from("U");
                                    break lab4;
                                } while (false);
                                cursor = v_4;
                                // (, line 32
                                // literal, line 32
                                if (!(eq_s(1, "y")))
                                {
                                    break lab3;
                                }
                                // ], line 32
                                ket = cursor;
                                if (!(in_grouping(g_v, 97, 252)))
                                {
                                    break lab3;
                                }
                                // <-, line 32
                                slice_from("Y");
                            } while (false);
                            cursor = v_3;
                            break golab2;
                        } while (false);
                        cursor = v_3;
                        if (cursor >= limit)
                        {
                            break lab1;
                        }
                        cursor++;
                    }
                    continue replab0;
                } while (false);
                cursor = v_2;
                break replab0;
            }
,
(startLine=121 endLine=186 srcPath=/home/sonia/NewExperiment/luceneFilter/01125/modules/analysis/common/src/java/org/tartarus/snowball/ext/GermanStemmer.java)
            {
                v_4 = cursor;
                lab5: do {
                    // goto, line 36
                    golab6: while(true)
                    {
                        v_5 = cursor;
                        lab7: do {
                            // (, line 36
                            if (!(in_grouping(g_v, 97, 252)))
                            {
                                break lab7;
                            }
                            // [, line 37
                            bra = cursor;
                            // or, line 37
                            lab8: do {
                                v_6 = cursor;
                                lab9: do {
                                    // (, line 37
                                    // literal, line 37
                                    if (!(eq_s(1, "u")))
                                    {
                                        break lab9;
                                    }
                                    // ], line 37
                                    ket = cursor;
                                    if (!(in_grouping(g_v, 97, 252)))
                                    {
                                        break lab9;
                                    }
                                    // <-, line 37
                                    slice_from("U");
                                    break lab8;
                                } while (false);
                                cursor = v_6;
                                // (, line 38
                                // literal, line 38
                                if (!(eq_s(1, "y")))
                                {
                                    break lab7;
                                }
                                // ], line 38
                                ket = cursor;
                                if (!(in_grouping(g_v, 97, 252)))
                                {
                                    break lab7;
                                }
                                // <-, line 38
                                slice_from("Y");
                            } while (false);
                            cursor = v_5;
                            break golab6;
                        } while (false);
                        cursor = v_5;
                        if (cursor >= limit)
                        {
                            break lab5;
                        }
                        cursor++;
                    }
                    continue replab4;
                } while (false);
                cursor = v_4;
                break replab4;
            }
,
(startLine=271 endLine=345 srcPath=/home/sonia/NewExperiment/luceneFilter/01125/modules/analysis/common/src/java/org/tartarus/snowball/ext/RomanianStemmer.java)
        private boolean r_prelude() {
            int v_1;
            int v_2;
            int v_3;
            // (, line 31
            // repeat, line 32
            replab0: while(true)
            {
                v_1 = cursor;
                lab1: do {
                    // goto, line 32
                    golab2: while(true)
                    {
                        v_2 = cursor;
                        lab3: do {
                            // (, line 32
                            if (!(in_grouping(g_v, 97, 259)))
                            {
                                break lab3;
                            }
                            // [, line 33
                            bra = cursor;
                            // or, line 33
                            lab4: do {
                                v_3 = cursor;
                                lab5: do {
                                    // (, line 33
                                    // literal, line 33
                                    if (!(eq_s(1, "u")))
                                    {
                                        break lab5;
                                    }
                                    // ], line 33
                                    ket = cursor;
                                    if (!(in_grouping(g_v, 97, 259)))
                                    {
                                        break lab5;
                                    }
                                    // <-, line 33
                                    slice_from("U");
                                    break lab4;
                                } while (false);
                                cursor = v_3;
                                // (, line 34
                                // literal, line 34
                                if (!(eq_s(1, "i")))
                                {
                                    break lab3;
                                }
                                // ], line 34
                                ket = cursor;
                                if (!(in_grouping(g_v, 97, 259)))
                                {
                                    break lab3;
                                }
                                // <-, line 34
                                slice_from("I");
                            } while (false);
                            cursor = v_2;
                            break golab2;
                        } while (false);
                        cursor = v_2;
                        if (cursor >= limit)
                        {
                            break lab1;
                        }
                        cursor++;
                    }
                    continue replab0;
                } while (false);
                cursor = v_1;
                break replab0;
            }
            return true;
        }
,
(startLine=217 endLine=276 srcPath=/home/sonia/NewExperiment/luceneFilter/01125/modules/analysis/common/src/java/org/tartarus/snowball/ext/FrenchStemmer.java)
                                lab5: do {
                                    // (, line 40
                                    if (!(in_grouping(g_v, 97, 251)))
                                    {
                                        break lab5;
                                    }
                                    // [, line 40
                                    bra = cursor;
                                    // or, line 40
                                    lab6: do {
                                        v_4 = cursor;
                                        lab7: do {
                                            // (, line 40
                                            // literal, line 40
                                            if (!(eq_s(1, "u")))
                                            {
                                                break lab7;
                                            }
                                            // ], line 40
                                            ket = cursor;
                                            if (!(in_grouping(g_v, 97, 251)))
                                            {
                                                break lab7;
                                            }
                                            // <-, line 40
                                            slice_from("U");
                                            break lab6;
                                        } while (false);
                                        cursor = v_4;
                                        lab8: do {
                                            // (, line 41
                                            // literal, line 41
                                            if (!(eq_s(1, "i")))
                                            {
                                                break lab8;
                                            }
                                            // ], line 41
                                            ket = cursor;
                                            if (!(in_grouping(g_v, 97, 251)))
                                            {
                                                break lab8;
                                            }
                                            // <-, line 41
                                            slice_from("I");
                                            break lab6;
                                        } while (false);
                                        cursor = v_4;
                                        // (, line 42
                                        // literal, line 42
                                        if (!(eq_s(1, "y")))
                                        {
                                            break lab5;
                                        }
                                        // ], line 42
                                        ket = cursor;
                                        // <-, line 42
                                        slice_from("Y");
                                    } while (false);
                                    break lab4;
                                } while (false);
,
(startLine=327 endLine=392 srcPath=/home/sonia/NewExperiment/luceneFilter/01125/modules/analysis/common/src/java/org/tartarus/snowball/ext/ItalianStemmer.java)
            {
                v_3 = cursor;
                lab3: do {
                    // goto, line 46
                    golab4: while(true)
                    {
                        v_4 = cursor;
                        lab5: do {
                            // (, line 46
                            if (!(in_grouping(g_v, 97, 249)))
                            {
                                break lab5;
                            }
                            // [, line 47
                            bra = cursor;
                            // or, line 47
                            lab6: do {
                                v_5 = cursor;
                                lab7: do {
                                    // (, line 47
                                    // literal, line 47
                                    if (!(eq_s(1, "u")))
                                    {
                                        break lab7;
                                    }
                                    // ], line 47
                                    ket = cursor;
                                    if (!(in_grouping(g_v, 97, 249)))
                                    {
                                        break lab7;
                                    }
                                    // <-, line 47
                                    slice_from("U");
                                    break lab6;
                                } while (false);
                                cursor = v_5;
                                // (, line 48
                                // literal, line 48
                                if (!(eq_s(1, "i")))
                                {
                                    break lab5;
                                }
                                // ], line 48
                                ket = cursor;
                                if (!(in_grouping(g_v, 97, 249)))
                                {
                                    break lab5;
                                }
                                // <-, line 48
                                slice_from("I");
                            } while (false);
                            cursor = v_4;
                            break golab4;
                        } while (false);
                        cursor = v_4;
                        if (cursor >= limit)
                        {
                            break lab3;
                        }
                        cursor++;
                    }
                    continue replab2;
                } while (false);
                cursor = v_3;
                break replab2;
            }
,
>
, <(startLine=611 endLine=642 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java)
      for(int numDocs=38;numDocs<500;numDocs += 38) {
        LogDocMergePolicy ldmp = new LogDocMergePolicy();
        ldmp.setMinMergeDocs(1);
        ldmp.setMergeFactor(5);
        IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(
          TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT))
          .setOpenMode(OpenMode.CREATE).setMaxBufferedDocs(2).setMergePolicy(
              ldmp));
        for(int j=0;j<numDocs;j++)
          writer.addDocument(doc);
        writer.close();

        SegmentInfos sis = new SegmentInfos();
        sis.read(dir);
        final int segCount = sis.size();

        ldmp = new LogDocMergePolicy();
        ldmp.setMergeFactor(5);
        writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT,
          new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMergePolicy(ldmp));
        writer.optimize(3);
        writer.close();

        sis = new SegmentInfos();
        sis.read(dir);
        final int optSegCount = sis.size();

        if (segCount < 3)
          assertEquals(segCount, optSegCount);
        else
          assertEquals(3, optSegCount);
      }
,
(startLine=616 endLine=647 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/test/org/apache/lucene/index/TestIndexWriter.java)
      for(int numDocs=38;numDocs<500;numDocs += 38) {
        IndexWriter writer  = new IndexWriter(dir, new WhitespaceAnalyzer(), true, IndexWriter.MaxFieldLength.LIMITED);
        LogDocMergePolicy ldmp = new LogDocMergePolicy();
        ldmp.setMinMergeDocs(1);
        writer.setMergePolicy(ldmp);
        writer.setMergeFactor(5);
        writer.setMaxBufferedDocs(2);
        for(int j=0;j<numDocs;j++)
          writer.addDocument(doc);
        writer.close();

        SegmentInfos sis = new SegmentInfos();
        sis.read(dir);
        final int segCount = sis.size();

        writer  = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);
        ldmp = new LogDocMergePolicy();
        ldmp.setMinMergeDocs(1);
        writer.setMergePolicy(ldmp);
        writer.setMergeFactor(5);
        writer.optimize(3);
        writer.close();

        sis = new SegmentInfos();
        sis.read(dir);
        final int optSegCount = sis.size();

        if (segCount < 3)
          assertEquals(segCount, optSegCount);
        else
          assertEquals(3, optSegCount);
      }
,
>
, <(startLine=639 endLine=716 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/test/org/apache/lucene/search/TestSort.java)
  public void testNormalizedScores() throws Exception {

    // capture relevancy scores
    HashMap<String,Float> scoresX = getScores (full.search (queryX, null, 1000).scoreDocs, full);
    HashMap<String,Float> scoresY = getScores (full.search (queryY, null, 1000).scoreDocs, full);
    HashMap<String,Float> scoresA = getScores (full.search (queryA, null, 1000).scoreDocs, full);

    // we'll test searching locally, remote and multi
    
    MultiSearcher multi  = new MultiSearcher (new Searchable[] { searchX, searchY });

    // change sorting and make sure relevancy stays the same

    sort = new Sort();
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort(SortField.FIELD_DOC);
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField("int", SortField.INT));
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField("float", SortField.FLOAT));
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField("string", SortField.STRING));
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField("int", SortField.INT),new SortField("float", SortField.FLOAT));
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField ("int", SortField.INT, true), new SortField (null, SortField.DOC, true) );
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField("int", SortField.INT),new SortField("string", SortField.STRING));
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

  }
,
(startLine=662 endLine=739 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/test/org/apache/lucene/search/TestSort.java)
  public void testNormalizedScores() throws Exception {

    // capture relevancy scores
    HashMap scoresX = getScores (full.search (queryX, null, 1000).scoreDocs, full);
    HashMap scoresY = getScores (full.search (queryY, null, 1000).scoreDocs, full);
    HashMap scoresA = getScores (full.search (queryA, null, 1000).scoreDocs, full);

    // we'll test searching locally, remote and multi
    
    MultiSearcher multi  = new MultiSearcher (new Searchable[] { searchX, searchY });

    // change sorting and make sure relevancy stays the same

    sort = new Sort();
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort(SortField.FIELD_DOC);
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField("int", SortField.INT));
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField("float", SortField.FLOAT));
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField("string", SortField.STRING));
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField("int", SortField.INT),new SortField("float", SortField.FLOAT));
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField ("int", SortField.INT, true), new SortField (null, SortField.DOC, true) );
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

    sort.setSort (new SortField("int", SortField.INT),new SortField("string", SortField.STRING));
    assertSameValues (scoresX, getScores (full.search (queryX, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresX, getScores (multi.search (queryX, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresY, getScores (full.search (queryY, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresY, getScores (multi.search (queryY, null, 1000, sort).scoreDocs, multi));
    assertSameValues (scoresA, getScores (full.search (queryA, null, 1000, sort).scoreDocs, full));
    assertSameValues (scoresA, getScores (multi.search (queryA, null, 1000, sort).scoreDocs, multi));

  }
,
>
, <(startLine=194 endLine=217 srcPath=/home/sonia/NewExperiment/luceneFilter/01864/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java)
      public void get(int docID, BytesRef result) {
        try {
          if (docID < 0 || docID >= maxDoc) {
            throw new IndexOutOfBoundsException("docID must be 0 .. " + (maxDoc-1) + "; got " + docID);
          }
          in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);
          SimpleTextUtil.readLine(in, scratch);
          assert StringHelper.startsWith(scratch, LENGTH);
          int len;
          try {
            len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, "UTF-8")).intValue();
          } catch (ParseException pe) {
            CorruptIndexException e = new CorruptIndexException("failed to parse int length (resource=" + in + ")");
            e.initCause(pe);
            throw e;
          }
          result.bytes = new byte[len];
          result.offset = 0;
          result.length = len;
          in.readBytes(result.bytes, 0, len);
        } catch (IOException ioe) {
          throw new RuntimeException(ioe);
        }
      }
,
(startLine=256 endLine=279 srcPath=/home/sonia/NewExperiment/luceneFilter/01864/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java)
      public void lookupOrd(int ord, BytesRef result) {
        try {
          if (ord < 0 || ord >= field.numValues) {
            throw new IndexOutOfBoundsException("ord must be 0 .. " + (field.numValues-1) + "; got " + ord);
          }
          in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));
          SimpleTextUtil.readLine(in, scratch);
          assert StringHelper.startsWith(scratch, LENGTH): "got " + scratch.utf8ToString() + " in=" + in;
          int len;
          try {
            len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, "UTF-8")).intValue();
          } catch (ParseException pe) {
            CorruptIndexException e = new CorruptIndexException("failed to parse int length (resource=" + in + ")");
            e.initCause(pe);
            throw e;
          }
          result.bytes = new byte[len];
          result.offset = 0;
          result.length = len;
          in.readBytes(result.bytes, 0, len);
        } catch (IOException ioe) {
          throw new RuntimeException(ioe);
        }
      }
,
(startLine=334 endLine=357 srcPath=/home/sonia/NewExperiment/luceneFilter/01864/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java)
      public void lookupOrd(long ord, BytesRef result) {
        try {
          if (ord < 0 || ord >= field.numValues) {
            throw new IndexOutOfBoundsException("ord must be 0 .. " + (field.numValues-1) + "; got " + ord);
          }
          in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));
          SimpleTextUtil.readLine(in, scratch);
          assert StringHelper.startsWith(scratch, LENGTH): "got " + scratch.utf8ToString() + " in=" + in;
          int len;
          try {
            len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, "UTF-8")).intValue();
          } catch (ParseException pe) {
            CorruptIndexException e = new CorruptIndexException("failed to parse int length (resource=" + in + ")");
            e.initCause(pe);
            throw e;
          }
          result.bytes = new byte[len];
          result.offset = 0;
          result.length = len;
          in.readBytes(result.bytes, 0, len);
        } catch (IOException ioe) {
          throw new RuntimeException(ioe);
        }
      }
,
>
, <(startLine=278 endLine=283 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/test/org/apache/lucene/index/TestIndexReaderCloneNorms.java)
      for (int j = 0; j < b.length; j++) {
        float norm = Similarity.getDefault().decodeNormValue(b[j]);
        float norm1 =  storedNorms.get(j).floatValue();
        assertEquals("stored norm value of " + field + " for doc " + j + " is "
            + norm + " - a mismatch!", norm, norm1, 0.000001);
      }
,
(startLine=229 endLine=234 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/test/org/apache/lucene/index/TestIndexReaderCloneNorms.java)
      for (int j = 0; j < b.length; j++) {
        float norm = Similarity.decodeNorm(b[j]);
        float norm1 = ((Float) storedNorms.get(j)).floatValue();
        assertEquals("stored norm value of " + field + " for doc " + j + " is "
            + norm + " - a mismatch!", norm, norm1, 0.000001);
      }
,
>
, <(startLine=470 endLine=483 srcPath=/home/sonia/NewExperiment/luceneFilter/01235/modules/queryparser/src/java/org/apache/lucene/queryparser/surround/parser/QueryParserTokenManager.java)
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               default : break;
            }
         } while(i != startsAt);
      }
,
(startLine=606 endLine=619 srcPath=/home/sonia/NewExperiment/luceneFilter/01235/modules/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserTokenManager.java)
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               default : break;
            }
         } while(i != startsAt);
      }
,
(startLine=496 endLine=509 srcPath=/home/sonia/NewExperiment/luceneFilter/01235/modules/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.java)
      {
         int hiByte = (int)(curChar >> 8);
         int i1 = hiByte >> 6;
         long l1 = 1L << (hiByte & 077);
         int i2 = (curChar & 0xff) >> 6;
         long l2 = 1L << (curChar & 077);
         do
         {
            switch(jjstateSet[--i])
            {
               default : break;
            }
         } while(i != startsAt);
      }
,
>
, <(startLine=51 endLine=94 srcPath=/home/sonia/NewExperiment/luceneFilter/00927/lucene/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java)
  public static void beforeClass() throws Exception {
    directory = newDirectory();
    RandomIndexWriter writer = new RandomIndexWriter(random, directory,
        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer())
        .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))
        .setMergePolicy(newInOrderLogMergePolicy()));
    
    NumericField
      field8 = new NumericField("field8", 8, Field.Store.YES, true),
      field6 = new NumericField("field6", 6, Field.Store.YES, true),
      field4 = new NumericField("field4", 4, Field.Store.YES, true),
      field2 = new NumericField("field2", 2, Field.Store.YES, true),
      fieldNoTrie = new NumericField("field"+Integer.MAX_VALUE, Integer.MAX_VALUE, Field.Store.YES, true),
      ascfield8 = new NumericField("ascfield8", 8, Field.Store.NO, true),
      ascfield6 = new NumericField("ascfield6", 6, Field.Store.NO, true),
      ascfield4 = new NumericField("ascfield4", 4, Field.Store.NO, true),
      ascfield2 = new NumericField("ascfield2", 2, Field.Store.NO, true);
    
    Document doc = new Document();
    // add fields, that have a distance to test general functionality
    doc.add(field8); doc.add(field6); doc.add(field4); doc.add(field2); doc.add(fieldNoTrie);
    // add ascending fields with a distance of 1, beginning at -noDocs/2 to test the correct splitting of range and inclusive/exclusive
    doc.add(ascfield8); doc.add(ascfield6); doc.add(ascfield4); doc.add(ascfield2);
    
    // Add a series of noDocs docs with increasing long values, by updating the fields
    for (int l=0; l<noDocs; l++) {
      long val=distance*l+startOffset;
      field8.setLongValue(val);
      field6.setLongValue(val);
      field4.setLongValue(val);
      field2.setLongValue(val);
      fieldNoTrie.setLongValue(val);

      val=l-(noDocs/2);
      ascfield8.setLongValue(val);
      ascfield6.setLongValue(val);
      ascfield4.setLongValue(val);
      ascfield2.setLongValue(val);
      writer.addDocument(doc);
    }
    reader = writer.getReader();
    searcher=new IndexSearcher(reader);
    writer.close();
  }
,
(startLine=54 endLine=94 srcPath=/home/sonia/NewExperiment/luceneFilter/00927/lucene/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java)
  public static void beforeClass() throws Exception {
    directory = newDirectory();
    RandomIndexWriter writer = new RandomIndexWriter(random, directory,
        newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer())
        .setMaxBufferedDocs(_TestUtil.nextInt(random, 50, 1000))
        .setMergePolicy(newInOrderLogMergePolicy()));
    
    NumericField
      field8 = new NumericField("field8", 8, Field.Store.YES, true),
      field4 = new NumericField("field4", 4, Field.Store.YES, true),
      field2 = new NumericField("field2", 2, Field.Store.YES, true),
      fieldNoTrie = new NumericField("field"+Integer.MAX_VALUE, Integer.MAX_VALUE, Field.Store.YES, true),
      ascfield8 = new NumericField("ascfield8", 8, Field.Store.NO, true),
      ascfield4 = new NumericField("ascfield4", 4, Field.Store.NO, true),
      ascfield2 = new NumericField("ascfield2", 2, Field.Store.NO, true);
    
    Document doc = new Document();
    // add fields, that have a distance to test general functionality
    doc.add(field8); doc.add(field4); doc.add(field2); doc.add(fieldNoTrie);
    // add ascending fields with a distance of 1, beginning at -noDocs/2 to test the correct splitting of range and inclusive/exclusive
    doc.add(ascfield8); doc.add(ascfield4); doc.add(ascfield2);
    
    // Add a series of noDocs docs with increasing int values
    for (int l=0; l<noDocs; l++) {
      int val=distance*l+startOffset;
      field8.setIntValue(val);
      field4.setIntValue(val);
      field2.setIntValue(val);
      fieldNoTrie.setIntValue(val);

      val=l-(noDocs/2);
      ascfield8.setIntValue(val);
      ascfield4.setIntValue(val);
      ascfield2.setIntValue(val);
      writer.addDocument(doc);
    }
  
    reader = writer.getReader();
    searcher=new IndexSearcher(reader);
    writer.close();
  }
,
>
, <(startLine=300 endLine=312 srcPath=/home/sonia/NewExperiment/luceneFilter/02409/lucene/test-framework/src/java/org/apache/lucene/index/AssertingLeafReader.java)
    public int nextDoc() throws IOException {
      assertThread("Docs enums", creationThread);
      assert state != DocsEnumState.FINISHED : "nextDoc() called after NO_MORE_DOCS";
      int nextDoc = super.nextDoc();
      assert nextDoc > doc : "backwards nextDoc from " + doc + " to " + nextDoc + " " + in;
      if (nextDoc == DocIdSetIterator.NO_MORE_DOCS) {
        state = DocsEnumState.FINISHED;
      } else {
        state = DocsEnumState.ITERATING;
      }
      assert super.docID() == nextDoc;
      return doc = nextDoc;
    }
,
(startLine=363 endLine=378 srcPath=/home/sonia/NewExperiment/luceneFilter/02409/lucene/test-framework/src/java/org/apache/lucene/index/AssertingLeafReader.java)
    public int nextDoc() throws IOException {
      assertThread("Docs enums", creationThread);
      assert state != DocsEnumState.FINISHED : "nextDoc() called after NO_MORE_DOCS";
      int nextDoc = super.nextDoc();
      assert nextDoc > doc : "backwards nextDoc from " + doc + " to " + nextDoc;
      positionCount = 0;
      if (nextDoc == DocIdSetIterator.NO_MORE_DOCS) {
        state = DocsEnumState.FINISHED;
        positionMax = 0;
      } else {
        state = DocsEnumState.ITERATING;
        positionMax = super.freq();
      }
      assert super.docID() == nextDoc;
      return doc = nextDoc;
    }
,
>
, <(startLine=900 endLine=913 srcPath=/home/sonia/NewExperiment/luceneFilter/01270/lucene/src/test/org/apache/lucene/search/TestSort.java)
    for (int i = 0; i < sort.length; i++) {
      Query q = new MatchAllDocsQuery();
      TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, false,
          false, true);
      
      full.search(q, tdc);
      
      TopDocs td = tdc.topDocs();
      ScoreDoc[] sd = td.scoreDocs;
      for (int j = 0; j < sd.length; j++) {
        assertTrue(Float.isNaN(sd[j].score));
      }
      assertTrue(Float.isNaN(td.getMaxScore()));
    }
,
(startLine=920 endLine=933 srcPath=/home/sonia/NewExperiment/luceneFilter/01270/lucene/src/test/org/apache/lucene/search/TestSort.java)
    for (int i = 0; i < sort.length; i++) {
      Query q = new MatchAllDocsQuery();
      TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true,
          false, true);
      
      full.search(q, tdc);
      
      TopDocs td = tdc.topDocs();
      ScoreDoc[] sd = td.scoreDocs;
      for (int j = 0; j < sd.length; j++) {
        assertTrue(!Float.isNaN(sd[j].score));
      }
      assertTrue(Float.isNaN(td.getMaxScore()));
    }
,
(startLine=941 endLine=954 srcPath=/home/sonia/NewExperiment/luceneFilter/01270/lucene/src/test/org/apache/lucene/search/TestSort.java)
    for (int i = 0; i < sort.length; i++) {
      Query q = new MatchAllDocsQuery();
      TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true,
          false, true);

      full.search(q, tdc);
      
      TopDocs td = tdc.topDocs();
      ScoreDoc[] sd = td.scoreDocs;
      for (int j = 0; j < sd.length; j++) {
        assertTrue(!Float.isNaN(sd[j].score));
      }
      assertTrue(Float.isNaN(td.getMaxScore()));
    }
,
(startLine=961 endLine=974 srcPath=/home/sonia/NewExperiment/luceneFilter/01270/lucene/src/test/org/apache/lucene/search/TestSort.java)
    for (int i = 0; i < sort.length; i++) {
      Query q = new MatchAllDocsQuery();
      TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true,
          true, true);
      
      full.search(q, tdc);
      
      TopDocs td = tdc.topDocs();
      ScoreDoc[] sd = td.scoreDocs;
      for (int j = 0; j < sd.length; j++) {
        assertTrue(!Float.isNaN(sd[j].score));
      }
      assertTrue(!Float.isNaN(td.getMaxScore()));
    }
,
>
, <(startLine=162 endLine=168 srcPath=/home/sonia/NewExperiment/luceneFilter/00939/lucene/contrib/db/bdb-je/src/test/org/apache/lucene/store/je/JEStoreTest.java)
        if (VERBOSE) {
          duration = (int) (end.getTime() - start.getTime());
          System.out.print(duration);
          System.out.print(" total milliseconds to create, ");
          System.out.print(totalLength / duration);
          System.out.println(" kb/s");
        }
,
(startLine=213 endLine=219 srcPath=/home/sonia/NewExperiment/luceneFilter/00939/lucene/contrib/db/bdb-je/src/test/org/apache/lucene/store/je/JEStoreTest.java)
        if (VERBOSE) {
          duration = (int) (end.getTime() - start.getTime());
          System.out.print(duration);
          System.out.print(" total milliseconds to read, ");
          System.out.print(totalLength / duration);
          System.out.println(" kb/s");
        }
,
(startLine=308 endLine=314 srcPath=/home/sonia/NewExperiment/luceneFilter/00939/lucene/contrib/db/bdb-je/src/test/org/apache/lucene/store/je/JEStoreTest.java)
        if (VERBOSE) {
          duration = (int) (end.getTime() - start.getTime());
          System.out.print(duration);
          System.out.print(" total milliseconds to read, ");
          System.out.print(totalLength / duration);
          System.out.println(" kb/s");
        }
,
(startLine=408 endLine=414 srcPath=/home/sonia/NewExperiment/luceneFilter/00939/lucene/contrib/db/bdb-je/src/test/org/apache/lucene/store/je/JEStoreTest.java)
        if (VERBOSE) {
          duration = (int) (end.getTime() - start.getTime());
          System.out.print(duration);
          System.out.print(" total milliseconds to read, ");
          System.out.print(totalLength / duration);
          System.out.println(" kb/s");
        }
,
(startLine=538 endLine=544 srcPath=/home/sonia/NewExperiment/luceneFilter/00939/lucene/contrib/db/bdb-je/src/test/org/apache/lucene/store/je/JEStoreTest.java)
        if (VERBOSE) {
          duration = (int) (end.getTime() - start.getTime());
          System.out.print(duration);
          System.out.print(" total milliseconds to create, ");
          System.out.print(totalLength / duration);
          System.out.println(" kb/s");
        }
,
(startLine=590 endLine=596 srcPath=/home/sonia/NewExperiment/luceneFilter/00939/lucene/contrib/db/bdb-je/src/test/org/apache/lucene/store/je/JEStoreTest.java)
        if (VERBOSE) {
          duration = (int) (end.getTime() - start.getTime());
          System.out.print(duration);
          System.out.print(" total milliseconds to read, ");
          System.out.print(totalLength / duration);
          System.out.println(" kb/s");
        }
,
(startLine=164 endLine=170 srcPath=/home/sonia/NewExperiment/luceneFilter/00939/lucene/contrib/db/bdb/src/test/org/apache/lucene/store/db/DbStoreTest.java)
        if (VERBOSE) {
          duration = (int) (end.getTime() - start.getTime());
          System.out.print(duration);
          System.out.print(" total milliseconds to create, ");
          System.out.print(totalLength / duration);
          System.out.println(" kb/s");
        }
,
(startLine=216 endLine=222 srcPath=/home/sonia/NewExperiment/luceneFilter/00939/lucene/contrib/db/bdb/src/test/org/apache/lucene/store/db/DbStoreTest.java)
        if (VERBOSE) {
          duration = (int) (end.getTime() - start.getTime());
          System.out.print(duration);
          System.out.print(" total milliseconds to read, ");
          System.out.print(totalLength / duration);
          System.out.println(" kb/s");
        }
,
(startLine=313 endLine=319 srcPath=/home/sonia/NewExperiment/luceneFilter/00939/lucene/contrib/db/bdb/src/test/org/apache/lucene/store/db/DbStoreTest.java)
        if (VERBOSE) {
          duration = (int) (end.getTime() - start.getTime());
          System.out.print(duration);
          System.out.print(" total milliseconds to create, ");
          System.out.print(totalLength / duration);
          System.out.println(" kb/s");
        }
,
(startLine=366 endLine=372 srcPath=/home/sonia/NewExperiment/luceneFilter/00939/lucene/contrib/db/bdb/src/test/org/apache/lucene/store/db/DbStoreTest.java)
        if (VERBOSE) {
          duration = (int) (end.getTime() - start.getTime());
          System.out.print(duration);
          System.out.print(" total milliseconds to read, ");
          System.out.print(totalLength / duration);
          System.out.println(" kb/s");
        }
,
>
, <(startLine=188 endLine=222 srcPath=/home/sonia/NewExperiment/luceneFilter/02663/lucene/core/src/test/org/apache/lucene/index/TestBinaryDocValuesUpdates.java)
  public void testReopen() throws Exception {
    Directory dir = newDirectory();
    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));
    IndexWriter writer = new IndexWriter(dir, conf);
    writer.addDocument(doc(0));
    writer.addDocument(doc(1));
    
    final boolean isNRT = random().nextBoolean();
    final DirectoryReader reader1;
    if (isNRT) {
      reader1 = DirectoryReader.open(writer, true);
    } else {
      writer.commit();
      reader1 = DirectoryReader.open(dir);
    }

    // update doc
    writer.updateBinaryDocValue(new Term("id", "doc-0"), "val", toBytes(10)); // update doc-0's value to 10
    if (!isNRT) {
      writer.commit();
    }
    
    // reopen reader and assert only it sees the update
    final DirectoryReader reader2 = DirectoryReader.openIfChanged(reader1);
    assertNotNull(reader2);
    assertTrue(reader1 != reader2);

    BinaryDocValues bdv1 = reader1.leaves().get(0).reader().getBinaryDocValues("val");
    BinaryDocValues bdv2 = reader2.leaves().get(0).reader().getBinaryDocValues("val");
    assertEquals(1, getValue(bdv1, 0));
    assertEquals(10, getValue(bdv2, 0));

    writer.close();
    IOUtils.close(reader1, reader2, dir);
  }
,
(startLine=175 endLine=207 srcPath=/home/sonia/NewExperiment/luceneFilter/02663/lucene/core/src/test/org/apache/lucene/index/TestNumericDocValuesUpdates.java)
  public void testReopen() throws Exception {
    Directory dir = newDirectory();
    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));
    IndexWriter writer = new IndexWriter(dir, conf);
    writer.addDocument(doc(0));
    writer.addDocument(doc(1));
    
    final boolean isNRT = random().nextBoolean();
    final DirectoryReader reader1;
    if (isNRT) {
      reader1 = DirectoryReader.open(writer, true);
    } else {
      writer.commit();
      reader1 = DirectoryReader.open(dir);
    }

    // update doc
    writer.updateNumericDocValue(new Term("id", "doc-0"), "val", 10L); // update doc-0's value to 10
    if (!isNRT) {
      writer.commit();
    }
    
    // reopen reader and assert only it sees the update
    final DirectoryReader reader2 = DirectoryReader.openIfChanged(reader1);
    assertNotNull(reader2);
    assertTrue(reader1 != reader2);

    assertEquals(1, reader1.leaves().get(0).reader().getNumericDocValues("val").get(0));
    assertEquals(10, reader2.leaves().get(0).reader().getNumericDocValues("val").get(0));

    writer.close();
    IOUtils.close(reader1, reader2, dir);
  }
,
>
, <(startLine=605 endLine=653 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/src/java/org/apache/lucene/index/CheckIndex.java)
      while (termEnum.next()) {
        status.termCount++;
        final Term term = termEnum.term();
        final int docFreq = termEnum.docFreq();
        termPositions.seek(term);
        int lastDoc = -1;
        int freq0 = 0;
        status.totFreq += docFreq;
        while (termPositions.next()) {
          freq0++;
          final int doc = termPositions.doc();
          final int freq = termPositions.freq();
          if (doc <= lastDoc)
            throw new RuntimeException("term " + term + ": doc " + doc + " <= lastDoc " + lastDoc);
          if (doc >= maxDoc)
            throw new RuntimeException("term " + term + ": doc " + doc + " >= maxDoc " + maxDoc);

          lastDoc = doc;
          if (freq <= 0)
            throw new RuntimeException("term " + term + ": doc " + doc + ": freq " + freq + " is out of bounds");
            
          int lastPos = -1;
          status.totPos += freq;
          for(int j=0;j<freq;j++) {
            final int pos = termPositions.nextPosition();
            if (pos < -1)
              throw new RuntimeException("term " + term + ": doc " + doc + ": pos " + pos + " is out of bounds");
            if (pos < lastPos)
              throw new RuntimeException("term " + term + ": doc " + doc + ": pos " + pos + " < lastPos " + lastPos);
            lastPos = pos;
          }
        }

        // Now count how many deleted docs occurred in
        // this term:
        final int delCount;
        if (reader.hasDeletions()) {
          myTermDocs.seek(term);
          while(myTermDocs.next()) { }
          delCount = myTermDocs.delCount;
        } else {
          delCount = 0; 
        }

        if (freq0 + delCount != docFreq) {
          throw new RuntimeException("term " + term + " docFreq=" + 
                                     docFreq + " != num docs seen " + freq0 + " + num docs deleted " + delCount);
        }
      }
,
(startLine=608 endLine=656 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/backwards/src/java/org/apache/lucene/index/CheckIndex.java)
      while (termEnum.next()) {
        status.termCount++;
        final Term term = termEnum.term();
        final int docFreq = termEnum.docFreq();
        termPositions.seek(term);
        int lastDoc = -1;
        int freq0 = 0;
        status.totFreq += docFreq;
        while (termPositions.next()) {
          freq0++;
          final int doc = termPositions.doc();
          final int freq = termPositions.freq();
          if (doc <= lastDoc)
            throw new RuntimeException("term " + term + ": doc " + doc + " <= lastDoc " + lastDoc);
          if (doc >= maxDoc)
            throw new RuntimeException("term " + term + ": doc " + doc + " >= maxDoc " + maxDoc);

          lastDoc = doc;
          if (freq <= 0)
            throw new RuntimeException("term " + term + ": doc " + doc + ": freq " + freq + " is out of bounds");
            
          int lastPos = -1;
          status.totPos += freq;
          for(int j=0;j<freq;j++) {
            final int pos = termPositions.nextPosition();
            if (pos < -1)
              throw new RuntimeException("term " + term + ": doc " + doc + ": pos " + pos + " is out of bounds");
            if (pos < lastPos)
              throw new RuntimeException("term " + term + ": doc " + doc + ": pos " + pos + " < lastPos " + lastPos);
            lastPos = pos;
          }
        }

        // Now count how many deleted docs occurred in
        // this term:
        final int delCount;
        if (reader.hasDeletions()) {
          myTermDocs.seek(term);
          while(myTermDocs.next()) { }
          delCount = myTermDocs.delCount;
        } else {
          delCount = 0; 
        }

        if (freq0 + delCount != docFreq) {
          throw new RuntimeException("term " + term + " docFreq=" + 
                                     docFreq + " != num docs seen " + freq0 + " + num docs deleted " + delCount);
        }
      }
,
>
, <(startLine=295 endLine=303 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/src/java/org/apache/lucene/util/automaton/Automaton.java)
    while (worklist.size() > 0) {
      State s = worklist.removeFirst();
      if (s.accept) accepts.add(s);
      for (Transition t : s.transitions)
        if (!visited.contains(t.to)) {
          visited.add(t.to);
          worklist.add(t.to);
        }
    }
,
(startLine=295 endLine=303 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/src/java/org/apache/lucene/util/automaton/Automaton.java)
    while (worklist.size() > 0) {
      State s = worklist.removeFirst();
      if (s.accept) accepts.add(s);
      for (Transition t : s.transitions)
        if (!visited.contains(t.to)) {
          visited.add(t.to);
          worklist.add(t.to);
        }
    }
,
>
, <(startLine=341 endLine=365 srcPath=/home/sonia/NewExperiment/luceneFilter/01451/lucene/analysis/common/src/test/org/apache/lucene/analysis/compound/TestCompoundWordTokenFilter.java)
  public void testRandomStrings() throws Exception {
    final CharArraySet dict = makeDictionary("a", "e", "i", "o", "u", "y", "bc", "def");
    Analyzer a = new Analyzer() {

      @Override
      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
        Tokenizer tokenizer = new MockTokenizer(reader, MockTokenizer.WHITESPACE, false);
        return new TokenStreamComponents(tokenizer, new DictionaryCompoundWordTokenFilter(TEST_VERSION_CURRENT, tokenizer, dict));
      }
    };
    checkRandomData(random(), a, 10000*RANDOM_MULTIPLIER);
    
    InputSource is = new InputSource(getClass().getResource("da_UTF8.xml").toExternalForm());
    final HyphenationTree hyphenator = HyphenationCompoundWordTokenFilter.getHyphenationTree(is);
    Analyzer b = new Analyzer() {

      @Override
      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
        Tokenizer tokenizer = new MockTokenizer(reader, MockTokenizer.WHITESPACE, false);
        TokenFilter filter = new HyphenationCompoundWordTokenFilter(TEST_VERSION_CURRENT, tokenizer, hyphenator);
        return new TokenStreamComponents(tokenizer, filter);
      }
    };
    checkRandomData(random(), b, 10000*RANDOM_MULTIPLIER);
  }
,
(startLine=367 endLine=391 srcPath=/home/sonia/NewExperiment/luceneFilter/01451/lucene/analysis/common/src/test/org/apache/lucene/analysis/compound/TestCompoundWordTokenFilter.java)
  public void testEmptyTerm() throws Exception {
    final CharArraySet dict = makeDictionary("a", "e", "i", "o", "u", "y", "bc", "def");
    Analyzer a = new Analyzer() {

      @Override
      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
        Tokenizer tokenizer = new KeywordTokenizer(reader);
        return new TokenStreamComponents(tokenizer, new DictionaryCompoundWordTokenFilter(TEST_VERSION_CURRENT, tokenizer, dict));
      }
    };
    checkOneTermReuse(a, "", "");
    
    InputSource is = new InputSource(getClass().getResource("da_UTF8.xml").toExternalForm());
    final HyphenationTree hyphenator = HyphenationCompoundWordTokenFilter.getHyphenationTree(is);
    Analyzer b = new Analyzer() {

      @Override
      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
        Tokenizer tokenizer = new KeywordTokenizer(reader);
        TokenFilter filter = new HyphenationCompoundWordTokenFilter(TEST_VERSION_CURRENT, tokenizer, hyphenator);
        return new TokenStreamComponents(tokenizer, filter);
      }
    };
    checkOneTermReuse(b, "", "");
  }
,
>
, <(startLine=157 endLine=182 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/test/org/apache/lucene/index/TestTransactionRollback.java)
    public void onInit(List<? extends IndexCommit> commits) throws IOException {
      for (final IndexCommit commit : commits) {
        Map<String,String> userData=commit.getUserData();
        if (userData.size() > 0) {
          // Label for a commit point is "Records 1-30"
          // This code reads the last id ("30" in this example) and deletes it
          // if it is after the desired rollback point
          String x = userData.get("index");
          String lastVal = x.substring(x.lastIndexOf("-")+1);
          int last = Integer.parseInt(lastVal);
          if (last>rollbackPoint) {
            /*
            System.out.print("\tRolling back commit point:" +
                             " UserData="+commit.getUserData() +")  ("+(commits.size()-1)+" commit points left) files=");
            Collection files = commit.getFileNames();
            for (Iterator iterator2 = files.iterator(); iterator2.hasNext();) {
              System.out.print(" "+iterator2.next());                
            }
            System.out.println();
            */
                        
            commit.delete();                                    
          }
        }
      }
    }        
,
(startLine=158 endLine=184 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/test/org/apache/lucene/index/TestTransactionRollback.java)
    public void onInit(List commits) throws IOException {
      for (Iterator iterator = commits.iterator(); iterator.hasNext();) {
        IndexCommit commit = (IndexCommit) iterator.next();
        Map userData=commit.getUserData();
        if (userData.size() > 0) {
          // Label for a commit point is "Records 1-30"
          // This code reads the last id ("30" in this example) and deletes it
          // if it is after the desired rollback point
          String x = (String) userData.get("index");
          String lastVal = x.substring(x.lastIndexOf("-")+1);
          int last = Integer.parseInt(lastVal);
          if (last>rollbackPoint) {
            /*
            System.out.print("\tRolling back commit point:" +
                             " UserData="+commit.getUserData() +")  ("+(commits.size()-1)+" commit points left) files=");
            Collection files = commit.getFileNames();
            for (Iterator iterator2 = files.iterator(); iterator2.hasNext();) {
              System.out.print(" "+iterator2.next());                
            }
            System.out.println();
            */
                        
            commit.delete();                                    
          }
        }
      }
    }        
,
>
, <(startLine=837 endLine=893 srcPath=/home/sonia/NewExperiment/luceneFilter/00699/lucene/src/java/org/apache/lucene/index/SegmentInfos.java)
  final void finishCommit(Directory dir) throws IOException {
    if (pendingSegnOutput == null)
      throw new IllegalStateException("prepareCommit was not called");
    boolean success = false;
    try {
      pendingSegnOutput.finishCommit();
      pendingSegnOutput.close();
      pendingSegnOutput = null;
      success = true;
    } finally {
      if (!success)
        rollbackCommit(dir);
    }

    // NOTE: if we crash here, we have left a segments_N
    // file in the directory in a possibly corrupt state (if
    // some bytes made it to stable storage and others
    // didn't).  But, the segments_N file includes checksum
    // at the end, which should catch this case.  So when a
    // reader tries to read it, it will throw a
    // CorruptIndexException, which should cause the retry
    // logic in SegmentInfos to kick in and load the last
    // good (previous) segments_N-1 file.

    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,
                                                                  "",
                                                                  generation);
    success = false;
    try {
      dir.sync(Collections.singleton(fileName));
      success = true;
    } finally {
      if (!success) {
        try {
          dir.deleteFile(fileName);
        } catch (Throwable t) {
          // Suppress so we keep throwing the original exception
        }
      }
    }

    lastGeneration = generation;

    try {
      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN);
      try {
        genOutput.writeInt(FORMAT_LOCKLESS);
        genOutput.writeLong(generation);
        genOutput.writeLong(generation);
      } finally {
        genOutput.close();
      }
    } catch (Throwable t) {
      // It's OK if we fail to write this file since it's
      // used only as one of the retry fallbacks.
    }
  }
,
(startLine=805 endLine=861 srcPath=/home/sonia/NewExperiment/luceneFilter/00699/lucene/backwards/src/java/org/apache/lucene/index/SegmentInfos.java)
  final void finishCommit(Directory dir) throws IOException {
    if (pendingSegnOutput == null)
      throw new IllegalStateException("prepareCommit was not called");
    boolean success = false;
    try {
      pendingSegnOutput.finishCommit();
      pendingSegnOutput.close();
      pendingSegnOutput = null;
      success = true;
    } finally {
      if (!success)
        rollbackCommit(dir);
    }

    // NOTE: if we crash here, we have left a segments_N
    // file in the directory in a possibly corrupt state (if
    // some bytes made it to stable storage and others
    // didn't).  But, the segments_N file includes checksum
    // at the end, which should catch this case.  So when a
    // reader tries to read it, it will throw a
    // CorruptIndexException, which should cause the retry
    // logic in SegmentInfos to kick in and load the last
    // good (previous) segments_N-1 file.

    final String fileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,
                                                                  "",
                                                                  generation);
    success = false;
    try {
      dir.sync(fileName);
      success = true;
    } finally {
      if (!success) {
        try {
          dir.deleteFile(fileName);
        } catch (Throwable t) {
          // Suppress so we keep throwing the original exception
        }
      }
    }

    lastGeneration = generation;

    try {
      IndexOutput genOutput = dir.createOutput(IndexFileNames.SEGMENTS_GEN);
      try {
        genOutput.writeInt(FORMAT_LOCKLESS);
        genOutput.writeLong(generation);
        genOutput.writeLong(generation);
      } finally {
        genOutput.close();
      }
    } catch (Throwable t) {
      // It's OK if we fail to write this file since it's
      // used only as one of the retry fallbacks.
    }
  }
,
>
, <(startLine=225 endLine=231 srcPath=/home/sonia/NewExperiment/luceneFilter/01037/lucene/src/test/org/apache/lucene/search/function/TestFieldScoreQuery.java)
      try {
        log("compare: " + innerArray + " to "
            + q.valSrc.getValues(leaf).getInnerArray());
        assertNotSame(
            "cached field values should not be reused if reader as changed!",
            innerArray, q.valSrc.getValues(leaf).getInnerArray());
      } catch (UnsupportedOperationException e) {
,
(startLine=237 endLine=243 srcPath=/home/sonia/NewExperiment/luceneFilter/01037/lucene/src/test/org/apache/lucene/search/function/TestOrdValues.java)
      try {
        log("compare (should differ): " + innerArray + " to "
                + q.valSrc.getValues(leaf).getInnerArray());
        assertNotSame(
                "cached field values should not be reused if reader as changed!",
                innerArray, q.valSrc.getValues(leaf).getInnerArray());
      } catch (UnsupportedOperationException e) {
,
>
, <(startLine=28 endLine=35 srcPath=/home/sonia/NewExperiment/luceneFilter/02606/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/SolrQueryEscapingEvaluator.java)
  public String evaluate(String expression, Context context) {
    List<Object> l = parseParams(expression, context.getVariableResolver());
    if (l.size() != 1) {
      throw new DataImportHandlerException(SEVERE, "'escapeQueryChars' must have at least one parameter ");
    }
    String s = l.get(0).toString();
    return ClientUtils.escapeQueryChars(s);
  }
,
(startLine=31 endLine=41 srcPath=/home/sonia/NewExperiment/luceneFilter/02606/solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/SqlEscapingEvaluator.java)
  public String evaluate(String expression, Context context) {
    List<Object> l = parseParams(expression, context.getVariableResolver());
    if (l.size() != 1) {
      throw new DataImportHandlerException(SEVERE, "'escapeSql' must have at least one parameter ");
    }
    String s = l.get(0).toString();
    // escape single quote with two single quotes, double quote
    // with two doule quotes, and backslash with double backslash.
    // See:  http://dev.mysql.com/doc/refman/4.1/en/mysql-real-escape-string.html
    return s.replaceAll("'", "''").replaceAll("\"", "\"\"").replaceAll("\\\\", "\\\\\\\\");
  }
,
>
, <(startLine=324 endLine=334 srcPath=/home/sonia/NewExperiment/luceneFilter/00659/lucene/src/java/org/apache/lucene/search/NumericRangeQuery.java)
  public String toString(final String field) {
    final StringBuilder sb = new StringBuilder();
    if (!this.field.equals(field)) sb.append(this.field).append(':');
    return sb.append(minInclusive ? '[' : '{')
      .append((min == null) ? "*" : min.toString())
      .append(" TO ")
      .append((max == null) ? "*" : max.toString())
      .append(maxInclusive ? ']' : '}')
      .append(ToStringUtils.boost(getBoost()))
      .toString();
  }
,
(startLine=325 endLine=335 srcPath=/home/sonia/NewExperiment/luceneFilter/00659/lucene/backwards/src/java/org/apache/lucene/search/NumericRangeQuery.java)
  public String toString(final String field) {
    final StringBuilder sb = new StringBuilder();
    if (!this.field.equals(field)) sb.append(this.field).append(':');
    return sb.append(minInclusive ? '[' : '{')
      .append((min == null) ? "*" : min.toString())
      .append(" TO ")
      .append((max == null) ? "*" : max.toString())
      .append(maxInclusive ? ']' : '}')
      .append(ToStringUtils.boost(getBoost()))
      .toString();
  }
,
>
, <(startLine=518 endLine=528 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/src/test/org/apache/lucene/index/TestPayloads.java)
        while (terms.next()) {
            TermPositions tp = reader.termPositions(terms.term());
            while(tp.next()) {
                int freq = tp.freq();
                for (int i = 0; i < freq; i++) {
                    tp.nextPosition();
                    assertEquals(pool.bytesToString(tp.getPayload(new byte[5], 0)), terms.term().text);
                }
            }
            tp.close();
        }
,
(startLine=503 endLine=513 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/backwards/src/test/org/apache/lucene/index/TestPayloads.java)
        while (terms.next()) {
            TermPositions tp = reader.termPositions(terms.term());
            while(tp.next()) {
                int freq = tp.freq();
                for (int i = 0; i < freq; i++) {
                    tp.nextPosition();
                    assertEquals(pool.bytesToString(tp.getPayload(new byte[5], 0)), terms.term().text);
                }
            }
            tp.close();
        }
,
>
, <(startLine=283 endLine=301 srcPath=/home/sonia/NewExperiment/luceneFilter/00664/lucene/src/test/org/apache/lucene/store/TestLockFactory.java)
                if (writer != null) {
                    try {
                        addDoc(writer);
                    } catch (IOException e) {
                        hitException = true;
                        System.out.println("Stress Test Index Writer: addDoc hit unexpected exception: " + e.toString());
                        e.printStackTrace(System.out);
                        break;
                    }
                    try {
                        writer.close();
                    } catch (IOException e) {
                        hitException = true;
                        System.out.println("Stress Test Index Writer: close hit unexpected exception: " + e.toString());
                        e.printStackTrace(System.out);
                        break;
                    }
                    writer = null;
                }
,
(startLine=272 endLine=290 srcPath=/home/sonia/NewExperiment/luceneFilter/00664/lucene/backwards/src/test/org/apache/lucene/store/TestLockFactory.java)
                if (writer != null) {
                    try {
                        addDoc(writer);
                    } catch (IOException e) {
                        hitException = true;
                        System.out.println("Stress Test Index Writer: addDoc hit unexpected exception: " + e.toString());
                        e.printStackTrace(System.out);
                        break;
                    }
                    try {
                        writer.close();
                    } catch (IOException e) {
                        hitException = true;
                        System.out.println("Stress Test Index Writer: close hit unexpected exception: " + e.toString());
                        e.printStackTrace(System.out);
                        break;
                    }
                    writer = null;
                }
,
>
, <(startLine=320 endLine=328 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/src/java/org/apache/lucene/index/FieldsReader.java)
      if (compressed) {
        int toRead = fieldsStream.readVInt();
        long pointer = fieldsStream.getFilePointer();
        f = new LazyField(fi.name, store, toRead, pointer, binary, compressed);
        //skip over the part that we aren't loading
        fieldsStream.seek(pointer + toRead);
        f.setOmitNorms(fi.omitNorms);
        f.setOmitTermFreqAndPositions(fi.omitTermFreqAndPositions);
      } else {
,
(startLine=320 endLine=328 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/backwards/src/java/org/apache/lucene/index/FieldsReader.java)
      if (compressed) {
        int toRead = fieldsStream.readVInt();
        long pointer = fieldsStream.getFilePointer();
        f = new LazyField(fi.name, store, toRead, pointer, binary, compressed);
        //skip over the part that we aren't loading
        fieldsStream.seek(pointer + toRead);
        f.setOmitNorms(fi.omitNorms);
        f.setOmitTermFreqAndPositions(fi.omitTermFreqAndPositions);
      } else {
,
>
, <(startLine=381 endLine=409 srcPath=/home/sonia/NewExperiment/luceneFilter/00927/lucene/lucene/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java)
    try {
      
      assertEquals("4 docs should match " + q.toString(), 4, h.length);
      
      float score0 = h[0].score;
      float score1 = h[1].score;
      float score2 = h[2].score;
      float score3 = h[3].score;
      
      String doc0 = s.doc(h[0].doc).get("id");
      String doc1 = s.doc(h[1].doc).get("id");
      String doc2 = s.doc(h[2].doc).get("id");
      String doc3 = s.doc(h[3].doc).get("id");
      
      assertTrue("doc0 should be d2 or d4: " + doc0, doc0.equals("d2")
          || doc0.equals("d4"));
      assertTrue("doc1 should be d2 or d4: " + doc0, doc1.equals("d2")
          || doc1.equals("d4"));
      assertEquals("score0 and score1 should match", score0, score1,
          SCORE_COMP_THRESH);
      assertEquals("wrong third", "d3", doc2);
      assertTrue("d3 does not have worse score then d2 and d4: " + score1
          + " >? " + score2, score1 > score2);
      
      assertEquals("wrong fourth", "d1", doc3);
      assertTrue("d1 does not have worse score then d3: " + score2 + " >? "
          + score3, score2 > score3);
      
    } catch (Error e) {
,
(startLine=435 endLine=461 srcPath=/home/sonia/NewExperiment/luceneFilter/00927/lucene/lucene/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java)
    try {
      
      assertEquals("4 docs should match " + q.toString(), 4, h.length);
      
      float score0 = h[0].score;
      float score1 = h[1].score;
      float score2 = h[2].score;
      float score3 = h[3].score;
      
      String doc0 = s.doc(h[0].doc).get("id");
      String doc1 = s.doc(h[1].doc).get("id");
      String doc2 = s.doc(h[2].doc).get("id");
      String doc3 = s.doc(h[3].doc).get("id");
      
      assertEquals("doc0 should be d4: ", "d4", doc0);
      assertEquals("doc1 should be d3: ", "d3", doc1);
      assertEquals("doc2 should be d2: ", "d2", doc2);
      assertEquals("doc3 should be d1: ", "d1", doc3);
      
      assertTrue("d4 does not have a better score then d3: " + score0 + " >? "
          + score1, score0 > score1);
      assertTrue("d3 does not have a better score then d2: " + score1 + " >? "
          + score2, score1 > score2);
      assertTrue("d3 does not have a better score then d1: " + score2 + " >? "
          + score3, score2 > score3);
      
    } catch (Error e) {
,
>
, <(startLine=40 endLine=59 srcPath=/home/sonia/NewExperiment/luceneFilter/00696/lucene/src/test/org/apache/lucene/search/TestNot.java)
  public void testNot() throws Exception {
    RAMDirectory store = new RAMDirectory();
    IndexWriter writer = new IndexWriter(store, new IndexWriterConfig(
        TEST_VERSION_CURRENT, new SimpleAnalyzer(
        TEST_VERSION_CURRENT)));

    Document d1 = new Document();
    d1.add(new Field("field", "a b", Field.Store.YES, Field.Index.ANALYZED));

    writer.addDocument(d1);
    writer.optimize();
    writer.close();

    Searcher searcher = new IndexSearcher(store, true);
      QueryParser parser = new QueryParser(TEST_VERSION_CURRENT, "field", new SimpleAnalyzer(TEST_VERSION_CURRENT));
    Query query = parser.parse("a NOT b");
    //System.out.println(query);
    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals(0, hits.length);
  }
,
(startLine=40 endLine=57 srcPath=/home/sonia/NewExperiment/luceneFilter/00696/lucene/backwards/src/test/org/apache/lucene/search/TestNot.java)
  public void testNot() throws Exception {
    RAMDirectory store = new RAMDirectory();
    IndexWriter writer = new IndexWriter(store, new SimpleAnalyzer(), true, IndexWriter.MaxFieldLength.LIMITED);

    Document d1 = new Document();
    d1.add(new Field("field", "a b", Field.Store.YES, Field.Index.ANALYZED));

    writer.addDocument(d1);
    writer.optimize();
    writer.close();

    Searcher searcher = new IndexSearcher(store, true);
      QueryParser parser = new QueryParser(Version.LUCENE_CURRENT, "field", new SimpleAnalyzer());
    Query query = parser.parse("a NOT b");
    //System.out.println(query);
    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals(0, hits.length);
  }
,
>
, <(startLine=177 endLine=185 srcPath=/home/sonia/NewExperiment/luceneFilter/02762/lucene/sandbox/src/java/org/apache/lucene/rangetree/RangeTreeDocValuesProducer.java)
  public synchronized Collection<Accountable> getChildResources() {
    List<Accountable> resources = new ArrayList<>();
    for(Map.Entry<String,RangeTreeReader> ent : treeReaders.entrySet()) {
      resources.add(Accountables.namedAccountable("field " + ent.getKey(), ent.getValue()));
    }
    resources.add(Accountables.namedAccountable("delegate", delegate));

    return resources;
  }
,
(startLine=156 endLine=164 srcPath=/home/sonia/NewExperiment/luceneFilter/02762/lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeDocValuesProducer.java)
  public synchronized Collection<Accountable> getChildResources() {
    List<Accountable> resources = new ArrayList<>();
    for(Map.Entry<String,BKDTreeReader> ent : treeReaders.entrySet()) {
      resources.add(Accountables.namedAccountable("field " + ent.getKey(), ent.getValue()));
    }
    resources.add(Accountables.namedAccountable("delegate", delegate));

    return resources;
  }
,
(startLine=158 endLine=166 srcPath=/home/sonia/NewExperiment/luceneFilter/02762/lucene/spatial3d/src/java/org/apache/lucene/bkdtree3d/Geo3DDocValuesProducer.java)
  public synchronized Collection<Accountable> getChildResources() {
    List<Accountable> resources = new ArrayList<>();
    for(Map.Entry<String,BKD3DTreeReader> ent : treeReaders.entrySet()) {
      resources.add(Accountables.namedAccountable("field " + ent.getKey(), ent.getValue()));
    }
    resources.add(Accountables.namedAccountable("delegate", delegate));

    return resources;
  }
,
>
, <(startLine=536 endLine=545 srcPath=/home/sonia/NewExperiment/luceneFilter/01816/solr/core/src/java/org/apache/solr/core/SolrCore.java)
    } catch (Exception e) {
      // The JVM likes to wrap our helpful SolrExceptions in things like
      // "InvocationTargetException" that have no useful getMessage
      if (null != e.getCause() && e.getCause() instanceof SolrException) {
        SolrException inner = (SolrException) e.getCause();
        throw inner;
      }

      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,"Error Instantiating "+msg+", "+className+ " failed to instantiate " +cast.getName(), e);
    }
,
(startLine=566 endLine=575 srcPath=/home/sonia/NewExperiment/luceneFilter/01816/solr/core/src/java/org/apache/solr/core/SolrCore.java)
    } catch (Exception e) {
      // The JVM likes to wrap our helpful SolrExceptions in things like
      // "InvocationTargetException" that have no useful getMessage
      if (null != e.getCause() && e.getCause() instanceof SolrException) {
        SolrException inner = (SolrException) e.getCause();
        throw inner;
      }

      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,"Error Instantiating "+msg+", "+className+ " failed to instantiate " + UpdateHandler.class.getName(), e);
    }
,
>
, <(startLine=828 endLine=938 srcPath=/home/sonia/NewExperiment/luceneFilter/02196/lucene/core/src/java/org/apache/lucene/codecs/lucene49/Lucene49DocValuesProducer.java)
    private TermsEnum getTermsEnum(final IndexInput input) throws IOException {
      input.seek(bytes.offset);
      
      return new TermsEnum() {
        private long currentOrd = -1;
        // TODO: maxLength is negative when all terms are merged away...
        private final BytesRef term = new BytesRef(bytes.maxLength < 0 ? 0 : bytes.maxLength);

        @Override
        public BytesRef next() throws IOException {
          if (++currentOrd >= numValues) {
            return null;
          } else {
            int start = input.readVInt();
            int suffix = input.readVInt();
            input.readBytes(term.bytes, start, suffix);
            term.length = start + suffix;
            return term;
          }
        }

        @Override
        public SeekStatus seekCeil(BytesRef text) throws IOException {
          // binary-search just the index values to find the block,
          // then scan within the block
          long low = 0;
          long high = numIndexValues-1;

          while (low <= high) {
            long mid = (low + high) >>> 1;
            seekExact(mid * interval);
            int cmp = term.compareTo(text);

            if (cmp < 0) {
              low = mid + 1;
            } else if (cmp > 0) {
              high = mid - 1;
            } else {
              // we got lucky, found an indexed term
              return SeekStatus.FOUND;
            }
          }
          
          if (numIndexValues == 0) {
            return SeekStatus.END;
          }
          
          // block before insertion point
          long block = low-1;
          seekExact(block < 0 ? -1 : block * interval);
          
          while (next() != null) {
            int cmp = term.compareTo(text);
            if (cmp == 0) {
              return SeekStatus.FOUND;
            } else if (cmp > 0) {
              return SeekStatus.NOT_FOUND;
            }
          }
          
          return SeekStatus.END;
        }

        @Override
        public void seekExact(long ord) throws IOException {
          long block = ord / interval;

          if (ord >= currentOrd && block == currentOrd / interval) {
            // seek within current block
          } else {
            // position before start of block
            currentOrd = ord - ord % interval - 1;
            input.seek(bytes.offset + addresses.get(block));
          }
          
          while (currentOrd < ord) {
            next();
          }
        }

        @Override
        public BytesRef term() throws IOException {
          return term;
        }

        @Override
        public long ord() throws IOException {
          return currentOrd;
        }

        @Override
        public int docFreq() throws IOException {
          throw new UnsupportedOperationException();
        }

        @Override
        public long totalTermFreq() throws IOException {
          return -1;
        }

        @Override
        public DocsEnum docs(Bits liveDocs, DocsEnum reuse, int flags) throws IOException {
          throw new UnsupportedOperationException();
        }

        @Override
        public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, int flags) throws IOException {
          throw new UnsupportedOperationException();
        }
      };
    }
,
(startLine=793 endLine=903 srcPath=/home/sonia/NewExperiment/luceneFilter/02196/lucene/core/src/java/org/apache/lucene/codecs/lucene45/Lucene45DocValuesProducer.java)
    private TermsEnum getTermsEnum(final IndexInput input) throws IOException {
      input.seek(bytes.offset);
      
      return new TermsEnum() {
        private long currentOrd = -1;
        // TODO: maxLength is negative when all terms are merged away...
        private final BytesRef term = new BytesRef(bytes.maxLength < 0 ? 0 : bytes.maxLength);

        @Override
        public BytesRef next() throws IOException {
          if (++currentOrd >= numValues) {
            return null;
          } else {
            int start = input.readVInt();
            int suffix = input.readVInt();
            input.readBytes(term.bytes, start, suffix);
            term.length = start + suffix;
            return term;
          }
        }

        @Override
        public SeekStatus seekCeil(BytesRef text) throws IOException {
          // binary-search just the index values to find the block,
          // then scan within the block
          long low = 0;
          long high = numIndexValues-1;

          while (low <= high) {
            long mid = (low + high) >>> 1;
            seekExact(mid * interval);
            int cmp = term.compareTo(text);

            if (cmp < 0) {
              low = mid + 1;
            } else if (cmp > 0) {
              high = mid - 1;
            } else {
              // we got lucky, found an indexed term
              return SeekStatus.FOUND;
            }
          }
          
          if (numIndexValues == 0) {
            return SeekStatus.END;
          }
          
          // block before insertion point
          long block = low-1;
          seekExact(block < 0 ? -1 : block * interval);
          
          while (next() != null) {
            int cmp = term.compareTo(text);
            if (cmp == 0) {
              return SeekStatus.FOUND;
            } else if (cmp > 0) {
              return SeekStatus.NOT_FOUND;
            }
          }
          
          return SeekStatus.END;
        }

        @Override
        public void seekExact(long ord) throws IOException {
          long block = ord / interval;

          if (ord >= currentOrd && block == currentOrd / interval) {
            // seek within current block
          } else {
            // position before start of block
            currentOrd = ord - ord % interval - 1;
            input.seek(bytes.offset + addresses.get(block));
          }
          
          while (currentOrd < ord) {
            next();
          }
        }

        @Override
        public BytesRef term() throws IOException {
          return term;
        }

        @Override
        public long ord() throws IOException {
          return currentOrd;
        }

        @Override
        public int docFreq() throws IOException {
          throw new UnsupportedOperationException();
        }

        @Override
        public long totalTermFreq() throws IOException {
          return -1;
        }

        @Override
        public DocsEnum docs(Bits liveDocs, DocsEnum reuse, int flags) throws IOException {
          throw new UnsupportedOperationException();
        }

        @Override
        public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, int flags) throws IOException {
          throw new UnsupportedOperationException();
        }
      };
    }
,
>
, <(startLine=208 endLine=239 srcPath=/home/sonia/NewExperiment/luceneFilter/00697/lucene/src/test/org/apache/lucene/search/TestPhraseQuery.java)
  public void testPhraseQueryWithStopAnalyzer() throws Exception {
    RAMDirectory directory = new RAMDirectory();
    StopAnalyzer stopAnalyzer = new StopAnalyzer(Version.LUCENE_24);
    IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(
        Version.LUCENE_24, stopAnalyzer));
    Document doc = new Document();
    doc.add(new Field("field", "the stop words are here", Field.Store.YES, Field.Index.ANALYZED));
    writer.addDocument(doc);
    writer.close();

    IndexSearcher searcher = new IndexSearcher(directory, true);

    // valid exact phrase query
    PhraseQuery query = new PhraseQuery();
    query.add(new Term("field","stop"));
    query.add(new Term("field","words"));
    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals(1, hits.length);
    QueryUtils.check(query,searcher);


    // StopAnalyzer as of 2.4 does not leave "holes", so this matches.
    query = new PhraseQuery();
    query.add(new Term("field", "words"));
    query.add(new Term("field", "here"));
    hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals(1, hits.length);
    QueryUtils.check(query,searcher);


    searcher.close();
  }
,
(startLine=207 endLine=238 srcPath=/home/sonia/NewExperiment/luceneFilter/00697/lucene/backwards/src/test/org/apache/lucene/search/TestPhraseQuery.java)
  public void testPhraseQueryWithStopAnalyzer() throws Exception {
    RAMDirectory directory = new RAMDirectory();
    StopAnalyzer stopAnalyzer = new StopAnalyzer(Version.LUCENE_24);
    IndexWriter writer = new IndexWriter(directory, stopAnalyzer, true, 
                                         IndexWriter.MaxFieldLength.LIMITED);
    Document doc = new Document();
    doc.add(new Field("field", "the stop words are here", Field.Store.YES, Field.Index.ANALYZED));
    writer.addDocument(doc);
    writer.close();

    IndexSearcher searcher = new IndexSearcher(directory, true);

    // valid exact phrase query
    PhraseQuery query = new PhraseQuery();
    query.add(new Term("field","stop"));
    query.add(new Term("field","words"));
    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals(1, hits.length);
    QueryUtils.check(query,searcher);


    // StopAnalyzer as of 2.4 does not leave "holes", so this matches.
    query = new PhraseQuery();
    query.add(new Term("field", "words"));
    query.add(new Term("field", "here"));
    hits = searcher.search(query, null, 1000).scoreDocs;
    assertEquals(1, hits.length);
    QueryUtils.check(query,searcher);


    searcher.close();
  }
,
>
, <(startLine=42 endLine=49 srcPath=/home/sonia/NewExperiment/luceneFilter/01248/solr/core/src/java/org/apache/solr/analysis/NGramTokenizerFactory.java)
    public void init(Map<String, String> args) {
        super.init(args);
        String maxArg = args.get("maxGramSize");
        maxGramSize = (maxArg != null ? Integer.parseInt(maxArg) : NGramTokenizer.DEFAULT_MAX_NGRAM_SIZE);

        String minArg = args.get("minGramSize");
        minGramSize = (minArg != null ? Integer.parseInt(minArg) : NGramTokenizer.DEFAULT_MIN_NGRAM_SIZE);
    }
,
(startLine=42 endLine=51 srcPath=/home/sonia/NewExperiment/luceneFilter/01248/solr/core/src/java/org/apache/solr/analysis/NGramFilterFactory.java)
  public void init(Map<String, String> args) {
    super.init(args);
    String maxArg = args.get("maxGramSize");
    maxGramSize = (maxArg != null ? Integer.parseInt(maxArg)
        : NGramTokenFilter.DEFAULT_MAX_NGRAM_SIZE);

    String minArg = args.get("minGramSize");
    minGramSize = (minArg != null ? Integer.parseInt(minArg)
        : NGramTokenFilter.DEFAULT_MIN_NGRAM_SIZE);
  }
,
>
, <(startLine=80 endLine=91 srcPath=/home/sonia/NewExperiment/luceneFilter/00659/lucene/src/test/org/apache/lucene/search/TestBooleanOr.java)
  public void testParenthesisMust() throws IOException {
    BooleanQuery q3 = new BooleanQuery();
    q3.add(new BooleanClause(t1, BooleanClause.Occur.SHOULD));
    q3.add(new BooleanClause(t2, BooleanClause.Occur.SHOULD));
    BooleanQuery q4 = new BooleanQuery();
    q4.add(new BooleanClause(c1, BooleanClause.Occur.MUST));
    q4.add(new BooleanClause(c2, BooleanClause.Occur.MUST));
    BooleanQuery q2 = new BooleanQuery();
    q2.add(q3, BooleanClause.Occur.SHOULD);
    q2.add(q4, BooleanClause.Occur.SHOULD);
    assertEquals(1, search(q2));
  }
,
(startLine=99 endLine=110 srcPath=/home/sonia/NewExperiment/luceneFilter/00659/lucene/src/test/org/apache/lucene/search/TestBooleanOr.java)
  public void testParenthesisMust2() throws IOException {
    BooleanQuery q3 = new BooleanQuery();
    q3.add(new BooleanClause(t1, BooleanClause.Occur.SHOULD));
    q3.add(new BooleanClause(t2, BooleanClause.Occur.SHOULD));
    BooleanQuery q4 = new BooleanQuery();
    q4.add(new BooleanClause(c1, BooleanClause.Occur.SHOULD));
    q4.add(new BooleanClause(c2, BooleanClause.Occur.SHOULD));
    BooleanQuery q2 = new BooleanQuery();
    q2.add(q3, BooleanClause.Occur.SHOULD);
    q2.add(q4, BooleanClause.Occur.MUST);
    assertEquals(1, search(q2));
  }
,
(startLine=118 endLine=129 srcPath=/home/sonia/NewExperiment/luceneFilter/00659/lucene/src/test/org/apache/lucene/search/TestBooleanOr.java)
  public void testParenthesisShould() throws IOException {
    BooleanQuery q3 = new BooleanQuery();
    q3.add(new BooleanClause(t1, BooleanClause.Occur.SHOULD));
    q3.add(new BooleanClause(t2, BooleanClause.Occur.SHOULD));
    BooleanQuery q4 = new BooleanQuery();
    q4.add(new BooleanClause(c1, BooleanClause.Occur.SHOULD));
    q4.add(new BooleanClause(c2, BooleanClause.Occur.SHOULD));
    BooleanQuery q2 = new BooleanQuery();
    q2.add(q3, BooleanClause.Occur.SHOULD);
    q2.add(q4, BooleanClause.Occur.SHOULD);
    assertEquals(1, search(q2));
  }
,
(startLine=79 endLine=90 srcPath=/home/sonia/NewExperiment/luceneFilter/00659/lucene/backwards/src/test/org/apache/lucene/search/TestBooleanOr.java)
  public void testParenthesisMust() throws IOException {
    BooleanQuery q3 = new BooleanQuery();
    q3.add(new BooleanClause(t1, BooleanClause.Occur.SHOULD));
    q3.add(new BooleanClause(t2, BooleanClause.Occur.SHOULD));
    BooleanQuery q4 = new BooleanQuery();
    q4.add(new BooleanClause(c1, BooleanClause.Occur.MUST));
    q4.add(new BooleanClause(c2, BooleanClause.Occur.MUST));
    BooleanQuery q2 = new BooleanQuery();
    q2.add(q3, BooleanClause.Occur.SHOULD);
    q2.add(q4, BooleanClause.Occur.SHOULD);
    assertEquals(1, search(q2));
  }
,
(startLine=98 endLine=109 srcPath=/home/sonia/NewExperiment/luceneFilter/00659/lucene/backwards/src/test/org/apache/lucene/search/TestBooleanOr.java)
  public void testParenthesisMust2() throws IOException {
    BooleanQuery q3 = new BooleanQuery();
    q3.add(new BooleanClause(t1, BooleanClause.Occur.SHOULD));
    q3.add(new BooleanClause(t2, BooleanClause.Occur.SHOULD));
    BooleanQuery q4 = new BooleanQuery();
    q4.add(new BooleanClause(c1, BooleanClause.Occur.SHOULD));
    q4.add(new BooleanClause(c2, BooleanClause.Occur.SHOULD));
    BooleanQuery q2 = new BooleanQuery();
    q2.add(q3, BooleanClause.Occur.SHOULD);
    q2.add(q4, BooleanClause.Occur.MUST);
    assertEquals(1, search(q2));
  }
,
(startLine=117 endLine=128 srcPath=/home/sonia/NewExperiment/luceneFilter/00659/lucene/backwards/src/test/org/apache/lucene/search/TestBooleanOr.java)
  public void testParenthesisShould() throws IOException {
    BooleanQuery q3 = new BooleanQuery();
    q3.add(new BooleanClause(t1, BooleanClause.Occur.SHOULD));
    q3.add(new BooleanClause(t2, BooleanClause.Occur.SHOULD));
    BooleanQuery q4 = new BooleanQuery();
    q4.add(new BooleanClause(c1, BooleanClause.Occur.SHOULD));
    q4.add(new BooleanClause(c2, BooleanClause.Occur.SHOULD));
    BooleanQuery q2 = new BooleanQuery();
    q2.add(q3, BooleanClause.Occur.SHOULD);
    q2.add(q4, BooleanClause.Occur.SHOULD);
    assertEquals(1, search(q2));
  }
,
>
, <(startLine=132 endLine=153 srcPath=/home/sonia/NewExperiment/luceneFilter/00662/lucene/src/java/org/apache/lucene/index/DocFieldProcessorPerThread.java)
  private void rehash() {
    final int newHashSize = (fieldHash.length*2);
    assert newHashSize > fieldHash.length;

    final DocFieldProcessorPerField newHashArray[] = new DocFieldProcessorPerField[newHashSize];

    // Rehash
    int newHashMask = newHashSize-1;
    for(int j=0;j<fieldHash.length;j++) {
      DocFieldProcessorPerField fp0 = fieldHash[j];
      while(fp0 != null) {
        final int hashPos2 = fp0.fieldInfo.name.hashCode() & newHashMask;
        DocFieldProcessorPerField nextFP0 = fp0.next;
        fp0.next = newHashArray[hashPos2];
        newHashArray[hashPos2] = fp0;
        fp0 = nextFP0;
      }
    }

    fieldHash = newHashArray;
    hashMask = newHashMask;
  }
,
(startLine=131 endLine=152 srcPath=/home/sonia/NewExperiment/luceneFilter/00662/lucene/backwards/src/java/org/apache/lucene/index/DocFieldProcessorPerThread.java)
  private void rehash() {
    final int newHashSize = (fieldHash.length*2);
    assert newHashSize > fieldHash.length;

    final DocFieldProcessorPerField newHashArray[] = new DocFieldProcessorPerField[newHashSize];

    // Rehash
    int newHashMask = newHashSize-1;
    for(int j=0;j<fieldHash.length;j++) {
      DocFieldProcessorPerField fp0 = fieldHash[j];
      while(fp0 != null) {
        final int hashPos2 = fp0.fieldInfo.name.hashCode() & newHashMask;
        DocFieldProcessorPerField nextFP0 = fp0.next;
        fp0.next = newHashArray[hashPos2];
        newHashArray[hashPos2] = fp0;
        fp0 = nextFP0;
      }
    }

    fieldHash = newHashArray;
    hashMask = newHashMask;
  }
,
>
, <(startLine=312 endLine=325 srcPath=/home/sonia/NewExperiment/luceneFilter/00677/lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterPhraseTest.java)
    public boolean incrementToken() throws IOException {
      this.i++;
      if (this.i >= this.tokens.length) {
        return false;
      }
      clearAttributes();
      termAttribute.setTermBuffer(this.tokens[i].term(), 0, this.tokens[i]
          .term().length());
      offsetAttribute.setOffset(this.tokens[i].startOffset(), this.tokens[i]
          .endOffset());
      positionIncrementAttribute.setPositionIncrement(this.tokens[i]
          .getPositionIncrement());
      return true;
    }
,
(startLine=358 endLine=371 srcPath=/home/sonia/NewExperiment/luceneFilter/00677/lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterPhraseTest.java)
    public boolean incrementToken() throws IOException {
      this.i++;
      if (this.i >= this.tokens.length) {
        return false;
      }
      clearAttributes();
      termAttribute.setTermBuffer(this.tokens[i].term(), 0, this.tokens[i]
          .term().length());
      offsetAttribute.setOffset(this.tokens[i].startOffset(), this.tokens[i]
          .endOffset());
      positionIncrementAttribute.setPositionIncrement(this.tokens[i]
          .getPositionIncrement());
      return true;
    }
,
>
, <(startLine=103 endLine=111 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/compound/hyphenation/PatternParser.java)
  public void parse(File file) throws HyphenationException {
    try {
      InputSource src = new InputSource(file.toURL().toExternalForm());
      parse(src);
    } catch (MalformedURLException e) {
      throw new HyphenationException("Error converting the File '" + file
          + "' to a URL: " + e.getMessage());
    }
  }
,
(startLine=116 endLine=124 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree.java)
  public void loadPatterns(File f) throws HyphenationException {
    try {
      InputSource src = new InputSource(f.toURL().toExternalForm());
      loadPatterns(src);
    } catch (MalformedURLException e) {
      throw new HyphenationException("Error converting the File '" + f
          + "' to a URL: " + e.getMessage());
    }
  }
,
>
, <(startLine=152 endLine=158 srcPath=/home/sonia/NewExperiment/luceneFilter/03317/solr/contrib/analytics/src/test/org/apache/solr/analytics/AbstractAnalyticsStatsCloudTest.java)
    if (stat.contains("perc_")) {
      ArrayList<Integer> percs = new ArrayList<>(1);
      int ord = (int) Math.ceil(Double.parseDouble(stat.substring(5))/100 * list.size()) - 1;
      percs.add(ord);
      OrdinalCalculator.putOrdinalsInPosition(list, percs);
      result = list.get(percs.get(0));
    } else if (stat.equals("count")) {
,
(startLine=173 endLine=179 srcPath=/home/sonia/NewExperiment/luceneFilter/03317/solr/contrib/analytics/src/test/org/apache/solr/analytics/AbstractAnalyticsStatsTest.java)
    if (stat.contains("perc_")) {
      ArrayList<Integer> percs = new ArrayList<>(1);
      int ord = (int) Math.ceil(Double.parseDouble(stat.substring(5))/100 * list.size()) - 1;
      percs.add(ord);
      OrdinalCalculator.putOrdinalsInPosition(list, percs);
      result = list.get(percs.get(0));
    } else if (stat.equals("count")) {
,
(startLine=233 endLine=243 srcPath=/home/sonia/NewExperiment/luceneFilter/03317/solr/contrib/analytics/src/test/org/apache/solr/analytics/facet/AbstractAnalyticsFacetTest.java)
    if (stat.contains("perc_")) {
      result = new ArrayList<T>();
      for (List<T> list : lists) {
        if( list.size() == 0) continue;
        int ord = (int) Math.ceil(Double.parseDouble(stat.substring(5))/100 * list.size()) - 1;
        ArrayList<Integer> percs = new ArrayList<>(1);
        percs.add(ord);
        OrdinalCalculator.putOrdinalsInPosition(list, percs);
        result.add(list.get(ord));
      }
    } else if (stat.equals("count")) {
,
>
, <(startLine=57 endLine=70 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms.java)
    if (field != null) { 
      Terms terms = reader.fields().terms(field);
      if (terms != null) {
        TermsEnum termsEnum = terms.iterator();
        while(true) {
          BytesRef term = termsEnum.next();
          if (term != null) {
            tiq.insertWithOverflow(new TermInfo(new Term(field, term.utf8ToString()), termsEnum.docFreq()));
          } else {
            break;
          }    
        }
      }
    } else {
,
(startLine=70 endLine=88 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms.java)
    } else {
      FieldsEnum fields = reader.fields().iterator();
      while(true) {
        field = fields.next();
        if (field != null) {
          TermsEnum terms = fields.terms();
          while(true) {
            BytesRef term = terms.next();
            if (term != null) {
              tiq.insertWithOverflow(new TermInfo(new Term(field, term.toString()), terms.docFreq()));
            } else {
              break;
            }
          }
        } else {
          break;
        }
      }
    }
,
>
, <(startLine=180 endLine=189 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    for (int i = 0; i < hits.totalHits; i++) {
      String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
      TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME,
          new StringReader(text));
      highlighter.setTextFragmenter(new SimpleFragmenter(40));

      String result = highlighter.getBestFragments(tokenStream, text, maxNumFragmentsRequired,
          "...");
      if (VERBOSE) System.out.println("\t" + result);
    }
,
(startLine=259 endLine=268 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    for (int i = 0; i < hits.totalHits; i++) {
      String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
      TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));

      highlighter.setTextFragmenter(new SimpleFragmenter(40));

      String result = highlighter.getBestFragments(tokenStream, text, maxNumFragmentsRequired,
          "...");
      if (VERBOSE) System.out.println("\t" + result);
    }
,
(startLine=288 endLine=297 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    for (int i = 0; i < hits.totalHits; i++) {
      String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
      TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));

      highlighter.setTextFragmenter(new SimpleFragmenter(40));

      String result = highlighter.getBestFragments(tokenStream, text, maxNumFragmentsRequired,
          "...");
      if (VERBOSE) System.out.println("\t" + result);
    }
,
(startLine=317 endLine=326 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    for (int i = 0; i < hits.totalHits; i++) {
      String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
      TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));

      highlighter.setTextFragmenter(new SimpleFragmenter(40));

      String result = highlighter.getBestFragments(tokenStream, text, maxNumFragmentsRequired,
          "...");
      if (VERBOSE) System.out.println("\t" + result);
    }
,
(startLine=342 endLine=351 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    for (int i = 0; i < hits.totalHits; i++) {
      String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
      TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));

      highlighter.setTextFragmenter(new SimpleFragmenter(40));

      String result = highlighter.getBestFragments(tokenStream, text, maxNumFragmentsRequired,
          "...");
      if (VERBOSE) System.out.println("\t" + result);
    }
,
(startLine=366 endLine=375 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    for (int i = 0; i < hits.totalHits; i++) {
      String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
      TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));

      highlighter.setTextFragmenter(new SimpleFragmenter(40));

      String result = highlighter.getBestFragments(tokenStream, text, maxNumFragmentsRequired,
          "...");
      if (VERBOSE) System.out.println("\t" + result);
    }
,
(startLine=419 endLine=426 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    for (int i = 0; i < hits.totalHits; i++) {
      String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
      TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));

      String result = highlighter.getBestFragments(tokenStream, text, maxNumFragmentsRequired,
          "...");
      if (VERBOSE) System.out.println("\t" + result);
    }
,
(startLine=471 endLine=481 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    for (int i = 0; i < hits.totalHits; i++) {
      String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
      TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));

      highlighter.setTextFragmenter(new SimpleSpanFragmenter(scorer, 5));

      String result = highlighter.getBestFragments(tokenStream, text,
          maxNumFragmentsRequired, "...");
      if (VERBOSE) System.out.println("\t" + result);

    }
,
(startLine=494 endLine=504 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    for (int i = 0; i < hits.totalHits; i++) {
      String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
      TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));

      highlighter.setTextFragmenter(new SimpleSpanFragmenter(scorer, 20));

      String result = highlighter.getBestFragments(tokenStream, text,
          maxNumFragmentsRequired, "...");
      if (VERBOSE) System.out.println("\t" + result);

    }
,
(startLine=596 endLine=603 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
    for (int i = 0; i < hits.totalHits; i++) {
      String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
      TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));

      String result = highlighter.getBestFragments(tokenStream, text, maxNumFragmentsRequired,
          "...");
      if (VERBOSE) System.out.println("\t" + result);
    }
,
(startLine=987 endLine=996 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
        for (int i = 0; i < hits.totalHits; i++) {
          String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
          TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));

          Highlighter highlighter = getHighlighter(query, FIELD_NAME,
              HighlighterTest.this);
          highlighter.setTextFragmenter(new SimpleFragmenter(40));
          String result = highlighter.getBestFragment(tokenStream, text);
          if (VERBOSE) System.out.println("\t" + result);
        }
,
(startLine=1118 endLine=1125 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
        for (int i = 0; i < hits.totalHits; i++) {
          String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
          TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));
          Highlighter highlighter = getHighlighter(query, FIELD_NAME,
              HighlighterTest.this);
          String result = highlighter.getBestFragment(tokenStream, text);
          if (VERBOSE) System.out.println("\t" + result);
        }
,
(startLine=1293 endLine=1304 srcPath=/home/sonia/NewExperiment/luceneFilter/01587/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java)
        for (int i = 0; i < hits.totalHits; i++) {
          String text = searcher.doc(hits.scoreDocs[i].doc).get(FIELD_NAME);
          TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));
          Highlighter highlighter = getHighlighter(query, FIELD_NAME, HighlighterTest.this, false);

          highlighter.setTextFragmenter(new SimpleFragmenter(40));

          String highlightedText = highlighter.getBestFragments(tokenStream, text,
              maxNumFragmentsRequired, "...");

          if (VERBOSE) System.out.println(highlightedText);
        }
,
>
, <(startLine=101 endLine=121 srcPath=/home/sonia/NewExperiment/luceneFilter/00800/lucene/src/test/org/apache/lucene/queryParser/TestQueryParser.java)
    public boolean incrementToken() throws IOException {
      if (inPhrase) {
        inPhrase = false;
        clearAttributes();
        termAtt.append("phrase2");
        offsetAtt.setOffset(savedStart, savedEnd);
        return true;
      } else
        while (input.incrementToken()) {
          if (termAtt.toString().equals("phrase")) {
            inPhrase = true;
            savedStart = offsetAtt.startOffset();
            savedEnd = offsetAtt.endOffset();
            termAtt.setEmpty().append("phrase1");
            offsetAtt.setOffset(savedStart, savedEnd);
            return true;
          } else if (!termAtt.toString().equals("stop"))
            return true;
        }
      return false;
    }
,
(startLine=82 endLine=101 srcPath=/home/sonia/NewExperiment/luceneFilter/00800/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java)
    public boolean incrementToken() throws IOException {
      clearAttributes();
      if (inPhrase) {
        inPhrase = false;
        termAtt.setEmpty().append("phrase2");
        offsetAtt.setOffset(savedStart, savedEnd);
        return true;
      } else
        while(input.incrementToken())
          if (termAtt.toString().equals("phrase")) {
            inPhrase = true;
            savedStart = offsetAtt.startOffset();
            savedEnd = offsetAtt.endOffset();
            termAtt.setEmpty().append("phrase1");
            offsetAtt.setOffset(savedStart, savedEnd);
            return true;
          } else if (!termAtt.toString().equals("stop"))
            return true;
      return false;
    }
,
(startLine=116 endLine=136 srcPath=/home/sonia/NewExperiment/luceneFilter/00800/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java)
    public boolean incrementToken() throws IOException {
      if (inPhrase) {
        inPhrase = false;
        clearAttributes();
        termAtt.setEmpty().append("phrase2");
        offsetAtt.setOffset(savedStart, savedEnd);
        return true;
      } else
        while (input.incrementToken()) {
          if (termAtt.toString().equals("phrase")) {
            inPhrase = true;
            savedStart = offsetAtt.startOffset();
            savedEnd = offsetAtt.endOffset();
            termAtt.setEmpty().append("phrase1");
            offsetAtt.setOffset(savedStart, savedEnd);
            return true;
          } else if (!termAtt.toString().equals("stop"))
            return true;
        }
      return false;
    }
,
(startLine=113 endLine=133 srcPath=/home/sonia/NewExperiment/luceneFilter/00800/lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java)
    public boolean incrementToken() throws IOException {
      if (inPhrase) {
        inPhrase = false;
        clearAttributes();
        termAtt.setEmpty().append("phrase2");
        offsetAtt.setOffset(savedStart, savedEnd);
        return true;
      } else
        while (input.incrementToken()) {
          if (termAtt.toString().equals("phrase")) {
            inPhrase = true;
            savedStart = offsetAtt.startOffset();
            savedEnd = offsetAtt.endOffset();
            termAtt.setEmpty().append("phrase1");
            offsetAtt.setOffset(savedStart, savedEnd);
            return true;
          } else if (!termAtt.toString().equals("stop"))
            return true;
        }
      return false;
    }
,
>
, <(startLine=519 endLine=554 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_H() {
            int v_1;
            int v_2;
            // (, line 28
            // test, line 28
            v_1 = limit - cursor;
            // hop, line 28
            {
                int c = cursor - 2;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // or, line 28
            lab0: do {
                v_2 = limit - cursor;
                lab1: do {
                    // literal, line 28
                    if (!(eq_s_b(1, "t")))
                    {
                        break lab1;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                // literal, line 28
                if (!(eq_s_b(2, "ll")))
                {
                    return false;
                }
            } while (false);
            return true;
        }
,
(startLine=556 endLine=600 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_I() {
            int v_1;
            int v_2;
            int v_3;
            // (, line 29
            // test, line 29
            v_1 = limit - cursor;
            // hop, line 29
            {
                int c = cursor - 2;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // not, line 29
            {
                v_2 = limit - cursor;
                lab0: do {
                    // literal, line 29
                    if (!(eq_s_b(1, "o")))
                    {
                        break lab0;
                    }
                    return false;
                } while (false);
                cursor = limit - v_2;
            }
            // not, line 29
            {
                v_3 = limit - cursor;
                lab1: do {
                    // literal, line 29
                    if (!(eq_s_b(1, "e")))
                    {
                        break lab1;
                    }
                    return false;
                } while (false);
                cursor = limit - v_3;
            }
            return true;
        }
,
(startLine=602 endLine=646 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_J() {
            int v_1;
            int v_2;
            int v_3;
            // (, line 30
            // test, line 30
            v_1 = limit - cursor;
            // hop, line 30
            {
                int c = cursor - 2;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // not, line 30
            {
                v_2 = limit - cursor;
                lab0: do {
                    // literal, line 30
                    if (!(eq_s_b(1, "a")))
                    {
                        break lab0;
                    }
                    return false;
                } while (false);
                cursor = limit - v_2;
            }
            // not, line 30
            {
                v_3 = limit - cursor;
                lab1: do {
                    // literal, line 30
                    if (!(eq_s_b(1, "e")))
                    {
                        break lab1;
                    }
                    return false;
                } while (false);
                cursor = limit - v_3;
            }
            return true;
        }
,
(startLine=648 endLine=704 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_K() {
            int v_1;
            int v_2;
            // (, line 31
            // test, line 31
            v_1 = limit - cursor;
            // hop, line 31
            {
                int c = cursor - 3;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // or, line 31
            lab0: do {
                v_2 = limit - cursor;
                lab1: do {
                    // literal, line 31
                    if (!(eq_s_b(1, "l")))
                    {
                        break lab1;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                lab2: do {
                    // literal, line 31
                    if (!(eq_s_b(1, "i")))
                    {
                        break lab2;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                // (, line 31
                // literal, line 31
                if (!(eq_s_b(1, "e")))
                {
                    return false;
                }
                // next, line 31
                if (cursor <= limit_backward)
                {
                    return false;
                }
                cursor--;
                // literal, line 31
                if (!(eq_s_b(1, "u")))
                {
                    return false;
                }
            } while (false);
            return true;
        }
,
(startLine=915 endLine=950 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_O() {
            int v_1;
            int v_2;
            // (, line 35
            // test, line 35
            v_1 = limit - cursor;
            // hop, line 35
            {
                int c = cursor - 2;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // or, line 35
            lab0: do {
                v_2 = limit - cursor;
                lab1: do {
                    // literal, line 35
                    if (!(eq_s_b(1, "l")))
                    {
                        break lab1;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                // literal, line 35
                if (!(eq_s_b(1, "i")))
                {
                    return false;
                }
            } while (false);
            return true;
        }
,
(startLine=1043 endLine=1078 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_R() {
            int v_1;
            int v_2;
            // (, line 38
            // test, line 38
            v_1 = limit - cursor;
            // hop, line 38
            {
                int c = cursor - 2;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // or, line 38
            lab0: do {
                v_2 = limit - cursor;
                lab1: do {
                    // literal, line 38
                    if (!(eq_s_b(1, "n")))
                    {
                        break lab1;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                // literal, line 38
                if (!(eq_s_b(1, "r")))
                {
                    return false;
                }
            } while (false);
            return true;
        }
,
(startLine=1080 endLine=1130 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_S() {
            int v_1;
            int v_2;
            int v_3;
            // (, line 39
            // test, line 39
            v_1 = limit - cursor;
            // hop, line 39
            {
                int c = cursor - 2;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // or, line 39
            lab0: do {
                v_2 = limit - cursor;
                lab1: do {
                    // literal, line 39
                    if (!(eq_s_b(2, "dr")))
                    {
                        break lab1;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                // (, line 39
                // literal, line 39
                if (!(eq_s_b(1, "t")))
                {
                    return false;
                }
                // not, line 39
                {
                    v_3 = limit - cursor;
                    lab2: do {
                        // literal, line 39
                        if (!(eq_s_b(1, "t")))
                        {
                            break lab2;
                        }
                        return false;
                    } while (false);
                    cursor = limit - v_3;
                }
            } while (false);
            return true;
        }
,
(startLine=1132 endLine=1182 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_T() {
            int v_1;
            int v_2;
            int v_3;
            // (, line 40
            // test, line 40
            v_1 = limit - cursor;
            // hop, line 40
            {
                int c = cursor - 2;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // or, line 40
            lab0: do {
                v_2 = limit - cursor;
                lab1: do {
                    // literal, line 40
                    if (!(eq_s_b(1, "s")))
                    {
                        break lab1;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                // (, line 40
                // literal, line 40
                if (!(eq_s_b(1, "t")))
                {
                    return false;
                }
                // not, line 40
                {
                    v_3 = limit - cursor;
                    lab2: do {
                        // literal, line 40
                        if (!(eq_s_b(1, "o")))
                        {
                            break lab2;
                        }
                        return false;
                    } while (false);
                    cursor = limit - v_3;
                }
            } while (false);
            return true;
        }
,
(startLine=1184 endLine=1237 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_U() {
            int v_1;
            int v_2;
            // (, line 41
            // test, line 41
            v_1 = limit - cursor;
            // hop, line 41
            {
                int c = cursor - 2;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // or, line 41
            lab0: do {
                v_2 = limit - cursor;
                lab1: do {
                    // literal, line 41
                    if (!(eq_s_b(1, "l")))
                    {
                        break lab1;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                lab2: do {
                    // literal, line 41
                    if (!(eq_s_b(1, "m")))
                    {
                        break lab2;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                lab3: do {
                    // literal, line 41
                    if (!(eq_s_b(1, "n")))
                    {
                        break lab3;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                // literal, line 41
                if (!(eq_s_b(1, "r")))
                {
                    return false;
                }
            } while (false);
            return true;
        }
,
(startLine=1262 endLine=1306 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_W() {
            int v_1;
            int v_2;
            int v_3;
            // (, line 43
            // test, line 43
            v_1 = limit - cursor;
            // hop, line 43
            {
                int c = cursor - 2;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // not, line 43
            {
                v_2 = limit - cursor;
                lab0: do {
                    // literal, line 43
                    if (!(eq_s_b(1, "s")))
                    {
                        break lab0;
                    }
                    return false;
                } while (false);
                cursor = limit - v_2;
            }
            // not, line 43
            {
                v_3 = limit - cursor;
                lab1: do {
                    // literal, line 43
                    if (!(eq_s_b(1, "u")))
                    {
                        break lab1;
                    }
                    return false;
                } while (false);
                cursor = limit - v_3;
            }
            return true;
        }
,
(startLine=1308 endLine=1364 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_X() {
            int v_1;
            int v_2;
            // (, line 44
            // test, line 44
            v_1 = limit - cursor;
            // hop, line 44
            {
                int c = cursor - 2;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // or, line 44
            lab0: do {
                v_2 = limit - cursor;
                lab1: do {
                    // literal, line 44
                    if (!(eq_s_b(1, "l")))
                    {
                        break lab1;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                lab2: do {
                    // literal, line 44
                    if (!(eq_s_b(1, "i")))
                    {
                        break lab2;
                    }
                    break lab0;
                } while (false);
                cursor = limit - v_2;
                // (, line 44
                // literal, line 44
                if (!(eq_s_b(1, "e")))
                {
                    return false;
                }
                // next, line 44
                if (cursor <= limit_backward)
                {
                    return false;
                }
                cursor--;
                // literal, line 44
                if (!(eq_s_b(1, "u")))
                {
                    return false;
                }
            } while (false);
            return true;
        }
,
(startLine=1444 endLine=1488 srcPath=/home/sonia/NewExperiment/luceneFilter/00128/sandbox/contributions/snowball/src/java/net/sf/snowball/ext/LovinsStemmer.java)
        private boolean r_BB() {
            int v_1;
            int v_2;
            int v_3;
            // (, line 48
            // test, line 48
            v_1 = limit - cursor;
            // hop, line 48
            {
                int c = cursor - 3;
                if (limit_backward > c || c > limit)
                {
                    return false;
                }
                cursor = c;
            }
            cursor = limit - v_1;
            // not, line 48
            {
                v_2 = limit - cursor;
                lab0: do {
                    // literal, line 48
                    if (!(eq_s_b(3, "met")))
                    {
                        break lab0;
                    }
                    return false;
                } while (false);
                cursor = limit - v_2;
            }
            // not, line 48
            {
                v_3 = limit - cursor;
                lab1: do {
                    // literal, line 48
                    if (!(eq_s_b(4, "ryst")))
                    {
                        break lab1;
                    }
                    return false;
                } while (false);
                cursor = limit - v_3;
            }
            return true;
        }
,
>
, <(startLine=71 endLine=105 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/src/test/org/apache/lucene/search/TestBooleanPrefixQuery.java)
  public void testMethod() throws Exception {
    RAMDirectory directory = new RAMDirectory();

    String[] categories = new String[]{"food",
                                       "foodanddrink",
                                       "foodanddrinkandgoodtimes",
                                       "food and drink"};

    Query rw1 = null;
    Query rw2 = null;
    IndexReader reader = null;
    try {
      IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(
          TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)));
      for (int i = 0; i < categories.length; i++) {
        Document doc = new Document();
        doc.add(new Field("category", categories[i], Field.Store.YES, Field.Index.NOT_ANALYZED));
        writer.addDocument(doc);
      }
      writer.close();
      
      reader = IndexReader.open(directory, true);
      PrefixQuery query = new PrefixQuery(new Term("category", "foo"));
      rw1 = query.rewrite(reader);
      
      BooleanQuery bq = new BooleanQuery();
      bq.add(query, BooleanClause.Occur.MUST);
      
      rw2 = bq.rewrite(reader);
    } catch (IOException e) {
      fail(e.getMessage());
    }

    assertEquals("Number of Clauses Mismatch", getCount(reader, rw1), getCount(reader, rw2));
  }
,
(startLine=70 endLine=104 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/backwards/src/test/org/apache/lucene/search/TestBooleanPrefixQuery.java)
  public void testMethod() throws Exception {
    RAMDirectory directory = new RAMDirectory();

    String[] categories = new String[]{"food",
                                       "foodanddrink",
                                       "foodanddrinkandgoodtimes",
                                       "food and drink"};

    Query rw1 = null;
    Query rw2 = null;
    IndexReader reader = null;
    try {
      IndexWriter writer = new IndexWriter(directory, new
                                           WhitespaceAnalyzer(), true, IndexWriter.MaxFieldLength.LIMITED);
      for (int i = 0; i < categories.length; i++) {
        Document doc = new Document();
        doc.add(new Field("category", categories[i], Field.Store.YES, Field.Index.NOT_ANALYZED));
        writer.addDocument(doc);
      }
      writer.close();
      
      reader = IndexReader.open(directory, true);
      PrefixQuery query = new PrefixQuery(new Term("category", "foo"));
      rw1 = query.rewrite(reader);
      
      BooleanQuery bq = new BooleanQuery();
      bq.add(query, BooleanClause.Occur.MUST);
      
      rw2 = bq.rewrite(reader);
    } catch (IOException e) {
      fail(e.getMessage());
    }

    assertEquals("Number of Clauses Mismatch", getCount(reader, rw1), getCount(reader, rw2));
  }
,
>
, <(startLine=164 endLine=1899 srcPath=/home/sonia/NewExperiment/luceneFilter/00676/lucene/src/test/org/apache/lucene/analysis/TestASCIIFoldingFilter.java)
  public void testAllFoldings() throws Exception {
    // Alternating strings of:
    //   1. All non-ASCII characters to be folded, concatenated together as a
    //      single string.
    //   2. The string of ASCII characters to which each of the above
    //      characters should be folded.
    String[] foldings = {
      "À"  // U+00C0: LATIN CAPITAL LETTER A WITH GRAVE
      + "Á"  // U+00C1: LATIN CAPITAL LETTER A WITH ACUTE
      + "Â"  // U+00C2: LATIN CAPITAL LETTER A WITH CIRCUMFLEX
      + "Ã"  // U+00C3: LATIN CAPITAL LETTER A WITH TILDE
      + "Ä"  // U+00C4: LATIN CAPITAL LETTER A WITH DIAERESIS
      + "Å"  // U+00C5: LATIN CAPITAL LETTER A WITH RING ABOVE
      + "Ā"  // U+0100: LATIN CAPITAL LETTER A WITH MACRON
      + "Ă"  // U+0102: LATIN CAPITAL LETTER A WITH BREVE
      + "Ą"  // U+0104: LATIN CAPITAL LETTER A WITH OGONEK
      + "Ə"  // U+018F: LATIN CAPITAL LETTER SCHWA
      + "Ǎ"  // U+01CD: LATIN CAPITAL LETTER A WITH CARON
      + "Ǟ"  // U+01DE: LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON
      + "Ǡ"  // U+01E0: LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON
      + "Ǻ"  // U+01FA: LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
      + "Ȁ"  // U+0200: LATIN CAPITAL LETTER A WITH DOUBLE GRAVE
      + "Ȃ"  // U+0202: LATIN CAPITAL LETTER A WITH INVERTED BREVE
      + "Ȧ"  // U+0226: LATIN CAPITAL LETTER A WITH DOT ABOVE
      + "Ⱥ"  // U+023A: LATIN CAPITAL LETTER A WITH STROKE
      + "ᴀ"  // U+1D00: LATIN LETTER SMALL CAPITAL A
      + "Ḁ"  // U+1E00: LATIN CAPITAL LETTER A WITH RING BELOW
      + "Ạ"  // U+1EA0: LATIN CAPITAL LETTER A WITH DOT BELOW
      + "Ả"  // U+1EA2: LATIN CAPITAL LETTER A WITH HOOK ABOVE
      + "Ấ"  // U+1EA4: LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
      + "Ầ"  // U+1EA6: LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
      + "Ẩ"  // U+1EA8: LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
      + "Ẫ"  // U+1EAA: LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
      + "Ậ"  // U+1EAC: LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
      + "Ắ"  // U+1EAE: LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
      + "Ằ"  // U+1EB0: LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
      + "Ẳ"  // U+1EB2: LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
      + "Ẵ"  // U+1EB4: LATIN CAPITAL LETTER A WITH BREVE AND TILDE
      + "Ặ"  // U+1EB6: LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
      + "Ⓐ"  // U+24B6: CIRCLED LATIN CAPITAL LETTER A
      + "Ａ"  // U+FF21: FULLWIDTH LATIN CAPITAL LETTER A
      ,"A", // Folded result

       "à"  // U+00E0: LATIN SMALL LETTER A WITH GRAVE
       + "á"  // U+00E1: LATIN SMALL LETTER A WITH ACUTE
       + "â"  // U+00E2: LATIN SMALL LETTER A WITH CIRCUMFLEX
       + "ã"  // U+00E3: LATIN SMALL LETTER A WITH TILDE
       + "ä"  // U+00E4: LATIN SMALL LETTER A WITH DIAERESIS
       + "å"  // U+00E5: LATIN SMALL LETTER A WITH RING ABOVE
       + "ā"  // U+0101: LATIN SMALL LETTER A WITH MACRON
       + "ă"  // U+0103: LATIN SMALL LETTER A WITH BREVE
       + "ą"  // U+0105: LATIN SMALL LETTER A WITH OGONEK
       + "ǎ"  // U+01CE: LATIN SMALL LETTER A WITH CARON
       + "ǟ"  // U+01DF: LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
       + "ǡ"  // U+01E1: LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
       + "ǻ"  // U+01FB: LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
       + "ȁ"  // U+0201: LATIN SMALL LETTER A WITH DOUBLE GRAVE
       + "ȃ"  // U+0203: LATIN SMALL LETTER A WITH INVERTED BREVE
       + "ȧ"  // U+0227: LATIN SMALL LETTER A WITH DOT ABOVE
       + "ɐ"  // U+0250: LATIN SMALL LETTER TURNED A
       + "ə"  // U+0259: LATIN SMALL LETTER SCHWA
       + "ɚ"  // U+025A: LATIN SMALL LETTER SCHWA WITH HOOK
       + "ᶏ"  // U+1D8F: LATIN SMALL LETTER A WITH RETROFLEX HOOK
       + "ḁ"  // U+1E01: LATIN SMALL LETTER A WITH RING BELOW
       + "ᶕ"  // U+1D95: LATIN SMALL LETTER SCHWA WITH RETROFLEX HOOK
       + "ẚ"  // U+1E9A: LATIN SMALL LETTER A WITH RIGHT HALF RING
       + "ạ"  // U+1EA1: LATIN SMALL LETTER A WITH DOT BELOW
       + "ả"  // U+1EA3: LATIN SMALL LETTER A WITH HOOK ABOVE
       + "ấ"  // U+1EA5: LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
       + "ầ"  // U+1EA7: LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
       + "ẩ"  // U+1EA9: LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
       + "ẫ"  // U+1EAB: LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
       + "ậ"  // U+1EAD: LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
       + "ắ"  // U+1EAF: LATIN SMALL LETTER A WITH BREVE AND ACUTE
       + "ằ"  // U+1EB1: LATIN SMALL LETTER A WITH BREVE AND GRAVE
       + "ẳ"  // U+1EB3: LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
       + "ẵ"  // U+1EB5: LATIN SMALL LETTER A WITH BREVE AND TILDE
       + "ặ"  // U+1EB7: LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
       + "ₐ"  // U+2090: LATIN SUBSCRIPT SMALL LETTER A
       + "ₔ"  // U+2094: LATIN SUBSCRIPT SMALL LETTER SCHWA
       + "ⓐ"  // U+24D0: CIRCLED LATIN SMALL LETTER A
       + "ⱥ"  // U+2C65: LATIN SMALL LETTER A WITH STROKE
       + "Ɐ"  // U+2C6F: LATIN CAPITAL LETTER TURNED A
       + "ａ"  // U+FF41: FULLWIDTH LATIN SMALL LETTER A
      ,"a", // Folded result

       "Ꜳ"  // U+A732: LATIN CAPITAL LETTER AA
      ,"AA", // Folded result

       "Æ"  // U+00C6: LATIN CAPITAL LETTER AE
       + "Ǣ"  // U+01E2: LATIN CAPITAL LETTER AE WITH MACRON
       + "Ǽ"  // U+01FC: LATIN CAPITAL LETTER AE WITH ACUTE
       + "ᴁ"  // U+1D01: LATIN LETTER SMALL CAPITAL AE
      ,"AE", // Folded result

       "Ꜵ"  // U+A734: LATIN CAPITAL LETTER AO
      ,"AO", // Folded result

       "Ꜷ"  // U+A736: LATIN CAPITAL LETTER AU
      ,"AU", // Folded result

       "Ꜹ"  // U+A738: LATIN CAPITAL LETTER AV
       + "Ꜻ"  // U+A73A: LATIN CAPITAL LETTER AV WITH HORIZONTAL BAR
      ,"AV", // Folded result

       "Ꜽ"  // U+A73C: LATIN CAPITAL LETTER AY
      ,"AY", // Folded result

       "⒜"  // U+249C: PARENTHESIZED LATIN SMALL LETTER A
      ,"(a)", // Folded result

       "ꜳ"  // U+A733: LATIN SMALL LETTER AA
      ,"aa", // Folded result

       "æ"  // U+00E6: LATIN SMALL LETTER AE
       + "ǣ"  // U+01E3: LATIN SMALL LETTER AE WITH MACRON
       + "ǽ"  // U+01FD: LATIN SMALL LETTER AE WITH ACUTE
       + "ᴂ"  // U+1D02: LATIN SMALL LETTER TURNED AE
      ,"ae", // Folded result

       "ꜵ"  // U+A735: LATIN SMALL LETTER AO
      ,"ao", // Folded result

       "ꜷ"  // U+A737: LATIN SMALL LETTER AU
      ,"au", // Folded result

       "ꜹ"  // U+A739: LATIN SMALL LETTER AV
       + "ꜻ"  // U+A73B: LATIN SMALL LETTER AV WITH HORIZONTAL BAR
      ,"av", // Folded result

       "ꜽ"  // U+A73D: LATIN SMALL LETTER AY
      ,"ay", // Folded result

       "Ɓ"  // U+0181: LATIN CAPITAL LETTER B WITH HOOK
       + "Ƃ"  // U+0182: LATIN CAPITAL LETTER B WITH TOPBAR
       + "Ƀ"  // U+0243: LATIN CAPITAL LETTER B WITH STROKE
       + "ʙ"  // U+0299: LATIN LETTER SMALL CAPITAL B
       + "ᴃ"  // U+1D03: LATIN LETTER SMALL CAPITAL BARRED B
       + "Ḃ"  // U+1E02: LATIN CAPITAL LETTER B WITH DOT ABOVE
       + "Ḅ"  // U+1E04: LATIN CAPITAL LETTER B WITH DOT BELOW
       + "Ḇ"  // U+1E06: LATIN CAPITAL LETTER B WITH LINE BELOW
       + "Ⓑ"  // U+24B7: CIRCLED LATIN CAPITAL LETTER B
       + "Ｂ"  // U+FF22: FULLWIDTH LATIN CAPITAL LETTER B
      ,"B", // Folded result

       "ƀ"  // U+0180: LATIN SMALL LETTER B WITH STROKE
       + "ƃ"  // U+0183: LATIN SMALL LETTER B WITH TOPBAR
       + "ɓ"  // U+0253: LATIN SMALL LETTER B WITH HOOK
       + "ᵬ"  // U+1D6C: LATIN SMALL LETTER B WITH MIDDLE TILDE
       + "ᶀ"  // U+1D80: LATIN SMALL LETTER B WITH PALATAL HOOK
       + "ḃ"  // U+1E03: LATIN SMALL LETTER B WITH DOT ABOVE
       + "ḅ"  // U+1E05: LATIN SMALL LETTER B WITH DOT BELOW
       + "ḇ"  // U+1E07: LATIN SMALL LETTER B WITH LINE BELOW
       + "ⓑ"  // U+24D1: CIRCLED LATIN SMALL LETTER B
       + "ｂ"  // U+FF42: FULLWIDTH LATIN SMALL LETTER B
      ,"b", // Folded result

       "⒝"  // U+249D: PARENTHESIZED LATIN SMALL LETTER B
      ,"(b)", // Folded result

       "Ç"  // U+00C7: LATIN CAPITAL LETTER C WITH CEDILLA
       + "Ć"  // U+0106: LATIN CAPITAL LETTER C WITH ACUTE
       + "Ĉ"  // U+0108: LATIN CAPITAL LETTER C WITH CIRCUMFLEX
       + "Ċ"  // U+010A: LATIN CAPITAL LETTER C WITH DOT ABOVE
       + "Č"  // U+010C: LATIN CAPITAL LETTER C WITH CARON
       + "Ƈ"  // U+0187: LATIN CAPITAL LETTER C WITH HOOK
       + "Ȼ"  // U+023B: LATIN CAPITAL LETTER C WITH STROKE
       + "ʗ"  // U+0297: LATIN LETTER STRETCHED C
       + "ᴄ"  // U+1D04: LATIN LETTER SMALL CAPITAL C
       + "Ḉ"  // U+1E08: LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
       + "Ⓒ"  // U+24B8: CIRCLED LATIN CAPITAL LETTER C
       + "Ｃ"  // U+FF23: FULLWIDTH LATIN CAPITAL LETTER C
      ,"C", // Folded result

       "ç"  // U+00E7: LATIN SMALL LETTER C WITH CEDILLA
       + "ć"  // U+0107: LATIN SMALL LETTER C WITH ACUTE
       + "ĉ"  // U+0109: LATIN SMALL LETTER C WITH CIRCUMFLEX
       + "ċ"  // U+010B: LATIN SMALL LETTER C WITH DOT ABOVE
       + "č"  // U+010D: LATIN SMALL LETTER C WITH CARON
       + "ƈ"  // U+0188: LATIN SMALL LETTER C WITH HOOK
       + "ȼ"  // U+023C: LATIN SMALL LETTER C WITH STROKE
       + "ɕ"  // U+0255: LATIN SMALL LETTER C WITH CURL
       + "ḉ"  // U+1E09: LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
       + "ↄ"  // U+2184: LATIN SMALL LETTER REVERSED C
       + "ⓒ"  // U+24D2: CIRCLED LATIN SMALL LETTER C
       + "Ꜿ"  // U+A73E: LATIN CAPITAL LETTER REVERSED C WITH DOT
       + "ꜿ"  // U+A73F: LATIN SMALL LETTER REVERSED C WITH DOT
       + "ｃ"  // U+FF43: FULLWIDTH LATIN SMALL LETTER C
      ,"c", // Folded result

       "⒞"  // U+249E: PARENTHESIZED LATIN SMALL LETTER C
      ,"(c)", // Folded result

       "Ð"  // U+00D0: LATIN CAPITAL LETTER ETH
       + "Ď"  // U+010E: LATIN CAPITAL LETTER D WITH CARON
       + "Đ"  // U+0110: LATIN CAPITAL LETTER D WITH STROKE
       + "Ɖ"  // U+0189: LATIN CAPITAL LETTER AFRICAN D
       + "Ɗ"  // U+018A: LATIN CAPITAL LETTER D WITH HOOK
       + "Ƌ"  // U+018B: LATIN CAPITAL LETTER D WITH TOPBAR
       + "ᴅ"  // U+1D05: LATIN LETTER SMALL CAPITAL D
       + "ᴆ"  // U+1D06: LATIN LETTER SMALL CAPITAL ETH
       + "Ḋ"  // U+1E0A: LATIN CAPITAL LETTER D WITH DOT ABOVE
       + "Ḍ"  // U+1E0C: LATIN CAPITAL LETTER D WITH DOT BELOW
       + "Ḏ"  // U+1E0E: LATIN CAPITAL LETTER D WITH LINE BELOW
       + "Ḑ"  // U+1E10: LATIN CAPITAL LETTER D WITH CEDILLA
       + "Ḓ"  // U+1E12: LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW
       + "Ⓓ"  // U+24B9: CIRCLED LATIN CAPITAL LETTER D
       + "Ꝺ"  // U+A779: LATIN CAPITAL LETTER INSULAR D
       + "Ｄ"  // U+FF24: FULLWIDTH LATIN CAPITAL LETTER D
      ,"D", // Folded result

       "ð"  // U+00F0: LATIN SMALL LETTER ETH
       + "ď"  // U+010F: LATIN SMALL LETTER D WITH CARON
       + "đ"  // U+0111: LATIN SMALL LETTER D WITH STROKE
       + "ƌ"  // U+018C: LATIN SMALL LETTER D WITH TOPBAR
       + "ȡ"  // U+0221: LATIN SMALL LETTER D WITH CURL
       + "ɖ"  // U+0256: LATIN SMALL LETTER D WITH TAIL
       + "ɗ"  // U+0257: LATIN SMALL LETTER D WITH HOOK
       + "ᵭ"  // U+1D6D: LATIN SMALL LETTER D WITH MIDDLE TILDE
       + "ᶁ"  // U+1D81: LATIN SMALL LETTER D WITH PALATAL HOOK
       + "ᶑ"  // U+1D91: LATIN SMALL LETTER D WITH HOOK AND TAIL
       + "ḋ"  // U+1E0B: LATIN SMALL LETTER D WITH DOT ABOVE
       + "ḍ"  // U+1E0D: LATIN SMALL LETTER D WITH DOT BELOW
       + "ḏ"  // U+1E0F: LATIN SMALL LETTER D WITH LINE BELOW
       + "ḑ"  // U+1E11: LATIN SMALL LETTER D WITH CEDILLA
       + "ḓ"  // U+1E13: LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW
       + "ⓓ"  // U+24D3: CIRCLED LATIN SMALL LETTER D
       + "ꝺ"  // U+A77A: LATIN SMALL LETTER INSULAR D
       + "ｄ"  // U+FF44: FULLWIDTH LATIN SMALL LETTER D
      ,"d", // Folded result

       "Ǆ"  // U+01C4: LATIN CAPITAL LETTER DZ WITH CARON
       + "Ǳ"  // U+01F1: LATIN CAPITAL LETTER DZ
      ,"DZ", // Folded result

       "ǅ"  // U+01C5: LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON
       + "ǲ"  // U+01F2: LATIN CAPITAL LETTER D WITH SMALL LETTER Z
      ,"Dz", // Folded result

       "⒟"  // U+249F: PARENTHESIZED LATIN SMALL LETTER D
      ,"(d)", // Folded result

       "ȸ"  // U+0238: LATIN SMALL LETTER DB DIGRAPH
      ,"db", // Folded result

       "ǆ"  // U+01C6: LATIN SMALL LETTER DZ WITH CARON
       + "ǳ"  // U+01F3: LATIN SMALL LETTER DZ
       + "ʣ"  // U+02A3: LATIN SMALL LETTER DZ DIGRAPH
       + "ʥ"  // U+02A5: LATIN SMALL LETTER DZ DIGRAPH WITH CURL
      ,"dz", // Folded result

       "È"  // U+00C8: LATIN CAPITAL LETTER E WITH GRAVE
       + "É"  // U+00C9: LATIN CAPITAL LETTER E WITH ACUTE
       + "Ê"  // U+00CA: LATIN CAPITAL LETTER E WITH CIRCUMFLEX
       + "Ë"  // U+00CB: LATIN CAPITAL LETTER E WITH DIAERESIS
       + "Ē"  // U+0112: LATIN CAPITAL LETTER E WITH MACRON
       + "Ĕ"  // U+0114: LATIN CAPITAL LETTER E WITH BREVE
       + "Ė"  // U+0116: LATIN CAPITAL LETTER E WITH DOT ABOVE
       + "Ę"  // U+0118: LATIN CAPITAL LETTER E WITH OGONEK
       + "Ě"  // U+011A: LATIN CAPITAL LETTER E WITH CARON
       + "Ǝ"  // U+018E: LATIN CAPITAL LETTER REVERSED E
       + "Ɛ"  // U+0190: LATIN CAPITAL LETTER OPEN E
       + "Ȅ"  // U+0204: LATIN CAPITAL LETTER E WITH DOUBLE GRAVE
       + "Ȇ"  // U+0206: LATIN CAPITAL LETTER E WITH INVERTED BREVE
       + "Ȩ"  // U+0228: LATIN CAPITAL LETTER E WITH CEDILLA
       + "Ɇ"  // U+0246: LATIN CAPITAL LETTER E WITH STROKE
       + "ᴇ"  // U+1D07: LATIN LETTER SMALL CAPITAL E
       + "Ḕ"  // U+1E14: LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
       + "Ḗ"  // U+1E16: LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
       + "Ḙ"  // U+1E18: LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW
       + "Ḛ"  // U+1E1A: LATIN CAPITAL LETTER E WITH TILDE BELOW
       + "Ḝ"  // U+1E1C: LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE
       + "Ẹ"  // U+1EB8: LATIN CAPITAL LETTER E WITH DOT BELOW
       + "Ẻ"  // U+1EBA: LATIN CAPITAL LETTER E WITH HOOK ABOVE
       + "Ẽ"  // U+1EBC: LATIN CAPITAL LETTER E WITH TILDE
       + "Ế"  // U+1EBE: LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
       + "Ề"  // U+1EC0: LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
       + "Ể"  // U+1EC2: LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
       + "Ễ"  // U+1EC4: LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
       + "Ệ"  // U+1EC6: LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
       + "Ⓔ"  // U+24BA: CIRCLED LATIN CAPITAL LETTER E
       + "ⱻ"  // U+2C7B: LATIN LETTER SMALL CAPITAL TURNED E
       + "Ｅ"  // U+FF25: FULLWIDTH LATIN CAPITAL LETTER E
      ,"E", // Folded result

       "è"  // U+00E8: LATIN SMALL LETTER E WITH GRAVE
       + "é"  // U+00E9: LATIN SMALL LETTER E WITH ACUTE
       + "ê"  // U+00EA: LATIN SMALL LETTER E WITH CIRCUMFLEX
       + "ë"  // U+00EB: LATIN SMALL LETTER E WITH DIAERESIS
       + "ē"  // U+0113: LATIN SMALL LETTER E WITH MACRON
       + "ĕ"  // U+0115: LATIN SMALL LETTER E WITH BREVE
       + "ė"  // U+0117: LATIN SMALL LETTER E WITH DOT ABOVE
       + "ę"  // U+0119: LATIN SMALL LETTER E WITH OGONEK
       + "ě"  // U+011B: LATIN SMALL LETTER E WITH CARON
       + "ǝ"  // U+01DD: LATIN SMALL LETTER TURNED E
       + "ȅ"  // U+0205: LATIN SMALL LETTER E WITH DOUBLE GRAVE
       + "ȇ"  // U+0207: LATIN SMALL LETTER E WITH INVERTED BREVE
       + "ȩ"  // U+0229: LATIN SMALL LETTER E WITH CEDILLA
       + "ɇ"  // U+0247: LATIN SMALL LETTER E WITH STROKE
       + "ɘ"  // U+0258: LATIN SMALL LETTER REVERSED E
       + "ɛ"  // U+025B: LATIN SMALL LETTER OPEN E
       + "ɜ"  // U+025C: LATIN SMALL LETTER REVERSED OPEN E
       + "ɝ"  // U+025D: LATIN SMALL LETTER REVERSED OPEN E WITH HOOK
       + "ɞ"  // U+025E: LATIN SMALL LETTER CLOSED REVERSED OPEN E
       + "ʚ"  // U+029A: LATIN SMALL LETTER CLOSED OPEN E
       + "ᴈ"  // U+1D08: LATIN SMALL LETTER TURNED OPEN E
       + "ᶒ"  // U+1D92: LATIN SMALL LETTER E WITH RETROFLEX HOOK
       + "ᶓ"  // U+1D93: LATIN SMALL LETTER OPEN E WITH RETROFLEX HOOK
       + "ᶔ"  // U+1D94: LATIN SMALL LETTER REVERSED OPEN E WITH RETROFLEX HOOK
       + "ḕ"  // U+1E15: LATIN SMALL LETTER E WITH MACRON AND GRAVE
       + "ḗ"  // U+1E17: LATIN SMALL LETTER E WITH MACRON AND ACUTE
       + "ḙ"  // U+1E19: LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW
       + "ḛ"  // U+1E1B: LATIN SMALL LETTER E WITH TILDE BELOW
       + "ḝ"  // U+1E1D: LATIN SMALL LETTER E WITH CEDILLA AND BREVE
       + "ẹ"  // U+1EB9: LATIN SMALL LETTER E WITH DOT BELOW
       + "ẻ"  // U+1EBB: LATIN SMALL LETTER E WITH HOOK ABOVE
       + "ẽ"  // U+1EBD: LATIN SMALL LETTER E WITH TILDE
       + "ế"  // U+1EBF: LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
       + "ề"  // U+1EC1: LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
       + "ể"  // U+1EC3: LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
       + "ễ"  // U+1EC5: LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
       + "ệ"  // U+1EC7: LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
       + "ₑ"  // U+2091: LATIN SUBSCRIPT SMALL LETTER E
       + "ⓔ"  // U+24D4: CIRCLED LATIN SMALL LETTER E
       + "ⱸ"  // U+2C78: LATIN SMALL LETTER E WITH NOTCH
       + "ｅ"  // U+FF45: FULLWIDTH LATIN SMALL LETTER E
      ,"e", // Folded result

       "⒠"  // U+24A0: PARENTHESIZED LATIN SMALL LETTER E
      ,"(e)", // Folded result

       "Ƒ"  // U+0191: LATIN CAPITAL LETTER F WITH HOOK
       + "Ḟ"  // U+1E1E: LATIN CAPITAL LETTER F WITH DOT ABOVE
       + "Ⓕ"  // U+24BB: CIRCLED LATIN CAPITAL LETTER F
       + "ꜰ"  // U+A730: LATIN LETTER SMALL CAPITAL F
       + "Ꝼ"  // U+A77B: LATIN CAPITAL LETTER INSULAR F
       + "ꟻ"  // U+A7FB: LATIN EPIGRAPHIC LETTER REVERSED F
       + "Ｆ"  // U+FF26: FULLWIDTH LATIN CAPITAL LETTER F
      ,"F", // Folded result

       "ƒ"  // U+0192: LATIN SMALL LETTER F WITH HOOK
       + "ᵮ"  // U+1D6E: LATIN SMALL LETTER F WITH MIDDLE TILDE
       + "ᶂ"  // U+1D82: LATIN SMALL LETTER F WITH PALATAL HOOK
       + "ḟ"  // U+1E1F: LATIN SMALL LETTER F WITH DOT ABOVE
       + "ẛ"  // U+1E9B: LATIN SMALL LETTER LONG S WITH DOT ABOVE
       + "ⓕ"  // U+24D5: CIRCLED LATIN SMALL LETTER F
       + "ꝼ"  // U+A77C: LATIN SMALL LETTER INSULAR F
       + "ｆ"  // U+FF46: FULLWIDTH LATIN SMALL LETTER F
      ,"f", // Folded result

       "⒡"  // U+24A1: PARENTHESIZED LATIN SMALL LETTER F
      ,"(f)", // Folded result

       "ﬀ"  // U+FB00: LATIN SMALL LIGATURE FF
      ,"ff", // Folded result

       "ﬃ"  // U+FB03: LATIN SMALL LIGATURE FFI
      ,"ffi", // Folded result

       "ﬄ"  // U+FB04: LATIN SMALL LIGATURE FFL
      ,"ffl", // Folded result

       "ﬁ"  // U+FB01: LATIN SMALL LIGATURE FI
      ,"fi", // Folded result

       "ﬂ"  // U+FB02: LATIN SMALL LIGATURE FL
      ,"fl", // Folded result

       "Ĝ"  // U+011C: LATIN CAPITAL LETTER G WITH CIRCUMFLEX
       + "Ğ"  // U+011E: LATIN CAPITAL LETTER G WITH BREVE
       + "Ġ"  // U+0120: LATIN CAPITAL LETTER G WITH DOT ABOVE
       + "Ģ"  // U+0122: LATIN CAPITAL LETTER G WITH CEDILLA
       + "Ɠ"  // U+0193: LATIN CAPITAL LETTER G WITH HOOK
       + "Ǥ"  // U+01E4: LATIN CAPITAL LETTER G WITH STROKE
       + "ǥ"  // U+01E5: LATIN SMALL LETTER G WITH STROKE
       + "Ǧ"  // U+01E6: LATIN CAPITAL LETTER G WITH CARON
       + "ǧ"  // U+01E7: LATIN SMALL LETTER G WITH CARON
       + "Ǵ"  // U+01F4: LATIN CAPITAL LETTER G WITH ACUTE
       + "ɢ"  // U+0262: LATIN LETTER SMALL CAPITAL G
       + "ʛ"  // U+029B: LATIN LETTER SMALL CAPITAL G WITH HOOK
       + "Ḡ"  // U+1E20: LATIN CAPITAL LETTER G WITH MACRON
       + "Ⓖ"  // U+24BC: CIRCLED LATIN CAPITAL LETTER G
       + "Ᵹ"  // U+A77D: LATIN CAPITAL LETTER INSULAR G
       + "Ꝿ"  // U+A77E: LATIN CAPITAL LETTER TURNED INSULAR G
       + "Ｇ"  // U+FF27: FULLWIDTH LATIN CAPITAL LETTER G
      ,"G", // Folded result

       "ĝ"  // U+011D: LATIN SMALL LETTER G WITH CIRCUMFLEX
       + "ğ"  // U+011F: LATIN SMALL LETTER G WITH BREVE
       + "ġ"  // U+0121: LATIN SMALL LETTER G WITH DOT ABOVE
       + "ģ"  // U+0123: LATIN SMALL LETTER G WITH CEDILLA
       + "ǵ"  // U+01F5: LATIN SMALL LETTER G WITH ACUTE
       + "ɠ"  // U+0260: LATIN SMALL LETTER G WITH HOOK
       + "ɡ"  // U+0261: LATIN SMALL LETTER SCRIPT G
       + "ᵷ"  // U+1D77: LATIN SMALL LETTER TURNED G
       + "ᵹ"  // U+1D79: LATIN SMALL LETTER INSULAR G
       + "ᶃ"  // U+1D83: LATIN SMALL LETTER G WITH PALATAL HOOK
       + "ḡ"  // U+1E21: LATIN SMALL LETTER G WITH MACRON
       + "ⓖ"  // U+24D6: CIRCLED LATIN SMALL LETTER G
       + "ꝿ"  // U+A77F: LATIN SMALL LETTER TURNED INSULAR G
       + "ｇ"  // U+FF47: FULLWIDTH LATIN SMALL LETTER G
      ,"g", // Folded result

       "⒢"  // U+24A2: PARENTHESIZED LATIN SMALL LETTER G
      ,"(g)", // Folded result

       "Ĥ"  // U+0124: LATIN CAPITAL LETTER H WITH CIRCUMFLEX
       + "Ħ"  // U+0126: LATIN CAPITAL LETTER H WITH STROKE
       + "Ȟ"  // U+021E: LATIN CAPITAL LETTER H WITH CARON
       + "ʜ"  // U+029C: LATIN LETTER SMALL CAPITAL H
       + "Ḣ"  // U+1E22: LATIN CAPITAL LETTER H WITH DOT ABOVE
       + "Ḥ"  // U+1E24: LATIN CAPITAL LETTER H WITH DOT BELOW
       + "Ḧ"  // U+1E26: LATIN CAPITAL LETTER H WITH DIAERESIS
       + "Ḩ"  // U+1E28: LATIN CAPITAL LETTER H WITH CEDILLA
       + "Ḫ"  // U+1E2A: LATIN CAPITAL LETTER H WITH BREVE BELOW
       + "Ⓗ"  // U+24BD: CIRCLED LATIN CAPITAL LETTER H
       + "Ⱨ"  // U+2C67: LATIN CAPITAL LETTER H WITH DESCENDER
       + "Ⱶ"  // U+2C75: LATIN CAPITAL LETTER HALF H
       + "Ｈ"  // U+FF28: FULLWIDTH LATIN CAPITAL LETTER H
      ,"H", // Folded result

       "ĥ"  // U+0125: LATIN SMALL LETTER H WITH CIRCUMFLEX
       + "ħ"  // U+0127: LATIN SMALL LETTER H WITH STROKE
       + "ȟ"  // U+021F: LATIN SMALL LETTER H WITH CARON
       + "ɥ"  // U+0265: LATIN SMALL LETTER TURNED H
       + "ɦ"  // U+0266: LATIN SMALL LETTER H WITH HOOK
       + "ʮ"  // U+02AE: LATIN SMALL LETTER TURNED H WITH FISHHOOK
       + "ʯ"  // U+02AF: LATIN SMALL LETTER TURNED H WITH FISHHOOK AND TAIL
       + "ḣ"  // U+1E23: LATIN SMALL LETTER H WITH DOT ABOVE
       + "ḥ"  // U+1E25: LATIN SMALL LETTER H WITH DOT BELOW
       + "ḧ"  // U+1E27: LATIN SMALL LETTER H WITH DIAERESIS
       + "ḩ"  // U+1E29: LATIN SMALL LETTER H WITH CEDILLA
       + "ḫ"  // U+1E2B: LATIN SMALL LETTER H WITH BREVE BELOW
       + "ẖ"  // U+1E96: LATIN SMALL LETTER H WITH LINE BELOW
       + "ⓗ"  // U+24D7: CIRCLED LATIN SMALL LETTER H
       + "ⱨ"  // U+2C68: LATIN SMALL LETTER H WITH DESCENDER
       + "ⱶ"  // U+2C76: LATIN SMALL LETTER HALF H
       + "ｈ"  // U+FF48: FULLWIDTH LATIN SMALL LETTER H
      ,"h", // Folded result

       "Ƕ"  // U+01F6: LATIN CAPITAL LETTER HWAIR
      ,"HV", // Folded result

       "⒣"  // U+24A3: PARENTHESIZED LATIN SMALL LETTER H
      ,"(h)", // Folded result

       "ƕ"  // U+0195: LATIN SMALL LETTER HV
      ,"hv", // Folded result

       "Ì"  // U+00CC: LATIN CAPITAL LETTER I WITH GRAVE
       + "Í"  // U+00CD: LATIN CAPITAL LETTER I WITH ACUTE
       + "Î"  // U+00CE: LATIN CAPITAL LETTER I WITH CIRCUMFLEX
       + "Ï"  // U+00CF: LATIN CAPITAL LETTER I WITH DIAERESIS
       + "Ĩ"  // U+0128: LATIN CAPITAL LETTER I WITH TILDE
       + "Ī"  // U+012A: LATIN CAPITAL LETTER I WITH MACRON
       + "Ĭ"  // U+012C: LATIN CAPITAL LETTER I WITH BREVE
       + "Į"  // U+012E: LATIN CAPITAL LETTER I WITH OGONEK
       + "İ"  // U+0130: LATIN CAPITAL LETTER I WITH DOT ABOVE
       + "Ɩ"  // U+0196: LATIN CAPITAL LETTER IOTA
       + "Ɨ"  // U+0197: LATIN CAPITAL LETTER I WITH STROKE
       + "Ǐ"  // U+01CF: LATIN CAPITAL LETTER I WITH CARON
       + "Ȉ"  // U+0208: LATIN CAPITAL LETTER I WITH DOUBLE GRAVE
       + "Ȋ"  // U+020A: LATIN CAPITAL LETTER I WITH INVERTED BREVE
       + "ɪ"  // U+026A: LATIN LETTER SMALL CAPITAL I
       + "ᵻ"  // U+1D7B: LATIN SMALL CAPITAL LETTER I WITH STROKE
       + "Ḭ"  // U+1E2C: LATIN CAPITAL LETTER I WITH TILDE BELOW
       + "Ḯ"  // U+1E2E: LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
       + "Ỉ"  // U+1EC8: LATIN CAPITAL LETTER I WITH HOOK ABOVE
       + "Ị"  // U+1ECA: LATIN CAPITAL LETTER I WITH DOT BELOW
       + "Ⓘ"  // U+24BE: CIRCLED LATIN CAPITAL LETTER I
       + "ꟾ"  // U+A7FE: LATIN EPIGRAPHIC LETTER I LONGA
       + "Ｉ"  // U+FF29: FULLWIDTH LATIN CAPITAL LETTER I
      ,"I", // Folded result

       "ì"  // U+00EC: LATIN SMALL LETTER I WITH GRAVE
       + "í"  // U+00ED: LATIN SMALL LETTER I WITH ACUTE
       + "î"  // U+00EE: LATIN SMALL LETTER I WITH CIRCUMFLEX
       + "ï"  // U+00EF: LATIN SMALL LETTER I WITH DIAERESIS
       + "ĩ"  // U+0129: LATIN SMALL LETTER I WITH TILDE
       + "ī"  // U+012B: LATIN SMALL LETTER I WITH MACRON
       + "ĭ"  // U+012D: LATIN SMALL LETTER I WITH BREVE
       + "į"  // U+012F: LATIN SMALL LETTER I WITH OGONEK
       + "ı"  // U+0131: LATIN SMALL LETTER DOTLESS I
       + "ǐ"  // U+01D0: LATIN SMALL LETTER I WITH CARON
       + "ȉ"  // U+0209: LATIN SMALL LETTER I WITH DOUBLE GRAVE
       + "ȋ"  // U+020B: LATIN SMALL LETTER I WITH INVERTED BREVE
       + "ɨ"  // U+0268: LATIN SMALL LETTER I WITH STROKE
       + "ᴉ"  // U+1D09: LATIN SMALL LETTER TURNED I
       + "ᵢ"  // U+1D62: LATIN SUBSCRIPT SMALL LETTER I
       + "ᵼ"  // U+1D7C: LATIN SMALL LETTER IOTA WITH STROKE
       + "ᶖ"  // U+1D96: LATIN SMALL LETTER I WITH RETROFLEX HOOK
       + "ḭ"  // U+1E2D: LATIN SMALL LETTER I WITH TILDE BELOW
       + "ḯ"  // U+1E2F: LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
       + "ỉ"  // U+1EC9: LATIN SMALL LETTER I WITH HOOK ABOVE
       + "ị"  // U+1ECB: LATIN SMALL LETTER I WITH DOT BELOW
       + "ⁱ"  // U+2071: SUPERSCRIPT LATIN SMALL LETTER I
       + "ⓘ"  // U+24D8: CIRCLED LATIN SMALL LETTER I
       + "ｉ"  // U+FF49: FULLWIDTH LATIN SMALL LETTER I
      ,"i", // Folded result

       "Ĳ"  // U+0132: LATIN CAPITAL LIGATURE IJ
      ,"IJ", // Folded result

       "⒤"  // U+24A4: PARENTHESIZED LATIN SMALL LETTER I
      ,"(i)", // Folded result

       "ĳ"  // U+0133: LATIN SMALL LIGATURE IJ
      ,"ij", // Folded result

       "Ĵ"  // U+0134: LATIN CAPITAL LETTER J WITH CIRCUMFLEX
       + "Ɉ"  // U+0248: LATIN CAPITAL LETTER J WITH STROKE
       + "ᴊ"  // U+1D0A: LATIN LETTER SMALL CAPITAL J
       + "Ⓙ"  // U+24BF: CIRCLED LATIN CAPITAL LETTER J
       + "Ｊ"  // U+FF2A: FULLWIDTH LATIN CAPITAL LETTER J
      ,"J", // Folded result

       "ĵ"  // U+0135: LATIN SMALL LETTER J WITH CIRCUMFLEX
       + "ǰ"  // U+01F0: LATIN SMALL LETTER J WITH CARON
       + "ȷ"  // U+0237: LATIN SMALL LETTER DOTLESS J
       + "ɉ"  // U+0249: LATIN SMALL LETTER J WITH STROKE
       + "ɟ"  // U+025F: LATIN SMALL LETTER DOTLESS J WITH STROKE
       + "ʄ"  // U+0284: LATIN SMALL LETTER DOTLESS J WITH STROKE AND HOOK
       + "ʝ"  // U+029D: LATIN SMALL LETTER J WITH CROSSED-TAIL
       + "ⓙ"  // U+24D9: CIRCLED LATIN SMALL LETTER J
       + "ⱼ"  // U+2C7C: LATIN SUBSCRIPT SMALL LETTER J
       + "ｊ"  // U+FF4A: FULLWIDTH LATIN SMALL LETTER J
      ,"j", // Folded result

       "⒥"  // U+24A5: PARENTHESIZED LATIN SMALL LETTER J
      ,"(j)", // Folded result

       "Ķ"  // U+0136: LATIN CAPITAL LETTER K WITH CEDILLA
       + "Ƙ"  // U+0198: LATIN CAPITAL LETTER K WITH HOOK
       + "Ǩ"  // U+01E8: LATIN CAPITAL LETTER K WITH CARON
       + "ᴋ"  // U+1D0B: LATIN LETTER SMALL CAPITAL K
       + "Ḱ"  // U+1E30: LATIN CAPITAL LETTER K WITH ACUTE
       + "Ḳ"  // U+1E32: LATIN CAPITAL LETTER K WITH DOT BELOW
       + "Ḵ"  // U+1E34: LATIN CAPITAL LETTER K WITH LINE BELOW
       + "Ⓚ"  // U+24C0: CIRCLED LATIN CAPITAL LETTER K
       + "Ⱪ"  // U+2C69: LATIN CAPITAL LETTER K WITH DESCENDER
       + "Ꝁ"  // U+A740: LATIN CAPITAL LETTER K WITH STROKE
       + "Ꝃ"  // U+A742: LATIN CAPITAL LETTER K WITH DIAGONAL STROKE
       + "Ꝅ"  // U+A744: LATIN CAPITAL LETTER K WITH STROKE AND DIAGONAL STROKE
       + "Ｋ"  // U+FF2B: FULLWIDTH LATIN CAPITAL LETTER K
      ,"K", // Folded result

       "ķ"  // U+0137: LATIN SMALL LETTER K WITH CEDILLA
       + "ƙ"  // U+0199: LATIN SMALL LETTER K WITH HOOK
       + "ǩ"  // U+01E9: LATIN SMALL LETTER K WITH CARON
       + "ʞ"  // U+029E: LATIN SMALL LETTER TURNED K
       + "ᶄ"  // U+1D84: LATIN SMALL LETTER K WITH PALATAL HOOK
       + "ḱ"  // U+1E31: LATIN SMALL LETTER K WITH ACUTE
       + "ḳ"  // U+1E33: LATIN SMALL LETTER K WITH DOT BELOW
       + "ḵ"  // U+1E35: LATIN SMALL LETTER K WITH LINE BELOW
       + "ⓚ"  // U+24DA: CIRCLED LATIN SMALL LETTER K
       + "ⱪ"  // U+2C6A: LATIN SMALL LETTER K WITH DESCENDER
       + "ꝁ"  // U+A741: LATIN SMALL LETTER K WITH STROKE
       + "ꝃ"  // U+A743: LATIN SMALL LETTER K WITH DIAGONAL STROKE
       + "ꝅ"  // U+A745: LATIN SMALL LETTER K WITH STROKE AND DIAGONAL STROKE
       + "ｋ"  // U+FF4B: FULLWIDTH LATIN SMALL LETTER K
      ,"k", // Folded result

       "⒦"  // U+24A6: PARENTHESIZED LATIN SMALL LETTER K
      ,"(k)", // Folded result

       "Ĺ"  // U+0139: LATIN CAPITAL LETTER L WITH ACUTE
       + "Ļ"  // U+013B: LATIN CAPITAL LETTER L WITH CEDILLA
       + "Ľ"  // U+013D: LATIN CAPITAL LETTER L WITH CARON
       + "Ŀ"  // U+013F: LATIN CAPITAL LETTER L WITH MIDDLE DOT
       + "Ł"  // U+0141: LATIN CAPITAL LETTER L WITH STROKE
       + "Ƚ"  // U+023D: LATIN CAPITAL LETTER L WITH BAR
       + "ʟ"  // U+029F: LATIN LETTER SMALL CAPITAL L
       + "ᴌ"  // U+1D0C: LATIN LETTER SMALL CAPITAL L WITH STROKE
       + "Ḷ"  // U+1E36: LATIN CAPITAL LETTER L WITH DOT BELOW
       + "Ḹ"  // U+1E38: LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
       + "Ḻ"  // U+1E3A: LATIN CAPITAL LETTER L WITH LINE BELOW
       + "Ḽ"  // U+1E3C: LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW
       + "Ⓛ"  // U+24C1: CIRCLED LATIN CAPITAL LETTER L
       + "Ⱡ"  // U+2C60: LATIN CAPITAL LETTER L WITH DOUBLE BAR
       + "Ɫ"  // U+2C62: LATIN CAPITAL LETTER L WITH MIDDLE TILDE
       + "Ꝇ"  // U+A746: LATIN CAPITAL LETTER BROKEN L
       + "Ꝉ"  // U+A748: LATIN CAPITAL LETTER L WITH HIGH STROKE
       + "Ꞁ"  // U+A780: LATIN CAPITAL LETTER TURNED L
       + "Ｌ"  // U+FF2C: FULLWIDTH LATIN CAPITAL LETTER L
      ,"L", // Folded result

       "ĺ"  // U+013A: LATIN SMALL LETTER L WITH ACUTE
       + "ļ"  // U+013C: LATIN SMALL LETTER L WITH CEDILLA
       + "ľ"  // U+013E: LATIN SMALL LETTER L WITH CARON
       + "ŀ"  // U+0140: LATIN SMALL LETTER L WITH MIDDLE DOT
       + "ł"  // U+0142: LATIN SMALL LETTER L WITH STROKE
       + "ƚ"  // U+019A: LATIN SMALL LETTER L WITH BAR
       + "ȴ"  // U+0234: LATIN SMALL LETTER L WITH CURL
       + "ɫ"  // U+026B: LATIN SMALL LETTER L WITH MIDDLE TILDE
       + "ɬ"  // U+026C: LATIN SMALL LETTER L WITH BELT
       + "ɭ"  // U+026D: LATIN SMALL LETTER L WITH RETROFLEX HOOK
       + "ᶅ"  // U+1D85: LATIN SMALL LETTER L WITH PALATAL HOOK
       + "ḷ"  // U+1E37: LATIN SMALL LETTER L WITH DOT BELOW
       + "ḹ"  // U+1E39: LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
       + "ḻ"  // U+1E3B: LATIN SMALL LETTER L WITH LINE BELOW
       + "ḽ"  // U+1E3D: LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW
       + "ⓛ"  // U+24DB: CIRCLED LATIN SMALL LETTER L
       + "ⱡ"  // U+2C61: LATIN SMALL LETTER L WITH DOUBLE BAR
       + "ꝇ"  // U+A747: LATIN SMALL LETTER BROKEN L
       + "ꝉ"  // U+A749: LATIN SMALL LETTER L WITH HIGH STROKE
       + "ꞁ"  // U+A781: LATIN SMALL LETTER TURNED L
       + "ｌ"  // U+FF4C: FULLWIDTH LATIN SMALL LETTER L
      ,"l", // Folded result

       "Ǉ"  // U+01C7: LATIN CAPITAL LETTER LJ
      ,"LJ", // Folded result

       "Ỻ"  // U+1EFA: LATIN CAPITAL LETTER MIDDLE-WELSH LL
      ,"LL", // Folded result

       "ǈ"  // U+01C8: LATIN CAPITAL LETTER L WITH SMALL LETTER J
      ,"Lj", // Folded result

       "⒧"  // U+24A7: PARENTHESIZED LATIN SMALL LETTER L
      ,"(l)", // Folded result

       "ǉ"  // U+01C9: LATIN SMALL LETTER LJ
      ,"lj", // Folded result

       "ỻ"  // U+1EFB: LATIN SMALL LETTER MIDDLE-WELSH LL
      ,"ll", // Folded result

       "ʪ"  // U+02AA: LATIN SMALL LETTER LS DIGRAPH
      ,"ls", // Folded result

       "ʫ"  // U+02AB: LATIN SMALL LETTER LZ DIGRAPH
      ,"lz", // Folded result

       "Ɯ"  // U+019C: LATIN CAPITAL LETTER TURNED M
       + "ᴍ"  // U+1D0D: LATIN LETTER SMALL CAPITAL M
       + "Ḿ"  // U+1E3E: LATIN CAPITAL LETTER M WITH ACUTE
       + "Ṁ"  // U+1E40: LATIN CAPITAL LETTER M WITH DOT ABOVE
       + "Ṃ"  // U+1E42: LATIN CAPITAL LETTER M WITH DOT BELOW
       + "Ⓜ"  // U+24C2: CIRCLED LATIN CAPITAL LETTER M
       + "Ɱ"  // U+2C6E: LATIN CAPITAL LETTER M WITH HOOK
       + "ꟽ"  // U+A7FD: LATIN EPIGRAPHIC LETTER INVERTED M
       + "ꟿ"  // U+A7FF: LATIN EPIGRAPHIC LETTER ARCHAIC M
       + "Ｍ"  // U+FF2D: FULLWIDTH LATIN CAPITAL LETTER M
      ,"M", // Folded result

       "ɯ"  // U+026F: LATIN SMALL LETTER TURNED M
       + "ɰ"  // U+0270: LATIN SMALL LETTER TURNED M WITH LONG LEG
       + "ɱ"  // U+0271: LATIN SMALL LETTER M WITH HOOK
       + "ᵯ"  // U+1D6F: LATIN SMALL LETTER M WITH MIDDLE TILDE
       + "ᶆ"  // U+1D86: LATIN SMALL LETTER M WITH PALATAL HOOK
       + "ḿ"  // U+1E3F: LATIN SMALL LETTER M WITH ACUTE
       + "ṁ"  // U+1E41: LATIN SMALL LETTER M WITH DOT ABOVE
       + "ṃ"  // U+1E43: LATIN SMALL LETTER M WITH DOT BELOW
       + "ⓜ"  // U+24DC: CIRCLED LATIN SMALL LETTER M
       + "ｍ"  // U+FF4D: FULLWIDTH LATIN SMALL LETTER M
      ,"m", // Folded result

       "⒨"  // U+24A8: PARENTHESIZED LATIN SMALL LETTER M
      ,"(m)", // Folded result

       "Ñ"  // U+00D1: LATIN CAPITAL LETTER N WITH TILDE
       + "Ń"  // U+0143: LATIN CAPITAL LETTER N WITH ACUTE
       + "Ņ"  // U+0145: LATIN CAPITAL LETTER N WITH CEDILLA
       + "Ň"  // U+0147: LATIN CAPITAL LETTER N WITH CARON
       + "Ŋ"  // U+014A: LATIN CAPITAL LETTER ENG
       + "Ɲ"  // U+019D: LATIN CAPITAL LETTER N WITH LEFT HOOK
       + "Ǹ"  // U+01F8: LATIN CAPITAL LETTER N WITH GRAVE
       + "Ƞ"  // U+0220: LATIN CAPITAL LETTER N WITH LONG RIGHT LEG
       + "ɴ"  // U+0274: LATIN LETTER SMALL CAPITAL N
       + "ᴎ"  // U+1D0E: LATIN LETTER SMALL CAPITAL REVERSED N
       + "Ṅ"  // U+1E44: LATIN CAPITAL LETTER N WITH DOT ABOVE
       + "Ṇ"  // U+1E46: LATIN CAPITAL LETTER N WITH DOT BELOW
       + "Ṉ"  // U+1E48: LATIN CAPITAL LETTER N WITH LINE BELOW
       + "Ṋ"  // U+1E4A: LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW
       + "Ⓝ"  // U+24C3: CIRCLED LATIN CAPITAL LETTER N
       + "Ｎ"  // U+FF2E: FULLWIDTH LATIN CAPITAL LETTER N
      ,"N", // Folded result

       "ñ"  // U+00F1: LATIN SMALL LETTER N WITH TILDE
       + "ń"  // U+0144: LATIN SMALL LETTER N WITH ACUTE
       + "ņ"  // U+0146: LATIN SMALL LETTER N WITH CEDILLA
       + "ň"  // U+0148: LATIN SMALL LETTER N WITH CARON
       + "ŉ"  // U+0149: LATIN SMALL LETTER N PRECEDED BY APOSTROPHE
       + "ŋ"  // U+014B: LATIN SMALL LETTER ENG
       + "ƞ"  // U+019E: LATIN SMALL LETTER N WITH LONG RIGHT LEG
       + "ǹ"  // U+01F9: LATIN SMALL LETTER N WITH GRAVE
       + "ȵ"  // U+0235: LATIN SMALL LETTER N WITH CURL
       + "ɲ"  // U+0272: LATIN SMALL LETTER N WITH LEFT HOOK
       + "ɳ"  // U+0273: LATIN SMALL LETTER N WITH RETROFLEX HOOK
       + "ᵰ"  // U+1D70: LATIN SMALL LETTER N WITH MIDDLE TILDE
       + "ᶇ"  // U+1D87: LATIN SMALL LETTER N WITH PALATAL HOOK
       + "ṅ"  // U+1E45: LATIN SMALL LETTER N WITH DOT ABOVE
       + "ṇ"  // U+1E47: LATIN SMALL LETTER N WITH DOT BELOW
       + "ṉ"  // U+1E49: LATIN SMALL LETTER N WITH LINE BELOW
       + "ṋ"  // U+1E4B: LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW
       + "ⁿ"  // U+207F: SUPERSCRIPT LATIN SMALL LETTER N
       + "ⓝ"  // U+24DD: CIRCLED LATIN SMALL LETTER N
       + "ｎ"  // U+FF4E: FULLWIDTH LATIN SMALL LETTER N
      ,"n", // Folded result

       "Ǌ"  // U+01CA: LATIN CAPITAL LETTER NJ
      ,"NJ", // Folded result

       "ǋ"  // U+01CB: LATIN CAPITAL LETTER N WITH SMALL LETTER J
      ,"Nj", // Folded result

       "⒩"  // U+24A9: PARENTHESIZED LATIN SMALL LETTER N
      ,"(n)", // Folded result

       "ǌ"  // U+01CC: LATIN SMALL LETTER NJ
      ,"nj", // Folded result

       "Ò"  // U+00D2: LATIN CAPITAL LETTER O WITH GRAVE
       + "Ó"  // U+00D3: LATIN CAPITAL LETTER O WITH ACUTE
       + "Ô"  // U+00D4: LATIN CAPITAL LETTER O WITH CIRCUMFLEX
       + "Õ"  // U+00D5: LATIN CAPITAL LETTER O WITH TILDE
       + "Ö"  // U+00D6: LATIN CAPITAL LETTER O WITH DIAERESIS
       + "Ø"  // U+00D8: LATIN CAPITAL LETTER O WITH STROKE
       + "Ō"  // U+014C: LATIN CAPITAL LETTER O WITH MACRON
       + "Ŏ"  // U+014E: LATIN CAPITAL LETTER O WITH BREVE
       + "Ő"  // U+0150: LATIN CAPITAL LETTER O WITH DOUBLE ACUTE
       + "Ɔ"  // U+0186: LATIN CAPITAL LETTER OPEN O
       + "Ɵ"  // U+019F: LATIN CAPITAL LETTER O WITH MIDDLE TILDE
       + "Ơ"  // U+01A0: LATIN CAPITAL LETTER O WITH HORN
       + "Ǒ"  // U+01D1: LATIN CAPITAL LETTER O WITH CARON
       + "Ǫ"  // U+01EA: LATIN CAPITAL LETTER O WITH OGONEK
       + "Ǭ"  // U+01EC: LATIN CAPITAL LETTER O WITH OGONEK AND MACRON
       + "Ǿ"  // U+01FE: LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
       + "Ȍ"  // U+020C: LATIN CAPITAL LETTER O WITH DOUBLE GRAVE
       + "Ȏ"  // U+020E: LATIN CAPITAL LETTER O WITH INVERTED BREVE
       + "Ȫ"  // U+022A: LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON
       + "Ȭ"  // U+022C: LATIN CAPITAL LETTER O WITH TILDE AND MACRON
       + "Ȯ"  // U+022E: LATIN CAPITAL LETTER O WITH DOT ABOVE
       + "Ȱ"  // U+0230: LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON
       + "ᴏ"  // U+1D0F: LATIN LETTER SMALL CAPITAL O
       + "ᴐ"  // U+1D10: LATIN LETTER SMALL CAPITAL OPEN O
       + "Ṍ"  // U+1E4C: LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
       + "Ṏ"  // U+1E4E: LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS
       + "Ṑ"  // U+1E50: LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
       + "Ṓ"  // U+1E52: LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
       + "Ọ"  // U+1ECC: LATIN CAPITAL LETTER O WITH DOT BELOW
       + "Ỏ"  // U+1ECE: LATIN CAPITAL LETTER O WITH HOOK ABOVE
       + "Ố"  // U+1ED0: LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
       + "Ồ"  // U+1ED2: LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
       + "Ổ"  // U+1ED4: LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
       + "Ỗ"  // U+1ED6: LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
       + "Ộ"  // U+1ED8: LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
       + "Ớ"  // U+1EDA: LATIN CAPITAL LETTER O WITH HORN AND ACUTE
       + "Ờ"  // U+1EDC: LATIN CAPITAL LETTER O WITH HORN AND GRAVE
       + "Ở"  // U+1EDE: LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
       + "Ỡ"  // U+1EE0: LATIN CAPITAL LETTER O WITH HORN AND TILDE
       + "Ợ"  // U+1EE2: LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
       + "Ⓞ"  // U+24C4: CIRCLED LATIN CAPITAL LETTER O
       + "Ꝋ"  // U+A74A: LATIN CAPITAL LETTER O WITH LONG STROKE OVERLAY
       + "Ꝍ"  // U+A74C: LATIN CAPITAL LETTER O WITH LOOP
       + "Ｏ"  // U+FF2F: FULLWIDTH LATIN CAPITAL LETTER O
      ,"O", // Folded result

       "ò"  // U+00F2: LATIN SMALL LETTER O WITH GRAVE
       + "ó"  // U+00F3: LATIN SMALL LETTER O WITH ACUTE
       + "ô"  // U+00F4: LATIN SMALL LETTER O WITH CIRCUMFLEX
       + "õ"  // U+00F5: LATIN SMALL LETTER O WITH TILDE
       + "ö"  // U+00F6: LATIN SMALL LETTER O WITH DIAERESIS
       + "ø"  // U+00F8: LATIN SMALL LETTER O WITH STROKE
       + "ō"  // U+014D: LATIN SMALL LETTER O WITH MACRON
       + "ŏ"  // U+014F: LATIN SMALL LETTER O WITH BREVE
       + "ő"  // U+0151: LATIN SMALL LETTER O WITH DOUBLE ACUTE
       + "ơ"  // U+01A1: LATIN SMALL LETTER O WITH HORN
       + "ǒ"  // U+01D2: LATIN SMALL LETTER O WITH CARON
       + "ǫ"  // U+01EB: LATIN SMALL LETTER O WITH OGONEK
       + "ǭ"  // U+01ED: LATIN SMALL LETTER O WITH OGONEK AND MACRON
       + "ǿ"  // U+01FF: LATIN SMALL LETTER O WITH STROKE AND ACUTE
       + "ȍ"  // U+020D: LATIN SMALL LETTER O WITH DOUBLE GRAVE
       + "ȏ"  // U+020F: LATIN SMALL LETTER O WITH INVERTED BREVE
       + "ȫ"  // U+022B: LATIN SMALL LETTER O WITH DIAERESIS AND MACRON
       + "ȭ"  // U+022D: LATIN SMALL LETTER O WITH TILDE AND MACRON
       + "ȯ"  // U+022F: LATIN SMALL LETTER O WITH DOT ABOVE
       + "ȱ"  // U+0231: LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON
       + "ɔ"  // U+0254: LATIN SMALL LETTER OPEN O
       + "ɵ"  // U+0275: LATIN SMALL LETTER BARRED O
       + "ᴖ"  // U+1D16: LATIN SMALL LETTER TOP HALF O
       + "ᴗ"  // U+1D17: LATIN SMALL LETTER BOTTOM HALF O
       + "ᶗ"  // U+1D97: LATIN SMALL LETTER OPEN O WITH RETROFLEX HOOK
       + "ṍ"  // U+1E4D: LATIN SMALL LETTER O WITH TILDE AND ACUTE
       + "ṏ"  // U+1E4F: LATIN SMALL LETTER O WITH TILDE AND DIAERESIS
       + "ṑ"  // U+1E51: LATIN SMALL LETTER O WITH MACRON AND GRAVE
       + "ṓ"  // U+1E53: LATIN SMALL LETTER O WITH MACRON AND ACUTE
       + "ọ"  // U+1ECD: LATIN SMALL LETTER O WITH DOT BELOW
       + "ỏ"  // U+1ECF: LATIN SMALL LETTER O WITH HOOK ABOVE
       + "ố"  // U+1ED1: LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
       + "ồ"  // U+1ED3: LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
       + "ổ"  // U+1ED5: LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
       + "ỗ"  // U+1ED7: LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
       + "ộ"  // U+1ED9: LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
       + "ớ"  // U+1EDB: LATIN SMALL LETTER O WITH HORN AND ACUTE
       + "ờ"  // U+1EDD: LATIN SMALL LETTER O WITH HORN AND GRAVE
       + "ở"  // U+1EDF: LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
       + "ỡ"  // U+1EE1: LATIN SMALL LETTER O WITH HORN AND TILDE
       + "ợ"  // U+1EE3: LATIN SMALL LETTER O WITH HORN AND DOT BELOW
       + "ₒ"  // U+2092: LATIN SUBSCRIPT SMALL LETTER O
       + "ⓞ"  // U+24DE: CIRCLED LATIN SMALL LETTER O
       + "ⱺ"  // U+2C7A: LATIN SMALL LETTER O WITH LOW RING INSIDE
       + "ꝋ"  // U+A74B: LATIN SMALL LETTER O WITH LONG STROKE OVERLAY
       + "ꝍ"  // U+A74D: LATIN SMALL LETTER O WITH LOOP
       + "ｏ"  // U+FF4F: FULLWIDTH LATIN SMALL LETTER O
      ,"o", // Folded result

       "Œ"  // U+0152: LATIN CAPITAL LIGATURE OE
       + "ɶ"  // U+0276: LATIN LETTER SMALL CAPITAL OE
      ,"OE", // Folded result

       "Ꝏ"  // U+A74E: LATIN CAPITAL LETTER OO
      ,"OO", // Folded result

       "Ȣ"  // U+0222: LATIN CAPITAL LETTER OU
       + "ᴕ"  // U+1D15: LATIN LETTER SMALL CAPITAL OU
      ,"OU", // Folded result

       "⒪"  // U+24AA: PARENTHESIZED LATIN SMALL LETTER O
      ,"(o)", // Folded result

       "œ"  // U+0153: LATIN SMALL LIGATURE OE
       + "ᴔ"  // U+1D14: LATIN SMALL LETTER TURNED OE
      ,"oe", // Folded result

       "ꝏ"  // U+A74F: LATIN SMALL LETTER OO
      ,"oo", // Folded result

       "ȣ"  // U+0223: LATIN SMALL LETTER OU
      ,"ou", // Folded result

       "Ƥ"  // U+01A4: LATIN CAPITAL LETTER P WITH HOOK
       + "ᴘ"  // U+1D18: LATIN LETTER SMALL CAPITAL P
       + "Ṕ"  // U+1E54: LATIN CAPITAL LETTER P WITH ACUTE
       + "Ṗ"  // U+1E56: LATIN CAPITAL LETTER P WITH DOT ABOVE
       + "Ⓟ"  // U+24C5: CIRCLED LATIN CAPITAL LETTER P
       + "Ᵽ"  // U+2C63: LATIN CAPITAL LETTER P WITH STROKE
       + "Ꝑ"  // U+A750: LATIN CAPITAL LETTER P WITH STROKE THROUGH DESCENDER
       + "Ꝓ"  // U+A752: LATIN CAPITAL LETTER P WITH FLOURISH
       + "Ꝕ"  // U+A754: LATIN CAPITAL LETTER P WITH SQUIRREL TAIL
       + "Ｐ"  // U+FF30: FULLWIDTH LATIN CAPITAL LETTER P
      ,"P", // Folded result

       "ƥ"  // U+01A5: LATIN SMALL LETTER P WITH HOOK
       + "ᵱ"  // U+1D71: LATIN SMALL LETTER P WITH MIDDLE TILDE
       + "ᵽ"  // U+1D7D: LATIN SMALL LETTER P WITH STROKE
       + "ᶈ"  // U+1D88: LATIN SMALL LETTER P WITH PALATAL HOOK
       + "ṕ"  // U+1E55: LATIN SMALL LETTER P WITH ACUTE
       + "ṗ"  // U+1E57: LATIN SMALL LETTER P WITH DOT ABOVE
       + "ⓟ"  // U+24DF: CIRCLED LATIN SMALL LETTER P
       + "ꝑ"  // U+A751: LATIN SMALL LETTER P WITH STROKE THROUGH DESCENDER
       + "ꝓ"  // U+A753: LATIN SMALL LETTER P WITH FLOURISH
       + "ꝕ"  // U+A755: LATIN SMALL LETTER P WITH SQUIRREL TAIL
       + "ꟼ"  // U+A7FC: LATIN EPIGRAPHIC LETTER REVERSED P
       + "ｐ"  // U+FF50: FULLWIDTH LATIN SMALL LETTER P
      ,"p", // Folded result

       "⒫"  // U+24AB: PARENTHESIZED LATIN SMALL LETTER P
      ,"(p)", // Folded result

       "Ɋ"  // U+024A: LATIN CAPITAL LETTER SMALL Q WITH HOOK TAIL
       + "Ⓠ"  // U+24C6: CIRCLED LATIN CAPITAL LETTER Q
       + "Ꝗ"  // U+A756: LATIN CAPITAL LETTER Q WITH STROKE THROUGH DESCENDER
       + "Ꝙ"  // U+A758: LATIN CAPITAL LETTER Q WITH DIAGONAL STROKE
       + "Ｑ"  // U+FF31: FULLWIDTH LATIN CAPITAL LETTER Q
      ,"Q", // Folded result

       "ĸ"  // U+0138: LATIN SMALL LETTER KRA
       + "ɋ"  // U+024B: LATIN SMALL LETTER Q WITH HOOK TAIL
       + "ʠ"  // U+02A0: LATIN SMALL LETTER Q WITH HOOK
       + "ⓠ"  // U+24E0: CIRCLED LATIN SMALL LETTER Q
       + "ꝗ"  // U+A757: LATIN SMALL LETTER Q WITH STROKE THROUGH DESCENDER
       + "ꝙ"  // U+A759: LATIN SMALL LETTER Q WITH DIAGONAL STROKE
       + "ｑ"  // U+FF51: FULLWIDTH LATIN SMALL LETTER Q
      ,"q", // Folded result

       "⒬"  // U+24AC: PARENTHESIZED LATIN SMALL LETTER Q
      ,"(q)", // Folded result

       "ȹ"  // U+0239: LATIN SMALL LETTER QP DIGRAPH
      ,"qp", // Folded result

       "Ŕ"  // U+0154: LATIN CAPITAL LETTER R WITH ACUTE
       + "Ŗ"  // U+0156: LATIN CAPITAL LETTER R WITH CEDILLA
       + "Ř"  // U+0158: LATIN CAPITAL LETTER R WITH CARON
       + "Ȑ"  // U+0210: LATIN CAPITAL LETTER R WITH DOUBLE GRAVE
       + "Ȓ"  // U+0212: LATIN CAPITAL LETTER R WITH INVERTED BREVE
       + "Ɍ"  // U+024C: LATIN CAPITAL LETTER R WITH STROKE
       + "ʀ"  // U+0280: LATIN LETTER SMALL CAPITAL R
       + "ʁ"  // U+0281: LATIN LETTER SMALL CAPITAL INVERTED R
       + "ᴙ"  // U+1D19: LATIN LETTER SMALL CAPITAL REVERSED R
       + "ᴚ"  // U+1D1A: LATIN LETTER SMALL CAPITAL TURNED R
       + "Ṙ"  // U+1E58: LATIN CAPITAL LETTER R WITH DOT ABOVE
       + "Ṛ"  // U+1E5A: LATIN CAPITAL LETTER R WITH DOT BELOW
       + "Ṝ"  // U+1E5C: LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
       + "Ṟ"  // U+1E5E: LATIN CAPITAL LETTER R WITH LINE BELOW
       + "Ⓡ"  // U+24C7: CIRCLED LATIN CAPITAL LETTER R
       + "Ɽ"  // U+2C64: LATIN CAPITAL LETTER R WITH TAIL
       + "Ꝛ"  // U+A75A: LATIN CAPITAL LETTER R ROTUNDA
       + "Ꞃ"  // U+A782: LATIN CAPITAL LETTER INSULAR R
       + "Ｒ"  // U+FF32: FULLWIDTH LATIN CAPITAL LETTER R
      ,"R", // Folded result

       "ŕ"  // U+0155: LATIN SMALL LETTER R WITH ACUTE
       + "ŗ"  // U+0157: LATIN SMALL LETTER R WITH CEDILLA
       + "ř"  // U+0159: LATIN SMALL LETTER R WITH CARON
       + "ȑ"  // U+0211: LATIN SMALL LETTER R WITH DOUBLE GRAVE
       + "ȓ"  // U+0213: LATIN SMALL LETTER R WITH INVERTED BREVE
       + "ɍ"  // U+024D: LATIN SMALL LETTER R WITH STROKE
       + "ɼ"  // U+027C: LATIN SMALL LETTER R WITH LONG LEG
       + "ɽ"  // U+027D: LATIN SMALL LETTER R WITH TAIL
       + "ɾ"  // U+027E: LATIN SMALL LETTER R WITH FISHHOOK
       + "ɿ"  // U+027F: LATIN SMALL LETTER REVERSED R WITH FISHHOOK
       + "ᵣ"  // U+1D63: LATIN SUBSCRIPT SMALL LETTER R
       + "ᵲ"  // U+1D72: LATIN SMALL LETTER R WITH MIDDLE TILDE
       + "ᵳ"  // U+1D73: LATIN SMALL LETTER R WITH FISHHOOK AND MIDDLE TILDE
       + "ᶉ"  // U+1D89: LATIN SMALL LETTER R WITH PALATAL HOOK
       + "ṙ"  // U+1E59: LATIN SMALL LETTER R WITH DOT ABOVE
       + "ṛ"  // U+1E5B: LATIN SMALL LETTER R WITH DOT BELOW
       + "ṝ"  // U+1E5D: LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
       + "ṟ"  // U+1E5F: LATIN SMALL LETTER R WITH LINE BELOW
       + "ⓡ"  // U+24E1: CIRCLED LATIN SMALL LETTER R
       + "ꝛ"  // U+A75B: LATIN SMALL LETTER R ROTUNDA
       + "ꞃ"  // U+A783: LATIN SMALL LETTER INSULAR R
       + "ｒ"  // U+FF52: FULLWIDTH LATIN SMALL LETTER R
      ,"r", // Folded result

       "⒭"  // U+24AD: PARENTHESIZED LATIN SMALL LETTER R
      ,"(r)", // Folded result

       "Ś"  // U+015A: LATIN CAPITAL LETTER S WITH ACUTE
       + "Ŝ"  // U+015C: LATIN CAPITAL LETTER S WITH CIRCUMFLEX
       + "Ş"  // U+015E: LATIN CAPITAL LETTER S WITH CEDILLA
       + "Š"  // U+0160: LATIN CAPITAL LETTER S WITH CARON
       + "Ș"  // U+0218: LATIN CAPITAL LETTER S WITH COMMA BELOW
       + "Ṡ"  // U+1E60: LATIN CAPITAL LETTER S WITH DOT ABOVE
       + "Ṣ"  // U+1E62: LATIN CAPITAL LETTER S WITH DOT BELOW
       + "Ṥ"  // U+1E64: LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
       + "Ṧ"  // U+1E66: LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE
       + "Ṩ"  // U+1E68: LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE
       + "Ⓢ"  // U+24C8: CIRCLED LATIN CAPITAL LETTER S
       + "ꜱ"  // U+A731: LATIN LETTER SMALL CAPITAL S
       + "ꞅ"  // U+A785: LATIN SMALL LETTER INSULAR S
       + "Ｓ"  // U+FF33: FULLWIDTH LATIN CAPITAL LETTER S
      ,"S", // Folded result

       "ś"  // U+015B: LATIN SMALL LETTER S WITH ACUTE
       + "ŝ"  // U+015D: LATIN SMALL LETTER S WITH CIRCUMFLEX
       + "ş"  // U+015F: LATIN SMALL LETTER S WITH CEDILLA
       + "š"  // U+0161: LATIN SMALL LETTER S WITH CARON
       + "ſ"  // U+017F: LATIN SMALL LETTER LONG S
       + "ș"  // U+0219: LATIN SMALL LETTER S WITH COMMA BELOW
       + "ȿ"  // U+023F: LATIN SMALL LETTER S WITH SWASH TAIL
       + "ʂ"  // U+0282: LATIN SMALL LETTER S WITH HOOK
       + "ᵴ"  // U+1D74: LATIN SMALL LETTER S WITH MIDDLE TILDE
       + "ᶊ"  // U+1D8A: LATIN SMALL LETTER S WITH PALATAL HOOK
       + "ṡ"  // U+1E61: LATIN SMALL LETTER S WITH DOT ABOVE
       + "ṣ"  // U+1E63: LATIN SMALL LETTER S WITH DOT BELOW
       + "ṥ"  // U+1E65: LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
       + "ṧ"  // U+1E67: LATIN SMALL LETTER S WITH CARON AND DOT ABOVE
       + "ṩ"  // U+1E69: LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE
       + "ẜ"  // U+1E9C: LATIN SMALL LETTER LONG S WITH DIAGONAL STROKE
       + "ẝ"  // U+1E9D: LATIN SMALL LETTER LONG S WITH HIGH STROKE
       + "ⓢ"  // U+24E2: CIRCLED LATIN SMALL LETTER S
       + "Ꞅ"  // U+A784: LATIN CAPITAL LETTER INSULAR S
       + "ｓ"  // U+FF53: FULLWIDTH LATIN SMALL LETTER S
      ,"s", // Folded result

       "ẞ"  // U+1E9E: LATIN CAPITAL LETTER SHARP S
      ,"SS", // Folded result

       "⒮"  // U+24AE: PARENTHESIZED LATIN SMALL LETTER S
      ,"(s)", // Folded result

       "ß"  // U+00DF: LATIN SMALL LETTER SHARP S
      ,"ss", // Folded result

       "ﬆ"  // U+FB06: LATIN SMALL LIGATURE ST
      ,"st", // Folded result

       "Ţ"  // U+0162: LATIN CAPITAL LETTER T WITH CEDILLA
       + "Ť"  // U+0164: LATIN CAPITAL LETTER T WITH CARON
       + "Ŧ"  // U+0166: LATIN CAPITAL LETTER T WITH STROKE
       + "Ƭ"  // U+01AC: LATIN CAPITAL LETTER T WITH HOOK
       + "Ʈ"  // U+01AE: LATIN CAPITAL LETTER T WITH RETROFLEX HOOK
       + "Ț"  // U+021A: LATIN CAPITAL LETTER T WITH COMMA BELOW
       + "Ⱦ"  // U+023E: LATIN CAPITAL LETTER T WITH DIAGONAL STROKE
       + "ᴛ"  // U+1D1B: LATIN LETTER SMALL CAPITAL T
       + "Ṫ"  // U+1E6A: LATIN CAPITAL LETTER T WITH DOT ABOVE
       + "Ṭ"  // U+1E6C: LATIN CAPITAL LETTER T WITH DOT BELOW
       + "Ṯ"  // U+1E6E: LATIN CAPITAL LETTER T WITH LINE BELOW
       + "Ṱ"  // U+1E70: LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW
       + "Ⓣ"  // U+24C9: CIRCLED LATIN CAPITAL LETTER T
       + "Ꞇ"  // U+A786: LATIN CAPITAL LETTER INSULAR T
       + "Ｔ"  // U+FF34: FULLWIDTH LATIN CAPITAL LETTER T
      ,"T", // Folded result

       "ţ"  // U+0163: LATIN SMALL LETTER T WITH CEDILLA
       + "ť"  // U+0165: LATIN SMALL LETTER T WITH CARON
       + "ŧ"  // U+0167: LATIN SMALL LETTER T WITH STROKE
       + "ƫ"  // U+01AB: LATIN SMALL LETTER T WITH PALATAL HOOK
       + "ƭ"  // U+01AD: LATIN SMALL LETTER T WITH HOOK
       + "ț"  // U+021B: LATIN SMALL LETTER T WITH COMMA BELOW
       + "ȶ"  // U+0236: LATIN SMALL LETTER T WITH CURL
       + "ʇ"  // U+0287: LATIN SMALL LETTER TURNED T
       + "ʈ"  // U+0288: LATIN SMALL LETTER T WITH RETROFLEX HOOK
       + "ᵵ"  // U+1D75: LATIN SMALL LETTER T WITH MIDDLE TILDE
       + "ṫ"  // U+1E6B: LATIN SMALL LETTER T WITH DOT ABOVE
       + "ṭ"  // U+1E6D: LATIN SMALL LETTER T WITH DOT BELOW
       + "ṯ"  // U+1E6F: LATIN SMALL LETTER T WITH LINE BELOW
       + "ṱ"  // U+1E71: LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW
       + "ẗ"  // U+1E97: LATIN SMALL LETTER T WITH DIAERESIS
       + "ⓣ"  // U+24E3: CIRCLED LATIN SMALL LETTER T
       + "ⱦ"  // U+2C66: LATIN SMALL LETTER T WITH DIAGONAL STROKE
       + "ｔ"  // U+FF54: FULLWIDTH LATIN SMALL LETTER T
      ,"t", // Folded result

       "Þ"  // U+00DE: LATIN CAPITAL LETTER THORN
       + "Ꝧ"  // U+A766: LATIN CAPITAL LETTER THORN WITH STROKE THROUGH DESCENDER
      ,"TH", // Folded result

       "Ꜩ"  // U+A728: LATIN CAPITAL LETTER TZ
      ,"TZ", // Folded result

       "⒯"  // U+24AF: PARENTHESIZED LATIN SMALL LETTER T
      ,"(t)", // Folded result

       "ʨ"  // U+02A8: LATIN SMALL LETTER TC DIGRAPH WITH CURL
      ,"tc", // Folded result

       "þ"  // U+00FE: LATIN SMALL LETTER THORN
       + "ᵺ"  // U+1D7A: LATIN SMALL LETTER TH WITH STRIKETHROUGH
       + "ꝧ"  // U+A767: LATIN SMALL LETTER THORN WITH STROKE THROUGH DESCENDER
      ,"th", // Folded result

       "ʦ"  // U+02A6: LATIN SMALL LETTER TS DIGRAPH
      ,"ts", // Folded result

       "ꜩ"  // U+A729: LATIN SMALL LETTER TZ
      ,"tz", // Folded result

       "Ù"  // U+00D9: LATIN CAPITAL LETTER U WITH GRAVE
       + "Ú"  // U+00DA: LATIN CAPITAL LETTER U WITH ACUTE
       + "Û"  // U+00DB: LATIN CAPITAL LETTER U WITH CIRCUMFLEX
       + "Ü"  // U+00DC: LATIN CAPITAL LETTER U WITH DIAERESIS
       + "Ũ"  // U+0168: LATIN CAPITAL LETTER U WITH TILDE
       + "Ū"  // U+016A: LATIN CAPITAL LETTER U WITH MACRON
       + "Ŭ"  // U+016C: LATIN CAPITAL LETTER U WITH BREVE
       + "Ů"  // U+016E: LATIN CAPITAL LETTER U WITH RING ABOVE
       + "Ű"  // U+0170: LATIN CAPITAL LETTER U WITH DOUBLE ACUTE
       + "Ų"  // U+0172: LATIN CAPITAL LETTER U WITH OGONEK
       + "Ư"  // U+01AF: LATIN CAPITAL LETTER U WITH HORN
       + "Ǔ"  // U+01D3: LATIN CAPITAL LETTER U WITH CARON
       + "Ǖ"  // U+01D5: LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
       + "Ǘ"  // U+01D7: LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
       + "Ǚ"  // U+01D9: LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON
       + "Ǜ"  // U+01DB: LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
       + "Ȕ"  // U+0214: LATIN CAPITAL LETTER U WITH DOUBLE GRAVE
       + "Ȗ"  // U+0216: LATIN CAPITAL LETTER U WITH INVERTED BREVE
       + "Ʉ"  // U+0244: LATIN CAPITAL LETTER U BAR
       + "ᴜ"  // U+1D1C: LATIN LETTER SMALL CAPITAL U
       + "ᵾ"  // U+1D7E: LATIN SMALL CAPITAL LETTER U WITH STROKE
       + "Ṳ"  // U+1E72: LATIN CAPITAL LETTER U WITH DIAERESIS BELOW
       + "Ṵ"  // U+1E74: LATIN CAPITAL LETTER U WITH TILDE BELOW
       + "Ṷ"  // U+1E76: LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW
       + "Ṹ"  // U+1E78: LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
       + "Ṻ"  // U+1E7A: LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS
       + "Ụ"  // U+1EE4: LATIN CAPITAL LETTER U WITH DOT BELOW
       + "Ủ"  // U+1EE6: LATIN CAPITAL LETTER U WITH HOOK ABOVE
       + "Ứ"  // U+1EE8: LATIN CAPITAL LETTER U WITH HORN AND ACUTE
       + "Ừ"  // U+1EEA: LATIN CAPITAL LETTER U WITH HORN AND GRAVE
       + "Ử"  // U+1EEC: LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
       + "Ữ"  // U+1EEE: LATIN CAPITAL LETTER U WITH HORN AND TILDE
       + "Ự"  // U+1EF0: LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
       + "Ⓤ"  // U+24CA: CIRCLED LATIN CAPITAL LETTER U
       + "Ｕ"  // U+FF35: FULLWIDTH LATIN CAPITAL LETTER U
      ,"U", // Folded result

       "ù"  // U+00F9: LATIN SMALL LETTER U WITH GRAVE
       + "ú"  // U+00FA: LATIN SMALL LETTER U WITH ACUTE
       + "û"  // U+00FB: LATIN SMALL LETTER U WITH CIRCUMFLEX
       + "ü"  // U+00FC: LATIN SMALL LETTER U WITH DIAERESIS
       + "ũ"  // U+0169: LATIN SMALL LETTER U WITH TILDE
       + "ū"  // U+016B: LATIN SMALL LETTER U WITH MACRON
       + "ŭ"  // U+016D: LATIN SMALL LETTER U WITH BREVE
       + "ů"  // U+016F: LATIN SMALL LETTER U WITH RING ABOVE
       + "ű"  // U+0171: LATIN SMALL LETTER U WITH DOUBLE ACUTE
       + "ų"  // U+0173: LATIN SMALL LETTER U WITH OGONEK
       + "ư"  // U+01B0: LATIN SMALL LETTER U WITH HORN
       + "ǔ"  // U+01D4: LATIN SMALL LETTER U WITH CARON
       + "ǖ"  // U+01D6: LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
       + "ǘ"  // U+01D8: LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
       + "ǚ"  // U+01DA: LATIN SMALL LETTER U WITH DIAERESIS AND CARON
       + "ǜ"  // U+01DC: LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
       + "ȕ"  // U+0215: LATIN SMALL LETTER U WITH DOUBLE GRAVE
       + "ȗ"  // U+0217: LATIN SMALL LETTER U WITH INVERTED BREVE
       + "ʉ"  // U+0289: LATIN SMALL LETTER U BAR
       + "ᵤ"  // U+1D64: LATIN SUBSCRIPT SMALL LETTER U
       + "ᶙ"  // U+1D99: LATIN SMALL LETTER U WITH RETROFLEX HOOK
       + "ṳ"  // U+1E73: LATIN SMALL LETTER U WITH DIAERESIS BELOW
       + "ṵ"  // U+1E75: LATIN SMALL LETTER U WITH TILDE BELOW
       + "ṷ"  // U+1E77: LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW
       + "ṹ"  // U+1E79: LATIN SMALL LETTER U WITH TILDE AND ACUTE
       + "ṻ"  // U+1E7B: LATIN SMALL LETTER U WITH MACRON AND DIAERESIS
       + "ụ"  // U+1EE5: LATIN SMALL LETTER U WITH DOT BELOW
       + "ủ"  // U+1EE7: LATIN SMALL LETTER U WITH HOOK ABOVE
       + "ứ"  // U+1EE9: LATIN SMALL LETTER U WITH HORN AND ACUTE
       + "ừ"  // U+1EEB: LATIN SMALL LETTER U WITH HORN AND GRAVE
       + "ử"  // U+1EED: LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
       + "ữ"  // U+1EEF: LATIN SMALL LETTER U WITH HORN AND TILDE
       + "ự"  // U+1EF1: LATIN SMALL LETTER U WITH HORN AND DOT BELOW
       + "ⓤ"  // U+24E4: CIRCLED LATIN SMALL LETTER U
       + "ｕ"  // U+FF55: FULLWIDTH LATIN SMALL LETTER U
      ,"u", // Folded result

       "⒰"  // U+24B0: PARENTHESIZED LATIN SMALL LETTER U
      ,"(u)", // Folded result

       "ᵫ"  // U+1D6B: LATIN SMALL LETTER UE
      ,"ue", // Folded result

       "Ʋ"  // U+01B2: LATIN CAPITAL LETTER V WITH HOOK
       + "Ʌ"  // U+0245: LATIN CAPITAL LETTER TURNED V
       + "ᴠ"  // U+1D20: LATIN LETTER SMALL CAPITAL V
       + "Ṽ"  // U+1E7C: LATIN CAPITAL LETTER V WITH TILDE
       + "Ṿ"  // U+1E7E: LATIN CAPITAL LETTER V WITH DOT BELOW
       + "Ỽ"  // U+1EFC: LATIN CAPITAL LETTER MIDDLE-WELSH V
       + "Ⓥ"  // U+24CB: CIRCLED LATIN CAPITAL LETTER V
       + "Ꝟ"  // U+A75E: LATIN CAPITAL LETTER V WITH DIAGONAL STROKE
       + "Ꝩ"  // U+A768: LATIN CAPITAL LETTER VEND
       + "Ｖ"  // U+FF36: FULLWIDTH LATIN CAPITAL LETTER V
      ,"V", // Folded result

       "ʋ"  // U+028B: LATIN SMALL LETTER V WITH HOOK
       + "ʌ"  // U+028C: LATIN SMALL LETTER TURNED V
       + "ᵥ"  // U+1D65: LATIN SUBSCRIPT SMALL LETTER V
       + "ᶌ"  // U+1D8C: LATIN SMALL LETTER V WITH PALATAL HOOK
       + "ṽ"  // U+1E7D: LATIN SMALL LETTER V WITH TILDE
       + "ṿ"  // U+1E7F: LATIN SMALL LETTER V WITH DOT BELOW
       + "ⓥ"  // U+24E5: CIRCLED LATIN SMALL LETTER V
       + "ⱱ"  // U+2C71: LATIN SMALL LETTER V WITH RIGHT HOOK
       + "ⱴ"  // U+2C74: LATIN SMALL LETTER V WITH CURL
       + "ꝟ"  // U+A75F: LATIN SMALL LETTER V WITH DIAGONAL STROKE
       + "ｖ"  // U+FF56: FULLWIDTH LATIN SMALL LETTER V
      ,"v", // Folded result

       "Ꝡ"  // U+A760: LATIN CAPITAL LETTER VY
      ,"VY", // Folded result

       "⒱"  // U+24B1: PARENTHESIZED LATIN SMALL LETTER V
      ,"(v)", // Folded result

       "ꝡ"  // U+A761: LATIN SMALL LETTER VY
      ,"vy", // Folded result

       "Ŵ"  // U+0174: LATIN CAPITAL LETTER W WITH CIRCUMFLEX
       + "Ƿ"  // U+01F7: LATIN CAPITAL LETTER WYNN
       + "ᴡ"  // U+1D21: LATIN LETTER SMALL CAPITAL W
       + "Ẁ"  // U+1E80: LATIN CAPITAL LETTER W WITH GRAVE
       + "Ẃ"  // U+1E82: LATIN CAPITAL LETTER W WITH ACUTE
       + "Ẅ"  // U+1E84: LATIN CAPITAL LETTER W WITH DIAERESIS
       + "Ẇ"  // U+1E86: LATIN CAPITAL LETTER W WITH DOT ABOVE
       + "Ẉ"  // U+1E88: LATIN CAPITAL LETTER W WITH DOT BELOW
       + "Ⓦ"  // U+24CC: CIRCLED LATIN CAPITAL LETTER W
       + "Ⱳ"  // U+2C72: LATIN CAPITAL LETTER W WITH HOOK
       + "Ｗ"  // U+FF37: FULLWIDTH LATIN CAPITAL LETTER W
      ,"W", // Folded result

       "ŵ"  // U+0175: LATIN SMALL LETTER W WITH CIRCUMFLEX
       + "ƿ"  // U+01BF: LATIN LETTER WYNN
       + "ʍ"  // U+028D: LATIN SMALL LETTER TURNED W
       + "ẁ"  // U+1E81: LATIN SMALL LETTER W WITH GRAVE
       + "ẃ"  // U+1E83: LATIN SMALL LETTER W WITH ACUTE
       + "ẅ"  // U+1E85: LATIN SMALL LETTER W WITH DIAERESIS
       + "ẇ"  // U+1E87: LATIN SMALL LETTER W WITH DOT ABOVE
       + "ẉ"  // U+1E89: LATIN SMALL LETTER W WITH DOT BELOW
       + "ẘ"  // U+1E98: LATIN SMALL LETTER W WITH RING ABOVE
       + "ⓦ"  // U+24E6: CIRCLED LATIN SMALL LETTER W
       + "ⱳ"  // U+2C73: LATIN SMALL LETTER W WITH HOOK
       + "ｗ"  // U+FF57: FULLWIDTH LATIN SMALL LETTER W
      ,"w", // Folded result

       "⒲"  // U+24B2: PARENTHESIZED LATIN SMALL LETTER W
      ,"(w)", // Folded result

       "Ẋ"  // U+1E8A: LATIN CAPITAL LETTER X WITH DOT ABOVE
       + "Ẍ"  // U+1E8C: LATIN CAPITAL LETTER X WITH DIAERESIS
       + "Ⓧ"  // U+24CD: CIRCLED LATIN CAPITAL LETTER X
       + "Ｘ"  // U+FF38: FULLWIDTH LATIN CAPITAL LETTER X
      ,"X", // Folded result

       "ᶍ"  // U+1D8D: LATIN SMALL LETTER X WITH PALATAL HOOK
       + "ẋ"  // U+1E8B: LATIN SMALL LETTER X WITH DOT ABOVE
       + "ẍ"  // U+1E8D: LATIN SMALL LETTER X WITH DIAERESIS
       + "ₓ"  // U+2093: LATIN SUBSCRIPT SMALL LETTER X
       + "ⓧ"  // U+24E7: CIRCLED LATIN SMALL LETTER X
       + "ｘ"  // U+FF58: FULLWIDTH LATIN SMALL LETTER X
      ,"x", // Folded result

       "⒳"  // U+24B3: PARENTHESIZED LATIN SMALL LETTER X
      ,"(x)", // Folded result

       "Ý"  // U+00DD: LATIN CAPITAL LETTER Y WITH ACUTE
       + "Ŷ"  // U+0176: LATIN CAPITAL LETTER Y WITH CIRCUMFLEX
       + "Ÿ"  // U+0178: LATIN CAPITAL LETTER Y WITH DIAERESIS
       + "Ƴ"  // U+01B3: LATIN CAPITAL LETTER Y WITH HOOK
       + "Ȳ"  // U+0232: LATIN CAPITAL LETTER Y WITH MACRON
       + "Ɏ"  // U+024E: LATIN CAPITAL LETTER Y WITH STROKE
       + "ʏ"  // U+028F: LATIN LETTER SMALL CAPITAL Y
       + "Ẏ"  // U+1E8E: LATIN CAPITAL LETTER Y WITH DOT ABOVE
       + "Ỳ"  // U+1EF2: LATIN CAPITAL LETTER Y WITH GRAVE
       + "Ỵ"  // U+1EF4: LATIN CAPITAL LETTER Y WITH DOT BELOW
       + "Ỷ"  // U+1EF6: LATIN CAPITAL LETTER Y WITH HOOK ABOVE
       + "Ỹ"  // U+1EF8: LATIN CAPITAL LETTER Y WITH TILDE
       + "Ỿ"  // U+1EFE: LATIN CAPITAL LETTER Y WITH LOOP
       + "Ⓨ"  // U+24CE: CIRCLED LATIN CAPITAL LETTER Y
       + "Ｙ"  // U+FF39: FULLWIDTH LATIN CAPITAL LETTER Y
      ,"Y", // Folded result

       "ý"  // U+00FD: LATIN SMALL LETTER Y WITH ACUTE
       + "ÿ"  // U+00FF: LATIN SMALL LETTER Y WITH DIAERESIS
       + "ŷ"  // U+0177: LATIN SMALL LETTER Y WITH CIRCUMFLEX
       + "ƴ"  // U+01B4: LATIN SMALL LETTER Y WITH HOOK
       + "ȳ"  // U+0233: LATIN SMALL LETTER Y WITH MACRON
       + "ɏ"  // U+024F: LATIN SMALL LETTER Y WITH STROKE
       + "ʎ"  // U+028E: LATIN SMALL LETTER TURNED Y
       + "ẏ"  // U+1E8F: LATIN SMALL LETTER Y WITH DOT ABOVE
       + "ẙ"  // U+1E99: LATIN SMALL LETTER Y WITH RING ABOVE
       + "ỳ"  // U+1EF3: LATIN SMALL LETTER Y WITH GRAVE
       + "ỵ"  // U+1EF5: LATIN SMALL LETTER Y WITH DOT BELOW
       + "ỷ"  // U+1EF7: LATIN SMALL LETTER Y WITH HOOK ABOVE
       + "ỹ"  // U+1EF9: LATIN SMALL LETTER Y WITH TILDE
       + "ỿ"  // U+1EFF: LATIN SMALL LETTER Y WITH LOOP
       + "ⓨ"  // U+24E8: CIRCLED LATIN SMALL LETTER Y
       + "ｙ"  // U+FF59: FULLWIDTH LATIN SMALL LETTER Y
      ,"y", // Folded result

       "⒴"  // U+24B4: PARENTHESIZED LATIN SMALL LETTER Y
      ,"(y)", // Folded result

       "Ź"  // U+0179: LATIN CAPITAL LETTER Z WITH ACUTE
       + "Ż"  // U+017B: LATIN CAPITAL LETTER Z WITH DOT ABOVE
       + "Ž"  // U+017D: LATIN CAPITAL LETTER Z WITH CARON
       + "Ƶ"  // U+01B5: LATIN CAPITAL LETTER Z WITH STROKE
       + "Ȝ"  // U+021C: LATIN CAPITAL LETTER YOGH
       + "Ȥ"  // U+0224: LATIN CAPITAL LETTER Z WITH HOOK
       + "ᴢ"  // U+1D22: LATIN LETTER SMALL CAPITAL Z
       + "Ẑ"  // U+1E90: LATIN CAPITAL LETTER Z WITH CIRCUMFLEX
       + "Ẓ"  // U+1E92: LATIN CAPITAL LETTER Z WITH DOT BELOW
       + "Ẕ"  // U+1E94: LATIN CAPITAL LETTER Z WITH LINE BELOW
       + "Ⓩ"  // U+24CF: CIRCLED LATIN CAPITAL LETTER Z
       + "Ⱬ"  // U+2C6B: LATIN CAPITAL LETTER Z WITH DESCENDER
       + "Ꝣ"  // U+A762: LATIN CAPITAL LETTER VISIGOTHIC Z
       + "Ｚ"  // U+FF3A: FULLWIDTH LATIN CAPITAL LETTER Z
      ,"Z", // Folded result

       "ź"  // U+017A: LATIN SMALL LETTER Z WITH ACUTE
       + "ż"  // U+017C: LATIN SMALL LETTER Z WITH DOT ABOVE
       + "ž"  // U+017E: LATIN SMALL LETTER Z WITH CARON
       + "ƶ"  // U+01B6: LATIN SMALL LETTER Z WITH STROKE
       + "ȝ"  // U+021D: LATIN SMALL LETTER YOGH
       + "ȥ"  // U+0225: LATIN SMALL LETTER Z WITH HOOK
       + "ɀ"  // U+0240: LATIN SMALL LETTER Z WITH SWASH TAIL
       + "ʐ"  // U+0290: LATIN SMALL LETTER Z WITH RETROFLEX HOOK
       + "ʑ"  // U+0291: LATIN SMALL LETTER Z WITH CURL
       + "ᵶ"  // U+1D76: LATIN SMALL LETTER Z WITH MIDDLE TILDE
       + "ᶎ"  // U+1D8E: LATIN SMALL LETTER Z WITH PALATAL HOOK
       + "ẑ"  // U+1E91: LATIN SMALL LETTER Z WITH CIRCUMFLEX
       + "ẓ"  // U+1E93: LATIN SMALL LETTER Z WITH DOT BELOW
       + "ẕ"  // U+1E95: LATIN SMALL LETTER Z WITH LINE BELOW
       + "ⓩ"  // U+24E9: CIRCLED LATIN SMALL LETTER Z
       + "ⱬ"  // U+2C6C: LATIN SMALL LETTER Z WITH DESCENDER
       + "ꝣ"  // U+A763: LATIN SMALL LETTER VISIGOTHIC Z
       + "ｚ"  // U+FF5A: FULLWIDTH LATIN SMALL LETTER Z
      ,"z", // Folded result

       "⒵"  // U+24B5: PARENTHESIZED LATIN SMALL LETTER Z
      ,"(z)", // Folded result

       "⁰"  // U+2070: SUPERSCRIPT ZERO
       + "₀"  // U+2080: SUBSCRIPT ZERO
       + "⓪"  // U+24EA: CIRCLED DIGIT ZERO
       + "⓿"  // U+24FF: NEGATIVE CIRCLED DIGIT ZERO
       + "０"  // U+FF10: FULLWIDTH DIGIT ZERO
      ,"0", // Folded result

       "¹"  // U+00B9: SUPERSCRIPT ONE
       + "₁"  // U+2081: SUBSCRIPT ONE
       + "①"  // U+2460: CIRCLED DIGIT ONE
       + "⓵"  // U+24F5: DOUBLE CIRCLED DIGIT ONE
       + "❶"  // U+2776: DINGBAT NEGATIVE CIRCLED DIGIT ONE
       + "➀"  // U+2780: DINGBAT CIRCLED SANS-SERIF DIGIT ONE
       + "➊"  // U+278A: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT ONE
       + "１"  // U+FF11: FULLWIDTH DIGIT ONE
      ,"1", // Folded result

       "⒈"  // U+2488: DIGIT ONE FULL STOP
      ,"1.", // Folded result

       "⑴"  // U+2474: PARENTHESIZED DIGIT ONE
      ,"(1)", // Folded result

       "²"  // U+00B2: SUPERSCRIPT TWO
       + "₂"  // U+2082: SUBSCRIPT TWO
       + "②"  // U+2461: CIRCLED DIGIT TWO
       + "⓶"  // U+24F6: DOUBLE CIRCLED DIGIT TWO
       + "❷"  // U+2777: DINGBAT NEGATIVE CIRCLED DIGIT TWO
       + "➁"  // U+2781: DINGBAT CIRCLED SANS-SERIF DIGIT TWO
       + "➋"  // U+278B: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT TWO
       + "２"  // U+FF12: FULLWIDTH DIGIT TWO
      ,"2", // Folded result

       "⒉"  // U+2489: DIGIT TWO FULL STOP
      ,"2.", // Folded result

       "⑵"  // U+2475: PARENTHESIZED DIGIT TWO
      ,"(2)", // Folded result

       "³"  // U+00B3: SUPERSCRIPT THREE
       + "₃"  // U+2083: SUBSCRIPT THREE
       + "③"  // U+2462: CIRCLED DIGIT THREE
       + "⓷"  // U+24F7: DOUBLE CIRCLED DIGIT THREE
       + "❸"  // U+2778: DINGBAT NEGATIVE CIRCLED DIGIT THREE
       + "➂"  // U+2782: DINGBAT CIRCLED SANS-SERIF DIGIT THREE
       + "➌"  // U+278C: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT THREE
       + "３"  // U+FF13: FULLWIDTH DIGIT THREE
      ,"3", // Folded result

       "⒊"  // U+248A: DIGIT THREE FULL STOP
      ,"3.", // Folded result

       "⑶"  // U+2476: PARENTHESIZED DIGIT THREE
      ,"(3)", // Folded result

       "⁴"  // U+2074: SUPERSCRIPT FOUR
       + "₄"  // U+2084: SUBSCRIPT FOUR
       + "④"  // U+2463: CIRCLED DIGIT FOUR
       + "⓸"  // U+24F8: DOUBLE CIRCLED DIGIT FOUR
       + "❹"  // U+2779: DINGBAT NEGATIVE CIRCLED DIGIT FOUR
       + "➃"  // U+2783: DINGBAT CIRCLED SANS-SERIF DIGIT FOUR
       + "➍"  // U+278D: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT FOUR
       + "４"  // U+FF14: FULLWIDTH DIGIT FOUR
      ,"4", // Folded result

       "⒋"  // U+248B: DIGIT FOUR FULL STOP
      ,"4.", // Folded result

       "⑷"  // U+2477: PARENTHESIZED DIGIT FOUR
      ,"(4)", // Folded result

       "⁵"  // U+2075: SUPERSCRIPT FIVE
       + "₅"  // U+2085: SUBSCRIPT FIVE
       + "⑤"  // U+2464: CIRCLED DIGIT FIVE
       + "⓹"  // U+24F9: DOUBLE CIRCLED DIGIT FIVE
       + "❺"  // U+277A: DINGBAT NEGATIVE CIRCLED DIGIT FIVE
       + "➄"  // U+2784: DINGBAT CIRCLED SANS-SERIF DIGIT FIVE
       + "➎"  // U+278E: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT FIVE
       + "５"  // U+FF15: FULLWIDTH DIGIT FIVE
      ,"5", // Folded result

       "⒌"  // U+248C: DIGIT FIVE FULL STOP
      ,"5.", // Folded result

       "⑸"  // U+2478: PARENTHESIZED DIGIT FIVE
      ,"(5)", // Folded result

       "⁶"  // U+2076: SUPERSCRIPT SIX
       + "₆"  // U+2086: SUBSCRIPT SIX
       + "⑥"  // U+2465: CIRCLED DIGIT SIX
       + "⓺"  // U+24FA: DOUBLE CIRCLED DIGIT SIX
       + "❻"  // U+277B: DINGBAT NEGATIVE CIRCLED DIGIT SIX
       + "➅"  // U+2785: DINGBAT CIRCLED SANS-SERIF DIGIT SIX
       + "➏"  // U+278F: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT SIX
       + "６"  // U+FF16: FULLWIDTH DIGIT SIX
      ,"6", // Folded result

       "⒍"  // U+248D: DIGIT SIX FULL STOP
      ,"6.", // Folded result

       "⑹"  // U+2479: PARENTHESIZED DIGIT SIX
      ,"(6)", // Folded result

       "⁷"  // U+2077: SUPERSCRIPT SEVEN
       + "₇"  // U+2087: SUBSCRIPT SEVEN
       + "⑦"  // U+2466: CIRCLED DIGIT SEVEN
       + "⓻"  // U+24FB: DOUBLE CIRCLED DIGIT SEVEN
       + "❼"  // U+277C: DINGBAT NEGATIVE CIRCLED DIGIT SEVEN
       + "➆"  // U+2786: DINGBAT CIRCLED SANS-SERIF DIGIT SEVEN
       + "➐"  // U+2790: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT SEVEN
       + "７"  // U+FF17: FULLWIDTH DIGIT SEVEN
      ,"7", // Folded result

       "⒎"  // U+248E: DIGIT SEVEN FULL STOP
      ,"7.", // Folded result

       "⑺"  // U+247A: PARENTHESIZED DIGIT SEVEN
      ,"(7)", // Folded result

       "⁸"  // U+2078: SUPERSCRIPT EIGHT
       + "₈"  // U+2088: SUBSCRIPT EIGHT
       + "⑧"  // U+2467: CIRCLED DIGIT EIGHT
       + "⓼"  // U+24FC: DOUBLE CIRCLED DIGIT EIGHT
       + "❽"  // U+277D: DINGBAT NEGATIVE CIRCLED DIGIT EIGHT
       + "➇"  // U+2787: DINGBAT CIRCLED SANS-SERIF DIGIT EIGHT
       + "➑"  // U+2791: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT EIGHT
       + "８"  // U+FF18: FULLWIDTH DIGIT EIGHT
      ,"8", // Folded result

       "⒏"  // U+248F: DIGIT EIGHT FULL STOP
      ,"8.", // Folded result

       "⑻"  // U+247B: PARENTHESIZED DIGIT EIGHT
      ,"(8)", // Folded result

       "⁹"  // U+2079: SUPERSCRIPT NINE
       + "₉"  // U+2089: SUBSCRIPT NINE
       + "⑨"  // U+2468: CIRCLED DIGIT NINE
       + "⓽"  // U+24FD: DOUBLE CIRCLED DIGIT NINE
       + "❾"  // U+277E: DINGBAT NEGATIVE CIRCLED DIGIT NINE
       + "➈"  // U+2788: DINGBAT CIRCLED SANS-SERIF DIGIT NINE
       + "➒"  // U+2792: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT NINE
       + "９"  // U+FF19: FULLWIDTH DIGIT NINE
      ,"9", // Folded result

       "⒐"  // U+2490: DIGIT NINE FULL STOP
      ,"9.", // Folded result

       "⑼"  // U+247C: PARENTHESIZED DIGIT NINE
      ,"(9)", // Folded result

       "⑩"  // U+2469: CIRCLED NUMBER TEN
       + "⓾"  // U+24FE: DOUBLE CIRCLED NUMBER TEN
       + "❿"  // U+277F: DINGBAT NEGATIVE CIRCLED NUMBER TEN
       + "➉"  // U+2789: DINGBAT CIRCLED SANS-SERIF NUMBER TEN
       + "➓"  // U+2793: DINGBAT NEGATIVE CIRCLED SANS-SERIF NUMBER TEN
      ,"10", // Folded result

       "⒑"  // U+2491: NUMBER TEN FULL STOP
      ,"10.", // Folded result

       "⑽"  // U+247D: PARENTHESIZED NUMBER TEN
      ,"(10)", // Folded result

       "⑪"  // U+246A: CIRCLED NUMBER ELEVEN
       + "⓫"  // U+24EB: NEGATIVE CIRCLED NUMBER ELEVEN
      ,"11", // Folded result

       "⒒"  // U+2492: NUMBER ELEVEN FULL STOP
      ,"11.", // Folded result

       "⑾"  // U+247E: PARENTHESIZED NUMBER ELEVEN
      ,"(11)", // Folded result

       "⑫"  // U+246B: CIRCLED NUMBER TWELVE
       + "⓬"  // U+24EC: NEGATIVE CIRCLED NUMBER TWELVE
      ,"12", // Folded result

       "⒓"  // U+2493: NUMBER TWELVE FULL STOP
      ,"12.", // Folded result

       "⑿"  // U+247F: PARENTHESIZED NUMBER TWELVE
      ,"(12)", // Folded result

       "⑬"  // U+246C: CIRCLED NUMBER THIRTEEN
       + "⓭"  // U+24ED: NEGATIVE CIRCLED NUMBER THIRTEEN
      ,"13", // Folded result

       "⒔"  // U+2494: NUMBER THIRTEEN FULL STOP
      ,"13.", // Folded result

       "⒀"  // U+2480: PARENTHESIZED NUMBER THIRTEEN
      ,"(13)", // Folded result

       "⑭"  // U+246D: CIRCLED NUMBER FOURTEEN
       + "⓮"  // U+24EE: NEGATIVE CIRCLED NUMBER FOURTEEN
      ,"14", // Folded result

       "⒕"  // U+2495: NUMBER FOURTEEN FULL STOP
      ,"14.", // Folded result

       "⒁"  // U+2481: PARENTHESIZED NUMBER FOURTEEN
      ,"(14)", // Folded result

       "⑮"  // U+246E: CIRCLED NUMBER FIFTEEN
       + "⓯"  // U+24EF: NEGATIVE CIRCLED NUMBER FIFTEEN
      ,"15", // Folded result

       "⒖"  // U+2496: NUMBER FIFTEEN FULL STOP
      ,"15.", // Folded result

       "⒂"  // U+2482: PARENTHESIZED NUMBER FIFTEEN
      ,"(15)", // Folded result

       "⑯"  // U+246F: CIRCLED NUMBER SIXTEEN
       + "⓰"  // U+24F0: NEGATIVE CIRCLED NUMBER SIXTEEN
      ,"16", // Folded result

       "⒗"  // U+2497: NUMBER SIXTEEN FULL STOP
      ,"16.", // Folded result

       "⒃"  // U+2483: PARENTHESIZED NUMBER SIXTEEN
      ,"(16)", // Folded result

       "⑰"  // U+2470: CIRCLED NUMBER SEVENTEEN
       + "⓱"  // U+24F1: NEGATIVE CIRCLED NUMBER SEVENTEEN
      ,"17", // Folded result

       "⒘"  // U+2498: NUMBER SEVENTEEN FULL STOP
      ,"17.", // Folded result

       "⒄"  // U+2484: PARENTHESIZED NUMBER SEVENTEEN
      ,"(17)", // Folded result

       "⑱"  // U+2471: CIRCLED NUMBER EIGHTEEN
       + "⓲"  // U+24F2: NEGATIVE CIRCLED NUMBER EIGHTEEN
      ,"18", // Folded result

       "⒙"  // U+2499: NUMBER EIGHTEEN FULL STOP
      ,"18.", // Folded result

       "⒅"  // U+2485: PARENTHESIZED NUMBER EIGHTEEN
      ,"(18)", // Folded result

       "⑲"  // U+2472: CIRCLED NUMBER NINETEEN
       + "⓳"  // U+24F3: NEGATIVE CIRCLED NUMBER NINETEEN
      ,"19", // Folded result

       "⒚"  // U+249A: NUMBER NINETEEN FULL STOP
      ,"19.", // Folded result

       "⒆"  // U+2486: PARENTHESIZED NUMBER NINETEEN
      ,"(19)", // Folded result

       "⑳"  // U+2473: CIRCLED NUMBER TWENTY
       + "⓴"  // U+24F4: NEGATIVE CIRCLED NUMBER TWENTY
      ,"20", // Folded result

       "⒛"  // U+249B: NUMBER TWENTY FULL STOP
      ,"20.", // Folded result

       "⒇"  // U+2487: PARENTHESIZED NUMBER TWENTY
      ,"(20)", // Folded result

       "«"  // U+00AB: LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
       + "»"  // U+00BB: RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
       + "“"  // U+201C: LEFT DOUBLE QUOTATION MARK
       + "”"  // U+201D: RIGHT DOUBLE QUOTATION MARK
       + "„"  // U+201E: DOUBLE LOW-9 QUOTATION MARK
       + "″"  // U+2033: DOUBLE PRIME
       + "‶"  // U+2036: REVERSED DOUBLE PRIME
       + "❝"  // U+275D: HEAVY DOUBLE TURNED COMMA QUOTATION MARK ORNAMENT
       + "❞"  // U+275E: HEAVY DOUBLE COMMA QUOTATION MARK ORNAMENT
       + "❮"  // U+276E: HEAVY LEFT-POINTING ANGLE QUOTATION MARK ORNAMENT
       + "❯"  // U+276F: HEAVY RIGHT-POINTING ANGLE QUOTATION MARK ORNAMENT
       + "＂"  // U+FF02: FULLWIDTH QUOTATION MARK
      ,"\"", // Folded result

       "‘"  // U+2018: LEFT SINGLE QUOTATION MARK
       + "’"  // U+2019: RIGHT SINGLE QUOTATION MARK
       + "‚"  // U+201A: SINGLE LOW-9 QUOTATION MARK
       + "‛"  // U+201B: SINGLE HIGH-REVERSED-9 QUOTATION MARK
       + "′"  // U+2032: PRIME
       + "‵"  // U+2035: REVERSED PRIME
       + "‹"  // U+2039: SINGLE LEFT-POINTING ANGLE QUOTATION MARK
       + "›"  // U+203A: SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
       + "❛"  // U+275B: HEAVY SINGLE TURNED COMMA QUOTATION MARK ORNAMENT
       + "❜"  // U+275C: HEAVY SINGLE COMMA QUOTATION MARK ORNAMENT
       + "＇"  // U+FF07: FULLWIDTH APOSTROPHE
      ,"'", // Folded result

       "‐"  // U+2010: HYPHEN
       + "‑"  // U+2011: NON-BREAKING HYPHEN
       + "‒"  // U+2012: FIGURE DASH
       + "–"  // U+2013: EN DASH
       + "—"  // U+2014: EM DASH
       + "⁻"  // U+207B: SUPERSCRIPT MINUS
       + "₋"  // U+208B: SUBSCRIPT MINUS
       + "－"  // U+FF0D: FULLWIDTH HYPHEN-MINUS
      ,"-", // Folded result

       "⁅"  // U+2045: LEFT SQUARE BRACKET WITH QUILL
       + "❲"  // U+2772: LIGHT LEFT TORTOISE SHELL BRACKET ORNAMENT
       + "［"  // U+FF3B: FULLWIDTH LEFT SQUARE BRACKET
      ,"[", // Folded result

       "⁆"  // U+2046: RIGHT SQUARE BRACKET WITH QUILL
       + "❳"  // U+2773: LIGHT RIGHT TORTOISE SHELL BRACKET ORNAMENT
       + "］"  // U+FF3D: FULLWIDTH RIGHT SQUARE BRACKET
      ,"]", // Folded result

       "⁽"  // U+207D: SUPERSCRIPT LEFT PARENTHESIS
       + "₍"  // U+208D: SUBSCRIPT LEFT PARENTHESIS
       + "❨"  // U+2768: MEDIUM LEFT PARENTHESIS ORNAMENT
       + "❪"  // U+276A: MEDIUM FLATTENED LEFT PARENTHESIS ORNAMENT
       + "（"  // U+FF08: FULLWIDTH LEFT PARENTHESIS
      ,"(", // Folded result

       "⸨"  // U+2E28: LEFT DOUBLE PARENTHESIS
      ,"((", // Folded result

       "⁾"  // U+207E: SUPERSCRIPT RIGHT PARENTHESIS
       + "₎"  // U+208E: SUBSCRIPT RIGHT PARENTHESIS
       + "❩"  // U+2769: MEDIUM RIGHT PARENTHESIS ORNAMENT
       + "❫"  // U+276B: MEDIUM FLATTENED RIGHT PARENTHESIS ORNAMENT
       + "）"  // U+FF09: FULLWIDTH RIGHT PARENTHESIS
      ,")", // Folded result

       "⸩"  // U+2E29: RIGHT DOUBLE PARENTHESIS
      ,"))", // Folded result

       "❬"  // U+276C: MEDIUM LEFT-POINTING ANGLE BRACKET ORNAMENT
       + "❰"  // U+2770: HEAVY LEFT-POINTING ANGLE BRACKET ORNAMENT
       + "＜"  // U+FF1C: FULLWIDTH LESS-THAN SIGN
      ,"<", // Folded result

       "❭"  // U+276D: MEDIUM RIGHT-POINTING ANGLE BRACKET ORNAMENT
       + "❱"  // U+2771: HEAVY RIGHT-POINTING ANGLE BRACKET ORNAMENT
       + "＞"  // U+FF1E: FULLWIDTH GREATER-THAN SIGN
      ,">", // Folded result

       "❴"  // U+2774: MEDIUM LEFT CURLY BRACKET ORNAMENT
       + "｛"  // U+FF5B: FULLWIDTH LEFT CURLY BRACKET
      ,"{", // Folded result

       "❵"  // U+2775: MEDIUM RIGHT CURLY BRACKET ORNAMENT
       + "｝"  // U+FF5D: FULLWIDTH RIGHT CURLY BRACKET
      ,"}", // Folded result

       "⁺"  // U+207A: SUPERSCRIPT PLUS SIGN
       + "₊"  // U+208A: SUBSCRIPT PLUS SIGN
       + "＋"  // U+FF0B: FULLWIDTH PLUS SIGN
      ,"+", // Folded result

       "⁼"  // U+207C: SUPERSCRIPT EQUALS SIGN
       + "₌"  // U+208C: SUBSCRIPT EQUALS SIGN
       + "＝"  // U+FF1D: FULLWIDTH EQUALS SIGN
      ,"=", // Folded result

       "！"  // U+FF01: FULLWIDTH EXCLAMATION MARK
      ,"!", // Folded result

       "‼"  // U+203C: DOUBLE EXCLAMATION MARK
      ,"!!", // Folded result

       "⁉"  // U+2049: EXCLAMATION QUESTION MARK
      ,"!?", // Folded result

       "＃"  // U+FF03: FULLWIDTH NUMBER SIGN
      ,"#", // Folded result

       "＄"  // U+FF04: FULLWIDTH DOLLAR SIGN
      ,"$", // Folded result

       "⁒"  // U+2052: COMMERCIAL MINUS SIGN
       + "％"  // U+FF05: FULLWIDTH PERCENT SIGN
      ,"%", // Folded result

       "＆"  // U+FF06: FULLWIDTH AMPERSAND
      ,"&", // Folded result

       "⁎"  // U+204E: LOW ASTERISK
       + "＊"  // U+FF0A: FULLWIDTH ASTERISK
      ,"*", // Folded result

       "，"  // U+FF0C: FULLWIDTH COMMA
      ,",", // Folded result

       "．"  // U+FF0E: FULLWIDTH FULL STOP
      ,".", // Folded result

       "⁄"  // U+2044: FRACTION SLASH
       + "／"  // U+FF0F: FULLWIDTH SOLIDUS
      ,"/", // Folded result

       "："  // U+FF1A: FULLWIDTH COLON
      ,":", // Folded result

       "⁏"  // U+204F: REVERSED SEMICOLON
       + "；"  // U+FF1B: FULLWIDTH SEMICOLON
      ,";", // Folded result

       "？"  // U+FF1F: FULLWIDTH QUESTION MARK
      ,"?", // Folded result

       "⁇"  // U+2047: DOUBLE QUESTION MARK
      ,"??", // Folded result

       "⁈"  // U+2048: QUESTION EXCLAMATION MARK
      ,"?!", // Folded result

       "＠"  // U+FF20: FULLWIDTH COMMERCIAL AT
      ,"@", // Folded result

       "＼"  // U+FF3C: FULLWIDTH REVERSE SOLIDUS
      ,"\\", // Folded result

       "‸"  // U+2038: CARET
       + "＾"  // U+FF3E: FULLWIDTH CIRCUMFLEX ACCENT
      ,"^", // Folded result

       "＿"  // U+FF3F: FULLWIDTH LOW LINE
      ,"_", // Folded result

       "⁓"  // U+2053: SWUNG DASH
       + "～"  // U+FF5E: FULLWIDTH TILDE
      ,"~", // Folded result
    };

    // Construct input text and expected output tokens
    List<String> expectedOutputTokens = new ArrayList<String>();
    StringBuilder inputText = new StringBuilder();
    for (int n = 0 ; n < foldings.length ; n += 2) {
      if (n > 0) {
        inputText.append(' ');  // Space between tokens
      }
      inputText.append(foldings[n]);

      // Construct the expected output token: the ASCII string to fold to,
      // duplicated as many times as the number of characters in the input text.
      StringBuilder expected = new StringBuilder();
      int numChars = foldings[n].length();
      for (int m = 0 ; m < numChars; ++m) {
        expected.append(foldings[n + 1]);
      }
      expectedOutputTokens.add(expected.toString());
    }

    TokenStream stream = new WhitespaceTokenizer(TEST_VERSION_CURRENT, new StringReader(inputText.toString()));
    ASCIIFoldingFilter filter = new ASCIIFoldingFilter(stream);
    CharTermAttribute termAtt = filter.getAttribute(CharTermAttribute.class);
    Iterator<String> expectedIter = expectedOutputTokens.iterator();
    while (expectedIter.hasNext()) {
      assertTermEquals(expectedIter.next(), filter, termAtt);
    }
    assertFalse(filter.incrementToken());
  }
,
(startLine=165 endLine=1900 srcPath=/home/sonia/NewExperiment/luceneFilter/00676/lucene/backwards/src/test/org/apache/lucene/analysis/TestASCIIFoldingFilter.java)
  public void testAllFoldings() throws Exception {
    // Alternating strings of:
    //   1. All non-ASCII characters to be folded, concatenated together as a
    //      single string.
    //   2. The string of ASCII characters to which each of the above
    //      characters should be folded.
    String[] foldings = {
      "À"  // U+00C0: LATIN CAPITAL LETTER A WITH GRAVE
      + "Á"  // U+00C1: LATIN CAPITAL LETTER A WITH ACUTE
      + "Â"  // U+00C2: LATIN CAPITAL LETTER A WITH CIRCUMFLEX
      + "Ã"  // U+00C3: LATIN CAPITAL LETTER A WITH TILDE
      + "Ä"  // U+00C4: LATIN CAPITAL LETTER A WITH DIAERESIS
      + "Å"  // U+00C5: LATIN CAPITAL LETTER A WITH RING ABOVE
      + "Ā"  // U+0100: LATIN CAPITAL LETTER A WITH MACRON
      + "Ă"  // U+0102: LATIN CAPITAL LETTER A WITH BREVE
      + "Ą"  // U+0104: LATIN CAPITAL LETTER A WITH OGONEK
      + "Ə"  // U+018F: LATIN CAPITAL LETTER SCHWA
      + "Ǎ"  // U+01CD: LATIN CAPITAL LETTER A WITH CARON
      + "Ǟ"  // U+01DE: LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON
      + "Ǡ"  // U+01E0: LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON
      + "Ǻ"  // U+01FA: LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE
      + "Ȁ"  // U+0200: LATIN CAPITAL LETTER A WITH DOUBLE GRAVE
      + "Ȃ"  // U+0202: LATIN CAPITAL LETTER A WITH INVERTED BREVE
      + "Ȧ"  // U+0226: LATIN CAPITAL LETTER A WITH DOT ABOVE
      + "Ⱥ"  // U+023A: LATIN CAPITAL LETTER A WITH STROKE
      + "ᴀ"  // U+1D00: LATIN LETTER SMALL CAPITAL A
      + "Ḁ"  // U+1E00: LATIN CAPITAL LETTER A WITH RING BELOW
      + "Ạ"  // U+1EA0: LATIN CAPITAL LETTER A WITH DOT BELOW
      + "Ả"  // U+1EA2: LATIN CAPITAL LETTER A WITH HOOK ABOVE
      + "Ấ"  // U+1EA4: LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE
      + "Ầ"  // U+1EA6: LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE
      + "Ẩ"  // U+1EA8: LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
      + "Ẫ"  // U+1EAA: LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE
      + "Ậ"  // U+1EAC: LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW
      + "Ắ"  // U+1EAE: LATIN CAPITAL LETTER A WITH BREVE AND ACUTE
      + "Ằ"  // U+1EB0: LATIN CAPITAL LETTER A WITH BREVE AND GRAVE
      + "Ẳ"  // U+1EB2: LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE
      + "Ẵ"  // U+1EB4: LATIN CAPITAL LETTER A WITH BREVE AND TILDE
      + "Ặ"  // U+1EB6: LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW
      + "Ⓐ"  // U+24B6: CIRCLED LATIN CAPITAL LETTER A
      + "Ａ"  // U+FF21: FULLWIDTH LATIN CAPITAL LETTER A
      ,"A", // Folded result

       "à"  // U+00E0: LATIN SMALL LETTER A WITH GRAVE
       + "á"  // U+00E1: LATIN SMALL LETTER A WITH ACUTE
       + "â"  // U+00E2: LATIN SMALL LETTER A WITH CIRCUMFLEX
       + "ã"  // U+00E3: LATIN SMALL LETTER A WITH TILDE
       + "ä"  // U+00E4: LATIN SMALL LETTER A WITH DIAERESIS
       + "å"  // U+00E5: LATIN SMALL LETTER A WITH RING ABOVE
       + "ā"  // U+0101: LATIN SMALL LETTER A WITH MACRON
       + "ă"  // U+0103: LATIN SMALL LETTER A WITH BREVE
       + "ą"  // U+0105: LATIN SMALL LETTER A WITH OGONEK
       + "ǎ"  // U+01CE: LATIN SMALL LETTER A WITH CARON
       + "ǟ"  // U+01DF: LATIN SMALL LETTER A WITH DIAERESIS AND MACRON
       + "ǡ"  // U+01E1: LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON
       + "ǻ"  // U+01FB: LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE
       + "ȁ"  // U+0201: LATIN SMALL LETTER A WITH DOUBLE GRAVE
       + "ȃ"  // U+0203: LATIN SMALL LETTER A WITH INVERTED BREVE
       + "ȧ"  // U+0227: LATIN SMALL LETTER A WITH DOT ABOVE
       + "ɐ"  // U+0250: LATIN SMALL LETTER TURNED A
       + "ə"  // U+0259: LATIN SMALL LETTER SCHWA
       + "ɚ"  // U+025A: LATIN SMALL LETTER SCHWA WITH HOOK
       + "ᶏ"  // U+1D8F: LATIN SMALL LETTER A WITH RETROFLEX HOOK
       + "ḁ"  // U+1E01: LATIN SMALL LETTER A WITH RING BELOW
       + "ᶕ"  // U+1D95: LATIN SMALL LETTER SCHWA WITH RETROFLEX HOOK
       + "ẚ"  // U+1E9A: LATIN SMALL LETTER A WITH RIGHT HALF RING
       + "ạ"  // U+1EA1: LATIN SMALL LETTER A WITH DOT BELOW
       + "ả"  // U+1EA3: LATIN SMALL LETTER A WITH HOOK ABOVE
       + "ấ"  // U+1EA5: LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE
       + "ầ"  // U+1EA7: LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE
       + "ẩ"  // U+1EA9: LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE
       + "ẫ"  // U+1EAB: LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE
       + "ậ"  // U+1EAD: LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW
       + "ắ"  // U+1EAF: LATIN SMALL LETTER A WITH BREVE AND ACUTE
       + "ằ"  // U+1EB1: LATIN SMALL LETTER A WITH BREVE AND GRAVE
       + "ẳ"  // U+1EB3: LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE
       + "ẵ"  // U+1EB5: LATIN SMALL LETTER A WITH BREVE AND TILDE
       + "ặ"  // U+1EB7: LATIN SMALL LETTER A WITH BREVE AND DOT BELOW
       + "ₐ"  // U+2090: LATIN SUBSCRIPT SMALL LETTER A
       + "ₔ"  // U+2094: LATIN SUBSCRIPT SMALL LETTER SCHWA
       + "ⓐ"  // U+24D0: CIRCLED LATIN SMALL LETTER A
       + "ⱥ"  // U+2C65: LATIN SMALL LETTER A WITH STROKE
       + "Ɐ"  // U+2C6F: LATIN CAPITAL LETTER TURNED A
       + "ａ"  // U+FF41: FULLWIDTH LATIN SMALL LETTER A
      ,"a", // Folded result

       "Ꜳ"  // U+A732: LATIN CAPITAL LETTER AA
      ,"AA", // Folded result

       "Æ"  // U+00C6: LATIN CAPITAL LETTER AE
       + "Ǣ"  // U+01E2: LATIN CAPITAL LETTER AE WITH MACRON
       + "Ǽ"  // U+01FC: LATIN CAPITAL LETTER AE WITH ACUTE
       + "ᴁ"  // U+1D01: LATIN LETTER SMALL CAPITAL AE
      ,"AE", // Folded result

       "Ꜵ"  // U+A734: LATIN CAPITAL LETTER AO
      ,"AO", // Folded result

       "Ꜷ"  // U+A736: LATIN CAPITAL LETTER AU
      ,"AU", // Folded result

       "Ꜹ"  // U+A738: LATIN CAPITAL LETTER AV
       + "Ꜻ"  // U+A73A: LATIN CAPITAL LETTER AV WITH HORIZONTAL BAR
      ,"AV", // Folded result

       "Ꜽ"  // U+A73C: LATIN CAPITAL LETTER AY
      ,"AY", // Folded result

       "⒜"  // U+249C: PARENTHESIZED LATIN SMALL LETTER A
      ,"(a)", // Folded result

       "ꜳ"  // U+A733: LATIN SMALL LETTER AA
      ,"aa", // Folded result

       "æ"  // U+00E6: LATIN SMALL LETTER AE
       + "ǣ"  // U+01E3: LATIN SMALL LETTER AE WITH MACRON
       + "ǽ"  // U+01FD: LATIN SMALL LETTER AE WITH ACUTE
       + "ᴂ"  // U+1D02: LATIN SMALL LETTER TURNED AE
      ,"ae", // Folded result

       "ꜵ"  // U+A735: LATIN SMALL LETTER AO
      ,"ao", // Folded result

       "ꜷ"  // U+A737: LATIN SMALL LETTER AU
      ,"au", // Folded result

       "ꜹ"  // U+A739: LATIN SMALL LETTER AV
       + "ꜻ"  // U+A73B: LATIN SMALL LETTER AV WITH HORIZONTAL BAR
      ,"av", // Folded result

       "ꜽ"  // U+A73D: LATIN SMALL LETTER AY
      ,"ay", // Folded result

       "Ɓ"  // U+0181: LATIN CAPITAL LETTER B WITH HOOK
       + "Ƃ"  // U+0182: LATIN CAPITAL LETTER B WITH TOPBAR
       + "Ƀ"  // U+0243: LATIN CAPITAL LETTER B WITH STROKE
       + "ʙ"  // U+0299: LATIN LETTER SMALL CAPITAL B
       + "ᴃ"  // U+1D03: LATIN LETTER SMALL CAPITAL BARRED B
       + "Ḃ"  // U+1E02: LATIN CAPITAL LETTER B WITH DOT ABOVE
       + "Ḅ"  // U+1E04: LATIN CAPITAL LETTER B WITH DOT BELOW
       + "Ḇ"  // U+1E06: LATIN CAPITAL LETTER B WITH LINE BELOW
       + "Ⓑ"  // U+24B7: CIRCLED LATIN CAPITAL LETTER B
       + "Ｂ"  // U+FF22: FULLWIDTH LATIN CAPITAL LETTER B
      ,"B", // Folded result

       "ƀ"  // U+0180: LATIN SMALL LETTER B WITH STROKE
       + "ƃ"  // U+0183: LATIN SMALL LETTER B WITH TOPBAR
       + "ɓ"  // U+0253: LATIN SMALL LETTER B WITH HOOK
       + "ᵬ"  // U+1D6C: LATIN SMALL LETTER B WITH MIDDLE TILDE
       + "ᶀ"  // U+1D80: LATIN SMALL LETTER B WITH PALATAL HOOK
       + "ḃ"  // U+1E03: LATIN SMALL LETTER B WITH DOT ABOVE
       + "ḅ"  // U+1E05: LATIN SMALL LETTER B WITH DOT BELOW
       + "ḇ"  // U+1E07: LATIN SMALL LETTER B WITH LINE BELOW
       + "ⓑ"  // U+24D1: CIRCLED LATIN SMALL LETTER B
       + "ｂ"  // U+FF42: FULLWIDTH LATIN SMALL LETTER B
      ,"b", // Folded result

       "⒝"  // U+249D: PARENTHESIZED LATIN SMALL LETTER B
      ,"(b)", // Folded result

       "Ç"  // U+00C7: LATIN CAPITAL LETTER C WITH CEDILLA
       + "Ć"  // U+0106: LATIN CAPITAL LETTER C WITH ACUTE
       + "Ĉ"  // U+0108: LATIN CAPITAL LETTER C WITH CIRCUMFLEX
       + "Ċ"  // U+010A: LATIN CAPITAL LETTER C WITH DOT ABOVE
       + "Č"  // U+010C: LATIN CAPITAL LETTER C WITH CARON
       + "Ƈ"  // U+0187: LATIN CAPITAL LETTER C WITH HOOK
       + "Ȼ"  // U+023B: LATIN CAPITAL LETTER C WITH STROKE
       + "ʗ"  // U+0297: LATIN LETTER STRETCHED C
       + "ᴄ"  // U+1D04: LATIN LETTER SMALL CAPITAL C
       + "Ḉ"  // U+1E08: LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE
       + "Ⓒ"  // U+24B8: CIRCLED LATIN CAPITAL LETTER C
       + "Ｃ"  // U+FF23: FULLWIDTH LATIN CAPITAL LETTER C
      ,"C", // Folded result

       "ç"  // U+00E7: LATIN SMALL LETTER C WITH CEDILLA
       + "ć"  // U+0107: LATIN SMALL LETTER C WITH ACUTE
       + "ĉ"  // U+0109: LATIN SMALL LETTER C WITH CIRCUMFLEX
       + "ċ"  // U+010B: LATIN SMALL LETTER C WITH DOT ABOVE
       + "č"  // U+010D: LATIN SMALL LETTER C WITH CARON
       + "ƈ"  // U+0188: LATIN SMALL LETTER C WITH HOOK
       + "ȼ"  // U+023C: LATIN SMALL LETTER C WITH STROKE
       + "ɕ"  // U+0255: LATIN SMALL LETTER C WITH CURL
       + "ḉ"  // U+1E09: LATIN SMALL LETTER C WITH CEDILLA AND ACUTE
       + "ↄ"  // U+2184: LATIN SMALL LETTER REVERSED C
       + "ⓒ"  // U+24D2: CIRCLED LATIN SMALL LETTER C
       + "Ꜿ"  // U+A73E: LATIN CAPITAL LETTER REVERSED C WITH DOT
       + "ꜿ"  // U+A73F: LATIN SMALL LETTER REVERSED C WITH DOT
       + "ｃ"  // U+FF43: FULLWIDTH LATIN SMALL LETTER C
      ,"c", // Folded result

       "⒞"  // U+249E: PARENTHESIZED LATIN SMALL LETTER C
      ,"(c)", // Folded result

       "Ð"  // U+00D0: LATIN CAPITAL LETTER ETH
       + "Ď"  // U+010E: LATIN CAPITAL LETTER D WITH CARON
       + "Đ"  // U+0110: LATIN CAPITAL LETTER D WITH STROKE
       + "Ɖ"  // U+0189: LATIN CAPITAL LETTER AFRICAN D
       + "Ɗ"  // U+018A: LATIN CAPITAL LETTER D WITH HOOK
       + "Ƌ"  // U+018B: LATIN CAPITAL LETTER D WITH TOPBAR
       + "ᴅ"  // U+1D05: LATIN LETTER SMALL CAPITAL D
       + "ᴆ"  // U+1D06: LATIN LETTER SMALL CAPITAL ETH
       + "Ḋ"  // U+1E0A: LATIN CAPITAL LETTER D WITH DOT ABOVE
       + "Ḍ"  // U+1E0C: LATIN CAPITAL LETTER D WITH DOT BELOW
       + "Ḏ"  // U+1E0E: LATIN CAPITAL LETTER D WITH LINE BELOW
       + "Ḑ"  // U+1E10: LATIN CAPITAL LETTER D WITH CEDILLA
       + "Ḓ"  // U+1E12: LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW
       + "Ⓓ"  // U+24B9: CIRCLED LATIN CAPITAL LETTER D
       + "Ꝺ"  // U+A779: LATIN CAPITAL LETTER INSULAR D
       + "Ｄ"  // U+FF24: FULLWIDTH LATIN CAPITAL LETTER D
      ,"D", // Folded result

       "ð"  // U+00F0: LATIN SMALL LETTER ETH
       + "ď"  // U+010F: LATIN SMALL LETTER D WITH CARON
       + "đ"  // U+0111: LATIN SMALL LETTER D WITH STROKE
       + "ƌ"  // U+018C: LATIN SMALL LETTER D WITH TOPBAR
       + "ȡ"  // U+0221: LATIN SMALL LETTER D WITH CURL
       + "ɖ"  // U+0256: LATIN SMALL LETTER D WITH TAIL
       + "ɗ"  // U+0257: LATIN SMALL LETTER D WITH HOOK
       + "ᵭ"  // U+1D6D: LATIN SMALL LETTER D WITH MIDDLE TILDE
       + "ᶁ"  // U+1D81: LATIN SMALL LETTER D WITH PALATAL HOOK
       + "ᶑ"  // U+1D91: LATIN SMALL LETTER D WITH HOOK AND TAIL
       + "ḋ"  // U+1E0B: LATIN SMALL LETTER D WITH DOT ABOVE
       + "ḍ"  // U+1E0D: LATIN SMALL LETTER D WITH DOT BELOW
       + "ḏ"  // U+1E0F: LATIN SMALL LETTER D WITH LINE BELOW
       + "ḑ"  // U+1E11: LATIN SMALL LETTER D WITH CEDILLA
       + "ḓ"  // U+1E13: LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW
       + "ⓓ"  // U+24D3: CIRCLED LATIN SMALL LETTER D
       + "ꝺ"  // U+A77A: LATIN SMALL LETTER INSULAR D
       + "ｄ"  // U+FF44: FULLWIDTH LATIN SMALL LETTER D
      ,"d", // Folded result

       "Ǆ"  // U+01C4: LATIN CAPITAL LETTER DZ WITH CARON
       + "Ǳ"  // U+01F1: LATIN CAPITAL LETTER DZ
      ,"DZ", // Folded result

       "ǅ"  // U+01C5: LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON
       + "ǲ"  // U+01F2: LATIN CAPITAL LETTER D WITH SMALL LETTER Z
      ,"Dz", // Folded result

       "⒟"  // U+249F: PARENTHESIZED LATIN SMALL LETTER D
      ,"(d)", // Folded result

       "ȸ"  // U+0238: LATIN SMALL LETTER DB DIGRAPH
      ,"db", // Folded result

       "ǆ"  // U+01C6: LATIN SMALL LETTER DZ WITH CARON
       + "ǳ"  // U+01F3: LATIN SMALL LETTER DZ
       + "ʣ"  // U+02A3: LATIN SMALL LETTER DZ DIGRAPH
       + "ʥ"  // U+02A5: LATIN SMALL LETTER DZ DIGRAPH WITH CURL
      ,"dz", // Folded result

       "È"  // U+00C8: LATIN CAPITAL LETTER E WITH GRAVE
       + "É"  // U+00C9: LATIN CAPITAL LETTER E WITH ACUTE
       + "Ê"  // U+00CA: LATIN CAPITAL LETTER E WITH CIRCUMFLEX
       + "Ë"  // U+00CB: LATIN CAPITAL LETTER E WITH DIAERESIS
       + "Ē"  // U+0112: LATIN CAPITAL LETTER E WITH MACRON
       + "Ĕ"  // U+0114: LATIN CAPITAL LETTER E WITH BREVE
       + "Ė"  // U+0116: LATIN CAPITAL LETTER E WITH DOT ABOVE
       + "Ę"  // U+0118: LATIN CAPITAL LETTER E WITH OGONEK
       + "Ě"  // U+011A: LATIN CAPITAL LETTER E WITH CARON
       + "Ǝ"  // U+018E: LATIN CAPITAL LETTER REVERSED E
       + "Ɛ"  // U+0190: LATIN CAPITAL LETTER OPEN E
       + "Ȅ"  // U+0204: LATIN CAPITAL LETTER E WITH DOUBLE GRAVE
       + "Ȇ"  // U+0206: LATIN CAPITAL LETTER E WITH INVERTED BREVE
       + "Ȩ"  // U+0228: LATIN CAPITAL LETTER E WITH CEDILLA
       + "Ɇ"  // U+0246: LATIN CAPITAL LETTER E WITH STROKE
       + "ᴇ"  // U+1D07: LATIN LETTER SMALL CAPITAL E
       + "Ḕ"  // U+1E14: LATIN CAPITAL LETTER E WITH MACRON AND GRAVE
       + "Ḗ"  // U+1E16: LATIN CAPITAL LETTER E WITH MACRON AND ACUTE
       + "Ḙ"  // U+1E18: LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW
       + "Ḛ"  // U+1E1A: LATIN CAPITAL LETTER E WITH TILDE BELOW
       + "Ḝ"  // U+1E1C: LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE
       + "Ẹ"  // U+1EB8: LATIN CAPITAL LETTER E WITH DOT BELOW
       + "Ẻ"  // U+1EBA: LATIN CAPITAL LETTER E WITH HOOK ABOVE
       + "Ẽ"  // U+1EBC: LATIN CAPITAL LETTER E WITH TILDE
       + "Ế"  // U+1EBE: LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE
       + "Ề"  // U+1EC0: LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE
       + "Ể"  // U+1EC2: LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
       + "Ễ"  // U+1EC4: LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE
       + "Ệ"  // U+1EC6: LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW
       + "Ⓔ"  // U+24BA: CIRCLED LATIN CAPITAL LETTER E
       + "ⱻ"  // U+2C7B: LATIN LETTER SMALL CAPITAL TURNED E
       + "Ｅ"  // U+FF25: FULLWIDTH LATIN CAPITAL LETTER E
      ,"E", // Folded result

       "è"  // U+00E8: LATIN SMALL LETTER E WITH GRAVE
       + "é"  // U+00E9: LATIN SMALL LETTER E WITH ACUTE
       + "ê"  // U+00EA: LATIN SMALL LETTER E WITH CIRCUMFLEX
       + "ë"  // U+00EB: LATIN SMALL LETTER E WITH DIAERESIS
       + "ē"  // U+0113: LATIN SMALL LETTER E WITH MACRON
       + "ĕ"  // U+0115: LATIN SMALL LETTER E WITH BREVE
       + "ė"  // U+0117: LATIN SMALL LETTER E WITH DOT ABOVE
       + "ę"  // U+0119: LATIN SMALL LETTER E WITH OGONEK
       + "ě"  // U+011B: LATIN SMALL LETTER E WITH CARON
       + "ǝ"  // U+01DD: LATIN SMALL LETTER TURNED E
       + "ȅ"  // U+0205: LATIN SMALL LETTER E WITH DOUBLE GRAVE
       + "ȇ"  // U+0207: LATIN SMALL LETTER E WITH INVERTED BREVE
       + "ȩ"  // U+0229: LATIN SMALL LETTER E WITH CEDILLA
       + "ɇ"  // U+0247: LATIN SMALL LETTER E WITH STROKE
       + "ɘ"  // U+0258: LATIN SMALL LETTER REVERSED E
       + "ɛ"  // U+025B: LATIN SMALL LETTER OPEN E
       + "ɜ"  // U+025C: LATIN SMALL LETTER REVERSED OPEN E
       + "ɝ"  // U+025D: LATIN SMALL LETTER REVERSED OPEN E WITH HOOK
       + "ɞ"  // U+025E: LATIN SMALL LETTER CLOSED REVERSED OPEN E
       + "ʚ"  // U+029A: LATIN SMALL LETTER CLOSED OPEN E
       + "ᴈ"  // U+1D08: LATIN SMALL LETTER TURNED OPEN E
       + "ᶒ"  // U+1D92: LATIN SMALL LETTER E WITH RETROFLEX HOOK
       + "ᶓ"  // U+1D93: LATIN SMALL LETTER OPEN E WITH RETROFLEX HOOK
       + "ᶔ"  // U+1D94: LATIN SMALL LETTER REVERSED OPEN E WITH RETROFLEX HOOK
       + "ḕ"  // U+1E15: LATIN SMALL LETTER E WITH MACRON AND GRAVE
       + "ḗ"  // U+1E17: LATIN SMALL LETTER E WITH MACRON AND ACUTE
       + "ḙ"  // U+1E19: LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW
       + "ḛ"  // U+1E1B: LATIN SMALL LETTER E WITH TILDE BELOW
       + "ḝ"  // U+1E1D: LATIN SMALL LETTER E WITH CEDILLA AND BREVE
       + "ẹ"  // U+1EB9: LATIN SMALL LETTER E WITH DOT BELOW
       + "ẻ"  // U+1EBB: LATIN SMALL LETTER E WITH HOOK ABOVE
       + "ẽ"  // U+1EBD: LATIN SMALL LETTER E WITH TILDE
       + "ế"  // U+1EBF: LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE
       + "ề"  // U+1EC1: LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE
       + "ể"  // U+1EC3: LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE
       + "ễ"  // U+1EC5: LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE
       + "ệ"  // U+1EC7: LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW
       + "ₑ"  // U+2091: LATIN SUBSCRIPT SMALL LETTER E
       + "ⓔ"  // U+24D4: CIRCLED LATIN SMALL LETTER E
       + "ⱸ"  // U+2C78: LATIN SMALL LETTER E WITH NOTCH
       + "ｅ"  // U+FF45: FULLWIDTH LATIN SMALL LETTER E
      ,"e", // Folded result

       "⒠"  // U+24A0: PARENTHESIZED LATIN SMALL LETTER E
      ,"(e)", // Folded result

       "Ƒ"  // U+0191: LATIN CAPITAL LETTER F WITH HOOK
       + "Ḟ"  // U+1E1E: LATIN CAPITAL LETTER F WITH DOT ABOVE
       + "Ⓕ"  // U+24BB: CIRCLED LATIN CAPITAL LETTER F
       + "ꜰ"  // U+A730: LATIN LETTER SMALL CAPITAL F
       + "Ꝼ"  // U+A77B: LATIN CAPITAL LETTER INSULAR F
       + "ꟻ"  // U+A7FB: LATIN EPIGRAPHIC LETTER REVERSED F
       + "Ｆ"  // U+FF26: FULLWIDTH LATIN CAPITAL LETTER F
      ,"F", // Folded result

       "ƒ"  // U+0192: LATIN SMALL LETTER F WITH HOOK
       + "ᵮ"  // U+1D6E: LATIN SMALL LETTER F WITH MIDDLE TILDE
       + "ᶂ"  // U+1D82: LATIN SMALL LETTER F WITH PALATAL HOOK
       + "ḟ"  // U+1E1F: LATIN SMALL LETTER F WITH DOT ABOVE
       + "ẛ"  // U+1E9B: LATIN SMALL LETTER LONG S WITH DOT ABOVE
       + "ⓕ"  // U+24D5: CIRCLED LATIN SMALL LETTER F
       + "ꝼ"  // U+A77C: LATIN SMALL LETTER INSULAR F
       + "ｆ"  // U+FF46: FULLWIDTH LATIN SMALL LETTER F
      ,"f", // Folded result

       "⒡"  // U+24A1: PARENTHESIZED LATIN SMALL LETTER F
      ,"(f)", // Folded result

       "ﬀ"  // U+FB00: LATIN SMALL LIGATURE FF
      ,"ff", // Folded result

       "ﬃ"  // U+FB03: LATIN SMALL LIGATURE FFI
      ,"ffi", // Folded result

       "ﬄ"  // U+FB04: LATIN SMALL LIGATURE FFL
      ,"ffl", // Folded result

       "ﬁ"  // U+FB01: LATIN SMALL LIGATURE FI
      ,"fi", // Folded result

       "ﬂ"  // U+FB02: LATIN SMALL LIGATURE FL
      ,"fl", // Folded result

       "Ĝ"  // U+011C: LATIN CAPITAL LETTER G WITH CIRCUMFLEX
       + "Ğ"  // U+011E: LATIN CAPITAL LETTER G WITH BREVE
       + "Ġ"  // U+0120: LATIN CAPITAL LETTER G WITH DOT ABOVE
       + "Ģ"  // U+0122: LATIN CAPITAL LETTER G WITH CEDILLA
       + "Ɠ"  // U+0193: LATIN CAPITAL LETTER G WITH HOOK
       + "Ǥ"  // U+01E4: LATIN CAPITAL LETTER G WITH STROKE
       + "ǥ"  // U+01E5: LATIN SMALL LETTER G WITH STROKE
       + "Ǧ"  // U+01E6: LATIN CAPITAL LETTER G WITH CARON
       + "ǧ"  // U+01E7: LATIN SMALL LETTER G WITH CARON
       + "Ǵ"  // U+01F4: LATIN CAPITAL LETTER G WITH ACUTE
       + "ɢ"  // U+0262: LATIN LETTER SMALL CAPITAL G
       + "ʛ"  // U+029B: LATIN LETTER SMALL CAPITAL G WITH HOOK
       + "Ḡ"  // U+1E20: LATIN CAPITAL LETTER G WITH MACRON
       + "Ⓖ"  // U+24BC: CIRCLED LATIN CAPITAL LETTER G
       + "Ᵹ"  // U+A77D: LATIN CAPITAL LETTER INSULAR G
       + "Ꝿ"  // U+A77E: LATIN CAPITAL LETTER TURNED INSULAR G
       + "Ｇ"  // U+FF27: FULLWIDTH LATIN CAPITAL LETTER G
      ,"G", // Folded result

       "ĝ"  // U+011D: LATIN SMALL LETTER G WITH CIRCUMFLEX
       + "ğ"  // U+011F: LATIN SMALL LETTER G WITH BREVE
       + "ġ"  // U+0121: LATIN SMALL LETTER G WITH DOT ABOVE
       + "ģ"  // U+0123: LATIN SMALL LETTER G WITH CEDILLA
       + "ǵ"  // U+01F5: LATIN SMALL LETTER G WITH ACUTE
       + "ɠ"  // U+0260: LATIN SMALL LETTER G WITH HOOK
       + "ɡ"  // U+0261: LATIN SMALL LETTER SCRIPT G
       + "ᵷ"  // U+1D77: LATIN SMALL LETTER TURNED G
       + "ᵹ"  // U+1D79: LATIN SMALL LETTER INSULAR G
       + "ᶃ"  // U+1D83: LATIN SMALL LETTER G WITH PALATAL HOOK
       + "ḡ"  // U+1E21: LATIN SMALL LETTER G WITH MACRON
       + "ⓖ"  // U+24D6: CIRCLED LATIN SMALL LETTER G
       + "ꝿ"  // U+A77F: LATIN SMALL LETTER TURNED INSULAR G
       + "ｇ"  // U+FF47: FULLWIDTH LATIN SMALL LETTER G
      ,"g", // Folded result

       "⒢"  // U+24A2: PARENTHESIZED LATIN SMALL LETTER G
      ,"(g)", // Folded result

       "Ĥ"  // U+0124: LATIN CAPITAL LETTER H WITH CIRCUMFLEX
       + "Ħ"  // U+0126: LATIN CAPITAL LETTER H WITH STROKE
       + "Ȟ"  // U+021E: LATIN CAPITAL LETTER H WITH CARON
       + "ʜ"  // U+029C: LATIN LETTER SMALL CAPITAL H
       + "Ḣ"  // U+1E22: LATIN CAPITAL LETTER H WITH DOT ABOVE
       + "Ḥ"  // U+1E24: LATIN CAPITAL LETTER H WITH DOT BELOW
       + "Ḧ"  // U+1E26: LATIN CAPITAL LETTER H WITH DIAERESIS
       + "Ḩ"  // U+1E28: LATIN CAPITAL LETTER H WITH CEDILLA
       + "Ḫ"  // U+1E2A: LATIN CAPITAL LETTER H WITH BREVE BELOW
       + "Ⓗ"  // U+24BD: CIRCLED LATIN CAPITAL LETTER H
       + "Ⱨ"  // U+2C67: LATIN CAPITAL LETTER H WITH DESCENDER
       + "Ⱶ"  // U+2C75: LATIN CAPITAL LETTER HALF H
       + "Ｈ"  // U+FF28: FULLWIDTH LATIN CAPITAL LETTER H
      ,"H", // Folded result

       "ĥ"  // U+0125: LATIN SMALL LETTER H WITH CIRCUMFLEX
       + "ħ"  // U+0127: LATIN SMALL LETTER H WITH STROKE
       + "ȟ"  // U+021F: LATIN SMALL LETTER H WITH CARON
       + "ɥ"  // U+0265: LATIN SMALL LETTER TURNED H
       + "ɦ"  // U+0266: LATIN SMALL LETTER H WITH HOOK
       + "ʮ"  // U+02AE: LATIN SMALL LETTER TURNED H WITH FISHHOOK
       + "ʯ"  // U+02AF: LATIN SMALL LETTER TURNED H WITH FISHHOOK AND TAIL
       + "ḣ"  // U+1E23: LATIN SMALL LETTER H WITH DOT ABOVE
       + "ḥ"  // U+1E25: LATIN SMALL LETTER H WITH DOT BELOW
       + "ḧ"  // U+1E27: LATIN SMALL LETTER H WITH DIAERESIS
       + "ḩ"  // U+1E29: LATIN SMALL LETTER H WITH CEDILLA
       + "ḫ"  // U+1E2B: LATIN SMALL LETTER H WITH BREVE BELOW
       + "ẖ"  // U+1E96: LATIN SMALL LETTER H WITH LINE BELOW
       + "ⓗ"  // U+24D7: CIRCLED LATIN SMALL LETTER H
       + "ⱨ"  // U+2C68: LATIN SMALL LETTER H WITH DESCENDER
       + "ⱶ"  // U+2C76: LATIN SMALL LETTER HALF H
       + "ｈ"  // U+FF48: FULLWIDTH LATIN SMALL LETTER H
      ,"h", // Folded result

       "Ƕ"  // U+01F6: LATIN CAPITAL LETTER HWAIR
      ,"HV", // Folded result

       "⒣"  // U+24A3: PARENTHESIZED LATIN SMALL LETTER H
      ,"(h)", // Folded result

       "ƕ"  // U+0195: LATIN SMALL LETTER HV
      ,"hv", // Folded result

       "Ì"  // U+00CC: LATIN CAPITAL LETTER I WITH GRAVE
       + "Í"  // U+00CD: LATIN CAPITAL LETTER I WITH ACUTE
       + "Î"  // U+00CE: LATIN CAPITAL LETTER I WITH CIRCUMFLEX
       + "Ï"  // U+00CF: LATIN CAPITAL LETTER I WITH DIAERESIS
       + "Ĩ"  // U+0128: LATIN CAPITAL LETTER I WITH TILDE
       + "Ī"  // U+012A: LATIN CAPITAL LETTER I WITH MACRON
       + "Ĭ"  // U+012C: LATIN CAPITAL LETTER I WITH BREVE
       + "Į"  // U+012E: LATIN CAPITAL LETTER I WITH OGONEK
       + "İ"  // U+0130: LATIN CAPITAL LETTER I WITH DOT ABOVE
       + "Ɩ"  // U+0196: LATIN CAPITAL LETTER IOTA
       + "Ɨ"  // U+0197: LATIN CAPITAL LETTER I WITH STROKE
       + "Ǐ"  // U+01CF: LATIN CAPITAL LETTER I WITH CARON
       + "Ȉ"  // U+0208: LATIN CAPITAL LETTER I WITH DOUBLE GRAVE
       + "Ȋ"  // U+020A: LATIN CAPITAL LETTER I WITH INVERTED BREVE
       + "ɪ"  // U+026A: LATIN LETTER SMALL CAPITAL I
       + "ᵻ"  // U+1D7B: LATIN SMALL CAPITAL LETTER I WITH STROKE
       + "Ḭ"  // U+1E2C: LATIN CAPITAL LETTER I WITH TILDE BELOW
       + "Ḯ"  // U+1E2E: LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE
       + "Ỉ"  // U+1EC8: LATIN CAPITAL LETTER I WITH HOOK ABOVE
       + "Ị"  // U+1ECA: LATIN CAPITAL LETTER I WITH DOT BELOW
       + "Ⓘ"  // U+24BE: CIRCLED LATIN CAPITAL LETTER I
       + "ꟾ"  // U+A7FE: LATIN EPIGRAPHIC LETTER I LONGA
       + "Ｉ"  // U+FF29: FULLWIDTH LATIN CAPITAL LETTER I
      ,"I", // Folded result

       "ì"  // U+00EC: LATIN SMALL LETTER I WITH GRAVE
       + "í"  // U+00ED: LATIN SMALL LETTER I WITH ACUTE
       + "î"  // U+00EE: LATIN SMALL LETTER I WITH CIRCUMFLEX
       + "ï"  // U+00EF: LATIN SMALL LETTER I WITH DIAERESIS
       + "ĩ"  // U+0129: LATIN SMALL LETTER I WITH TILDE
       + "ī"  // U+012B: LATIN SMALL LETTER I WITH MACRON
       + "ĭ"  // U+012D: LATIN SMALL LETTER I WITH BREVE
       + "į"  // U+012F: LATIN SMALL LETTER I WITH OGONEK
       + "ı"  // U+0131: LATIN SMALL LETTER DOTLESS I
       + "ǐ"  // U+01D0: LATIN SMALL LETTER I WITH CARON
       + "ȉ"  // U+0209: LATIN SMALL LETTER I WITH DOUBLE GRAVE
       + "ȋ"  // U+020B: LATIN SMALL LETTER I WITH INVERTED BREVE
       + "ɨ"  // U+0268: LATIN SMALL LETTER I WITH STROKE
       + "ᴉ"  // U+1D09: LATIN SMALL LETTER TURNED I
       + "ᵢ"  // U+1D62: LATIN SUBSCRIPT SMALL LETTER I
       + "ᵼ"  // U+1D7C: LATIN SMALL LETTER IOTA WITH STROKE
       + "ᶖ"  // U+1D96: LATIN SMALL LETTER I WITH RETROFLEX HOOK
       + "ḭ"  // U+1E2D: LATIN SMALL LETTER I WITH TILDE BELOW
       + "ḯ"  // U+1E2F: LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE
       + "ỉ"  // U+1EC9: LATIN SMALL LETTER I WITH HOOK ABOVE
       + "ị"  // U+1ECB: LATIN SMALL LETTER I WITH DOT BELOW
       + "ⁱ"  // U+2071: SUPERSCRIPT LATIN SMALL LETTER I
       + "ⓘ"  // U+24D8: CIRCLED LATIN SMALL LETTER I
       + "ｉ"  // U+FF49: FULLWIDTH LATIN SMALL LETTER I
      ,"i", // Folded result

       "Ĳ"  // U+0132: LATIN CAPITAL LIGATURE IJ
      ,"IJ", // Folded result

       "⒤"  // U+24A4: PARENTHESIZED LATIN SMALL LETTER I
      ,"(i)", // Folded result

       "ĳ"  // U+0133: LATIN SMALL LIGATURE IJ
      ,"ij", // Folded result

       "Ĵ"  // U+0134: LATIN CAPITAL LETTER J WITH CIRCUMFLEX
       + "Ɉ"  // U+0248: LATIN CAPITAL LETTER J WITH STROKE
       + "ᴊ"  // U+1D0A: LATIN LETTER SMALL CAPITAL J
       + "Ⓙ"  // U+24BF: CIRCLED LATIN CAPITAL LETTER J
       + "Ｊ"  // U+FF2A: FULLWIDTH LATIN CAPITAL LETTER J
      ,"J", // Folded result

       "ĵ"  // U+0135: LATIN SMALL LETTER J WITH CIRCUMFLEX
       + "ǰ"  // U+01F0: LATIN SMALL LETTER J WITH CARON
       + "ȷ"  // U+0237: LATIN SMALL LETTER DOTLESS J
       + "ɉ"  // U+0249: LATIN SMALL LETTER J WITH STROKE
       + "ɟ"  // U+025F: LATIN SMALL LETTER DOTLESS J WITH STROKE
       + "ʄ"  // U+0284: LATIN SMALL LETTER DOTLESS J WITH STROKE AND HOOK
       + "ʝ"  // U+029D: LATIN SMALL LETTER J WITH CROSSED-TAIL
       + "ⓙ"  // U+24D9: CIRCLED LATIN SMALL LETTER J
       + "ⱼ"  // U+2C7C: LATIN SUBSCRIPT SMALL LETTER J
       + "ｊ"  // U+FF4A: FULLWIDTH LATIN SMALL LETTER J
      ,"j", // Folded result

       "⒥"  // U+24A5: PARENTHESIZED LATIN SMALL LETTER J
      ,"(j)", // Folded result

       "Ķ"  // U+0136: LATIN CAPITAL LETTER K WITH CEDILLA
       + "Ƙ"  // U+0198: LATIN CAPITAL LETTER K WITH HOOK
       + "Ǩ"  // U+01E8: LATIN CAPITAL LETTER K WITH CARON
       + "ᴋ"  // U+1D0B: LATIN LETTER SMALL CAPITAL K
       + "Ḱ"  // U+1E30: LATIN CAPITAL LETTER K WITH ACUTE
       + "Ḳ"  // U+1E32: LATIN CAPITAL LETTER K WITH DOT BELOW
       + "Ḵ"  // U+1E34: LATIN CAPITAL LETTER K WITH LINE BELOW
       + "Ⓚ"  // U+24C0: CIRCLED LATIN CAPITAL LETTER K
       + "Ⱪ"  // U+2C69: LATIN CAPITAL LETTER K WITH DESCENDER
       + "Ꝁ"  // U+A740: LATIN CAPITAL LETTER K WITH STROKE
       + "Ꝃ"  // U+A742: LATIN CAPITAL LETTER K WITH DIAGONAL STROKE
       + "Ꝅ"  // U+A744: LATIN CAPITAL LETTER K WITH STROKE AND DIAGONAL STROKE
       + "Ｋ"  // U+FF2B: FULLWIDTH LATIN CAPITAL LETTER K
      ,"K", // Folded result

       "ķ"  // U+0137: LATIN SMALL LETTER K WITH CEDILLA
       + "ƙ"  // U+0199: LATIN SMALL LETTER K WITH HOOK
       + "ǩ"  // U+01E9: LATIN SMALL LETTER K WITH CARON
       + "ʞ"  // U+029E: LATIN SMALL LETTER TURNED K
       + "ᶄ"  // U+1D84: LATIN SMALL LETTER K WITH PALATAL HOOK
       + "ḱ"  // U+1E31: LATIN SMALL LETTER K WITH ACUTE
       + "ḳ"  // U+1E33: LATIN SMALL LETTER K WITH DOT BELOW
       + "ḵ"  // U+1E35: LATIN SMALL LETTER K WITH LINE BELOW
       + "ⓚ"  // U+24DA: CIRCLED LATIN SMALL LETTER K
       + "ⱪ"  // U+2C6A: LATIN SMALL LETTER K WITH DESCENDER
       + "ꝁ"  // U+A741: LATIN SMALL LETTER K WITH STROKE
       + "ꝃ"  // U+A743: LATIN SMALL LETTER K WITH DIAGONAL STROKE
       + "ꝅ"  // U+A745: LATIN SMALL LETTER K WITH STROKE AND DIAGONAL STROKE
       + "ｋ"  // U+FF4B: FULLWIDTH LATIN SMALL LETTER K
      ,"k", // Folded result

       "⒦"  // U+24A6: PARENTHESIZED LATIN SMALL LETTER K
      ,"(k)", // Folded result

       "Ĺ"  // U+0139: LATIN CAPITAL LETTER L WITH ACUTE
       + "Ļ"  // U+013B: LATIN CAPITAL LETTER L WITH CEDILLA
       + "Ľ"  // U+013D: LATIN CAPITAL LETTER L WITH CARON
       + "Ŀ"  // U+013F: LATIN CAPITAL LETTER L WITH MIDDLE DOT
       + "Ł"  // U+0141: LATIN CAPITAL LETTER L WITH STROKE
       + "Ƚ"  // U+023D: LATIN CAPITAL LETTER L WITH BAR
       + "ʟ"  // U+029F: LATIN LETTER SMALL CAPITAL L
       + "ᴌ"  // U+1D0C: LATIN LETTER SMALL CAPITAL L WITH STROKE
       + "Ḷ"  // U+1E36: LATIN CAPITAL LETTER L WITH DOT BELOW
       + "Ḹ"  // U+1E38: LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON
       + "Ḻ"  // U+1E3A: LATIN CAPITAL LETTER L WITH LINE BELOW
       + "Ḽ"  // U+1E3C: LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW
       + "Ⓛ"  // U+24C1: CIRCLED LATIN CAPITAL LETTER L
       + "Ⱡ"  // U+2C60: LATIN CAPITAL LETTER L WITH DOUBLE BAR
       + "Ɫ"  // U+2C62: LATIN CAPITAL LETTER L WITH MIDDLE TILDE
       + "Ꝇ"  // U+A746: LATIN CAPITAL LETTER BROKEN L
       + "Ꝉ"  // U+A748: LATIN CAPITAL LETTER L WITH HIGH STROKE
       + "Ꞁ"  // U+A780: LATIN CAPITAL LETTER TURNED L
       + "Ｌ"  // U+FF2C: FULLWIDTH LATIN CAPITAL LETTER L
      ,"L", // Folded result

       "ĺ"  // U+013A: LATIN SMALL LETTER L WITH ACUTE
       + "ļ"  // U+013C: LATIN SMALL LETTER L WITH CEDILLA
       + "ľ"  // U+013E: LATIN SMALL LETTER L WITH CARON
       + "ŀ"  // U+0140: LATIN SMALL LETTER L WITH MIDDLE DOT
       + "ł"  // U+0142: LATIN SMALL LETTER L WITH STROKE
       + "ƚ"  // U+019A: LATIN SMALL LETTER L WITH BAR
       + "ȴ"  // U+0234: LATIN SMALL LETTER L WITH CURL
       + "ɫ"  // U+026B: LATIN SMALL LETTER L WITH MIDDLE TILDE
       + "ɬ"  // U+026C: LATIN SMALL LETTER L WITH BELT
       + "ɭ"  // U+026D: LATIN SMALL LETTER L WITH RETROFLEX HOOK
       + "ᶅ"  // U+1D85: LATIN SMALL LETTER L WITH PALATAL HOOK
       + "ḷ"  // U+1E37: LATIN SMALL LETTER L WITH DOT BELOW
       + "ḹ"  // U+1E39: LATIN SMALL LETTER L WITH DOT BELOW AND MACRON
       + "ḻ"  // U+1E3B: LATIN SMALL LETTER L WITH LINE BELOW
       + "ḽ"  // U+1E3D: LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW
       + "ⓛ"  // U+24DB: CIRCLED LATIN SMALL LETTER L
       + "ⱡ"  // U+2C61: LATIN SMALL LETTER L WITH DOUBLE BAR
       + "ꝇ"  // U+A747: LATIN SMALL LETTER BROKEN L
       + "ꝉ"  // U+A749: LATIN SMALL LETTER L WITH HIGH STROKE
       + "ꞁ"  // U+A781: LATIN SMALL LETTER TURNED L
       + "ｌ"  // U+FF4C: FULLWIDTH LATIN SMALL LETTER L
      ,"l", // Folded result

       "Ǉ"  // U+01C7: LATIN CAPITAL LETTER LJ
      ,"LJ", // Folded result

       "Ỻ"  // U+1EFA: LATIN CAPITAL LETTER MIDDLE-WELSH LL
      ,"LL", // Folded result

       "ǈ"  // U+01C8: LATIN CAPITAL LETTER L WITH SMALL LETTER J
      ,"Lj", // Folded result

       "⒧"  // U+24A7: PARENTHESIZED LATIN SMALL LETTER L
      ,"(l)", // Folded result

       "ǉ"  // U+01C9: LATIN SMALL LETTER LJ
      ,"lj", // Folded result

       "ỻ"  // U+1EFB: LATIN SMALL LETTER MIDDLE-WELSH LL
      ,"ll", // Folded result

       "ʪ"  // U+02AA: LATIN SMALL LETTER LS DIGRAPH
      ,"ls", // Folded result

       "ʫ"  // U+02AB: LATIN SMALL LETTER LZ DIGRAPH
      ,"lz", // Folded result

       "Ɯ"  // U+019C: LATIN CAPITAL LETTER TURNED M
       + "ᴍ"  // U+1D0D: LATIN LETTER SMALL CAPITAL M
       + "Ḿ"  // U+1E3E: LATIN CAPITAL LETTER M WITH ACUTE
       + "Ṁ"  // U+1E40: LATIN CAPITAL LETTER M WITH DOT ABOVE
       + "Ṃ"  // U+1E42: LATIN CAPITAL LETTER M WITH DOT BELOW
       + "Ⓜ"  // U+24C2: CIRCLED LATIN CAPITAL LETTER M
       + "Ɱ"  // U+2C6E: LATIN CAPITAL LETTER M WITH HOOK
       + "ꟽ"  // U+A7FD: LATIN EPIGRAPHIC LETTER INVERTED M
       + "ꟿ"  // U+A7FF: LATIN EPIGRAPHIC LETTER ARCHAIC M
       + "Ｍ"  // U+FF2D: FULLWIDTH LATIN CAPITAL LETTER M
      ,"M", // Folded result

       "ɯ"  // U+026F: LATIN SMALL LETTER TURNED M
       + "ɰ"  // U+0270: LATIN SMALL LETTER TURNED M WITH LONG LEG
       + "ɱ"  // U+0271: LATIN SMALL LETTER M WITH HOOK
       + "ᵯ"  // U+1D6F: LATIN SMALL LETTER M WITH MIDDLE TILDE
       + "ᶆ"  // U+1D86: LATIN SMALL LETTER M WITH PALATAL HOOK
       + "ḿ"  // U+1E3F: LATIN SMALL LETTER M WITH ACUTE
       + "ṁ"  // U+1E41: LATIN SMALL LETTER M WITH DOT ABOVE
       + "ṃ"  // U+1E43: LATIN SMALL LETTER M WITH DOT BELOW
       + "ⓜ"  // U+24DC: CIRCLED LATIN SMALL LETTER M
       + "ｍ"  // U+FF4D: FULLWIDTH LATIN SMALL LETTER M
      ,"m", // Folded result

       "⒨"  // U+24A8: PARENTHESIZED LATIN SMALL LETTER M
      ,"(m)", // Folded result

       "Ñ"  // U+00D1: LATIN CAPITAL LETTER N WITH TILDE
       + "Ń"  // U+0143: LATIN CAPITAL LETTER N WITH ACUTE
       + "Ņ"  // U+0145: LATIN CAPITAL LETTER N WITH CEDILLA
       + "Ň"  // U+0147: LATIN CAPITAL LETTER N WITH CARON
       + "Ŋ"  // U+014A: LATIN CAPITAL LETTER ENG
       + "Ɲ"  // U+019D: LATIN CAPITAL LETTER N WITH LEFT HOOK
       + "Ǹ"  // U+01F8: LATIN CAPITAL LETTER N WITH GRAVE
       + "Ƞ"  // U+0220: LATIN CAPITAL LETTER N WITH LONG RIGHT LEG
       + "ɴ"  // U+0274: LATIN LETTER SMALL CAPITAL N
       + "ᴎ"  // U+1D0E: LATIN LETTER SMALL CAPITAL REVERSED N
       + "Ṅ"  // U+1E44: LATIN CAPITAL LETTER N WITH DOT ABOVE
       + "Ṇ"  // U+1E46: LATIN CAPITAL LETTER N WITH DOT BELOW
       + "Ṉ"  // U+1E48: LATIN CAPITAL LETTER N WITH LINE BELOW
       + "Ṋ"  // U+1E4A: LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW
       + "Ⓝ"  // U+24C3: CIRCLED LATIN CAPITAL LETTER N
       + "Ｎ"  // U+FF2E: FULLWIDTH LATIN CAPITAL LETTER N
      ,"N", // Folded result

       "ñ"  // U+00F1: LATIN SMALL LETTER N WITH TILDE
       + "ń"  // U+0144: LATIN SMALL LETTER N WITH ACUTE
       + "ņ"  // U+0146: LATIN SMALL LETTER N WITH CEDILLA
       + "ň"  // U+0148: LATIN SMALL LETTER N WITH CARON
       + "ŉ"  // U+0149: LATIN SMALL LETTER N PRECEDED BY APOSTROPHE
       + "ŋ"  // U+014B: LATIN SMALL LETTER ENG
       + "ƞ"  // U+019E: LATIN SMALL LETTER N WITH LONG RIGHT LEG
       + "ǹ"  // U+01F9: LATIN SMALL LETTER N WITH GRAVE
       + "ȵ"  // U+0235: LATIN SMALL LETTER N WITH CURL
       + "ɲ"  // U+0272: LATIN SMALL LETTER N WITH LEFT HOOK
       + "ɳ"  // U+0273: LATIN SMALL LETTER N WITH RETROFLEX HOOK
       + "ᵰ"  // U+1D70: LATIN SMALL LETTER N WITH MIDDLE TILDE
       + "ᶇ"  // U+1D87: LATIN SMALL LETTER N WITH PALATAL HOOK
       + "ṅ"  // U+1E45: LATIN SMALL LETTER N WITH DOT ABOVE
       + "ṇ"  // U+1E47: LATIN SMALL LETTER N WITH DOT BELOW
       + "ṉ"  // U+1E49: LATIN SMALL LETTER N WITH LINE BELOW
       + "ṋ"  // U+1E4B: LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW
       + "ⁿ"  // U+207F: SUPERSCRIPT LATIN SMALL LETTER N
       + "ⓝ"  // U+24DD: CIRCLED LATIN SMALL LETTER N
       + "ｎ"  // U+FF4E: FULLWIDTH LATIN SMALL LETTER N
      ,"n", // Folded result

       "Ǌ"  // U+01CA: LATIN CAPITAL LETTER NJ
      ,"NJ", // Folded result

       "ǋ"  // U+01CB: LATIN CAPITAL LETTER N WITH SMALL LETTER J
      ,"Nj", // Folded result

       "⒩"  // U+24A9: PARENTHESIZED LATIN SMALL LETTER N
      ,"(n)", // Folded result

       "ǌ"  // U+01CC: LATIN SMALL LETTER NJ
      ,"nj", // Folded result

       "Ò"  // U+00D2: LATIN CAPITAL LETTER O WITH GRAVE
       + "Ó"  // U+00D3: LATIN CAPITAL LETTER O WITH ACUTE
       + "Ô"  // U+00D4: LATIN CAPITAL LETTER O WITH CIRCUMFLEX
       + "Õ"  // U+00D5: LATIN CAPITAL LETTER O WITH TILDE
       + "Ö"  // U+00D6: LATIN CAPITAL LETTER O WITH DIAERESIS
       + "Ø"  // U+00D8: LATIN CAPITAL LETTER O WITH STROKE
       + "Ō"  // U+014C: LATIN CAPITAL LETTER O WITH MACRON
       + "Ŏ"  // U+014E: LATIN CAPITAL LETTER O WITH BREVE
       + "Ő"  // U+0150: LATIN CAPITAL LETTER O WITH DOUBLE ACUTE
       + "Ɔ"  // U+0186: LATIN CAPITAL LETTER OPEN O
       + "Ɵ"  // U+019F: LATIN CAPITAL LETTER O WITH MIDDLE TILDE
       + "Ơ"  // U+01A0: LATIN CAPITAL LETTER O WITH HORN
       + "Ǒ"  // U+01D1: LATIN CAPITAL LETTER O WITH CARON
       + "Ǫ"  // U+01EA: LATIN CAPITAL LETTER O WITH OGONEK
       + "Ǭ"  // U+01EC: LATIN CAPITAL LETTER O WITH OGONEK AND MACRON
       + "Ǿ"  // U+01FE: LATIN CAPITAL LETTER O WITH STROKE AND ACUTE
       + "Ȍ"  // U+020C: LATIN CAPITAL LETTER O WITH DOUBLE GRAVE
       + "Ȏ"  // U+020E: LATIN CAPITAL LETTER O WITH INVERTED BREVE
       + "Ȫ"  // U+022A: LATIN CAPITAL LETTER O WITH DIAERESIS AND MACRON
       + "Ȭ"  // U+022C: LATIN CAPITAL LETTER O WITH TILDE AND MACRON
       + "Ȯ"  // U+022E: LATIN CAPITAL LETTER O WITH DOT ABOVE
       + "Ȱ"  // U+0230: LATIN CAPITAL LETTER O WITH DOT ABOVE AND MACRON
       + "ᴏ"  // U+1D0F: LATIN LETTER SMALL CAPITAL O
       + "ᴐ"  // U+1D10: LATIN LETTER SMALL CAPITAL OPEN O
       + "Ṍ"  // U+1E4C: LATIN CAPITAL LETTER O WITH TILDE AND ACUTE
       + "Ṏ"  // U+1E4E: LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS
       + "Ṑ"  // U+1E50: LATIN CAPITAL LETTER O WITH MACRON AND GRAVE
       + "Ṓ"  // U+1E52: LATIN CAPITAL LETTER O WITH MACRON AND ACUTE
       + "Ọ"  // U+1ECC: LATIN CAPITAL LETTER O WITH DOT BELOW
       + "Ỏ"  // U+1ECE: LATIN CAPITAL LETTER O WITH HOOK ABOVE
       + "Ố"  // U+1ED0: LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE
       + "Ồ"  // U+1ED2: LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE
       + "Ổ"  // U+1ED4: LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
       + "Ỗ"  // U+1ED6: LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE
       + "Ộ"  // U+1ED8: LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW
       + "Ớ"  // U+1EDA: LATIN CAPITAL LETTER O WITH HORN AND ACUTE
       + "Ờ"  // U+1EDC: LATIN CAPITAL LETTER O WITH HORN AND GRAVE
       + "Ở"  // U+1EDE: LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE
       + "Ỡ"  // U+1EE0: LATIN CAPITAL LETTER O WITH HORN AND TILDE
       + "Ợ"  // U+1EE2: LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW
       + "Ⓞ"  // U+24C4: CIRCLED LATIN CAPITAL LETTER O
       + "Ꝋ"  // U+A74A: LATIN CAPITAL LETTER O WITH LONG STROKE OVERLAY
       + "Ꝍ"  // U+A74C: LATIN CAPITAL LETTER O WITH LOOP
       + "Ｏ"  // U+FF2F: FULLWIDTH LATIN CAPITAL LETTER O
      ,"O", // Folded result

       "ò"  // U+00F2: LATIN SMALL LETTER O WITH GRAVE
       + "ó"  // U+00F3: LATIN SMALL LETTER O WITH ACUTE
       + "ô"  // U+00F4: LATIN SMALL LETTER O WITH CIRCUMFLEX
       + "õ"  // U+00F5: LATIN SMALL LETTER O WITH TILDE
       + "ö"  // U+00F6: LATIN SMALL LETTER O WITH DIAERESIS
       + "ø"  // U+00F8: LATIN SMALL LETTER O WITH STROKE
       + "ō"  // U+014D: LATIN SMALL LETTER O WITH MACRON
       + "ŏ"  // U+014F: LATIN SMALL LETTER O WITH BREVE
       + "ő"  // U+0151: LATIN SMALL LETTER O WITH DOUBLE ACUTE
       + "ơ"  // U+01A1: LATIN SMALL LETTER O WITH HORN
       + "ǒ"  // U+01D2: LATIN SMALL LETTER O WITH CARON
       + "ǫ"  // U+01EB: LATIN SMALL LETTER O WITH OGONEK
       + "ǭ"  // U+01ED: LATIN SMALL LETTER O WITH OGONEK AND MACRON
       + "ǿ"  // U+01FF: LATIN SMALL LETTER O WITH STROKE AND ACUTE
       + "ȍ"  // U+020D: LATIN SMALL LETTER O WITH DOUBLE GRAVE
       + "ȏ"  // U+020F: LATIN SMALL LETTER O WITH INVERTED BREVE
       + "ȫ"  // U+022B: LATIN SMALL LETTER O WITH DIAERESIS AND MACRON
       + "ȭ"  // U+022D: LATIN SMALL LETTER O WITH TILDE AND MACRON
       + "ȯ"  // U+022F: LATIN SMALL LETTER O WITH DOT ABOVE
       + "ȱ"  // U+0231: LATIN SMALL LETTER O WITH DOT ABOVE AND MACRON
       + "ɔ"  // U+0254: LATIN SMALL LETTER OPEN O
       + "ɵ"  // U+0275: LATIN SMALL LETTER BARRED O
       + "ᴖ"  // U+1D16: LATIN SMALL LETTER TOP HALF O
       + "ᴗ"  // U+1D17: LATIN SMALL LETTER BOTTOM HALF O
       + "ᶗ"  // U+1D97: LATIN SMALL LETTER OPEN O WITH RETROFLEX HOOK
       + "ṍ"  // U+1E4D: LATIN SMALL LETTER O WITH TILDE AND ACUTE
       + "ṏ"  // U+1E4F: LATIN SMALL LETTER O WITH TILDE AND DIAERESIS
       + "ṑ"  // U+1E51: LATIN SMALL LETTER O WITH MACRON AND GRAVE
       + "ṓ"  // U+1E53: LATIN SMALL LETTER O WITH MACRON AND ACUTE
       + "ọ"  // U+1ECD: LATIN SMALL LETTER O WITH DOT BELOW
       + "ỏ"  // U+1ECF: LATIN SMALL LETTER O WITH HOOK ABOVE
       + "ố"  // U+1ED1: LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE
       + "ồ"  // U+1ED3: LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE
       + "ổ"  // U+1ED5: LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE
       + "ỗ"  // U+1ED7: LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE
       + "ộ"  // U+1ED9: LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW
       + "ớ"  // U+1EDB: LATIN SMALL LETTER O WITH HORN AND ACUTE
       + "ờ"  // U+1EDD: LATIN SMALL LETTER O WITH HORN AND GRAVE
       + "ở"  // U+1EDF: LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE
       + "ỡ"  // U+1EE1: LATIN SMALL LETTER O WITH HORN AND TILDE
       + "ợ"  // U+1EE3: LATIN SMALL LETTER O WITH HORN AND DOT BELOW
       + "ₒ"  // U+2092: LATIN SUBSCRIPT SMALL LETTER O
       + "ⓞ"  // U+24DE: CIRCLED LATIN SMALL LETTER O
       + "ⱺ"  // U+2C7A: LATIN SMALL LETTER O WITH LOW RING INSIDE
       + "ꝋ"  // U+A74B: LATIN SMALL LETTER O WITH LONG STROKE OVERLAY
       + "ꝍ"  // U+A74D: LATIN SMALL LETTER O WITH LOOP
       + "ｏ"  // U+FF4F: FULLWIDTH LATIN SMALL LETTER O
      ,"o", // Folded result

       "Œ"  // U+0152: LATIN CAPITAL LIGATURE OE
       + "ɶ"  // U+0276: LATIN LETTER SMALL CAPITAL OE
      ,"OE", // Folded result

       "Ꝏ"  // U+A74E: LATIN CAPITAL LETTER OO
      ,"OO", // Folded result

       "Ȣ"  // U+0222: LATIN CAPITAL LETTER OU
       + "ᴕ"  // U+1D15: LATIN LETTER SMALL CAPITAL OU
      ,"OU", // Folded result

       "⒪"  // U+24AA: PARENTHESIZED LATIN SMALL LETTER O
      ,"(o)", // Folded result

       "œ"  // U+0153: LATIN SMALL LIGATURE OE
       + "ᴔ"  // U+1D14: LATIN SMALL LETTER TURNED OE
      ,"oe", // Folded result

       "ꝏ"  // U+A74F: LATIN SMALL LETTER OO
      ,"oo", // Folded result

       "ȣ"  // U+0223: LATIN SMALL LETTER OU
      ,"ou", // Folded result

       "Ƥ"  // U+01A4: LATIN CAPITAL LETTER P WITH HOOK
       + "ᴘ"  // U+1D18: LATIN LETTER SMALL CAPITAL P
       + "Ṕ"  // U+1E54: LATIN CAPITAL LETTER P WITH ACUTE
       + "Ṗ"  // U+1E56: LATIN CAPITAL LETTER P WITH DOT ABOVE
       + "Ⓟ"  // U+24C5: CIRCLED LATIN CAPITAL LETTER P
       + "Ᵽ"  // U+2C63: LATIN CAPITAL LETTER P WITH STROKE
       + "Ꝑ"  // U+A750: LATIN CAPITAL LETTER P WITH STROKE THROUGH DESCENDER
       + "Ꝓ"  // U+A752: LATIN CAPITAL LETTER P WITH FLOURISH
       + "Ꝕ"  // U+A754: LATIN CAPITAL LETTER P WITH SQUIRREL TAIL
       + "Ｐ"  // U+FF30: FULLWIDTH LATIN CAPITAL LETTER P
      ,"P", // Folded result

       "ƥ"  // U+01A5: LATIN SMALL LETTER P WITH HOOK
       + "ᵱ"  // U+1D71: LATIN SMALL LETTER P WITH MIDDLE TILDE
       + "ᵽ"  // U+1D7D: LATIN SMALL LETTER P WITH STROKE
       + "ᶈ"  // U+1D88: LATIN SMALL LETTER P WITH PALATAL HOOK
       + "ṕ"  // U+1E55: LATIN SMALL LETTER P WITH ACUTE
       + "ṗ"  // U+1E57: LATIN SMALL LETTER P WITH DOT ABOVE
       + "ⓟ"  // U+24DF: CIRCLED LATIN SMALL LETTER P
       + "ꝑ"  // U+A751: LATIN SMALL LETTER P WITH STROKE THROUGH DESCENDER
       + "ꝓ"  // U+A753: LATIN SMALL LETTER P WITH FLOURISH
       + "ꝕ"  // U+A755: LATIN SMALL LETTER P WITH SQUIRREL TAIL
       + "ꟼ"  // U+A7FC: LATIN EPIGRAPHIC LETTER REVERSED P
       + "ｐ"  // U+FF50: FULLWIDTH LATIN SMALL LETTER P
      ,"p", // Folded result

       "⒫"  // U+24AB: PARENTHESIZED LATIN SMALL LETTER P
      ,"(p)", // Folded result

       "Ɋ"  // U+024A: LATIN CAPITAL LETTER SMALL Q WITH HOOK TAIL
       + "Ⓠ"  // U+24C6: CIRCLED LATIN CAPITAL LETTER Q
       + "Ꝗ"  // U+A756: LATIN CAPITAL LETTER Q WITH STROKE THROUGH DESCENDER
       + "Ꝙ"  // U+A758: LATIN CAPITAL LETTER Q WITH DIAGONAL STROKE
       + "Ｑ"  // U+FF31: FULLWIDTH LATIN CAPITAL LETTER Q
      ,"Q", // Folded result

       "ĸ"  // U+0138: LATIN SMALL LETTER KRA
       + "ɋ"  // U+024B: LATIN SMALL LETTER Q WITH HOOK TAIL
       + "ʠ"  // U+02A0: LATIN SMALL LETTER Q WITH HOOK
       + "ⓠ"  // U+24E0: CIRCLED LATIN SMALL LETTER Q
       + "ꝗ"  // U+A757: LATIN SMALL LETTER Q WITH STROKE THROUGH DESCENDER
       + "ꝙ"  // U+A759: LATIN SMALL LETTER Q WITH DIAGONAL STROKE
       + "ｑ"  // U+FF51: FULLWIDTH LATIN SMALL LETTER Q
      ,"q", // Folded result

       "⒬"  // U+24AC: PARENTHESIZED LATIN SMALL LETTER Q
      ,"(q)", // Folded result

       "ȹ"  // U+0239: LATIN SMALL LETTER QP DIGRAPH
      ,"qp", // Folded result

       "Ŕ"  // U+0154: LATIN CAPITAL LETTER R WITH ACUTE
       + "Ŗ"  // U+0156: LATIN CAPITAL LETTER R WITH CEDILLA
       + "Ř"  // U+0158: LATIN CAPITAL LETTER R WITH CARON
       + "Ȑ"  // U+0210: LATIN CAPITAL LETTER R WITH DOUBLE GRAVE
       + "Ȓ"  // U+0212: LATIN CAPITAL LETTER R WITH INVERTED BREVE
       + "Ɍ"  // U+024C: LATIN CAPITAL LETTER R WITH STROKE
       + "ʀ"  // U+0280: LATIN LETTER SMALL CAPITAL R
       + "ʁ"  // U+0281: LATIN LETTER SMALL CAPITAL INVERTED R
       + "ᴙ"  // U+1D19: LATIN LETTER SMALL CAPITAL REVERSED R
       + "ᴚ"  // U+1D1A: LATIN LETTER SMALL CAPITAL TURNED R
       + "Ṙ"  // U+1E58: LATIN CAPITAL LETTER R WITH DOT ABOVE
       + "Ṛ"  // U+1E5A: LATIN CAPITAL LETTER R WITH DOT BELOW
       + "Ṝ"  // U+1E5C: LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON
       + "Ṟ"  // U+1E5E: LATIN CAPITAL LETTER R WITH LINE BELOW
       + "Ⓡ"  // U+24C7: CIRCLED LATIN CAPITAL LETTER R
       + "Ɽ"  // U+2C64: LATIN CAPITAL LETTER R WITH TAIL
       + "Ꝛ"  // U+A75A: LATIN CAPITAL LETTER R ROTUNDA
       + "Ꞃ"  // U+A782: LATIN CAPITAL LETTER INSULAR R
       + "Ｒ"  // U+FF32: FULLWIDTH LATIN CAPITAL LETTER R
      ,"R", // Folded result

       "ŕ"  // U+0155: LATIN SMALL LETTER R WITH ACUTE
       + "ŗ"  // U+0157: LATIN SMALL LETTER R WITH CEDILLA
       + "ř"  // U+0159: LATIN SMALL LETTER R WITH CARON
       + "ȑ"  // U+0211: LATIN SMALL LETTER R WITH DOUBLE GRAVE
       + "ȓ"  // U+0213: LATIN SMALL LETTER R WITH INVERTED BREVE
       + "ɍ"  // U+024D: LATIN SMALL LETTER R WITH STROKE
       + "ɼ"  // U+027C: LATIN SMALL LETTER R WITH LONG LEG
       + "ɽ"  // U+027D: LATIN SMALL LETTER R WITH TAIL
       + "ɾ"  // U+027E: LATIN SMALL LETTER R WITH FISHHOOK
       + "ɿ"  // U+027F: LATIN SMALL LETTER REVERSED R WITH FISHHOOK
       + "ᵣ"  // U+1D63: LATIN SUBSCRIPT SMALL LETTER R
       + "ᵲ"  // U+1D72: LATIN SMALL LETTER R WITH MIDDLE TILDE
       + "ᵳ"  // U+1D73: LATIN SMALL LETTER R WITH FISHHOOK AND MIDDLE TILDE
       + "ᶉ"  // U+1D89: LATIN SMALL LETTER R WITH PALATAL HOOK
       + "ṙ"  // U+1E59: LATIN SMALL LETTER R WITH DOT ABOVE
       + "ṛ"  // U+1E5B: LATIN SMALL LETTER R WITH DOT BELOW
       + "ṝ"  // U+1E5D: LATIN SMALL LETTER R WITH DOT BELOW AND MACRON
       + "ṟ"  // U+1E5F: LATIN SMALL LETTER R WITH LINE BELOW
       + "ⓡ"  // U+24E1: CIRCLED LATIN SMALL LETTER R
       + "ꝛ"  // U+A75B: LATIN SMALL LETTER R ROTUNDA
       + "ꞃ"  // U+A783: LATIN SMALL LETTER INSULAR R
       + "ｒ"  // U+FF52: FULLWIDTH LATIN SMALL LETTER R
      ,"r", // Folded result

       "⒭"  // U+24AD: PARENTHESIZED LATIN SMALL LETTER R
      ,"(r)", // Folded result

       "Ś"  // U+015A: LATIN CAPITAL LETTER S WITH ACUTE
       + "Ŝ"  // U+015C: LATIN CAPITAL LETTER S WITH CIRCUMFLEX
       + "Ş"  // U+015E: LATIN CAPITAL LETTER S WITH CEDILLA
       + "Š"  // U+0160: LATIN CAPITAL LETTER S WITH CARON
       + "Ș"  // U+0218: LATIN CAPITAL LETTER S WITH COMMA BELOW
       + "Ṡ"  // U+1E60: LATIN CAPITAL LETTER S WITH DOT ABOVE
       + "Ṣ"  // U+1E62: LATIN CAPITAL LETTER S WITH DOT BELOW
       + "Ṥ"  // U+1E64: LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE
       + "Ṧ"  // U+1E66: LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE
       + "Ṩ"  // U+1E68: LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE
       + "Ⓢ"  // U+24C8: CIRCLED LATIN CAPITAL LETTER S
       + "ꜱ"  // U+A731: LATIN LETTER SMALL CAPITAL S
       + "ꞅ"  // U+A785: LATIN SMALL LETTER INSULAR S
       + "Ｓ"  // U+FF33: FULLWIDTH LATIN CAPITAL LETTER S
      ,"S", // Folded result

       "ś"  // U+015B: LATIN SMALL LETTER S WITH ACUTE
       + "ŝ"  // U+015D: LATIN SMALL LETTER S WITH CIRCUMFLEX
       + "ş"  // U+015F: LATIN SMALL LETTER S WITH CEDILLA
       + "š"  // U+0161: LATIN SMALL LETTER S WITH CARON
       + "ſ"  // U+017F: LATIN SMALL LETTER LONG S
       + "ș"  // U+0219: LATIN SMALL LETTER S WITH COMMA BELOW
       + "ȿ"  // U+023F: LATIN SMALL LETTER S WITH SWASH TAIL
       + "ʂ"  // U+0282: LATIN SMALL LETTER S WITH HOOK
       + "ᵴ"  // U+1D74: LATIN SMALL LETTER S WITH MIDDLE TILDE
       + "ᶊ"  // U+1D8A: LATIN SMALL LETTER S WITH PALATAL HOOK
       + "ṡ"  // U+1E61: LATIN SMALL LETTER S WITH DOT ABOVE
       + "ṣ"  // U+1E63: LATIN SMALL LETTER S WITH DOT BELOW
       + "ṥ"  // U+1E65: LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE
       + "ṧ"  // U+1E67: LATIN SMALL LETTER S WITH CARON AND DOT ABOVE
       + "ṩ"  // U+1E69: LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE
       + "ẜ"  // U+1E9C: LATIN SMALL LETTER LONG S WITH DIAGONAL STROKE
       + "ẝ"  // U+1E9D: LATIN SMALL LETTER LONG S WITH HIGH STROKE
       + "ⓢ"  // U+24E2: CIRCLED LATIN SMALL LETTER S
       + "Ꞅ"  // U+A784: LATIN CAPITAL LETTER INSULAR S
       + "ｓ"  // U+FF53: FULLWIDTH LATIN SMALL LETTER S
      ,"s", // Folded result

       "ẞ"  // U+1E9E: LATIN CAPITAL LETTER SHARP S
      ,"SS", // Folded result

       "⒮"  // U+24AE: PARENTHESIZED LATIN SMALL LETTER S
      ,"(s)", // Folded result

       "ß"  // U+00DF: LATIN SMALL LETTER SHARP S
      ,"ss", // Folded result

       "ﬆ"  // U+FB06: LATIN SMALL LIGATURE ST
      ,"st", // Folded result

       "Ţ"  // U+0162: LATIN CAPITAL LETTER T WITH CEDILLA
       + "Ť"  // U+0164: LATIN CAPITAL LETTER T WITH CARON
       + "Ŧ"  // U+0166: LATIN CAPITAL LETTER T WITH STROKE
       + "Ƭ"  // U+01AC: LATIN CAPITAL LETTER T WITH HOOK
       + "Ʈ"  // U+01AE: LATIN CAPITAL LETTER T WITH RETROFLEX HOOK
       + "Ț"  // U+021A: LATIN CAPITAL LETTER T WITH COMMA BELOW
       + "Ⱦ"  // U+023E: LATIN CAPITAL LETTER T WITH DIAGONAL STROKE
       + "ᴛ"  // U+1D1B: LATIN LETTER SMALL CAPITAL T
       + "Ṫ"  // U+1E6A: LATIN CAPITAL LETTER T WITH DOT ABOVE
       + "Ṭ"  // U+1E6C: LATIN CAPITAL LETTER T WITH DOT BELOW
       + "Ṯ"  // U+1E6E: LATIN CAPITAL LETTER T WITH LINE BELOW
       + "Ṱ"  // U+1E70: LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW
       + "Ⓣ"  // U+24C9: CIRCLED LATIN CAPITAL LETTER T
       + "Ꞇ"  // U+A786: LATIN CAPITAL LETTER INSULAR T
       + "Ｔ"  // U+FF34: FULLWIDTH LATIN CAPITAL LETTER T
      ,"T", // Folded result

       "ţ"  // U+0163: LATIN SMALL LETTER T WITH CEDILLA
       + "ť"  // U+0165: LATIN SMALL LETTER T WITH CARON
       + "ŧ"  // U+0167: LATIN SMALL LETTER T WITH STROKE
       + "ƫ"  // U+01AB: LATIN SMALL LETTER T WITH PALATAL HOOK
       + "ƭ"  // U+01AD: LATIN SMALL LETTER T WITH HOOK
       + "ț"  // U+021B: LATIN SMALL LETTER T WITH COMMA BELOW
       + "ȶ"  // U+0236: LATIN SMALL LETTER T WITH CURL
       + "ʇ"  // U+0287: LATIN SMALL LETTER TURNED T
       + "ʈ"  // U+0288: LATIN SMALL LETTER T WITH RETROFLEX HOOK
       + "ᵵ"  // U+1D75: LATIN SMALL LETTER T WITH MIDDLE TILDE
       + "ṫ"  // U+1E6B: LATIN SMALL LETTER T WITH DOT ABOVE
       + "ṭ"  // U+1E6D: LATIN SMALL LETTER T WITH DOT BELOW
       + "ṯ"  // U+1E6F: LATIN SMALL LETTER T WITH LINE BELOW
       + "ṱ"  // U+1E71: LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW
       + "ẗ"  // U+1E97: LATIN SMALL LETTER T WITH DIAERESIS
       + "ⓣ"  // U+24E3: CIRCLED LATIN SMALL LETTER T
       + "ⱦ"  // U+2C66: LATIN SMALL LETTER T WITH DIAGONAL STROKE
       + "ｔ"  // U+FF54: FULLWIDTH LATIN SMALL LETTER T
      ,"t", // Folded result

       "Þ"  // U+00DE: LATIN CAPITAL LETTER THORN
       + "Ꝧ"  // U+A766: LATIN CAPITAL LETTER THORN WITH STROKE THROUGH DESCENDER
      ,"TH", // Folded result

       "Ꜩ"  // U+A728: LATIN CAPITAL LETTER TZ
      ,"TZ", // Folded result

       "⒯"  // U+24AF: PARENTHESIZED LATIN SMALL LETTER T
      ,"(t)", // Folded result

       "ʨ"  // U+02A8: LATIN SMALL LETTER TC DIGRAPH WITH CURL
      ,"tc", // Folded result

       "þ"  // U+00FE: LATIN SMALL LETTER THORN
       + "ᵺ"  // U+1D7A: LATIN SMALL LETTER TH WITH STRIKETHROUGH
       + "ꝧ"  // U+A767: LATIN SMALL LETTER THORN WITH STROKE THROUGH DESCENDER
      ,"th", // Folded result

       "ʦ"  // U+02A6: LATIN SMALL LETTER TS DIGRAPH
      ,"ts", // Folded result

       "ꜩ"  // U+A729: LATIN SMALL LETTER TZ
      ,"tz", // Folded result

       "Ù"  // U+00D9: LATIN CAPITAL LETTER U WITH GRAVE
       + "Ú"  // U+00DA: LATIN CAPITAL LETTER U WITH ACUTE
       + "Û"  // U+00DB: LATIN CAPITAL LETTER U WITH CIRCUMFLEX
       + "Ü"  // U+00DC: LATIN CAPITAL LETTER U WITH DIAERESIS
       + "Ũ"  // U+0168: LATIN CAPITAL LETTER U WITH TILDE
       + "Ū"  // U+016A: LATIN CAPITAL LETTER U WITH MACRON
       + "Ŭ"  // U+016C: LATIN CAPITAL LETTER U WITH BREVE
       + "Ů"  // U+016E: LATIN CAPITAL LETTER U WITH RING ABOVE
       + "Ű"  // U+0170: LATIN CAPITAL LETTER U WITH DOUBLE ACUTE
       + "Ų"  // U+0172: LATIN CAPITAL LETTER U WITH OGONEK
       + "Ư"  // U+01AF: LATIN CAPITAL LETTER U WITH HORN
       + "Ǔ"  // U+01D3: LATIN CAPITAL LETTER U WITH CARON
       + "Ǖ"  // U+01D5: LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON
       + "Ǘ"  // U+01D7: LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE
       + "Ǚ"  // U+01D9: LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON
       + "Ǜ"  // U+01DB: LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE
       + "Ȕ"  // U+0214: LATIN CAPITAL LETTER U WITH DOUBLE GRAVE
       + "Ȗ"  // U+0216: LATIN CAPITAL LETTER U WITH INVERTED BREVE
       + "Ʉ"  // U+0244: LATIN CAPITAL LETTER U BAR
       + "ᴜ"  // U+1D1C: LATIN LETTER SMALL CAPITAL U
       + "ᵾ"  // U+1D7E: LATIN SMALL CAPITAL LETTER U WITH STROKE
       + "Ṳ"  // U+1E72: LATIN CAPITAL LETTER U WITH DIAERESIS BELOW
       + "Ṵ"  // U+1E74: LATIN CAPITAL LETTER U WITH TILDE BELOW
       + "Ṷ"  // U+1E76: LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW
       + "Ṹ"  // U+1E78: LATIN CAPITAL LETTER U WITH TILDE AND ACUTE
       + "Ṻ"  // U+1E7A: LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS
       + "Ụ"  // U+1EE4: LATIN CAPITAL LETTER U WITH DOT BELOW
       + "Ủ"  // U+1EE6: LATIN CAPITAL LETTER U WITH HOOK ABOVE
       + "Ứ"  // U+1EE8: LATIN CAPITAL LETTER U WITH HORN AND ACUTE
       + "Ừ"  // U+1EEA: LATIN CAPITAL LETTER U WITH HORN AND GRAVE
       + "Ử"  // U+1EEC: LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE
       + "Ữ"  // U+1EEE: LATIN CAPITAL LETTER U WITH HORN AND TILDE
       + "Ự"  // U+1EF0: LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW
       + "Ⓤ"  // U+24CA: CIRCLED LATIN CAPITAL LETTER U
       + "Ｕ"  // U+FF35: FULLWIDTH LATIN CAPITAL LETTER U
      ,"U", // Folded result

       "ù"  // U+00F9: LATIN SMALL LETTER U WITH GRAVE
       + "ú"  // U+00FA: LATIN SMALL LETTER U WITH ACUTE
       + "û"  // U+00FB: LATIN SMALL LETTER U WITH CIRCUMFLEX
       + "ü"  // U+00FC: LATIN SMALL LETTER U WITH DIAERESIS
       + "ũ"  // U+0169: LATIN SMALL LETTER U WITH TILDE
       + "ū"  // U+016B: LATIN SMALL LETTER U WITH MACRON
       + "ŭ"  // U+016D: LATIN SMALL LETTER U WITH BREVE
       + "ů"  // U+016F: LATIN SMALL LETTER U WITH RING ABOVE
       + "ű"  // U+0171: LATIN SMALL LETTER U WITH DOUBLE ACUTE
       + "ų"  // U+0173: LATIN SMALL LETTER U WITH OGONEK
       + "ư"  // U+01B0: LATIN SMALL LETTER U WITH HORN
       + "ǔ"  // U+01D4: LATIN SMALL LETTER U WITH CARON
       + "ǖ"  // U+01D6: LATIN SMALL LETTER U WITH DIAERESIS AND MACRON
       + "ǘ"  // U+01D8: LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE
       + "ǚ"  // U+01DA: LATIN SMALL LETTER U WITH DIAERESIS AND CARON
       + "ǜ"  // U+01DC: LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE
       + "ȕ"  // U+0215: LATIN SMALL LETTER U WITH DOUBLE GRAVE
       + "ȗ"  // U+0217: LATIN SMALL LETTER U WITH INVERTED BREVE
       + "ʉ"  // U+0289: LATIN SMALL LETTER U BAR
       + "ᵤ"  // U+1D64: LATIN SUBSCRIPT SMALL LETTER U
       + "ᶙ"  // U+1D99: LATIN SMALL LETTER U WITH RETROFLEX HOOK
       + "ṳ"  // U+1E73: LATIN SMALL LETTER U WITH DIAERESIS BELOW
       + "ṵ"  // U+1E75: LATIN SMALL LETTER U WITH TILDE BELOW
       + "ṷ"  // U+1E77: LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW
       + "ṹ"  // U+1E79: LATIN SMALL LETTER U WITH TILDE AND ACUTE
       + "ṻ"  // U+1E7B: LATIN SMALL LETTER U WITH MACRON AND DIAERESIS
       + "ụ"  // U+1EE5: LATIN SMALL LETTER U WITH DOT BELOW
       + "ủ"  // U+1EE7: LATIN SMALL LETTER U WITH HOOK ABOVE
       + "ứ"  // U+1EE9: LATIN SMALL LETTER U WITH HORN AND ACUTE
       + "ừ"  // U+1EEB: LATIN SMALL LETTER U WITH HORN AND GRAVE
       + "ử"  // U+1EED: LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE
       + "ữ"  // U+1EEF: LATIN SMALL LETTER U WITH HORN AND TILDE
       + "ự"  // U+1EF1: LATIN SMALL LETTER U WITH HORN AND DOT BELOW
       + "ⓤ"  // U+24E4: CIRCLED LATIN SMALL LETTER U
       + "ｕ"  // U+FF55: FULLWIDTH LATIN SMALL LETTER U
      ,"u", // Folded result

       "⒰"  // U+24B0: PARENTHESIZED LATIN SMALL LETTER U
      ,"(u)", // Folded result

       "ᵫ"  // U+1D6B: LATIN SMALL LETTER UE
      ,"ue", // Folded result

       "Ʋ"  // U+01B2: LATIN CAPITAL LETTER V WITH HOOK
       + "Ʌ"  // U+0245: LATIN CAPITAL LETTER TURNED V
       + "ᴠ"  // U+1D20: LATIN LETTER SMALL CAPITAL V
       + "Ṽ"  // U+1E7C: LATIN CAPITAL LETTER V WITH TILDE
       + "Ṿ"  // U+1E7E: LATIN CAPITAL LETTER V WITH DOT BELOW
       + "Ỽ"  // U+1EFC: LATIN CAPITAL LETTER MIDDLE-WELSH V
       + "Ⓥ"  // U+24CB: CIRCLED LATIN CAPITAL LETTER V
       + "Ꝟ"  // U+A75E: LATIN CAPITAL LETTER V WITH DIAGONAL STROKE
       + "Ꝩ"  // U+A768: LATIN CAPITAL LETTER VEND
       + "Ｖ"  // U+FF36: FULLWIDTH LATIN CAPITAL LETTER V
      ,"V", // Folded result

       "ʋ"  // U+028B: LATIN SMALL LETTER V WITH HOOK
       + "ʌ"  // U+028C: LATIN SMALL LETTER TURNED V
       + "ᵥ"  // U+1D65: LATIN SUBSCRIPT SMALL LETTER V
       + "ᶌ"  // U+1D8C: LATIN SMALL LETTER V WITH PALATAL HOOK
       + "ṽ"  // U+1E7D: LATIN SMALL LETTER V WITH TILDE
       + "ṿ"  // U+1E7F: LATIN SMALL LETTER V WITH DOT BELOW
       + "ⓥ"  // U+24E5: CIRCLED LATIN SMALL LETTER V
       + "ⱱ"  // U+2C71: LATIN SMALL LETTER V WITH RIGHT HOOK
       + "ⱴ"  // U+2C74: LATIN SMALL LETTER V WITH CURL
       + "ꝟ"  // U+A75F: LATIN SMALL LETTER V WITH DIAGONAL STROKE
       + "ｖ"  // U+FF56: FULLWIDTH LATIN SMALL LETTER V
      ,"v", // Folded result

       "Ꝡ"  // U+A760: LATIN CAPITAL LETTER VY
      ,"VY", // Folded result

       "⒱"  // U+24B1: PARENTHESIZED LATIN SMALL LETTER V
      ,"(v)", // Folded result

       "ꝡ"  // U+A761: LATIN SMALL LETTER VY
      ,"vy", // Folded result

       "Ŵ"  // U+0174: LATIN CAPITAL LETTER W WITH CIRCUMFLEX
       + "Ƿ"  // U+01F7: LATIN CAPITAL LETTER WYNN
       + "ᴡ"  // U+1D21: LATIN LETTER SMALL CAPITAL W
       + "Ẁ"  // U+1E80: LATIN CAPITAL LETTER W WITH GRAVE
       + "Ẃ"  // U+1E82: LATIN CAPITAL LETTER W WITH ACUTE
       + "Ẅ"  // U+1E84: LATIN CAPITAL LETTER W WITH DIAERESIS
       + "Ẇ"  // U+1E86: LATIN CAPITAL LETTER W WITH DOT ABOVE
       + "Ẉ"  // U+1E88: LATIN CAPITAL LETTER W WITH DOT BELOW
       + "Ⓦ"  // U+24CC: CIRCLED LATIN CAPITAL LETTER W
       + "Ⱳ"  // U+2C72: LATIN CAPITAL LETTER W WITH HOOK
       + "Ｗ"  // U+FF37: FULLWIDTH LATIN CAPITAL LETTER W
      ,"W", // Folded result

       "ŵ"  // U+0175: LATIN SMALL LETTER W WITH CIRCUMFLEX
       + "ƿ"  // U+01BF: LATIN LETTER WYNN
       + "ʍ"  // U+028D: LATIN SMALL LETTER TURNED W
       + "ẁ"  // U+1E81: LATIN SMALL LETTER W WITH GRAVE
       + "ẃ"  // U+1E83: LATIN SMALL LETTER W WITH ACUTE
       + "ẅ"  // U+1E85: LATIN SMALL LETTER W WITH DIAERESIS
       + "ẇ"  // U+1E87: LATIN SMALL LETTER W WITH DOT ABOVE
       + "ẉ"  // U+1E89: LATIN SMALL LETTER W WITH DOT BELOW
       + "ẘ"  // U+1E98: LATIN SMALL LETTER W WITH RING ABOVE
       + "ⓦ"  // U+24E6: CIRCLED LATIN SMALL LETTER W
       + "ⱳ"  // U+2C73: LATIN SMALL LETTER W WITH HOOK
       + "ｗ"  // U+FF57: FULLWIDTH LATIN SMALL LETTER W
      ,"w", // Folded result

       "⒲"  // U+24B2: PARENTHESIZED LATIN SMALL LETTER W
      ,"(w)", // Folded result

       "Ẋ"  // U+1E8A: LATIN CAPITAL LETTER X WITH DOT ABOVE
       + "Ẍ"  // U+1E8C: LATIN CAPITAL LETTER X WITH DIAERESIS
       + "Ⓧ"  // U+24CD: CIRCLED LATIN CAPITAL LETTER X
       + "Ｘ"  // U+FF38: FULLWIDTH LATIN CAPITAL LETTER X
      ,"X", // Folded result

       "ᶍ"  // U+1D8D: LATIN SMALL LETTER X WITH PALATAL HOOK
       + "ẋ"  // U+1E8B: LATIN SMALL LETTER X WITH DOT ABOVE
       + "ẍ"  // U+1E8D: LATIN SMALL LETTER X WITH DIAERESIS
       + "ₓ"  // U+2093: LATIN SUBSCRIPT SMALL LETTER X
       + "ⓧ"  // U+24E7: CIRCLED LATIN SMALL LETTER X
       + "ｘ"  // U+FF58: FULLWIDTH LATIN SMALL LETTER X
      ,"x", // Folded result

       "⒳"  // U+24B3: PARENTHESIZED LATIN SMALL LETTER X
      ,"(x)", // Folded result

       "Ý"  // U+00DD: LATIN CAPITAL LETTER Y WITH ACUTE
       + "Ŷ"  // U+0176: LATIN CAPITAL LETTER Y WITH CIRCUMFLEX
       + "Ÿ"  // U+0178: LATIN CAPITAL LETTER Y WITH DIAERESIS
       + "Ƴ"  // U+01B3: LATIN CAPITAL LETTER Y WITH HOOK
       + "Ȳ"  // U+0232: LATIN CAPITAL LETTER Y WITH MACRON
       + "Ɏ"  // U+024E: LATIN CAPITAL LETTER Y WITH STROKE
       + "ʏ"  // U+028F: LATIN LETTER SMALL CAPITAL Y
       + "Ẏ"  // U+1E8E: LATIN CAPITAL LETTER Y WITH DOT ABOVE
       + "Ỳ"  // U+1EF2: LATIN CAPITAL LETTER Y WITH GRAVE
       + "Ỵ"  // U+1EF4: LATIN CAPITAL LETTER Y WITH DOT BELOW
       + "Ỷ"  // U+1EF6: LATIN CAPITAL LETTER Y WITH HOOK ABOVE
       + "Ỹ"  // U+1EF8: LATIN CAPITAL LETTER Y WITH TILDE
       + "Ỿ"  // U+1EFE: LATIN CAPITAL LETTER Y WITH LOOP
       + "Ⓨ"  // U+24CE: CIRCLED LATIN CAPITAL LETTER Y
       + "Ｙ"  // U+FF39: FULLWIDTH LATIN CAPITAL LETTER Y
      ,"Y", // Folded result

       "ý"  // U+00FD: LATIN SMALL LETTER Y WITH ACUTE
       + "ÿ"  // U+00FF: LATIN SMALL LETTER Y WITH DIAERESIS
       + "ŷ"  // U+0177: LATIN SMALL LETTER Y WITH CIRCUMFLEX
       + "ƴ"  // U+01B4: LATIN SMALL LETTER Y WITH HOOK
       + "ȳ"  // U+0233: LATIN SMALL LETTER Y WITH MACRON
       + "ɏ"  // U+024F: LATIN SMALL LETTER Y WITH STROKE
       + "ʎ"  // U+028E: LATIN SMALL LETTER TURNED Y
       + "ẏ"  // U+1E8F: LATIN SMALL LETTER Y WITH DOT ABOVE
       + "ẙ"  // U+1E99: LATIN SMALL LETTER Y WITH RING ABOVE
       + "ỳ"  // U+1EF3: LATIN SMALL LETTER Y WITH GRAVE
       + "ỵ"  // U+1EF5: LATIN SMALL LETTER Y WITH DOT BELOW
       + "ỷ"  // U+1EF7: LATIN SMALL LETTER Y WITH HOOK ABOVE
       + "ỹ"  // U+1EF9: LATIN SMALL LETTER Y WITH TILDE
       + "ỿ"  // U+1EFF: LATIN SMALL LETTER Y WITH LOOP
       + "ⓨ"  // U+24E8: CIRCLED LATIN SMALL LETTER Y
       + "ｙ"  // U+FF59: FULLWIDTH LATIN SMALL LETTER Y
      ,"y", // Folded result

       "⒴"  // U+24B4: PARENTHESIZED LATIN SMALL LETTER Y
      ,"(y)", // Folded result

       "Ź"  // U+0179: LATIN CAPITAL LETTER Z WITH ACUTE
       + "Ż"  // U+017B: LATIN CAPITAL LETTER Z WITH DOT ABOVE
       + "Ž"  // U+017D: LATIN CAPITAL LETTER Z WITH CARON
       + "Ƶ"  // U+01B5: LATIN CAPITAL LETTER Z WITH STROKE
       + "Ȝ"  // U+021C: LATIN CAPITAL LETTER YOGH
       + "Ȥ"  // U+0224: LATIN CAPITAL LETTER Z WITH HOOK
       + "ᴢ"  // U+1D22: LATIN LETTER SMALL CAPITAL Z
       + "Ẑ"  // U+1E90: LATIN CAPITAL LETTER Z WITH CIRCUMFLEX
       + "Ẓ"  // U+1E92: LATIN CAPITAL LETTER Z WITH DOT BELOW
       + "Ẕ"  // U+1E94: LATIN CAPITAL LETTER Z WITH LINE BELOW
       + "Ⓩ"  // U+24CF: CIRCLED LATIN CAPITAL LETTER Z
       + "Ⱬ"  // U+2C6B: LATIN CAPITAL LETTER Z WITH DESCENDER
       + "Ꝣ"  // U+A762: LATIN CAPITAL LETTER VISIGOTHIC Z
       + "Ｚ"  // U+FF3A: FULLWIDTH LATIN CAPITAL LETTER Z
      ,"Z", // Folded result

       "ź"  // U+017A: LATIN SMALL LETTER Z WITH ACUTE
       + "ż"  // U+017C: LATIN SMALL LETTER Z WITH DOT ABOVE
       + "ž"  // U+017E: LATIN SMALL LETTER Z WITH CARON
       + "ƶ"  // U+01B6: LATIN SMALL LETTER Z WITH STROKE
       + "ȝ"  // U+021D: LATIN SMALL LETTER YOGH
       + "ȥ"  // U+0225: LATIN SMALL LETTER Z WITH HOOK
       + "ɀ"  // U+0240: LATIN SMALL LETTER Z WITH SWASH TAIL
       + "ʐ"  // U+0290: LATIN SMALL LETTER Z WITH RETROFLEX HOOK
       + "ʑ"  // U+0291: LATIN SMALL LETTER Z WITH CURL
       + "ᵶ"  // U+1D76: LATIN SMALL LETTER Z WITH MIDDLE TILDE
       + "ᶎ"  // U+1D8E: LATIN SMALL LETTER Z WITH PALATAL HOOK
       + "ẑ"  // U+1E91: LATIN SMALL LETTER Z WITH CIRCUMFLEX
       + "ẓ"  // U+1E93: LATIN SMALL LETTER Z WITH DOT BELOW
       + "ẕ"  // U+1E95: LATIN SMALL LETTER Z WITH LINE BELOW
       + "ⓩ"  // U+24E9: CIRCLED LATIN SMALL LETTER Z
       + "ⱬ"  // U+2C6C: LATIN SMALL LETTER Z WITH DESCENDER
       + "ꝣ"  // U+A763: LATIN SMALL LETTER VISIGOTHIC Z
       + "ｚ"  // U+FF5A: FULLWIDTH LATIN SMALL LETTER Z
      ,"z", // Folded result

       "⒵"  // U+24B5: PARENTHESIZED LATIN SMALL LETTER Z
      ,"(z)", // Folded result

       "⁰"  // U+2070: SUPERSCRIPT ZERO
       + "₀"  // U+2080: SUBSCRIPT ZERO
       + "⓪"  // U+24EA: CIRCLED DIGIT ZERO
       + "⓿"  // U+24FF: NEGATIVE CIRCLED DIGIT ZERO
       + "０"  // U+FF10: FULLWIDTH DIGIT ZERO
      ,"0", // Folded result

       "¹"  // U+00B9: SUPERSCRIPT ONE
       + "₁"  // U+2081: SUBSCRIPT ONE
       + "①"  // U+2460: CIRCLED DIGIT ONE
       + "⓵"  // U+24F5: DOUBLE CIRCLED DIGIT ONE
       + "❶"  // U+2776: DINGBAT NEGATIVE CIRCLED DIGIT ONE
       + "➀"  // U+2780: DINGBAT CIRCLED SANS-SERIF DIGIT ONE
       + "➊"  // U+278A: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT ONE
       + "１"  // U+FF11: FULLWIDTH DIGIT ONE
      ,"1", // Folded result

       "⒈"  // U+2488: DIGIT ONE FULL STOP
      ,"1.", // Folded result

       "⑴"  // U+2474: PARENTHESIZED DIGIT ONE
      ,"(1)", // Folded result

       "²"  // U+00B2: SUPERSCRIPT TWO
       + "₂"  // U+2082: SUBSCRIPT TWO
       + "②"  // U+2461: CIRCLED DIGIT TWO
       + "⓶"  // U+24F6: DOUBLE CIRCLED DIGIT TWO
       + "❷"  // U+2777: DINGBAT NEGATIVE CIRCLED DIGIT TWO
       + "➁"  // U+2781: DINGBAT CIRCLED SANS-SERIF DIGIT TWO
       + "➋"  // U+278B: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT TWO
       + "２"  // U+FF12: FULLWIDTH DIGIT TWO
      ,"2", // Folded result

       "⒉"  // U+2489: DIGIT TWO FULL STOP
      ,"2.", // Folded result

       "⑵"  // U+2475: PARENTHESIZED DIGIT TWO
      ,"(2)", // Folded result

       "³"  // U+00B3: SUPERSCRIPT THREE
       + "₃"  // U+2083: SUBSCRIPT THREE
       + "③"  // U+2462: CIRCLED DIGIT THREE
       + "⓷"  // U+24F7: DOUBLE CIRCLED DIGIT THREE
       + "❸"  // U+2778: DINGBAT NEGATIVE CIRCLED DIGIT THREE
       + "➂"  // U+2782: DINGBAT CIRCLED SANS-SERIF DIGIT THREE
       + "➌"  // U+278C: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT THREE
       + "３"  // U+FF13: FULLWIDTH DIGIT THREE
      ,"3", // Folded result

       "⒊"  // U+248A: DIGIT THREE FULL STOP
      ,"3.", // Folded result

       "⑶"  // U+2476: PARENTHESIZED DIGIT THREE
      ,"(3)", // Folded result

       "⁴"  // U+2074: SUPERSCRIPT FOUR
       + "₄"  // U+2084: SUBSCRIPT FOUR
       + "④"  // U+2463: CIRCLED DIGIT FOUR
       + "⓸"  // U+24F8: DOUBLE CIRCLED DIGIT FOUR
       + "❹"  // U+2779: DINGBAT NEGATIVE CIRCLED DIGIT FOUR
       + "➃"  // U+2783: DINGBAT CIRCLED SANS-SERIF DIGIT FOUR
       + "➍"  // U+278D: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT FOUR
       + "４"  // U+FF14: FULLWIDTH DIGIT FOUR
      ,"4", // Folded result

       "⒋"  // U+248B: DIGIT FOUR FULL STOP
      ,"4.", // Folded result

       "⑷"  // U+2477: PARENTHESIZED DIGIT FOUR
      ,"(4)", // Folded result

       "⁵"  // U+2075: SUPERSCRIPT FIVE
       + "₅"  // U+2085: SUBSCRIPT FIVE
       + "⑤"  // U+2464: CIRCLED DIGIT FIVE
       + "⓹"  // U+24F9: DOUBLE CIRCLED DIGIT FIVE
       + "❺"  // U+277A: DINGBAT NEGATIVE CIRCLED DIGIT FIVE
       + "➄"  // U+2784: DINGBAT CIRCLED SANS-SERIF DIGIT FIVE
       + "➎"  // U+278E: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT FIVE
       + "５"  // U+FF15: FULLWIDTH DIGIT FIVE
      ,"5", // Folded result

       "⒌"  // U+248C: DIGIT FIVE FULL STOP
      ,"5.", // Folded result

       "⑸"  // U+2478: PARENTHESIZED DIGIT FIVE
      ,"(5)", // Folded result

       "⁶"  // U+2076: SUPERSCRIPT SIX
       + "₆"  // U+2086: SUBSCRIPT SIX
       + "⑥"  // U+2465: CIRCLED DIGIT SIX
       + "⓺"  // U+24FA: DOUBLE CIRCLED DIGIT SIX
       + "❻"  // U+277B: DINGBAT NEGATIVE CIRCLED DIGIT SIX
       + "➅"  // U+2785: DINGBAT CIRCLED SANS-SERIF DIGIT SIX
       + "➏"  // U+278F: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT SIX
       + "６"  // U+FF16: FULLWIDTH DIGIT SIX
      ,"6", // Folded result

       "⒍"  // U+248D: DIGIT SIX FULL STOP
      ,"6.", // Folded result

       "⑹"  // U+2479: PARENTHESIZED DIGIT SIX
      ,"(6)", // Folded result

       "⁷"  // U+2077: SUPERSCRIPT SEVEN
       + "₇"  // U+2087: SUBSCRIPT SEVEN
       + "⑦"  // U+2466: CIRCLED DIGIT SEVEN
       + "⓻"  // U+24FB: DOUBLE CIRCLED DIGIT SEVEN
       + "❼"  // U+277C: DINGBAT NEGATIVE CIRCLED DIGIT SEVEN
       + "➆"  // U+2786: DINGBAT CIRCLED SANS-SERIF DIGIT SEVEN
       + "➐"  // U+2790: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT SEVEN
       + "７"  // U+FF17: FULLWIDTH DIGIT SEVEN
      ,"7", // Folded result

       "⒎"  // U+248E: DIGIT SEVEN FULL STOP
      ,"7.", // Folded result

       "⑺"  // U+247A: PARENTHESIZED DIGIT SEVEN
      ,"(7)", // Folded result

       "⁸"  // U+2078: SUPERSCRIPT EIGHT
       + "₈"  // U+2088: SUBSCRIPT EIGHT
       + "⑧"  // U+2467: CIRCLED DIGIT EIGHT
       + "⓼"  // U+24FC: DOUBLE CIRCLED DIGIT EIGHT
       + "❽"  // U+277D: DINGBAT NEGATIVE CIRCLED DIGIT EIGHT
       + "➇"  // U+2787: DINGBAT CIRCLED SANS-SERIF DIGIT EIGHT
       + "➑"  // U+2791: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT EIGHT
       + "８"  // U+FF18: FULLWIDTH DIGIT EIGHT
      ,"8", // Folded result

       "⒏"  // U+248F: DIGIT EIGHT FULL STOP
      ,"8.", // Folded result

       "⑻"  // U+247B: PARENTHESIZED DIGIT EIGHT
      ,"(8)", // Folded result

       "⁹"  // U+2079: SUPERSCRIPT NINE
       + "₉"  // U+2089: SUBSCRIPT NINE
       + "⑨"  // U+2468: CIRCLED DIGIT NINE
       + "⓽"  // U+24FD: DOUBLE CIRCLED DIGIT NINE
       + "❾"  // U+277E: DINGBAT NEGATIVE CIRCLED DIGIT NINE
       + "➈"  // U+2788: DINGBAT CIRCLED SANS-SERIF DIGIT NINE
       + "➒"  // U+2792: DINGBAT NEGATIVE CIRCLED SANS-SERIF DIGIT NINE
       + "９"  // U+FF19: FULLWIDTH DIGIT NINE
      ,"9", // Folded result

       "⒐"  // U+2490: DIGIT NINE FULL STOP
      ,"9.", // Folded result

       "⑼"  // U+247C: PARENTHESIZED DIGIT NINE
      ,"(9)", // Folded result

       "⑩"  // U+2469: CIRCLED NUMBER TEN
       + "⓾"  // U+24FE: DOUBLE CIRCLED NUMBER TEN
       + "❿"  // U+277F: DINGBAT NEGATIVE CIRCLED NUMBER TEN
       + "➉"  // U+2789: DINGBAT CIRCLED SANS-SERIF NUMBER TEN
       + "➓"  // U+2793: DINGBAT NEGATIVE CIRCLED SANS-SERIF NUMBER TEN
      ,"10", // Folded result

       "⒑"  // U+2491: NUMBER TEN FULL STOP
      ,"10.", // Folded result

       "⑽"  // U+247D: PARENTHESIZED NUMBER TEN
      ,"(10)", // Folded result

       "⑪"  // U+246A: CIRCLED NUMBER ELEVEN
       + "⓫"  // U+24EB: NEGATIVE CIRCLED NUMBER ELEVEN
      ,"11", // Folded result

       "⒒"  // U+2492: NUMBER ELEVEN FULL STOP
      ,"11.", // Folded result

       "⑾"  // U+247E: PARENTHESIZED NUMBER ELEVEN
      ,"(11)", // Folded result

       "⑫"  // U+246B: CIRCLED NUMBER TWELVE
       + "⓬"  // U+24EC: NEGATIVE CIRCLED NUMBER TWELVE
      ,"12", // Folded result

       "⒓"  // U+2493: NUMBER TWELVE FULL STOP
      ,"12.", // Folded result

       "⑿"  // U+247F: PARENTHESIZED NUMBER TWELVE
      ,"(12)", // Folded result

       "⑬"  // U+246C: CIRCLED NUMBER THIRTEEN
       + "⓭"  // U+24ED: NEGATIVE CIRCLED NUMBER THIRTEEN
      ,"13", // Folded result

       "⒔"  // U+2494: NUMBER THIRTEEN FULL STOP
      ,"13.", // Folded result

       "⒀"  // U+2480: PARENTHESIZED NUMBER THIRTEEN
      ,"(13)", // Folded result

       "⑭"  // U+246D: CIRCLED NUMBER FOURTEEN
       + "⓮"  // U+24EE: NEGATIVE CIRCLED NUMBER FOURTEEN
      ,"14", // Folded result

       "⒕"  // U+2495: NUMBER FOURTEEN FULL STOP
      ,"14.", // Folded result

       "⒁"  // U+2481: PARENTHESIZED NUMBER FOURTEEN
      ,"(14)", // Folded result

       "⑮"  // U+246E: CIRCLED NUMBER FIFTEEN
       + "⓯"  // U+24EF: NEGATIVE CIRCLED NUMBER FIFTEEN
      ,"15", // Folded result

       "⒖"  // U+2496: NUMBER FIFTEEN FULL STOP
      ,"15.", // Folded result

       "⒂"  // U+2482: PARENTHESIZED NUMBER FIFTEEN
      ,"(15)", // Folded result

       "⑯"  // U+246F: CIRCLED NUMBER SIXTEEN
       + "⓰"  // U+24F0: NEGATIVE CIRCLED NUMBER SIXTEEN
      ,"16", // Folded result

       "⒗"  // U+2497: NUMBER SIXTEEN FULL STOP
      ,"16.", // Folded result

       "⒃"  // U+2483: PARENTHESIZED NUMBER SIXTEEN
      ,"(16)", // Folded result

       "⑰"  // U+2470: CIRCLED NUMBER SEVENTEEN
       + "⓱"  // U+24F1: NEGATIVE CIRCLED NUMBER SEVENTEEN
      ,"17", // Folded result

       "⒘"  // U+2498: NUMBER SEVENTEEN FULL STOP
      ,"17.", // Folded result

       "⒄"  // U+2484: PARENTHESIZED NUMBER SEVENTEEN
      ,"(17)", // Folded result

       "⑱"  // U+2471: CIRCLED NUMBER EIGHTEEN
       + "⓲"  // U+24F2: NEGATIVE CIRCLED NUMBER EIGHTEEN
      ,"18", // Folded result

       "⒙"  // U+2499: NUMBER EIGHTEEN FULL STOP
      ,"18.", // Folded result

       "⒅"  // U+2485: PARENTHESIZED NUMBER EIGHTEEN
      ,"(18)", // Folded result

       "⑲"  // U+2472: CIRCLED NUMBER NINETEEN
       + "⓳"  // U+24F3: NEGATIVE CIRCLED NUMBER NINETEEN
      ,"19", // Folded result

       "⒚"  // U+249A: NUMBER NINETEEN FULL STOP
      ,"19.", // Folded result

       "⒆"  // U+2486: PARENTHESIZED NUMBER NINETEEN
      ,"(19)", // Folded result

       "⑳"  // U+2473: CIRCLED NUMBER TWENTY
       + "⓴"  // U+24F4: NEGATIVE CIRCLED NUMBER TWENTY
      ,"20", // Folded result

       "⒛"  // U+249B: NUMBER TWENTY FULL STOP
      ,"20.", // Folded result

       "⒇"  // U+2487: PARENTHESIZED NUMBER TWENTY
      ,"(20)", // Folded result

       "«"  // U+00AB: LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
       + "»"  // U+00BB: RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
       + "“"  // U+201C: LEFT DOUBLE QUOTATION MARK
       + "”"  // U+201D: RIGHT DOUBLE QUOTATION MARK
       + "„"  // U+201E: DOUBLE LOW-9 QUOTATION MARK
       + "″"  // U+2033: DOUBLE PRIME
       + "‶"  // U+2036: REVERSED DOUBLE PRIME
       + "❝"  // U+275D: HEAVY DOUBLE TURNED COMMA QUOTATION MARK ORNAMENT
       + "❞"  // U+275E: HEAVY DOUBLE COMMA QUOTATION MARK ORNAMENT
       + "❮"  // U+276E: HEAVY LEFT-POINTING ANGLE QUOTATION MARK ORNAMENT
       + "❯"  // U+276F: HEAVY RIGHT-POINTING ANGLE QUOTATION MARK ORNAMENT
       + "＂"  // U+FF02: FULLWIDTH QUOTATION MARK
      ,"\"", // Folded result

       "‘"  // U+2018: LEFT SINGLE QUOTATION MARK
       + "’"  // U+2019: RIGHT SINGLE QUOTATION MARK
       + "‚"  // U+201A: SINGLE LOW-9 QUOTATION MARK
       + "‛"  // U+201B: SINGLE HIGH-REVERSED-9 QUOTATION MARK
       + "′"  // U+2032: PRIME
       + "‵"  // U+2035: REVERSED PRIME
       + "‹"  // U+2039: SINGLE LEFT-POINTING ANGLE QUOTATION MARK
       + "›"  // U+203A: SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
       + "❛"  // U+275B: HEAVY SINGLE TURNED COMMA QUOTATION MARK ORNAMENT
       + "❜"  // U+275C: HEAVY SINGLE COMMA QUOTATION MARK ORNAMENT
       + "＇"  // U+FF07: FULLWIDTH APOSTROPHE
      ,"'", // Folded result

       "‐"  // U+2010: HYPHEN
       + "‑"  // U+2011: NON-BREAKING HYPHEN
       + "‒"  // U+2012: FIGURE DASH
       + "–"  // U+2013: EN DASH
       + "—"  // U+2014: EM DASH
       + "⁻"  // U+207B: SUPERSCRIPT MINUS
       + "₋"  // U+208B: SUBSCRIPT MINUS
       + "－"  // U+FF0D: FULLWIDTH HYPHEN-MINUS
      ,"-", // Folded result

       "⁅"  // U+2045: LEFT SQUARE BRACKET WITH QUILL
       + "❲"  // U+2772: LIGHT LEFT TORTOISE SHELL BRACKET ORNAMENT
       + "［"  // U+FF3B: FULLWIDTH LEFT SQUARE BRACKET
      ,"[", // Folded result

       "⁆"  // U+2046: RIGHT SQUARE BRACKET WITH QUILL
       + "❳"  // U+2773: LIGHT RIGHT TORTOISE SHELL BRACKET ORNAMENT
       + "］"  // U+FF3D: FULLWIDTH RIGHT SQUARE BRACKET
      ,"]", // Folded result

       "⁽"  // U+207D: SUPERSCRIPT LEFT PARENTHESIS
       + "₍"  // U+208D: SUBSCRIPT LEFT PARENTHESIS
       + "❨"  // U+2768: MEDIUM LEFT PARENTHESIS ORNAMENT
       + "❪"  // U+276A: MEDIUM FLATTENED LEFT PARENTHESIS ORNAMENT
       + "（"  // U+FF08: FULLWIDTH LEFT PARENTHESIS
      ,"(", // Folded result

       "⸨"  // U+2E28: LEFT DOUBLE PARENTHESIS
      ,"((", // Folded result

       "⁾"  // U+207E: SUPERSCRIPT RIGHT PARENTHESIS
       + "₎"  // U+208E: SUBSCRIPT RIGHT PARENTHESIS
       + "❩"  // U+2769: MEDIUM RIGHT PARENTHESIS ORNAMENT
       + "❫"  // U+276B: MEDIUM FLATTENED RIGHT PARENTHESIS ORNAMENT
       + "）"  // U+FF09: FULLWIDTH RIGHT PARENTHESIS
      ,")", // Folded result

       "⸩"  // U+2E29: RIGHT DOUBLE PARENTHESIS
      ,"))", // Folded result

       "❬"  // U+276C: MEDIUM LEFT-POINTING ANGLE BRACKET ORNAMENT
       + "❰"  // U+2770: HEAVY LEFT-POINTING ANGLE BRACKET ORNAMENT
       + "＜"  // U+FF1C: FULLWIDTH LESS-THAN SIGN
      ,"<", // Folded result

       "❭"  // U+276D: MEDIUM RIGHT-POINTING ANGLE BRACKET ORNAMENT
       + "❱"  // U+2771: HEAVY RIGHT-POINTING ANGLE BRACKET ORNAMENT
       + "＞"  // U+FF1E: FULLWIDTH GREATER-THAN SIGN
      ,">", // Folded result

       "❴"  // U+2774: MEDIUM LEFT CURLY BRACKET ORNAMENT
       + "｛"  // U+FF5B: FULLWIDTH LEFT CURLY BRACKET
      ,"{", // Folded result

       "❵"  // U+2775: MEDIUM RIGHT CURLY BRACKET ORNAMENT
       + "｝"  // U+FF5D: FULLWIDTH RIGHT CURLY BRACKET
      ,"}", // Folded result

       "⁺"  // U+207A: SUPERSCRIPT PLUS SIGN
       + "₊"  // U+208A: SUBSCRIPT PLUS SIGN
       + "＋"  // U+FF0B: FULLWIDTH PLUS SIGN
      ,"+", // Folded result

       "⁼"  // U+207C: SUPERSCRIPT EQUALS SIGN
       + "₌"  // U+208C: SUBSCRIPT EQUALS SIGN
       + "＝"  // U+FF1D: FULLWIDTH EQUALS SIGN
      ,"=", // Folded result

       "！"  // U+FF01: FULLWIDTH EXCLAMATION MARK
      ,"!", // Folded result

       "‼"  // U+203C: DOUBLE EXCLAMATION MARK
      ,"!!", // Folded result

       "⁉"  // U+2049: EXCLAMATION QUESTION MARK
      ,"!?", // Folded result

       "＃"  // U+FF03: FULLWIDTH NUMBER SIGN
      ,"#", // Folded result

       "＄"  // U+FF04: FULLWIDTH DOLLAR SIGN
      ,"$", // Folded result

       "⁒"  // U+2052: COMMERCIAL MINUS SIGN
       + "％"  // U+FF05: FULLWIDTH PERCENT SIGN
      ,"%", // Folded result

       "＆"  // U+FF06: FULLWIDTH AMPERSAND
      ,"&", // Folded result

       "⁎"  // U+204E: LOW ASTERISK
       + "＊"  // U+FF0A: FULLWIDTH ASTERISK
      ,"*", // Folded result

       "，"  // U+FF0C: FULLWIDTH COMMA
      ,",", // Folded result

       "．"  // U+FF0E: FULLWIDTH FULL STOP
      ,".", // Folded result

       "⁄"  // U+2044: FRACTION SLASH
       + "／"  // U+FF0F: FULLWIDTH SOLIDUS
      ,"/", // Folded result

       "："  // U+FF1A: FULLWIDTH COLON
      ,":", // Folded result

       "⁏"  // U+204F: REVERSED SEMICOLON
       + "；"  // U+FF1B: FULLWIDTH SEMICOLON
      ,";", // Folded result

       "？"  // U+FF1F: FULLWIDTH QUESTION MARK
      ,"?", // Folded result

       "⁇"  // U+2047: DOUBLE QUESTION MARK
      ,"??", // Folded result

       "⁈"  // U+2048: QUESTION EXCLAMATION MARK
      ,"?!", // Folded result

       "＠"  // U+FF20: FULLWIDTH COMMERCIAL AT
      ,"@", // Folded result

       "＼"  // U+FF3C: FULLWIDTH REVERSE SOLIDUS
      ,"\\", // Folded result

       "‸"  // U+2038: CARET
       + "＾"  // U+FF3E: FULLWIDTH CIRCUMFLEX ACCENT
      ,"^", // Folded result

       "＿"  // U+FF3F: FULLWIDTH LOW LINE
      ,"_", // Folded result

       "⁓"  // U+2053: SWUNG DASH
       + "～"  // U+FF5E: FULLWIDTH TILDE
      ,"~", // Folded result
    };

    // Construct input text and expected output tokens
    List expectedOutputTokens = new ArrayList();
    StringBuilder inputText = new StringBuilder();
    for (int n = 0 ; n < foldings.length ; n += 2) {
      if (n > 0) {
        inputText.append(' ');  // Space between tokens
      }
      inputText.append(foldings[n]);

      // Construct the expected output token: the ASCII string to fold to,
      // duplicated as many times as the number of characters in the input text.
      StringBuilder expected = new StringBuilder();
      int numChars = foldings[n].length();
      for (int m = 0 ; m < numChars; ++m) {
        expected.append(foldings[n + 1]);
      }
      expectedOutputTokens.add(expected.toString());
    }

    TokenStream stream = new WhitespaceTokenizer(new StringReader(inputText.toString()));
    ASCIIFoldingFilter filter = new ASCIIFoldingFilter(stream);
    TermAttribute termAtt = filter.getAttribute(TermAttribute.class);
    Iterator expectedIter = expectedOutputTokens.iterator();
    while (expectedIter.hasNext()) {;
      assertTermEquals((String)expectedIter.next(), filter, termAtt);
    }
    assertFalse(filter.incrementToken());
  }
,
>
, <(startLine=1105 endLine=1124 srcPath=/home/sonia/NewExperiment/luceneFilter/00670/lucene/src/test/org/apache/lucene/index/TestIndexReaderReopen.java)
  public void testCloseOrig() throws Throwable {
    Directory dir = new MockRAMDirectory();
    createIndex(dir, false);
    IndexReader r1 = IndexReader.open(dir, false);
    IndexReader r2 = IndexReader.open(dir, false);
    r2.deleteDocument(0);
    r2.close();

    IndexReader r3 = r1.reopen();
    assertTrue(r1 != r3);
    r1.close();
    try {
      r1.document(2);
      fail("did not hit exception");
    } catch (AlreadyClosedException ace) {
      // expected
    }
    r3.close();
    dir.close();
  }
,
(startLine=1104 endLine=1123 srcPath=/home/sonia/NewExperiment/luceneFilter/00670/lucene/backwards/src/test/org/apache/lucene/index/TestIndexReaderReopen.java)
  public void testCloseOrig() throws Throwable {
    Directory dir = new MockRAMDirectory();
    createIndex(dir, false);
    IndexReader r1 = IndexReader.open(dir, false);
    IndexReader r2 = IndexReader.open(dir, false);
    r2.deleteDocument(0);
    r2.close();

    IndexReader r3 = r1.reopen();
    assertTrue(r1 != r3);
    r1.close();
    try {
      r1.document(2);
      fail("did not hit exception");
    } catch (AlreadyClosedException ace) {
      // expected
    }
    r3.close();
    dir.close();
  }
,
>
, <(startLine=308 endLine=337 srcPath=/home/sonia/NewExperiment/luceneFilter/00696/lucene/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java)
  public void testSpans2() throws Exception {
    SpanQuery qA1 = new SpanTermQuery(new Term("gender", "female"));
    SpanQuery qA2 = new SpanTermQuery(new Term("first",  "james"));
    SpanQuery qA  = new SpanOrQuery(new SpanQuery[]
      { qA1, new FieldMaskingSpanQuery(qA2, "gender")});
    SpanQuery qB  = new SpanTermQuery(new Term("last",   "jones"));
    SpanQuery q   = new SpanNearQuery(new SpanQuery[]
      { new FieldMaskingSpanQuery(qA, "id"),
        new FieldMaskingSpanQuery(qB, "id") }, -1, false );
    check(q, new int[] { 0, 1, 2, 3 });
  
    Spans span = q.getSpans(searcher.getIndexReader());
    
    assertEquals(true, span.next());
    assertEquals(s(0,0,1), s(span));

    assertEquals(true, span.next());
    assertEquals(s(1,1,2), s(span));

    assertEquals(true, span.next());
    assertEquals(s(2,0,1), s(span));

    assertEquals(true, span.next());
    assertEquals(s(2,2,3), s(span));

    assertEquals(true, span.next());
    assertEquals(s(3,0,1), s(span));

    assertEquals(false, span.next());
  }
,
(startLine=309 endLine=338 srcPath=/home/sonia/NewExperiment/luceneFilter/00696/lucene/backwards/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java)
  public void testSpans2() throws Exception {
    SpanQuery qA1 = new SpanTermQuery(new Term("gender", "female"));
    SpanQuery qA2 = new SpanTermQuery(new Term("first",  "james"));
    SpanQuery qA  = new SpanOrQuery(new SpanQuery[]
      { qA1, new FieldMaskingSpanQuery(qA2, "gender")});
    SpanQuery qB  = new SpanTermQuery(new Term("last",   "jones"));
    SpanQuery q   = new SpanNearQuery(new SpanQuery[]
      { new FieldMaskingSpanQuery(qA, "id"),
        new FieldMaskingSpanQuery(qB, "id") }, -1, false );
    check(q, new int[] { 0, 1, 2, 3 });
  
    Spans span = q.getSpans(searcher.getIndexReader());
    
    assertEquals(true, span.next());
    assertEquals(s(0,0,1), s(span));

    assertEquals(true, span.next());
    assertEquals(s(1,1,2), s(span));

    assertEquals(true, span.next());
    assertEquals(s(2,0,1), s(span));

    assertEquals(true, span.next());
    assertEquals(s(2,2,3), s(span));

    assertEquals(true, span.next());
    assertEquals(s(3,0,1), s(span));

    assertEquals(false, span.next());
  }
,
>
, <(startLine=204 endLine=214 srcPath=/home/sonia/NewExperiment/luceneFilter/02238/lucene/core/src/test/org/apache/lucene/index/TestMultiDocValues.java)
    for (int i = 0; i < numDocs; i++) {
      Document doc = new Document();
      int numValues = random().nextInt(5);
      for (int j = 0; j < numValues; j++) {
        doc.add(new SortedSetDocValuesField("bytes", new BytesRef(TestUtil.randomUnicodeString(random()))));
      }
      iw.addDocument(doc);
      if (random().nextInt(17) == 0) {
        iw.commit();
      }
    }
,
(startLine=267 endLine=277 srcPath=/home/sonia/NewExperiment/luceneFilter/02238/lucene/core/src/test/org/apache/lucene/index/TestMultiDocValues.java)
    for (int i = 0; i < numDocs; i++) {
      Document doc = new Document();
      int numValues = random().nextInt(5);
      for (int j = 0; j < numValues; j++) {
        doc.add(new SortedSetDocValuesField("bytes", new BytesRef(TestUtil.randomSimpleString(random(), 2))));
      }
      iw.addDocument(doc);
      if (random().nextInt(17) == 0) {
        iw.commit();
      }
    }
,
(startLine=329 endLine=339 srcPath=/home/sonia/NewExperiment/luceneFilter/02238/lucene/core/src/test/org/apache/lucene/index/TestMultiDocValues.java)
    for (int i = 0; i < numDocs; i++) {
      Document doc = new Document();
      int numValues = random().nextInt(5);
      for (int j = 0; j < numValues; j++) {
        doc.add(new SortedNumericDocValuesField("nums", TestUtil.nextLong(random(), Long.MIN_VALUE, Long.MAX_VALUE)));
      }
      iw.addDocument(doc);
      if (random().nextInt(17) == 0) {
        iw.commit();
      }
    }
,
>
, <(startLine=213 endLine=222 srcPath=/home/sonia/NewExperiment/luceneFilter/00647/solr/src/test/org/apache/solr/TestTrie.java)
    for (int i = 0; i < 10; i++) {
      long l = Integer.MAX_VALUE + i*1L;
      // index 10 days starting with today
      String d = format.format(i == 0 ? dmp.parseMath("/DAY") : dmp.parseMath("/DAY+" + i + "DAYS"));
      assertU(adoc("id", String.valueOf(i), "tint", String.valueOf(i),
              "tlong", String.valueOf(l),
              "tfloat", String.valueOf(i * i * 31.11f),
              "tdouble", String.valueOf(i * 2.33d),
              "tdate", d));
    }
,
(startLine=223 endLine=231 srcPath=/home/sonia/NewExperiment/luceneFilter/00647/solr/src/test/org/apache/solr/TestTrie.java)
    for (int i = 0; i < 5; i++) {
      long l = Integer.MAX_VALUE + i*1L;
      String d = format.format(i == 0 ? dmp.parseMath("/DAY") : dmp.parseMath("/DAY+" + i + "DAYS"));
      assertU(adoc("id", String.valueOf((i+1)*10), "tint", String.valueOf(i),
              "tlong", String.valueOf(l),
              "tfloat", String.valueOf(i * i * 31.11f),
              "tdouble", String.valueOf(i * 2.33d),
              "tdate", d));
    }
,
>
, <(startLine=264 endLine=276 srcPath=/home/sonia/NewExperiment/luceneFilter/02105/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter.java)
    } else {
      bytes = field.binaryValue();
      if (bytes != null) {
        bits = BYTE_ARR;
        string = null;
      } else {
        bits = STRING;
        string = field.stringValue();
        if (string == null) {
          throw new IllegalArgumentException("field " + field.name() + " is stored but does not have binaryValue, stringValue nor numericValue");
        }
      }
    }
,
(startLine=167 endLine=178 srcPath=/home/sonia/NewExperiment/luceneFilter/02105/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40StoredFieldsWriter.java)
    } else {
      bytes = field.binaryValue();
      if (bytes != null) {
        bits |= FIELD_IS_BINARY;
        string = null;
      } else {
        string = field.stringValue();
        if (string == null) {
          throw new IllegalArgumentException("field " + field.name() + " is stored but does not have binaryValue, stringValue nor numericValue");
        }
      }
    }
,
>
, <(startLine=95 endLine=117 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/src/test/org/apache/lucene/document/TestDocument.java)
  {
    Document doc = makeDocumentWithFields();
    assertEquals(8, doc.fields.size());
    doc.removeFields("keyword");
    assertEquals(6, doc.fields.size());
    doc.removeFields("doesnotexists");      // removing non-existing fields is siltenlty ignored
    doc.removeFields("keyword");        // removing a field more than once
    assertEquals(6, doc.fields.size());
    doc.removeField("text");
    assertEquals(5, doc.fields.size());
    doc.removeField("text");
    assertEquals(4, doc.fields.size());
    doc.removeField("text");
    assertEquals(4, doc.fields.size());
    doc.removeField("doesnotexists");       // removing non-existing fields is siltenlty ignored
    assertEquals(4, doc.fields.size());
    doc.removeFields("unindexed");
    assertEquals(2, doc.fields.size());
    doc.removeFields("unstored");
    assertEquals(0, doc.fields.size());
    doc.removeFields("doesnotexists");    // removing non-existing fields is siltenlty ignored
    assertEquals(0, doc.fields.size());
  }
,
(startLine=94 endLine=116 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/backwards/src/test/org/apache/lucene/document/TestDocument.java)
  {
    Document doc = makeDocumentWithFields();
    assertEquals(8, doc.fields.size());
    doc.removeFields("keyword");
    assertEquals(6, doc.fields.size());
    doc.removeFields("doesnotexists");      // removing non-existing fields is siltenlty ignored
    doc.removeFields("keyword");        // removing a field more than once
    assertEquals(6, doc.fields.size());
    doc.removeField("text");
    assertEquals(5, doc.fields.size());
    doc.removeField("text");
    assertEquals(4, doc.fields.size());
    doc.removeField("text");
    assertEquals(4, doc.fields.size());
    doc.removeField("doesnotexists");       // removing non-existing fields is siltenlty ignored
    assertEquals(4, doc.fields.size());
    doc.removeFields("unindexed");
    assertEquals(2, doc.fields.size());
    doc.removeFields("unstored");
    assertEquals(0, doc.fields.size());
    doc.removeFields("doesnotexists");    // removing non-existing fields is siltenlty ignored
    assertEquals(0, doc.fields.size());
  }
,
>
, <(startLine=656 endLine=667 srcPath=/home/sonia/NewExperiment/luceneFilter/00720/solr/src/common/org/apache/solr/common/util/JavaBinCodec.java)
    for (int i = start; i < end; i++) {
      int b = in.read();
      if ((b & 0x80) == 0)
        buffer[i] = (char) b;
      else if ((b & 0xE0) != 0xE0) {
        buffer[i] = (char) (((b & 0x1F) << 6)
                | (in.read() & 0x3F));
      } else
        buffer[i] = (char) (((b & 0x0F) << 12)
                | ((in.read() & 0x3F) << 6)
                | (in.read() & 0x3F));
    }
,
(startLine=61 endLine=72 srcPath=/home/sonia/NewExperiment/luceneFilter/00720/solr/src/test/org/apache/solr/common/util/TestFastInputStream.java)
    for (int i = start; i < end; i++) {
      int b = in.read();
      if ((b & 0x80) == 0)
        buffer[i] = (char) b;
      else if ((b & 0xE0) != 0xE0) {
        buffer[i] = (char) (((b & 0x1F) << 6)
                | (in.read() & 0x3F));
      } else
        buffer[i] = (char) (((b & 0x0F) << 12)
                | ((in.read() & 0x3F) << 6)
                | (in.read() & 0x3F));
    }
,
>
, <(startLine=118 endLine=124 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/src/test/org/apache/lucene/search/TestElevationComparator.java)
 private Document adoc(String[] vals) {
   Document doc = new Document();
   for (int i = 0; i < vals.length - 2; i += 2) {
     doc.add(new Field(vals[i], vals[i + 1], Field.Store.YES, Field.Index.ANALYZED));
   }
   return doc;
 }
,
(startLine=119 endLine=125 srcPath=/home/sonia/NewExperiment/luceneFilter/00650/backwards/src/test/org/apache/lucene/search/TestElevationComparator.java)
 private Document adoc(String[] vals) {
   Document doc = new Document();
   for (int i = 0; i < vals.length - 2; i += 2) {
     doc.add(new Field(vals[i], vals[i + 1], Field.Store.YES, Field.Index.ANALYZED));
   }
   return doc;
 }
,
>
, <(startLine=110 endLine=134 srcPath=/home/sonia/NewExperiment/luceneFilter/00702/lucene/src/test/org/apache/lucene/search/function/TestOrdValues.java)
  private void doTestExactScore(String field, boolean inOrder) throws CorruptIndexException, Exception {
    IndexSearcher s = new IndexSearcher(dir, true);
    ValueSource vs;
    if (inOrder) {
      vs = new OrdFieldSource(field);
    } else {
      vs = new ReverseOrdFieldSource(field);
    }
    Query q = new ValueSourceQuery(vs);
    TopDocs td = s.search(q, null, 1000);
    assertEquals("All docs should be matched!", N_DOCS, td.totalHits);
    ScoreDoc sd[] = td.scoreDocs;
    for (int i = 0; i < sd.length; i++) {
      float score = sd[i].score;
      String id = s.getIndexReader().document(sd[i].doc).get(ID_FIELD);
      log("-------- " + i + ". Explain doc " + id);
      log(s.explain(q, sd[i].doc));
      float expectedScore = N_DOCS - i;
      assertEquals("score of result " + i + " shuould be " + expectedScore + " != " + score, expectedScore, score, TEST_SCORE_TOLERANCE_DELTA);
      String expectedId = inOrder
              ? id2String(N_DOCS - i) // in-order ==> larger  values first
              : id2String(i + 1);     // reverse  ==> smaller values first
      assertTrue("id of result " + i + " shuould be " + expectedId + " != " + score, expectedId.equals(id));
    }
  }
,
(startLine=100 endLine=124 srcPath=/home/sonia/NewExperiment/luceneFilter/00702/lucene/backwards/src/test/org/apache/lucene/search/function/TestOrdValues.java)
  private void doTestExactScore (String field, boolean inOrder) throws CorruptIndexException, Exception {
    IndexSearcher s = new IndexSearcher(dir, true);
    ValueSource vs;
    if (inOrder) {
      vs = new OrdFieldSource(field);
    } else {
      vs = new ReverseOrdFieldSource(field);
    }
    Query q = new ValueSourceQuery(vs);
    TopDocs td = s.search(q,null,1000);
    assertEquals("All docs should be matched!",N_DOCS,td.totalHits);
    ScoreDoc sd[] = td.scoreDocs;
    for (int i=0; i<sd.length; i++) {
      float score = sd[i].score;
      String id = s.getIndexReader().document(sd[i].doc).get(ID_FIELD);
      log("-------- "+i+". Explain doc "+id);
      log(s.explain(q,sd[i].doc));
      float expectedScore =  N_DOCS-i;
      assertEquals("score of result "+i+" shuould be "+expectedScore+" != "+score, expectedScore, score, TEST_SCORE_TOLERANCE_DELTA);
      String expectedId =  inOrder 
        ? id2String(N_DOCS-i) // in-order ==> larger  values first 
        : id2String(i+1);     // reverse  ==> smaller values first 
      assertTrue("id of result "+i+" shuould be "+expectedId+" != "+score, expectedId.equals(id));
    }
  }
,
>
, <(startLine=63 endLine=83 srcPath=/home/sonia/NewExperiment/luceneFilter/01737/lucene/facet/src/java/org/apache/lucene/facet/encoding/EightFlagsIntDecoder.java)
      while (ordinal != 8) {
        if (DECODE_TABLE[indicator][ordinal++] == 0) {
          if (offset == upto) { // end of buffer
            return;
          }
          // it is better if the decoding is inlined like so, and not e.g.
          // in a utility method
          int value = 0;
          while (true) {
            byte b = buf.bytes[offset++];
            if (b >= 0) {
              values.ints[values.length++] = ((value << 7) | b) + 2;
              break;
            } else {
              value = (value << 7) | (b & 0x7F);
            }
          }
        } else {
          values.ints[values.length++] = 1;
        }
      }
,
(startLine=62 endLine=83 srcPath=/home/sonia/NewExperiment/luceneFilter/01737/lucene/facet/src/java/org/apache/lucene/facet/encoding/FourFlagsIntDecoder.java)
      while (ordinal != 4) {
        byte decodeVal = DECODE_TABLE[indicator][ordinal++];
        if (decodeVal == 0) {
          if (offset == upto) { // end of buffer
            return;
          }
          // it is better if the decoding is inlined like so, and not e.g.
          // in a utility method
          int value = 0;
          while (true) {
            byte b = buf.bytes[offset++];
            if (b >= 0) {
              values.ints[values.length++] = ((value << 7) | b) + 4;
              break;
            } else {
              value = (value << 7) | (b & 0x7F);
            }
          }
        } else {
          values.ints[values.length++] = decodeVal;
        }
      }
,
>
, <(startLine=104 endLine=116 srcPath=/home/sonia/NewExperiment/luceneFilter/00434/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java)
    public void testOneReqAndSomeOptional() throws Exception {

        /* one required, some optional */
        BooleanQuery q = new BooleanQuery();
        q.add(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.SHOULD);//false, false);

        q.setMinimumNumberShouldMatch(2); // 2 of 3 optional 

        verifyNrHits(q, 5);
    }
,
(startLine=118 endLine=131 srcPath=/home/sonia/NewExperiment/luceneFilter/00434/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java)
    public void testSomeReqAndSomeOptional() throws Exception {

        /* two required, some optional */
        BooleanQuery q = new BooleanQuery();
        q.add(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.SHOULD);//false, false);

        q.setMinimumNumberShouldMatch(2); // 2 of 3 optional 

        verifyNrHits(q, 5);
    }
,
(startLine=133 endLine=145 srcPath=/home/sonia/NewExperiment/luceneFilter/00434/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java)
    public void testOneProhibAndSomeOptional() throws Exception {

        /* one prohibited, some optional */
        BooleanQuery q = new BooleanQuery();
        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);

        q.setMinimumNumberShouldMatch(2); // 2 of 3 optional 

        verifyNrHits(q, 1);
    }
,
(startLine=147 endLine=160 srcPath=/home/sonia/NewExperiment/luceneFilter/00434/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java)
    public void testSomeProhibAndSomeOptional() throws Exception {

        /* two prohibited, some optional */
        BooleanQuery q = new BooleanQuery();
        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT);//false, true );

        q.setMinimumNumberShouldMatch(2); // 2 of 3 optional 

        verifyNrHits(q, 1);
    }
,
(startLine=162 endLine=176 srcPath=/home/sonia/NewExperiment/luceneFilter/00434/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java)
    public void testOneReqOneProhibAndSomeOptional() throws Exception {

        /* one required, one prohibited, some optional */
        BooleanQuery q = new BooleanQuery();
        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);// true,  false);
        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);

        q.setMinimumNumberShouldMatch(3); // 3 of 4 optional 

        verifyNrHits(q, 1);
    }
,
(startLine=178 endLine=193 srcPath=/home/sonia/NewExperiment/luceneFilter/00434/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java)
    public void testSomeReqOneProhibAndSomeOptional() throws Exception {

        /* two required, one prohibited, some optional */
        BooleanQuery q = new BooleanQuery();
        q.add(new TermQuery(new Term("all",  "all")), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);

        q.setMinimumNumberShouldMatch(3); // 3 of 4 optional 

        verifyNrHits(q, 1);
    }
,
(startLine=195 endLine=210 srcPath=/home/sonia/NewExperiment/luceneFilter/00434/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java)
    public void testOneReqSomeProhibAndSomeOptional() throws Exception {

        /* one required, two prohibited, some optional */
        BooleanQuery q = new BooleanQuery();
        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT);//false, true );

        q.setMinimumNumberShouldMatch(3); // 3 of 4 optional 

        verifyNrHits(q, 1);
    }
,
(startLine=212 endLine=228 srcPath=/home/sonia/NewExperiment/luceneFilter/00434/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java)
    public void testSomeReqSomeProhibAndSomeOptional() throws Exception {

        /* two required, two prohibited, some optional */
        BooleanQuery q = new BooleanQuery();
        q.add(new TermQuery(new Term("all",  "all")), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT);//false, true );

        q.setMinimumNumberShouldMatch(3); // 3 of 4 optional 

        verifyNrHits(q, 1);
    }
,
(startLine=230 endLine=246 srcPath=/home/sonia/NewExperiment/luceneFilter/00434/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java)
    public void testMinHigherThenNumOptional() throws Exception {

        /* two required, two prohibited, some optional */
        BooleanQuery q = new BooleanQuery();
        q.add(new TermQuery(new Term("all",  "all")), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "5"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "4"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST_NOT);//false, true );
        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "1"  )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "C"  )), BooleanClause.Occur.MUST_NOT);//false, true );

        q.setMinimumNumberShouldMatch(90); // 90 of 4 optional ?!?!?!

        verifyNrHits(q, 0);
    }
,
(startLine=248 endLine=260 srcPath=/home/sonia/NewExperiment/luceneFilter/00434/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java)
    public void testMinEqualToNumOptional() throws Exception {

        /* two required, two optional */
        BooleanQuery q = new BooleanQuery();
        q.add(new TermQuery(new Term("all", "all" )), BooleanClause.Occur.SHOULD);//false, false);
        q.add(new TermQuery(new Term("data", "6"  )), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "3"  )), BooleanClause.Occur.MUST);//true,  false);
        q.add(new TermQuery(new Term("data", "2"  )), BooleanClause.Occur.SHOULD);//false, false);

        q.setMinimumNumberShouldMatch(2); // 2 of 2 optional 

        verifyNrHits(q, 1);
    }
,
>
, <(startLine=51 endLine=57 srcPath=/home/sonia/NewExperiment/luceneFilter/03278/lucene/core/src/java/org/apache/lucene/codecs/Codec.java)
    static NamedSPILoader<Codec> getLoader() {
      if (LOADER == null) {
        throw new IllegalStateException("You tried to lookup a Codec by name before all Codecs could be initialized. "+
          "This likely happens if you call Codec#forName from a Codec's ctor.");
      }
      return LOADER;
    }
,
(startLine=52 endLine=58 srcPath=/home/sonia/NewExperiment/luceneFilter/03278/lucene/core/src/java/org/apache/lucene/codecs/DocValuesFormat.java)
    static NamedSPILoader<DocValuesFormat> getLoader() {
      if (LOADER == null) {
        throw new IllegalStateException("You tried to lookup a DocValuesFormat by name before all formats could be initialized. "+
          "This likely happens if you call DocValuesFormat#forName from a DocValuesFormat's ctor.");
      }
      return LOADER;
    }
,
(startLine=53 endLine=59 srcPath=/home/sonia/NewExperiment/luceneFilter/03278/lucene/core/src/java/org/apache/lucene/codecs/PostingsFormat.java)
    static NamedSPILoader<PostingsFormat> getLoader() {
      if (LOADER == null) {
        throw new IllegalStateException("You tried to lookup a PostingsFormat by name before all formats could be initialized. "+
          "This likely happens if you call PostingsFormat#forName from a PostingsFormat's ctor.");
      }
      return LOADER;
    }
,
>
, <(startLine=207 endLine=229 srcPath=/home/sonia/NewExperiment/luceneFilter/00659/lucene/contrib/swing/src/java/org/apache/lucene/swing/models/ListSearcher.java)
    private void resetSearchResults(IndexSearcher searcher, Query query) {
        try {
            //clear our index mapping this list model rows to
            //the decorated inner list model
            rowToModelIndex.clear();
            
            CountingCollector countingCollector = new CountingCollector();
            searcher.search(query, countingCollector);
            ScoreDoc[] hits = searcher.search(query, countingCollector.numHits).scoreDocs;
            
            //iterate through the hits
            //get the row number stored at the index
            //that number is the row number of the decorated
            //table model row that we are mapping to
            for (int t=0; t<hits.length; t++){
                Document document = searcher.doc(hits[t].doc);
                Fieldable field = document.getField(ROW_NUMBER);
                rowToModelIndex.add(Integer.valueOf(field.stringValue()));
            }
        } catch (Exception e){
            e.printStackTrace();
        }
    }
,
(startLine=265 endLine=287 srcPath=/home/sonia/NewExperiment/luceneFilter/00659/lucene/contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher.java)
    private void resetSearchResults(IndexSearcher searcher, Query query) {
        try {
            //clear our index mapping this table model rows to
            //the decorated inner table model
            rowToModelIndex.clear();
            
            CountingCollector countingCollector = new CountingCollector();
            searcher.search(query, countingCollector);
            ScoreDoc[] hits = searcher.search(query, countingCollector.numHits).scoreDocs;
            
            //iterate through the hits
            //get the row number stored at the index
            //that number is the row number of the decorated
            //table model row that we are mapping to
            for (int t=0; t<hits.length; t++){
                Document document = searcher.doc(hits[t].doc);
                Fieldable field = document.getField(ROW_NUMBER);
                rowToModelIndex.add(Integer.valueOf(field.stringValue()));
            }
        } catch (Exception e){
            e.printStackTrace();
        }
    }
,
>
, <(startLine=344 endLine=362 srcPath=/home/sonia/NewExperiment/luceneFilter/02404/solr/core/src/java/org/apache/solr/SolrLogFormatter.java)
    for (;;) {
      if (idx < 0) {
        if (lastIdx == -1) {
          addFirstLine(sb, msg.substring(lastIdx+1));
        } else {
          sb.append(msg.substring(lastIdx+1));
        }
        break;
      }
      if (lastIdx == -1) {
        addFirstLine(sb, msg.substring(lastIdx+1, idx));
      } else {
        sb.append(msg.substring(lastIdx+1, idx));
      }

      sb.append("\n\t");
      lastIdx = idx;
      idx = msg.indexOf('\n',lastIdx+1);
    }
,
(startLine=294 endLine=312 srcPath=/home/sonia/NewExperiment/luceneFilter/02404/solr/core/src/java/org/apache/solr/util/SolrLogLayout.java)
    for (;;) {
      if (idx < 0) {
        if (lastIdx == -1) {
          addFirstLine(sb, msg.substring(lastIdx + 1));
        } else {
          sb.append(msg.substring(lastIdx + 1));
        }
        break;
      }
      if (lastIdx == -1) {
        addFirstLine(sb, msg.substring(lastIdx + 1, idx));
      } else {
        sb.append(msg.substring(lastIdx + 1, idx));
      }
      
      sb.append("\n\t");
      lastIdx = idx;
      idx = msg.indexOf('\n', lastIdx + 1);
    }
,
>
, <(startLine=137 endLine=154 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java)
        do {
          termCount++;
          // System.out.println("  iter termCount=" + termCount + " term=" +
          // enumerator.term().toBytesString());
          docsEnum = termsEnum.docs(delDocs, docsEnum);
          final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();
          while (true) {
            final int count = docsEnum.read();
            if (count != 0) {
              final int[] docs = result.docs.ints;
              for (int i = 0; i < count; i++) {
                bitSet.set(docs[i]);
              }
            } else {
              break;
            }
          }
        } while (termsEnum.next() != null);
,
(startLine=137 endLine=154 srcPath=/home/sonia/NewExperiment/luceneFilter/00693/lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java)
        do {
          termCount++;
          // System.out.println("  iter termCount=" + termCount + " term=" +
          // enumerator.term().toBytesString());
          docsEnum = termsEnum.docs(delDocs, docsEnum);
          final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();
          while (true) {
            final int count = docsEnum.read();
            if (count != 0) {
              final int[] docs = result.docs.ints;
              for (int i = 0; i < count; i++) {
                bitSet.set(docs[i]);
              }
            } else {
              break;
            }
          }
        } while (termsEnum.next() != null);
,
>
, <(startLine=51 endLine=81 srcPath=/home/sonia/NewExperiment/luceneFilter/02032/solr/core/src/test/org/apache/solr/search/similarities/TestSweetSpotSimilarityFactory.java)
  public void testBaselineParameters() throws Exception {
    SweetSpotSimilarity sim = getSimilarity("text_baseline", 
                                            SweetSpotSimilarity.class);
    
    DefaultSimilarity d = new DefaultSimilarity();

    // constant up to 6
    for (int i = 1; i <=6; i++) {
      assertEquals("tf i="+i, 1.5F, sim.tf(i), 0.0F);
    }
    // less then default sim above 6
    for (int i = 6; i <=1000; i++) {
      assertTrue("tf: i="+i+" : s="+sim.tf(i)+
                 " < d="+d.tf(i),
                 sim.tf(i) < d.tf(i));
    }

    // norms: plateau from 3-5
    assertEquals("norm 1 == 7", 
                 sim.computeLengthNorm(1), sim.computeLengthNorm(7),  0.0F);
    assertEquals("norm 2 == 6",  
                 sim.computeLengthNorm(1), sim.computeLengthNorm(7),  0.0F);
    assertEquals("norm 3",  1.00F, sim.computeLengthNorm(3),  0.0F);
    assertEquals("norm 4",  1.00F, sim.computeLengthNorm(4),  0.0F);
    assertEquals("norm 5",  1.00F, sim.computeLengthNorm(5),  0.0F);
    assertTrue("norm 6 too high: " + sim.computeLengthNorm(6),
               sim.computeLengthNorm(6) < 1.0F);
    assertTrue("norm 7 higher then norm 6", 
               sim.computeLengthNorm(7) < sim.computeLengthNorm(6));
    assertEquals("norm 20", 0.25F, sim.computeLengthNorm(20), 0.0F);
  }
,
(startLine=84 endLine=108 srcPath=/home/sonia/NewExperiment/luceneFilter/02032/solr/core/src/test/org/apache/solr/search/similarities/TestSweetSpotSimilarityFactory.java)
  public void testHyperbolicParameters() throws Exception {
    SweetSpotSimilarity sim = getSimilarity("text_hyperbolic", 
                                            SweetSpotSimilarity.class);

    for (int i = 1; i <=1000; i++) {
      assertTrue("MIN tf: i="+i+" : s="+sim.tf(i),
                 3.3F <= sim.tf(i));
      assertTrue("MAX tf: i="+i+" : s="+sim.tf(i),
                 sim.tf(i) <= 7.7F);
    }
    assertEquals("MID tf", 3.3F+(7.7F - 3.3F)/2.0F, sim.tf(5), 0.00001F);

    // norms: plateau from 1-5, shallow slope
    assertEquals("norm 1",  1.00F, sim.computeLengthNorm(1),  0.0F);
    assertEquals("norm 2",  1.00F, sim.computeLengthNorm(2),  0.0F);
    assertEquals("norm 3",  1.00F, sim.computeLengthNorm(3),  0.0F);
    assertEquals("norm 4",  1.00F, sim.computeLengthNorm(4),  0.0F);
    assertEquals("norm 5",  1.00F, sim.computeLengthNorm(5),  0.0F);
    assertTrue("norm 6 too high: " + sim.computeLengthNorm(6),
               sim.computeLengthNorm(6) < 1.0F);
    assertTrue("norm 7 higher then norm 6", 
               sim.computeLengthNorm(7) < sim.computeLengthNorm(6));
    assertTrue("norm 20 not high enough: " + sim.computeLengthNorm(20),
               0.25F < sim.computeLengthNorm(20));
  }
,
>
, <(startLine=522 endLine=544 srcPath=/home/sonia/NewExperiment/luceneFilter/03345/lucene/spatial-extras/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java)
    } else if (!bbox.getCrossesDateLine()) {
      // queries that do not cross the date line

      // docMinX >= queryExtent.getMinX() AND docMaxX <= queryExtent.getMaxX()
      Query qMinX = this.makeNumericRangeQuery(field_minX, bbox.getMinX(), null, true, false);
      Query qMaxX = this.makeNumericRangeQuery(field_maxX, null, bbox.getMaxX(), false, true);
      Query qMinMax = this.makeQuery(BooleanClause.Occur.MUST, qMinX, qMaxX);

      double edge = 0;//none, otherwise opposite dateline of query
      if (bbox.getMinX() == -180.0)
        edge = 180;
      else if (bbox.getMaxX() == 180.0)
        edge = -180;
      if (edge != 0 && ctx.isGeo()) {
        Query edgeQ = makeQuery(BooleanClause.Occur.MUST,
            makeNumberTermQuery(field_minX, edge), makeNumberTermQuery(field_maxX, edge));
        qMinMax = makeQuery(BooleanClause.Occur.SHOULD, qMinMax, edgeQ);
      }

      xConditions = this.makeXDL(false, qMinMax);

      // queries that cross the date line
    } else {
,
(startLine=568 endLine=590 srcPath=/home/sonia/NewExperiment/luceneFilter/03345/solr/core/src/java/org/apache/solr/legacy/BBoxStrategy.java)
    } else if (!bbox.getCrossesDateLine()) {
      // queries that do not cross the date line

      // docMinX >= queryExtent.getMinX() AND docMaxX <= queryExtent.getMaxX()
      Query qMinX = this.makeNumericRangeQuery(field_minX, bbox.getMinX(), null, true, false);
      Query qMaxX = this.makeNumericRangeQuery(field_maxX, null, bbox.getMaxX(), false, true);
      Query qMinMax = this.makeQuery(BooleanClause.Occur.MUST, qMinX, qMaxX);

      double edge = 0;//none, otherwise opposite dateline of query
      if (bbox.getMinX() == -180.0)
        edge = 180;
      else if (bbox.getMaxX() == 180.0)
        edge = -180;
      if (edge != 0 && ctx.isGeo()) {
        Query edgeQ = makeQuery(BooleanClause.Occur.MUST,
            makeNumberTermQuery(field_minX, edge), makeNumberTermQuery(field_maxX, edge));
        qMinMax = makeQuery(BooleanClause.Occur.SHOULD, qMinMax, edgeQ);
      }

      xConditions = this.makeXDL(false, qMinMax);

      // queries that cross the date line
    } else {
,
>
, <(startLine=285 endLine=295 srcPath=/home/sonia/NewExperiment/luceneFilter/00670/lucene/src/test/org/apache/lucene/search/TestWildcard.java)
    for (int i = 0; i < matchOneDocPrefix.length; i++) {
      for (int j = 0; j < matchOneDocPrefix[i].length; j++) {
        String qtxt = matchOneDocPrefix[i][j];
        Query q = qp.parse(qtxt);
        if (VERBOSE) System.out.println("match 1 prefix: doc="+docs[i]+" qtxt="+qtxt+" q="+q+" "+q.getClass().getName());
        assertEquals(PrefixQuery.class, q.getClass());
        ScoreDoc[] hits = searcher.search(q, null, 1000).scoreDocs;
        assertEquals(1,hits.length);
        assertEquals(i,hits[0].doc);
      }
    }
,
(startLine=298 endLine=308 srcPath=/home/sonia/NewExperiment/luceneFilter/00670/lucene/src/test/org/apache/lucene/search/TestWildcard.java)
    for (int i = 0; i < matchOneDocPrefix.length; i++) {
      for (int j = 0; j < matchOneDocWild[i].length; j++) {
        String qtxt = matchOneDocWild[i][j];
        Query q = qp.parse(qtxt);
        if (VERBOSE) System.out.println("match 1 wild: doc="+docs[i]+" qtxt="+qtxt+" q="+q+" "+q.getClass().getName());
        assertEquals(WildcardQuery.class, q.getClass());
        ScoreDoc[] hits = searcher.search(q, null, 1000).scoreDocs;
        assertEquals(1,hits.length);
        assertEquals(i,hits[0].doc);
      }
    }
,
(startLine=303 endLine=313 srcPath=/home/sonia/NewExperiment/luceneFilter/00670/lucene/backwards/src/test/org/apache/lucene/search/TestWildcard.java)
    for (int i = 0; i < matchOneDocPrefix.length; i++) {
      for (int j = 0; j < matchOneDocPrefix[i].length; j++) {
        String qtxt = matchOneDocPrefix[i][j];
        Query q = qp.parse(qtxt);
        if (dbg) System.out.println("match 1 prefix: doc="+docs[i]+" qtxt="+qtxt+" q="+q+" "+q.getClass().getName());
        assertEquals(PrefixQuery.class, q.getClass());
        ScoreDoc[] hits = searcher.search(q, null, 1000).scoreDocs;
        assertEquals(1,hits.length);
        assertEquals(i,hits[0].doc);
      }
    }
,
(startLine=316 endLine=326 srcPath=/home/sonia/NewExperiment/luceneFilter/00670/lucene/backwards/src/test/org/apache/lucene/search/TestWildcard.java)
    for (int i = 0; i < matchOneDocPrefix.length; i++) {
      for (int j = 0; j < matchOneDocWild[i].length; j++) {
        String qtxt = matchOneDocWild[i][j];
        Query q = qp.parse(qtxt);
        if (dbg) System.out.println("match 1 wild: doc="+docs[i]+" qtxt="+qtxt+" q="+q+" "+q.getClass().getName());
        assertEquals(WildcardQuery.class, q.getClass());
        ScoreDoc[] hits = searcher.search(q, null, 1000).scoreDocs;
        assertEquals(1,hits.length);
        assertEquals(i,hits[0].doc);
      }
    }
,
>
, <(startLine=120 endLine=143 srcPath=/home/sonia/NewExperiment/luceneFilter/01029/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDelta.java)
  public void testCompositePk_DeltaImport_empty() throws Exception {
    List deltaRow = new ArrayList();
    deltaRow.add(createMap("id", "1"));
    MockDataSource.setIterator(DELTA_QUERY, deltaRow.iterator());

    MockDataSource.setIterator(DELETED_PK_QUERY, Collections
        .EMPTY_LIST.iterator());

    List parentRow = new ArrayList();
    parentRow.add(createMap("id", "1"));
    MockDataSource.setIterator("select * from x where id='1'", parentRow
        .iterator());

    List childRow = new ArrayList();
    childRow.add(createMap("desc", "hello"));
    MockDataSource.setIterator("select * from y where y.A='1'",
        childRow.iterator());

    runDeltaImport(dataConfig_delta);

    assertQ(req("*:* OR testCompositePk_DeltaImport_empty"), "//*[@numFound='1']");
    assertQ(req("id:1"), "//*[@numFound='1']");
    assertQ(req("desc:hello"), "//*[@numFound='1']");
  }
,
(startLine=149 endLine=176 srcPath=/home/sonia/NewExperiment/luceneFilter/01029/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDelta.java)
  public void testCompositePk_DeltaImport_replace_delete() throws Exception {
    add1document();
    MockDataSource.clearCache();

    List deltaRow = new ArrayList();
    deltaRow.add(createMap("id", "1"));
    MockDataSource.setIterator(DELTA_QUERY,
        deltaRow.iterator());

    List deletedRow = new ArrayList();
    deletedRow.add(createMap("id", "1"));
    MockDataSource.setIterator(DELETED_PK_QUERY,
        deletedRow.iterator());

    List parentRow = new ArrayList();
    parentRow.add(createMap("id", "1"));
    MockDataSource.setIterator("select * from x where id='1'", parentRow
        .iterator());

    List childRow = new ArrayList();
    childRow.add(createMap("desc", "goodbye"));
    MockDataSource.setIterator("select * from y where y.A='1'", childRow
        .iterator());

    runDeltaImport(dataConfig_delta);

    assertQ(req("*:* OR testCompositePk_DeltaImport_replace_delete"), "//*[@numFound='0']");
  }
,
(startLine=181 endLine=209 srcPath=/home/sonia/NewExperiment/luceneFilter/01029/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDelta.java)
  public void testCompositePk_DeltaImport_replace_nodelete() throws Exception {
    add1document();
    MockDataSource.clearCache();

    List deltaRow = new ArrayList();
    deltaRow.add(createMap("id", "1"));
    MockDataSource.setIterator(DELTA_QUERY,
        deltaRow.iterator());

    MockDataSource.setIterator(DELETED_PK_QUERY, Collections
        .EMPTY_LIST.iterator());

    List parentRow = new ArrayList();
    parentRow.add(createMap("id", "1"));
    MockDataSource.setIterator("select * from x where id='1'", parentRow
        .iterator());

    List childRow = new ArrayList();
    childRow.add(createMap("desc", "goodbye"));
    MockDataSource.setIterator("select * from y where y.A='1'", childRow
        .iterator());

    runDeltaImport(dataConfig_delta);

    assertQ(req("*:* OR XtestCompositePk_DeltaImport_replace_nodelete"), "//*[@numFound='1']");
    assertQ(req("id:1"), "//*[@numFound='1']");
    assertQ(req("desc:hello OR XtestCompositePk_DeltaImport_replace_nodelete"), "//*[@numFound='0']");
    assertQ(req("desc:goodbye"), "//*[@numFound='1']");
  }
,
(startLine=213 endLine=239 srcPath=/home/sonia/NewExperiment/luceneFilter/01029/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDelta.java)
  public void testCompositePk_DeltaImport_add() throws Exception {
    add1document();
    MockDataSource.clearCache();

    List deltaRow = new ArrayList();
    deltaRow.add(createMap("id", "2"));
    MockDataSource.setIterator(DELTA_QUERY,
        deltaRow.iterator());

    List parentRow = new ArrayList();
    parentRow.add(createMap("id", "2"));
    MockDataSource.setIterator("select * from x where id='2'", parentRow
        .iterator());

    List childRow = new ArrayList();
    childRow.add(createMap("desc", "goodbye"));
    MockDataSource.setIterator("select * from y where y.A='2'", childRow
        .iterator());

    runDeltaImport(dataConfig_delta);

    assertQ(req("*:* OR testCompositePk_DeltaImport_add"), "//*[@numFound='2']");
    assertQ(req("id:1"), "//*[@numFound='1']");
    assertQ(req("id:2"), "//*[@numFound='1']");
    assertQ(req("desc:hello"), "//*[@numFound='1']");
    assertQ(req("desc:goodbye"), "//*[@numFound='1']");
  }
,
(startLine=259 endLine=289 srcPath=/home/sonia/NewExperiment/luceneFilter/01029/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDelta.java)
  public void testCompositePk_DeltaImport_add_delete() throws Exception {
    add1document();
    MockDataSource.clearCache();

    List deltaRow = new ArrayList();
    deltaRow.add(createMap("id", "2"));
    MockDataSource.setIterator(DELTA_QUERY,
        deltaRow.iterator());

    List deletedRow = new ArrayList();
    deletedRow.add(createMap("id", "1"));
    MockDataSource.setIterator(DELETED_PK_QUERY,
        deletedRow.iterator());

    List parentRow = new ArrayList();
    parentRow.add(createMap("id", "2"));
    MockDataSource.setIterator("select * from x where id='2'", parentRow
        .iterator());

    List childRow = new ArrayList();
    childRow.add(createMap("desc", "goodbye"));
    MockDataSource.setIterator("select * from y where y.A='2'", childRow
        .iterator());

    runDeltaImport(dataConfig_delta);

    assertQ(req("*:* OR XtestCompositePk_DeltaImport_add_delete"), "//*[@numFound='1']");
    assertQ(req("id:2"), "//*[@numFound='1']");
    assertQ(req("desc:hello"), "//*[@numFound='0']");
    assertQ(req("desc:goodbye"), "//*[@numFound='1']");
  }
,
(startLine=118 endLine=141 srcPath=/home/sonia/NewExperiment/luceneFilter/01029/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDelta2.java)
  public void testCompositePk_DeltaImport_empty() throws Exception {
    List deltaRow = new ArrayList();
    deltaRow.add(createMap("id", "1"));
    MockDataSource.setIterator(DELTA_QUERY, deltaRow.iterator());

    MockDataSource.setIterator(DELETED_PK_QUERY, Collections
        .EMPTY_LIST.iterator());

    List parentRow = new ArrayList();
    parentRow.add(createMap("id", "1"));
    MockDataSource.setIterator("select * from x where id='1'", parentRow
        .iterator());

    List childRow = new ArrayList();
    childRow.add(createMap("desc", "hello"));
    MockDataSource.setIterator("select * from y where y.A='1'", childRow
        .iterator());

    runDeltaImport(dataConfig_delta2);

    assertQ(req("*:* OR testCompositePk_DeltaImport_empty"), "//*[@numFound='1']");
    assertQ(req("solr_id:prefix-1"), "//*[@numFound='1']");
    assertQ(req("desc:hello"), "//*[@numFound='1']");
  }
,
(startLine=145 endLine=172 srcPath=/home/sonia/NewExperiment/luceneFilter/01029/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDelta2.java)
  public void testCompositePk_DeltaImport_replace_delete() throws Exception {
    add1document();
    MockDataSource.clearCache();

    List deltaRow = new ArrayList();
    deltaRow.add(createMap("id", "1"));
    MockDataSource.setIterator(DELTA_QUERY,
        deltaRow.iterator());

    List deletedRow = new ArrayList();
    deletedRow.add(createMap("id", "1"));
    MockDataSource.setIterator(DELETED_PK_QUERY,
        deletedRow.iterator());

    List parentRow = new ArrayList();
    parentRow.add(createMap("id", "1"));
    MockDataSource.setIterator("select * from x where id='1'", parentRow
        .iterator());

    List childRow = new ArrayList();
    childRow.add(createMap("desc", "goodbye"));
    MockDataSource.setIterator("select * from y where y.A='1'", childRow
        .iterator());

    runDeltaImport(dataConfig_delta2);

    assertQ(req("*:* OR testCompositePk_DeltaImport_replace_delete"), "//*[@numFound='0']");
  }
,
(startLine=177 endLine=205 srcPath=/home/sonia/NewExperiment/luceneFilter/01029/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDelta2.java)
  public void testCompositePk_DeltaImport_replace_nodelete() throws Exception {
    add1document();
    MockDataSource.clearCache();

    List deltaRow = new ArrayList();
    deltaRow.add(createMap("id", "1"));
    MockDataSource.setIterator(DELTA_QUERY,
        deltaRow.iterator());

    MockDataSource.setIterator(DELETED_PK_QUERY, Collections
        .EMPTY_LIST.iterator());

    List parentRow = new ArrayList();
    parentRow.add(createMap("id", "1"));
    MockDataSource.setIterator("select * from x where id='1'", parentRow
        .iterator());

    List childRow = new ArrayList();
    childRow.add(createMap("desc", "goodbye"));
    MockDataSource.setIterator("select * from y where y.A='1'", childRow
        .iterator());

    runDeltaImport(dataConfig_delta2);

    assertQ(req("*:* OR XtestCompositePk_DeltaImport_replace_nodelete"), "//*[@numFound='1']");
    assertQ(req("solr_id:prefix-1"), "//*[@numFound='1']");
    assertQ(req("desc:hello OR XtestCompositePk_DeltaImport_replace_nodelete"), "//*[@numFound='0']");
    assertQ(req("desc:goodbye"), "//*[@numFound='1']");
  }
,
(startLine=209 endLine=235 srcPath=/home/sonia/NewExperiment/luceneFilter/01029/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDelta2.java)
  public void testCompositePk_DeltaImport_add() throws Exception {
    add1document();
    MockDataSource.clearCache();

    List deltaRow = new ArrayList();
    deltaRow.add(createMap("id", "2"));
    MockDataSource.setIterator(DELTA_QUERY,
        deltaRow.iterator());

    List parentRow = new ArrayList();
    parentRow.add(createMap("id", "2"));
    MockDataSource.setIterator("select * from x where id='2'", parentRow
        .iterator());

    List childRow = new ArrayList();
    childRow.add(createMap("desc", "goodbye"));
    MockDataSource.setIterator("select * from y where y.A='2'", childRow
        .iterator());

    runDeltaImport(dataConfig_delta2);

    assertQ(req("*:* OR testCompositePk_DeltaImport_add"), "//*[@numFound='2']");
    assertQ(req("solr_id:prefix-1"), "//*[@numFound='1']");
    assertQ(req("solr_id:prefix-2"), "//*[@numFound='1']");
    assertQ(req("desc:hello"), "//*[@numFound='1']");
    assertQ(req("desc:goodbye"), "//*[@numFound='1']");
  }
,
(startLine=255 endLine=285 srcPath=/home/sonia/NewExperiment/luceneFilter/01029/solr/contrib/dataimporthandler/src/test/java/org/apache/solr/handler/dataimport/TestSqlEntityProcessorDelta2.java)
  public void testCompositePk_DeltaImport_add_delete() throws Exception {
    add1document();
    MockDataSource.clearCache();

    List deltaRow = new ArrayList();
    deltaRow.add(createMap("id", "2"));
    MockDataSource.setIterator(DELTA_QUERY,
        deltaRow.iterator());

    List deletedRow = new ArrayList();
    deletedRow.add(createMap("id", "1"));
    MockDataSource.setIterator(DELETED_PK_QUERY,
        deletedRow.iterator());

    List parentRow = new ArrayList();
    parentRow.add(createMap("id", "2"));
    MockDataSource.setIterator("select * from x where id='2'", parentRow
        .iterator());

    List childRow = new ArrayList();
    childRow.add(createMap("desc", "goodbye"));
    MockDataSource.setIterator("select * from y where y.A='2'", childRow
        .iterator());

    runDeltaImport(dataConfig_delta2);

    assertQ(req("*:* OR XtestCompositePk_DeltaImport_add_delete"), "//*[@numFound='1']");
    assertQ(req("solr_id:prefix-2"), "//*[@numFound='1']");
    assertQ(req("desc:hello"), "//*[@numFound='0']");
    assertQ(req("desc:goodbye"), "//*[@numFound='1']");
  }
,
>
, <(startLine=409 endLine=672 srcPath=/home/sonia/NewExperiment/luceneFilter/00927/lucene/modules/analysis/common/src/java/org/tartarus/snowball/ext/German2Stemmer.java)
        private boolean r_standard_suffix() {
            int among_var;
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            int v_5;
            int v_6;
            int v_7;
            int v_8;
            int v_9;
            // (, line 79
            // do, line 80
            v_1 = limit - cursor;
            lab0: do {
                // (, line 80
                // [, line 81
                ket = cursor;
                // substring, line 81
                among_var = find_among_b(a_2, 7);
                if (among_var == 0)
                {
                    break lab0;
                }
                // ], line 81
                bra = cursor;
                // call R1, line 81
                if (!r_R1())
                {
                    break lab0;
                }
                switch(among_var) {
                    case 0:
                        break lab0;
                    case 1:
                        // (, line 83
                        // delete, line 83
                        slice_del();
                        break;
                    case 2:
                        // (, line 86
                        if (!(in_grouping_b(g_s_ending, 98, 116)))
                        {
                            break lab0;
                        }
                        // delete, line 86
                        slice_del();
                        break;
                }
            } while (false);
            cursor = limit - v_1;
            // do, line 90
            v_2 = limit - cursor;
            lab1: do {
                // (, line 90
                // [, line 91
                ket = cursor;
                // substring, line 91
                among_var = find_among_b(a_3, 4);
                if (among_var == 0)
                {
                    break lab1;
                }
                // ], line 91
                bra = cursor;
                // call R1, line 91
                if (!r_R1())
                {
                    break lab1;
                }
                switch(among_var) {
                    case 0:
                        break lab1;
                    case 1:
                        // (, line 93
                        // delete, line 93
                        slice_del();
                        break;
                    case 2:
                        // (, line 96
                        if (!(in_grouping_b(g_st_ending, 98, 116)))
                        {
                            break lab1;
                        }
                        // hop, line 96
                        {
                            int c = cursor - 3;
                            if (limit_backward > c || c > limit)
                            {
                                break lab1;
                            }
                            cursor = c;
                        }
                        // delete, line 96
                        slice_del();
                        break;
                }
            } while (false);
            cursor = limit - v_2;
            // do, line 100
            v_3 = limit - cursor;
            lab2: do {
                // (, line 100
                // [, line 101
                ket = cursor;
                // substring, line 101
                among_var = find_among_b(a_5, 8);
                if (among_var == 0)
                {
                    break lab2;
                }
                // ], line 101
                bra = cursor;
                // call R2, line 101
                if (!r_R2())
                {
                    break lab2;
                }
                switch(among_var) {
                    case 0:
                        break lab2;
                    case 1:
                        // (, line 103
                        // delete, line 103
                        slice_del();
                        // try, line 104
                        v_4 = limit - cursor;
                        lab3: do {
                            // (, line 104
                            // [, line 104
                            ket = cursor;
                            // literal, line 104
                            if (!(eq_s_b(2, "ig")))
                            {
                                cursor = limit - v_4;
                                break lab3;
                            }
                            // ], line 104
                            bra = cursor;
                            // not, line 104
                            {
                                v_5 = limit - cursor;
                                lab4: do {
                                    // literal, line 104
                                    if (!(eq_s_b(1, "e")))
                                    {
                                        break lab4;
                                    }
                                    cursor = limit - v_4;
                                    break lab3;
                                } while (false);
                                cursor = limit - v_5;
                            }
                            // call R2, line 104
                            if (!r_R2())
                            {
                                cursor = limit - v_4;
                                break lab3;
                            }
                            // delete, line 104
                            slice_del();
                        } while (false);
                        break;
                    case 2:
                        // (, line 107
                        // not, line 107
                        {
                            v_6 = limit - cursor;
                            lab5: do {
                                // literal, line 107
                                if (!(eq_s_b(1, "e")))
                                {
                                    break lab5;
                                }
                                break lab2;
                            } while (false);
                            cursor = limit - v_6;
                        }
                        // delete, line 107
                        slice_del();
                        break;
                    case 3:
                        // (, line 110
                        // delete, line 110
                        slice_del();
                        // try, line 111
                        v_7 = limit - cursor;
                        lab6: do {
                            // (, line 111
                            // [, line 112
                            ket = cursor;
                            // or, line 112
                            lab7: do {
                                v_8 = limit - cursor;
                                lab8: do {
                                    // literal, line 112
                                    if (!(eq_s_b(2, "er")))
                                    {
                                        break lab8;
                                    }
                                    break lab7;
                                } while (false);
                                cursor = limit - v_8;
                                // literal, line 112
                                if (!(eq_s_b(2, "en")))
                                {
                                    cursor = limit - v_7;
                                    break lab6;
                                }
                            } while (false);
                            // ], line 112
                            bra = cursor;
                            // call R1, line 112
                            if (!r_R1())
                            {
                                cursor = limit - v_7;
                                break lab6;
                            }
                            // delete, line 112
                            slice_del();
                        } while (false);
                        break;
                    case 4:
                        // (, line 116
                        // delete, line 116
                        slice_del();
                        // try, line 117
                        v_9 = limit - cursor;
                        lab9: do {
                            // (, line 117
                            // [, line 118
                            ket = cursor;
                            // substring, line 118
                            among_var = find_among_b(a_4, 2);
                            if (among_var == 0)
                            {
                                cursor = limit - v_9;
                                break lab9;
                            }
                            // ], line 118
                            bra = cursor;
                            // call R2, line 118
                            if (!r_R2())
                            {
                                cursor = limit - v_9;
                                break lab9;
                            }
                            switch(among_var) {
                                case 0:
                                    cursor = limit - v_9;
                                    break lab9;
                                case 1:
                                    // (, line 120
                                    // delete, line 120
                                    slice_del();
                                    break;
                            }
                        } while (false);
                        break;
                }
            } while (false);
            cursor = limit - v_3;
            return true;
        }
,
(startLine=371 endLine=634 srcPath=/home/sonia/NewExperiment/luceneFilter/00927/lucene/modules/analysis/common/src/java/org/tartarus/snowball/ext/GermanStemmer.java)
        private boolean r_standard_suffix() {
            int among_var;
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            int v_5;
            int v_6;
            int v_7;
            int v_8;
            int v_9;
            // (, line 73
            // do, line 74
            v_1 = limit - cursor;
            lab0: do {
                // (, line 74
                // [, line 75
                ket = cursor;
                // substring, line 75
                among_var = find_among_b(a_1, 7);
                if (among_var == 0)
                {
                    break lab0;
                }
                // ], line 75
                bra = cursor;
                // call R1, line 75
                if (!r_R1())
                {
                    break lab0;
                }
                switch(among_var) {
                    case 0:
                        break lab0;
                    case 1:
                        // (, line 77
                        // delete, line 77
                        slice_del();
                        break;
                    case 2:
                        // (, line 80
                        if (!(in_grouping_b(g_s_ending, 98, 116)))
                        {
                            break lab0;
                        }
                        // delete, line 80
                        slice_del();
                        break;
                }
            } while (false);
            cursor = limit - v_1;
            // do, line 84
            v_2 = limit - cursor;
            lab1: do {
                // (, line 84
                // [, line 85
                ket = cursor;
                // substring, line 85
                among_var = find_among_b(a_2, 4);
                if (among_var == 0)
                {
                    break lab1;
                }
                // ], line 85
                bra = cursor;
                // call R1, line 85
                if (!r_R1())
                {
                    break lab1;
                }
                switch(among_var) {
                    case 0:
                        break lab1;
                    case 1:
                        // (, line 87
                        // delete, line 87
                        slice_del();
                        break;
                    case 2:
                        // (, line 90
                        if (!(in_grouping_b(g_st_ending, 98, 116)))
                        {
                            break lab1;
                        }
                        // hop, line 90
                        {
                            int c = cursor - 3;
                            if (limit_backward > c || c > limit)
                            {
                                break lab1;
                            }
                            cursor = c;
                        }
                        // delete, line 90
                        slice_del();
                        break;
                }
            } while (false);
            cursor = limit - v_2;
            // do, line 94
            v_3 = limit - cursor;
            lab2: do {
                // (, line 94
                // [, line 95
                ket = cursor;
                // substring, line 95
                among_var = find_among_b(a_4, 8);
                if (among_var == 0)
                {
                    break lab2;
                }
                // ], line 95
                bra = cursor;
                // call R2, line 95
                if (!r_R2())
                {
                    break lab2;
                }
                switch(among_var) {
                    case 0:
                        break lab2;
                    case 1:
                        // (, line 97
                        // delete, line 97
                        slice_del();
                        // try, line 98
                        v_4 = limit - cursor;
                        lab3: do {
                            // (, line 98
                            // [, line 98
                            ket = cursor;
                            // literal, line 98
                            if (!(eq_s_b(2, "ig")))
                            {
                                cursor = limit - v_4;
                                break lab3;
                            }
                            // ], line 98
                            bra = cursor;
                            // not, line 98
                            {
                                v_5 = limit - cursor;
                                lab4: do {
                                    // literal, line 98
                                    if (!(eq_s_b(1, "e")))
                                    {
                                        break lab4;
                                    }
                                    cursor = limit - v_4;
                                    break lab3;
                                } while (false);
                                cursor = limit - v_5;
                            }
                            // call R2, line 98
                            if (!r_R2())
                            {
                                cursor = limit - v_4;
                                break lab3;
                            }
                            // delete, line 98
                            slice_del();
                        } while (false);
                        break;
                    case 2:
                        // (, line 101
                        // not, line 101
                        {
                            v_6 = limit - cursor;
                            lab5: do {
                                // literal, line 101
                                if (!(eq_s_b(1, "e")))
                                {
                                    break lab5;
                                }
                                break lab2;
                            } while (false);
                            cursor = limit - v_6;
                        }
                        // delete, line 101
                        slice_del();
                        break;
                    case 3:
                        // (, line 104
                        // delete, line 104
                        slice_del();
                        // try, line 105
                        v_7 = limit - cursor;
                        lab6: do {
                            // (, line 105
                            // [, line 106
                            ket = cursor;
                            // or, line 106
                            lab7: do {
                                v_8 = limit - cursor;
                                lab8: do {
                                    // literal, line 106
                                    if (!(eq_s_b(2, "er")))
                                    {
                                        break lab8;
                                    }
                                    break lab7;
                                } while (false);
                                cursor = limit - v_8;
                                // literal, line 106
                                if (!(eq_s_b(2, "en")))
                                {
                                    cursor = limit - v_7;
                                    break lab6;
                                }
                            } while (false);
                            // ], line 106
                            bra = cursor;
                            // call R1, line 106
                            if (!r_R1())
                            {
                                cursor = limit - v_7;
                                break lab6;
                            }
                            // delete, line 106
                            slice_del();
                        } while (false);
                        break;
                    case 4:
                        // (, line 110
                        // delete, line 110
                        slice_del();
                        // try, line 111
                        v_9 = limit - cursor;
                        lab9: do {
                            // (, line 111
                            // [, line 112
                            ket = cursor;
                            // substring, line 112
                            among_var = find_among_b(a_3, 2);
                            if (among_var == 0)
                            {
                                cursor = limit - v_9;
                                break lab9;
                            }
                            // ], line 112
                            bra = cursor;
                            // call R2, line 112
                            if (!r_R2())
                            {
                                cursor = limit - v_9;
                                break lab9;
                            }
                            switch(among_var) {
                                case 0:
                                    cursor = limit - v_9;
                                    break lab9;
                                case 1:
                                    // (, line 114
                                    // delete, line 114
                                    slice_del();
                                    break;
                            }
                        } while (false);
                        break;
                }
            } while (false);
            cursor = limit - v_3;
            return true;
        }
,
(startLine=487 endLine=783 srcPath=/home/sonia/NewExperiment/luceneFilter/00927/lucene/modules/analysis/common/src/java/org/tartarus/snowball/ext/DutchStemmer.java)
        private boolean r_standard_suffix() {
            int among_var;
            int v_1;
            int v_2;
            int v_3;
            int v_4;
            int v_5;
            int v_6;
            int v_7;
            int v_8;
            int v_9;
            int v_10;
            // (, line 106
            // do, line 107
            v_1 = limit - cursor;
            lab0: do {
                // (, line 107
                // [, line 108
                ket = cursor;
                // substring, line 108
                among_var = find_among_b(a_3, 5);
                if (among_var == 0)
                {
                    break lab0;
                }
                // ], line 108
                bra = cursor;
                switch(among_var) {
                    case 0:
                        break lab0;
                    case 1:
                        // (, line 110
                        // call R1, line 110
                        if (!r_R1())
                        {
                            break lab0;
                        }
                        // <-, line 110
                        slice_from("heid");
                        break;
                    case 2:
                        // (, line 113
                        // call en_ending, line 113
                        if (!r_en_ending())
                        {
                            break lab0;
                        }
                        break;
                    case 3:
                        // (, line 116
                        // call R1, line 116
                        if (!r_R1())
                        {
                            break lab0;
                        }
                        if (!(out_grouping_b(g_v_j, 97, 232)))
                        {
                            break lab0;
                        }
                        // delete, line 116
                        slice_del();
                        break;
                }
            } while (false);
            cursor = limit - v_1;
            // do, line 120
            v_2 = limit - cursor;
            lab1: do {
                // call e_ending, line 120
                if (!r_e_ending())
                {
                    break lab1;
                }
            } while (false);
            cursor = limit - v_2;
            // do, line 122
            v_3 = limit - cursor;
            lab2: do {
                // (, line 122
                // [, line 122
                ket = cursor;
                // literal, line 122
                if (!(eq_s_b(4, "heid")))
                {
                    break lab2;
                }
                // ], line 122
                bra = cursor;
                // call R2, line 122
                if (!r_R2())
                {
                    break lab2;
                }
                // not, line 122
                {
                    v_4 = limit - cursor;
                    lab3: do {
                        // literal, line 122
                        if (!(eq_s_b(1, "c")))
                        {
                            break lab3;
                        }
                        break lab2;
                    } while (false);
                    cursor = limit - v_4;
                }
                // delete, line 122
                slice_del();
                // [, line 123
                ket = cursor;
                // literal, line 123
                if (!(eq_s_b(2, "en")))
                {
                    break lab2;
                }
                // ], line 123
                bra = cursor;
                // call en_ending, line 123
                if (!r_en_ending())
                {
                    break lab2;
                }
            } while (false);
            cursor = limit - v_3;
            // do, line 126
            v_5 = limit - cursor;
            lab4: do {
                // (, line 126
                // [, line 127
                ket = cursor;
                // substring, line 127
                among_var = find_among_b(a_4, 6);
                if (among_var == 0)
                {
                    break lab4;
                }
                // ], line 127
                bra = cursor;
                switch(among_var) {
                    case 0:
                        break lab4;
                    case 1:
                        // (, line 129
                        // call R2, line 129
                        if (!r_R2())
                        {
                            break lab4;
                        }
                        // delete, line 129
                        slice_del();
                        // or, line 130
                        lab5: do {
                            v_6 = limit - cursor;
                            lab6: do {
                                // (, line 130
                                // [, line 130
                                ket = cursor;
                                // literal, line 130
                                if (!(eq_s_b(2, "ig")))
                                {
                                    break lab6;
                                }
                                // ], line 130
                                bra = cursor;
                                // call R2, line 130
                                if (!r_R2())
                                {
                                    break lab6;
                                }
                                // not, line 130
                                {
                                    v_7 = limit - cursor;
                                    lab7: do {
                                        // literal, line 130
                                        if (!(eq_s_b(1, "e")))
                                        {
                                            break lab7;
                                        }
                                        break lab6;
                                    } while (false);
                                    cursor = limit - v_7;
                                }
                                // delete, line 130
                                slice_del();
                                break lab5;
                            } while (false);
                            cursor = limit - v_6;
                            // call undouble, line 130
                            if (!r_undouble())
                            {
                                break lab4;
                            }
                        } while (false);
                        break;
                    case 2:
                        // (, line 133
                        // call R2, line 133
                        if (!r_R2())
                        {
                            break lab4;
                        }
                        // not, line 133
                        {
                            v_8 = limit - cursor;
                            lab8: do {
                                // literal, line 133
                                if (!(eq_s_b(1, "e")))
                                {
                                    break lab8;
                                }
                                break lab4;
                            } while (false);
                            cursor = limit - v_8;
                        }
                        // delete, line 133
                        slice_del();
                        break;
                    case 3:
                        // (, line 136
                        // call R2, line 136
                        if (!r_R2())
                        {
                            break lab4;
                        }
                        // delete, line 136
                        slice_del();
                        // call e_ending, line 136
                        if (!r_e_ending())
                        {
                            break lab4;
                        }
                        break;
                    case 4:
                        // (, line 139
                        // call R2, line 139
                        if (!r_R2())
                        {
                            break lab4;
                        }
                        // delete, line 139
                        slice_del();
                        break;
                    case 5:
                        // (, line 142
                        // call R2, line 142
                        if (!r_R2())
                        {
                            break lab4;
                        }
                        // Boolean test e_found, line 142
                        if (!(B_e_found))
                        {
                            break lab4;
                        }
                        // delete, line 142
                        slice_del();
                        break;
                }
            } while (false);
            cursor = limit - v_5;
            // do, line 146
            v_9 = limit - cursor;
            lab9: do {
                // (, line 146
                if (!(out_grouping_b(g_v_I, 73, 232)))
                {
                    break lab9;
                }
                // test, line 148
                v_10 = limit - cursor;
                // (, line 148
                // among, line 149
                if (find_among_b(a_5, 4) == 0)
                {
                    break lab9;
                }
                if (!(out_grouping_b(g_v, 97, 232)))
                {
                    break lab9;
                }
                cursor = limit - v_10;
                // [, line 152
                ket = cursor;
                // next, line 152
                if (cursor <= limit_backward)
                {
                    break lab9;
                }
                cursor--;
                // ], line 152
                bra = cursor;
                // delete, line 152
                slice_del();
            } while (false);
            cursor = limit - v_9;
            return true;
        }
,
>
, <(startLine=43 endLine=54 srcPath=/home/sonia/NewExperiment/luceneFilter/00687/lucene/src/java/org/apache/lucene/analysis/NormalizeCharMap.java)
    for(int i = 0; i < singleMatch.length(); i++) {
      char c = singleMatch.charAt(i);
      if (currMap.submap == null) {
        currMap.submap = new HashMap<Character, NormalizeCharMap>(1);
      }
      NormalizeCharMap map = currMap.submap.get(Character.valueOf(c));
      if (map == null) {
        map = new NormalizeCharMap();
        currMap.submap.put(Character.valueOf(c), map);
      }
      currMap = map;
    }
,
(startLine=43 endLine=54 srcPath=/home/sonia/NewExperiment/luceneFilter/00687/lucene/backwards/src/java/org/apache/lucene/analysis/NormalizeCharMap.java)
    for(int i = 0; i < singleMatch.length(); i++) {
      char c = singleMatch.charAt(i);
      if (currMap.submap == null) {
        currMap.submap = new HashMap<Character, NormalizeCharMap>(1);
      }
      NormalizeCharMap map = currMap.submap.get(Character.valueOf(c));
      if (map == null) {
        map = new NormalizeCharMap();
        currMap.submap.put(Character.valueOf(c), map);
      }
      currMap = map;
    }
,
>
, <(startLine=478 endLine=488 srcPath=/home/sonia/NewExperiment/luceneFilter/00978/solr/src/java/org/apache/solr/request/UnInvertedField.java)
    for (String f : facet) {
      FieldType facet_ft = searcher.getSchema().getFieldType(f);
      try {
        si = FieldCache.DEFAULT.getTermsIndex(searcher.getIndexReader(), f);
      }
      catch (IOException e) {
        throw new RuntimeException("failed to open field cache for: " + f, e);
      }
      finfo[i] = new FieldFacetStats(f, si, facet_ft, numTermsInField);
      i++;
    }
,
(startLine=263 endLine=272 srcPath=/home/sonia/NewExperiment/luceneFilter/00978/solr/src/java/org/apache/solr/handler/component/StatsComponent.java)
    for( String f : facet ) {
      ft = searcher.getSchema().getFieldType(f);
      try {
        si = FieldCache.DEFAULT.getTermsIndex(searcher.getIndexReader(), f);
      } 
      catch (IOException e) {
        throw new RuntimeException( "failed to open field cache for: "+f, e );
      }
      finfo[i++] = new FieldFacetStats( f, si, ft, 0 );
    }
,
>
, <(startLine=1008 endLine=1023 srcPath=/home/sonia/NewExperiment/luceneFilter/01593/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java)
  public void testStopwords() throws Exception {
    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|foo").toAutomaton());
    CommonQueryParserConfiguration qp = getParserConfig(new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopSet, true));
    Query result = getQuery("field:the OR field:foo",qp);
    assertNotNull("result is null and it shouldn't be", result);
    assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
    assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: " + 0, ((BooleanQuery) result).clauses().size() == 0);
    result = getQuery("field:woo OR field:the",qp);
    assertNotNull("result is null and it shouldn't be", result);
    assertTrue("result is not a TermQuery", result instanceof TermQuery);
    result = getQuery("(fieldX:xxxxx OR fieldy:xxxxxxxx)^2 AND (fieldx:the OR fieldy:foo)",qp);
    assertNotNull("result is null and it shouldn't be", result);
    assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
    if (VERBOSE) System.out.println("Result: " + result);
    assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: " + 2, ((BooleanQuery) result).clauses().size() == 2);
  }
,
(startLine=1179 endLine=1201 srcPath=/home/sonia/NewExperiment/luceneFilter/01593/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestQPHelper.java)
  public void testStopwords() throws Exception {
    StandardQueryParser qp = new StandardQueryParser();
    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|foo").toAutomaton());
    qp.setAnalyzer(new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopSet, true));

    Query result = qp.parse("a:the OR a:foo", "a");
    assertNotNull("result is null and it shouldn't be", result);
    assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
    assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: "
        + 0, ((BooleanQuery) result).clauses().size() == 0);
    result = qp.parse("a:woo OR a:the", "a");
    assertNotNull("result is null and it shouldn't be", result);
    assertTrue("result is not a TermQuery", result instanceof TermQuery);
    result = qp.parse(
        "(fieldX:xxxxx OR fieldy:xxxxxxxx)^2 AND (fieldx:the OR fieldy:foo)",
        "a");
    assertNotNull("result is null and it shouldn't be", result);
    assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
    if (VERBOSE)
      System.out.println("Result: " + result);
    assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: "
        + 2, ((BooleanQuery) result).clauses().size() == 2);
  }
,
>
, <(startLine=96 endLine=109 srcPath=/home/sonia/NewExperiment/luceneFilter/00219/contrib/db/bdb-je/src/java/org/apache/lucene/store/je/JEIndexOutput.java)
        while (blockPos + len >= BLOCK_LEN) {
            int blockLen = BLOCK_LEN - blockPos;

            System.arraycopy(b, offset, block.getData(), blockPos, blockLen);
            block.put(directory);

            len -= blockLen;
            offset += blockLen;
            position += blockLen;

            block.seek(position);
            block.get(directory);
            blockPos = 0;
        }
,
(startLine=99 endLine=112 srcPath=/home/sonia/NewExperiment/luceneFilter/00219/contrib/db/bdb/src/java/org/apache/lucene/store/db/DbIndexOutput.java)
        while (blockPos + len >= BLOCK_LEN) {
            int blockLen = BLOCK_LEN - blockPos;

            System.arraycopy(b, offset, block.getData(), blockPos, blockLen);
            block.put(directory);

            len -= blockLen;
            offset += blockLen;
            position += blockLen;

            block.seek(position);
            block.get(directory);
            blockPos = 0;
        }
,
>
, <(startLine=232 endLine=247 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DirContentSource.java)
  public void setConfig(Config config) {
    super.setConfig(config);
    
    File workDir = new File(config.get("work.dir", "work"));
    String d = config.get("docs.dir", "dir-out");
    dataDir = new File(d);
    if (!dataDir.isAbsolute()) {
      dataDir = new File(workDir, d);
    }

    inputFiles = new Iterator(dataDir);

    if (inputFiles == null) {
      throw new RuntimeException("No txt files in dataDir: " + dataDir.getAbsolutePath());
    }
  }
,
(startLine=57 endLine=70 srcPath=/home/sonia/NewExperiment/luceneFilter/00674/lucene/lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersContentSource.java)
  public void setConfig(Config config) {
    super.setConfig(config);
    File workDir = new File(config.get("work.dir", "work"));
    String d = config.get("docs.dir", "reuters-out");
    dataDir = new File(d);
    if (!dataDir.isAbsolute()) {
      dataDir = new File(workDir, d);
    }
    inputFiles.clear();
    collectFiles(dataDir, inputFiles);
    if (inputFiles.size() == 0) {
      throw new RuntimeException("No txt files in dataDir: "+dataDir.getAbsolutePath());
    }
  }
,
>
, <(startLine=139 endLine=151 srcPath=/home/sonia/NewExperiment/luceneFilter/01550/solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler.java)
    } else {
      fname = fname.replace('\\', '/'); // normalize slashes
      if (hiddenFiles.contains(fname.toUpperCase(Locale.ROOT))) {
        throw new SolrException(ErrorCode.FORBIDDEN, "Can not access: " + fname);
      }
      if (fname.indexOf("..") >= 0) {
        throw new SolrException(ErrorCode.FORBIDDEN, "Invalid path: " + fname);
      }
      if (fname.startsWith("/")) { // Only files relative to conf are valid
        fname = fname.substring(1);
      }
      adminFile = confPath + "/" + fname;
    }
,
(startLine=218 endLine=227 srcPath=/home/sonia/NewExperiment/luceneFilter/01550/solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler.java)
    else {
      fname = fname.replace( '\\', '/' ); // normalize slashes
      if( hiddenFiles.contains( fname.toUpperCase(Locale.ROOT) ) ) {
        throw new SolrException( ErrorCode.FORBIDDEN, "Can not access: "+fname );
      }
      if( fname.indexOf( ".." ) >= 0 ) {
        throw new SolrException( ErrorCode.FORBIDDEN, "Invalid path: "+fname );  
      }
      adminFile = new File( configdir, fname );
    }
,
>
]